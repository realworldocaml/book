<html style="" lang="en" class="js flexbox fontface"><head><meta charset="utf-8"><meta content="width=device-width, initial-scale=1.0" name="viewport"><title>Data Serialization with S-Expressions - Real World OCaml</title><link href="css/app.css" rel="stylesheet"><link href="css/prism.css" rel="stylesheet"><script src="js/min/modernizr-min.js"></script><script src="js/prism.js"></script><script src="//use.typekit.net/gfj8wez.js"></script><script>try{Typekit.load();}catch(e){}</script></head><body><div class="title-bar"><div class="title"><h1>Real World OCaml</h1><h5>2<sup>nd</sup> Edition (published in Q4 2021)</h5><nav><a href="index.html">Home</a><a href="toc.html">Table of Contents</a><a href="faqs.html">FAQs</a><a href="install.html">Install</a><a href="https://ocaml.janestreet.com/ocaml-core/">API Docs</a></nav></div></div><div class="wrap"><div class="left-column"><a class="to-chapter" href="toc.html"><small>Back</small><h5>Table of Contents</h5></a></div><article class="main-body"><section class="level1" id="data-serialization-with-s-expressions">
<h1>Data Serialization with S-Expressions</h1>
<p>S-expressions are nested parenthetical expressions whose atomic
values are strings. They were first popularized by the Lisp programming
language in the 1960s, and have remained one of the simplest and most
effective ways to encode structured data in a human-readable and
editable form. <a data-primary="s-expressions" data-type="indexterm">&nbsp;</a> <a data-secondary="s-expressions" data-primary="serialization formats" data-type="indexterm">&nbsp;</a> <a data-secondary="with s-expressions" data-primary="data serialization" data-type="indexterm">&nbsp;</a></p>
<p>An example s-expression might look like this.</p>
<div class="highlight">
<pre><code class="language-clike">(this (is an) (s expression))</code></pre>
</div>
<p>S-expressions play a major role in Base and Core, effectively acting
as the default serialization format. Indeed, we’ve encountered
s-expressions multiple times already, including in <a data-type="xref" href="error-handling.html#error-handling">Chapter 7, Error
Handling</a>, <a data-type="xref" href="functors.html#functors">Chapter 10, Functors</a>, and <a data-type="xref" href="first-class-modules.html#first-class-modules">Chapter 11, First Class Modules</a>.</p>
<p>This chapter will go into s-expressions in more depth. In particular,
we’ll discuss:</p>
<ul>
<li><p>The details of the s-expression format, including how to parse it
while generating good error messages for debugging malformed
inputs</p></li>
<li><p>How to generate converters between s-expressions and arbitrary
OCaml types</p></li>
<li><p>How to use annotations to control the behavior of these generated
converters</p></li>
<li><p>How to integrate s-expressions into your interfaces, in
particular how to add s-expression converters to a module without
breaking abstraction boundaries</p></li>
</ul>
<p>We’ll tie this together at the end of the chapter with a simple
s-expression formatted configuration file for a web server</p>
<section class="level2" id="basic-usage">
<h2>Basic Usage</h2>
<p>The type used to represent an s-expression is quite simple: <a data-secondary="basic usage of" data-primary="s-expressions" data-type="indexterm">&nbsp;</a></p>
<div class="highlight">
<pre><code class="language-ocaml">module Sexp : sig
  type t =
  | Atom of string
  | List of t list
end</code></pre>
</div>
<p>An s-expression can be thought of as a tree where each node contains
a list of its children, and where the leaves of the tree are strings.
Core provides good support for s-expressions in its <code>Sexp</code>
module, including functions for converting s-expressions to and from
strings. Let’s rewrite our example s-expression in terms of this
type:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">open Core;;
Sexp.List [
  Sexp.Atom "this";
  Sexp.List [ Sexp.Atom "is"; Sexp.Atom "an"];
  Sexp.List [ Sexp.Atom "s"; Sexp.Atom "expression" ];
];;
&gt;- : Sexp.t = (this (is an) (s expression))
</code></pre>
</div>
<p>This prints out nicely because Core registers a pretty printer with
the toplevel. This pretty printer is based on the functions in
<code>Sexp</code> for converting s-expressions to and from strings:
<a data-primary="pretty printers" data-type="indexterm">&nbsp;</a></p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Sexp.to_string (Sexp.List [Sexp.Atom "1"; Sexp.Atom "2"]);;
&gt;- : string = "(1 2)"
Sexp.of_string ("(1 2 (3 4))");;
&gt;- : Sexp.t = (1 2 (3 4))
</code></pre>
</div>
<section data-type="note" class="level4" id="base-core-and-parsexp">
<h4>Base, Core, and Parsexp</h4>
<p>In these examples, we’re using Core rather than Base because Core has
integrated support for parsing s-expressions, courtesy of the
<code>Parsexp</code> library. If you just use Base, you’ll find that you
don’t have <code>Sexp.of_string</code> at your disposal.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">open Base;;
Sexp.of_string "(1 2 3)";;
&gt;Line 1, characters 1-15:
&gt;Alert deprecated: Base.Sexp.of_string
&gt;[since 2018-02] Use [Parsexp.Single.parse_string_exn]
&gt;Line 1, characters 1-15:
&gt;Error: This expression has type unit
&gt;       This is not a function; it cannot be applied.
</code></pre>
</div>
<p>That’s because, in an attempt to keep <code>Base</code> light, the
s-expression parsing functions aren’t included. That said, you can
always use them by calling out to the corresponding functions from the
<code>Parsexp</code> library:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Parsexp.Single.parse_string_exn "(1 2 3)";;
&gt;- : Sexp.t = (1 2 3)
</code></pre>
</div>
</section>
<p>In addition to providing the <code>Sexp</code> module, most of the
base types in Base and Core support conversion to and from
s-expressions. For example, we can use the conversion functions defined
in the respective modules for integers, strings, and exceptions:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Int.sexp_of_t 3;;
&gt;- : Sexp.t = 3
String.sexp_of_t "hello";;
&gt;- : Sexp.t = hello
Exn.sexp_of_t (Invalid_argument "foo");;
&gt;- : Sexp.t = (Invalid_argument foo)
</code></pre>
</div>
<p>It’s also possible to convert container types such as lists or arrays
that are polymorphic over the type of data they contain.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">#show List.sexp_of_t;;
&gt;val sexp_of_t : ('a -&gt; Sexp.t) -&gt; 'a list -&gt; Sexp.t
</code></pre>
</div>
<p>Notice that <code>List.sexp_of_t</code> is polymorphic and takes as
its first argument another conversion function to handle the elements of
the list to be converted. Base and Core use this scheme more generally
for defining sexp converters for polymorphic types. Here’s an example of
it in action.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">List.sexp_of_t Int.sexp_of_t [1; 2; 3];;
&gt;- : Sexp.t = (1 2 3)
</code></pre>
</div>
<p>The functions that go in the other direction, <em>i.e.</em>,
reconstruct an OCaml value from an s-expression, use essentially the
same trick for handling polymorphic types, as shown below.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">List.t_of_sexp Int.t_of_sexp (Sexp.of_string "(1 2 3)");;
&gt;- : int list = [1; 2; 3]
</code></pre>
</div>
<p>Such a function will fail with an exception when presented with an
s-expression that doesn’t match the structure of the OCaml type in
question.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">List.t_of_sexp Int.t_of_sexp (Sexp.of_string "(1 2 three)");;
&gt;Exception:
&gt;(Of_sexp_error "int_of_sexp: (Failure int_of_string)" (invalid_sexp three))
</code></pre>
</div>
<section data-type="note" class="level4" id="more-on-top-level-printing">
<h4>More on Top-Level Printing</h4>
<p>The values of the s-expressions that we created were printed properly
as s-expressions in the toplevel, instead of as the tree of
<code>Atom</code> and <code>List</code> variants that they’re actually
made of. <a data-primary="top-level printers" data-type="indexterm">&nbsp;</a></p>
<p>This is due to OCaml’s facility for installing custom <em>top-level
printers</em> that can rewrite some values into more top-level-friendly
equivalents. They are generally installed as <code>ocamlfind</code>
packages ending in <code>top</code>:</p>
<div class="highlight">
<pre data-filter-output=">" data-host="lama" data-user="fun" class="command-line"><code class="language-bash">ocamlfind list | grep top
&gt;astring.top         (version: 0.8.3)
&gt;cohttp.top          (version: n/a)
&gt;compiler-libs.toplevel (version: [distributed with Ocaml])
&gt;core.top            (version: v0.10.0)
...
&gt;uri.top             (version: 1.9.6)
&gt;utop                (version: 2.1.0)
</code></pre>
</div>
<p>The <code>core.top</code> package (which you should have loaded by
default in your <code>.ocamlinit</code> file) loads in printers for the
Core extensions already, so you don’t need to do anything special to use
the s-expression printer.</p>
</section>
<section class="level3" id="s-expression-converters-for-new-types">
<h3>S-Expression Converters for New Types</h3>
<p>But what if you want a function to convert a brand new type to an
s-expression? You can of course write it yourself manually. Here’s an
example. <a data-secondary="generating from OCaml
types" data-primary="s-expressions" data-type="indexterm">&nbsp;</a></p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">type t = { foo: int; bar: float };;
&gt;type t = { foo : int; bar : float; }
let sexp_of_t t =
  let a x = Sexp.Atom x and l x = Sexp.List x in
  l [ l [a "foo"; Int.sexp_of_t t.foo  ];
      l [a "bar"; Float.sexp_of_t t.bar]; ];;
&gt;val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;
sexp_of_t { foo = 3; bar = -5.5 };;
&gt;- : Sexp.t = ((foo 3) (bar -5.5))
</code></pre>
</div>
<p>This is somewhat tiresome to write, and it gets more so when you
consider the parser, i.e., <code>t_of_sexp</code>, which is considerably
more complex. Writing this kind of parsing and printing code by hand is
mechanical and error prone, not to mention a drag.</p>
<p>Given how mechanical the code is, you could imagine writing a program
that inspects the type definition and automatically generates the
conversion code for you. As it turns out, there’s a <em>syntax
extension</em> called <code>ppx_sexp_conv</code> which does just that,
creating the required functions for every type annotated with
<code>[@@deriving sexp]</code>. To enable <code>ppx_sexp_conv</code>,
we’re going to enable <code>ppx_jane</code>, which is a larger
collection of useful extensions that includes
<code>ppx_sexp_conv</code>. <a data-primary="ppx_sexp_conv" data-type="indexterm">&nbsp;</a> <a data-secondary="ppx_sexp_conv" data-primary="syntax extension" data-type="indexterm">&nbsp;</a></p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">#require "ppx_jane";;
</code></pre>
</div>
<p> We can use the extension as follows.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">type t = { foo: int; bar: float } [@@deriving sexp];;
&gt;type t = { foo : int; bar : float; }
&gt;val t_of_sexp : Sexp.t -&gt; t = &lt;fun&gt;
&gt;val sexp_of_t : t -&gt; Sexp.t = &lt;fun&gt;
t_of_sexp (Sexp.of_string "((bar 35) (foo 3))");;
&gt;- : t = {foo = 3; bar = 35.}
</code></pre>
</div>
<p>The syntax extension can be used outside of type declarations as
well. As discussed in <a data-type="xref" href="error-handling.html#error-handling">Chapter 7, Error Handling</a>, <code>[@@deriving sexp]</code> can
be attached to the declaration of an exception to improve the quality of
errors printed by OCaml’s top-level exception handler.</p>
<p>Here are two exception declarations, one with an annotation, and one
without:</p>
<div class="highlight">
<pre><code class="language-ocaml">exception Ordinary_exn of string list;;
exception Exn_with_sexp of string list [@@deriving sexp];;</code></pre>
</div>
<p> And here’s the difference in what you see when you throw these
exceptions.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">raise (Ordinary_exn ["1";"2";"3"]);;
&gt;Exception: Ordinary_exn(_).
raise (Exn_with_sexp ["1";"2";"3"]);;
&gt;Exception: (//toplevel//.Exn_with_sexp (1 2 3))
</code></pre>
</div>
<p><code>ppx_sexp_conv</code> also supports inline declarations that
generate converters for anonymous types.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">[%sexp_of: int * string ];;
&gt;- : int * string -&gt; Sexp.t = &lt;fun&gt;
[%sexp_of: int * string ] (3, "foo");;
&gt;- : Sexp.t = (3 foo)
</code></pre>
</div>
<p>The syntax extensions bundled with Base and Core almost all have the
same basic structure: they auto-generate code based on type definitions,
implementing functionality that you could in theory have implemented by
hand, but with far less programmer effort.</p>
<section data-type="note" class="level4" id="syntax-extensions-and-ppx">
<h4>Syntax Extensions and PPX</h4>
<p>OCaml doesn’t directly support deriving s-expression converters from
type definitions. Instead, it provides a mechanism called <em>PPX</em>
which allows you to add to the compilation pipeline code for
transforming OCaml programs at the syntactic level, via the
<code>-ppx</code> compiler flag.</p>
<p>PPXs operate on OCaml’s <em>abstract syntax tree</em>, or AST, which
is a data type that represents the syntax of a well-formed OCaml
program. Annotations like <code>[%sexp_of: int]</code> or
<code>[@@deriving sexp]</code> are part of special extensions to the
syntax, called <em>extension points</em>, which were added to the
language to give a place to put information that would be consumed by
syntax extensions like <code>ppx_sexp_conv</code>. <a data-primary="PPX
syntax extensions" data-type="indexterm">&nbsp;</a><a data-primary="syntax extension with
PPX" data-type="indexterm">&nbsp;</a></p>
<p><code>ppx_sexp_conv</code> is part of a family of syntax extensions,
including <code>ppx_compare</code>, described in <a data-type="xref" href="maps-and-hashtables.html#maps-and-hash-tables">Chapter 14, Maps And Hash Tables</a>, and <code>ppx_fields</code>,
described in <a data-type="xref" href="records.html#records">Chapter 5, Records</a>, that generate code based on type
declarations. <a data-secondary="ppx_sexp_conv" data-primary="syntax extension" data-type="indexterm">&nbsp;</a>
<a data-secondary="ppx_compare" data-primary="syntax extension" data-type="indexterm">&nbsp;</a> <a data-primary="ppx_sexp_conv" data-type="indexterm">&nbsp;</a> <a data-primary="ppx_compare" data-type="indexterm">&nbsp;</a></p>
<p>Using these extensions from a <code>dune</code> file is as simple as
adding this directive to a <code>(library)</code> or
<code>(executable)</code> stanza to indicate that the files should be
run through a preprocessor:</p>
<div class="highlight">
<pre><code class="language-sexp">(executable
  (name hello)
  (preprocess (pps ppx_sexp_conv))
)</code></pre>
</div>
</section>
</section>
</section>
<section class="level2" id="the-sexp-format">
<h2>The Sexp Format</h2>
<p>The textual representation of s-expressions is pretty
straightforward. An s-expression is written down as a nested
parenthetical expression, with whitespace-separated strings as the
atoms. Quotes are used for atoms that contain parentheses or spaces
themselves; backslash is the escape character; and semicolons are used
to introduce single-line comments. Thus, the following file,
<code>example.scm</code>: <a data-secondary="format
of" data-primary="s-expressions" data-type="indexterm">&nbsp;</a></p>
<div class="highlight">
<pre><code class="language-clike">((foo 3.3) ;; This is a comment
 (bar "this is () an \" atom"))</code></pre>
</div>
<p> can be loaded as follows.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Sexp.load_sexp "example.scm";;
&gt;- : Sexp.t = ((foo 3.3) (bar "this is () an \" atom"))
</code></pre>
</div>
<p> As you can see, the comment is not part of the loaded
s-expression.</p>
<p>All in, the s-expression format supports three comment syntaxes:</p>
<dl>
<dt><code>;</code></dt>
<dd>
Comments out everything to the end of line
</dd>
<dt><code>#|,|#</code></dt>
<dd>
Delimiters for commenting out a block
</dd>
<dt><code>#;</code></dt>
<dd>
Comments out the first complete s-expression that follows
</dd>
</dl>
<p>The following example shows all of these in action:</p>
<div class="highlight">
<pre><code class="language-clike">;; comment_heavy_example.scm
((this is included)
 ; (this is commented out
 (this stays)
 #; (all of this is commented
     out (even though it crosses lines.))
  (and #| block delimiters #| which can be nested |#
     will comment out
    an arbitrary multi-line block))) |#
   now we're done
   ))</code></pre>
</div>
<p> Again, loading the file as an s-expression drops the comments:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Sexp.load_sexp "comment_heavy.scm";;
&gt;- : Sexp.t = ((this is included) (this stays) (and now we're done))
</code></pre>
</div>
<p>If we introduce an error into our s-expression, by, say, creating a
file <code>broken_example.scm</code> which is <code>example.scm</code>,
without the open-paren in front of <code>bar</code>, we’ll get a parse
error:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Sexp.load_sexp "example_broken.scm";;
&gt;Exception:
&gt;(Sexplib.Sexp.Parse_error
&gt;  ((err_msg "unexpected character: ')'") (text_line 4) (text_char 30)
&gt;    (global_offset 78) (buf_pos 78)))
</code></pre>
</div>
</section>
<section class="level2" id="preserving-invariants">
<h2>Preserving Invariants</h2>
<p>Modules and module interfaces are an important part of how OCaml code
is structured and designed. One of the key reasons we use module
interfaces is to make it possible to enforce invariants. In particular,
by restricting how values of a given type can be created and
transformed, interfaces let you enforce various rules, including
ensuring that your data is well-formed. <a data-secondary="preserving invariants in" data-primary="s-expressions" data-type="indexterm">&nbsp;</a></p>
<p>When you add s-expression converters (or really any deserializer) to
an API, you’re adding an alternate path for creating values, and if
you’re not careful, that alternate path can violate the carefully
maintained invariants of your code.</p>
<p>In the following, we’ll show how this problem can crop up, and how to
resolve it. Let’s consider a module <code>Int_interval</code> for
representing closed integer intervals, similar to the one described in
<a data-type="xref" href="functors.html#functors">Chapter 10, Functors</a>.</p>
<p>Here’s the signature.</p>
<div class="highlight">
<pre><code class="language-ocaml">type t [@@deriving sexp]

(** [create lo hi] creates an interval from [lo] to [hi] inclusive,
   and is empty if [lo &gt; hi]. *)
val create : int -&gt; int -&gt; t

val is_empty : t -&gt; bool
val contains : t -&gt; int -&gt; bool</code></pre>
</div>
<p>In addition to basic operations for creating and evaluating
intervals, this interface also exposes s-expression converters. Note
that the <code>[@@deriving sexp]</code> syntax works in a signature as
well, but in this case, it just adds the signature for the conversion
functions, not the implementation.</p>
<p>Here’s the implementation of <code>Int_interval</code>.</p>
<div class="highlight">
<pre><code class="language-ocaml">open Core

(* for [Range (x,y)], we require that [y &gt;= x] *)
type t =
  | Range of int * int
  | Empty
[@@deriving sexp]

let create x y = if x &gt; y then Empty else Range (x, y)

let is_empty = function
  | Empty -&gt; true
  | Range _ -&gt; false

let contains i x =
  match i with
  | Empty -&gt; false
  | Range (low, high) -&gt; x &gt;= low &amp;&amp; x &lt;= high</code></pre>
</div>
<p>One critical invariant here is that <code>Range</code> is only used
to represent non-empty intervals. A call to <code>create</code> with a
lower bound above the upper bound will return an <code>Empty</code>.</p>
<p>Now, let’s demonstrate the functionality with some tests, using the
expect test framework described in <a data-type="xref" href="testing.html#expect-tests">Chapter 17, Testing</a>. First, we’ll write a test helper that
takes an interval and a list of points, and prints out the result of
checking for emptiness, and a classification of which points are inside
and outside the interval.</p>
<div class="highlight">
<pre><code class="language-ocaml">let test_interval i points =
  let in_, out =
    List.partition_tf points ~f:(fun x -&gt; Int_interval.contains i x)
  in
  let to_string l =
    List.map ~f:Int.to_string l |&gt; String.concat ~sep:", "
  in
  print_endline
    (String.concat
       ~sep:"\n"
       [ (if Int_interval.is_empty i then "empty" else "non-empty")
       ; "in:  " ^ to_string in_
       ; "out: " ^ to_string out
       ])</code></pre>
</div>
<p>We can run this test on a non-empty interval,</p>
<div class="highlight">
<pre><code class="language-ocaml">let%expect_test "ordinary interval" =
  test_interval (Int_interval.create 3 6) (List.range 1 10);
  [%expect
    {|
    non-empty
    in:  3, 4, 5, 6
    out: 1, 2, 7, 8, 9 |}]</code></pre>
</div>
<p> And also on an empty one.</p>
<div class="highlight">
<pre><code class="language-ocaml">let%expect_test "empty interval" =
  test_interval (Int_interval.create 6 3) (List.range 1 10);
  [%expect {|
    empty
    in:
    out: 1, 2, 3, 4, 5, 6, 7, 8, 9 |}]</code></pre>
</div>
<p> Note that the result of checking <code>is_empty</code> lines up with
the test of what elements are contained and not contained in the
interval.</p>
<p>Now, let’s test out the s-expression converters, starting with
<code>sexp_of_t</code>. This test lets you see that a flipped-bounds
interval is represented by <code>Empty</code>.</p>
<div class="highlight">
<pre><code class="language-ocaml">let%expect_test "test to_sexp" =
  let t lo hi =
    let i = Int_interval.create lo hi in
    print_s [%sexp (i : Int_interval.t)]
  in
  t 3 6;
  [%expect {| (Range 3 6) |}];
  t 4 4;
  [%expect {| (Range 4 4) |}];
  t 6 3;
  [%expect {| Empty |}]</code></pre>
</div>
<p>The next thing to check is the <code>t_of_sexp</code> converters, and
here, we run into a problem. In particular, consider what would happen
if we create an interval from the s-expression <code>(Range 6 3)</code>.
That’s an s-expression that shouldn’t ever be generated by the library,
since intervals should never have swapped bounds. But there’s nothing to
stop us from generating that s-expression by hand.</p>
<div class="highlight">
<pre><code class="language-ocaml">let%expect_test "test (range 6 3)" =
  let i = Int_interval.t_of_sexp (Sexp.of_string "(Range 6 3)") in
  test_interval i (List.range 1 10);
  [%expect
    {|
    non-empty
    in:
    out: 1, 2, 3, 4, 5, 6, 7, 8, 9 |}]</code></pre>
</div>
<p>You can see something bad has happened, since this interval is
detected as non-empty, but doesn’t appear to contain anything. The
problem traces back to the fact that <code>t_of_sexp</code> doesn’t
check the same invariant that <code>create</code> does. We can fix this,
by overriding the auto-generated s-expression converter with one that
checks the invariant, in this case, by calling <code>create</code>.</p>
<div class="highlight">
<pre><code class="language-ocaml">let t_of_sexp sexp =
  match t_of_sexp sexp with
  | Empty -&gt; Empty
  | Range (x, y) -&gt; create x y</code></pre>
</div>
<p>Overriding an existing function definition with a new one is
perfectly acceptable in OCaml. Since <code>t_of_sexp</code> is defined
with an ordinary <code>let</code> rather than a <code>let rec</code>,
the call to the <code>t_of_sexp</code> goes to the derived version of
the function, rather than being a recursive call.</p>
<p>Note that, rather than fixing up the invariant, we could have instead
thrown an exception if the invariant was violated. In any case, the
approach we took means that rerunning our test produces a more
consistent and sensible result.</p>
<div class="highlight">
<pre><code class="language-ocaml">let%expect_test "test (range 6 3)" =
  let i = Int_interval.t_of_sexp (Sexp.of_string "(Range 6 3)") in
  test_interval i (List.range 1 10);
  [%expect
    {|
    empty
    in:
    out: 1, 2, 3, 4, 5, 6, 7, 8, 9 |}]</code></pre>
</div>
</section>
<section class="level2" id="getting-good-error-messages">
<h2>Getting Good Error Messages</h2>
<p>There are two steps to deserializing a type from an s-expression:
first, converting the bytes in a file to an s-expression; and the
second, converting that s-expression into the type in question. One
problem with this is that it can be hard to localize errors to the right
place using this scheme. Consider the following example. <a data-secondary="s-expressions" data-primary="debugging" data-type="indexterm">&nbsp;</a><a data-secondary="error
messages with s-expressions" data-primary="errors" data-type="indexterm">&nbsp;</a><a data-secondary="deserializing a type from" data-primary="s-expressions" data-type="indexterm">&nbsp;</a></p>
<div class="highlight">
<pre><code class="language-ocaml">open Core

type t =
  { a : string
  ; b : int
  ; c : float option
  }
[@@deriving sexp]

let () =
  let t = Sexp.load_sexp "example.scm" |&gt; t_of_sexp in
  printf "b is: %d\n%!" t.b</code></pre>
</div>
<p>If you were to run this on a malformatted file, say, this one:</p>
<div class="highlight">
<pre><code class="language-clike">((a not-a-string)
 (b not-a-string)
 (c 1.0))</code></pre>
</div>
<p> you’ll get the following error. (Note that we set the
<code>OCAMLRUNPARAM</code> environment variable to suppress the stack
trace here.)</p>
<div class="highlight">
<pre data-filter-output=">" data-host="lama" data-user="fun" class="command-line"><code class="language-bash">OCAMLRUNPARAM=b=0 dune exec -- ./read_foo.exe
&gt;Uncaught exception:
&gt;
&gt;  (Of_sexp_error "int_of_sexp: (Failure int_of_string)"
&gt;   (invalid_sexp not-a-string))
&gt;
[2]</code></pre>
</div>
<p>If all you have is the error message and the string, it’s not
terribly informative. In particular, you know that the parsing errored
out on the atom “not-an-integer,” but you don’t know which one! In a
large file, this kind of bad error message can be pure misery.</p>
<p>But there’s hope! We can make a small change to the code to improve
the error message greatly:</p>
<div class="highlight">
<pre><code class="language-ocaml">open Core

type t =
  { a : string
  ; b : int
  ; c : float option
  }
[@@deriving sexp]

let () =
  let t = Sexp.load_sexp_conv_exn "example.scm" t_of_sexp in
  printf "b is: %d\n%!" t.b</code></pre>
</div>
<p>If we run it again, we’ll see a more informative error.</p>
<div class="highlight">
<pre data-filter-output=">" data-host="lama" data-user="fun" class="command-line"><code class="language-bash">OCAMLRUNPARAM=b=0 dune exec -- ./read_foo.exe
&gt;Uncaught exception:
&gt;
&gt;  (Of_sexp_error example.scm:2:4 "int_of_sexp: (Failure int_of_string)"
&gt;   (invalid_sexp not-an-integer))
&gt;
[2]</code></pre>
</div>
<p>Here, <code>example.scm:2:5</code> tells us that the error occurred
in the file <code>"example.scm"</code> on line 2, character 5. This is a
much better start for figuring out what went wrong. The ability to find
the precise location of the error depends on the sexp converter
reporting errors using the function <code>of_sexp_error</code>. This is
already done by converters generated by <code>ppx_sexp_conv</code>, but
you should make sure to do the same when you write custom
converters.</p>
</section>
<section class="level2" id="sexp-conversion-directives">
<h2>Sexp-Conversion Directives</h2>
<p><code>ppx_sexp_conv</code> supports a collection of directives for
modifying the default behavior of the auto-generated sexp converters.
These directives allow you to customize the way in which types are
represented as s-expressions without having to write a custom converter.
<a data-secondary="directives" data-primary="ppx_sexp_conv" data-type="indexterm">&nbsp;</a></p>
<section class="level3" id="sexp_opaque">
<h3><code>@sexp.opaque</code></h3>
<p>The most commonly used directive is <code>[@sexp_opaque]</code>,
whose purpose is to mark a given component of a type as being
unconvertible. Anything marked with the <code>[@sexp.opaque]</code>
attribute will be presented as the atom <code>&lt;opaque&gt;</code> by
the to-sexp converter, and will trigger an exception from the from-sexp
converter. <a data-secondary="sexp.opaque" data-primary="ppx_sexp_conv" data-type="indexterm">&nbsp;</a></p>
<p>Note that the type of a component marked as opaque doesn’t need to
have a sexp converter defined. By default, if we define a type without a
sexp converter and then try to use it as part of another type with a
sexp converter, we’ll error out:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">type no_converter = int * int;;
&gt;type no_converter = int * int
type t = { a: no_converter; b: string } [@@deriving sexp];;
&gt;Line 1, characters 15-27:
&gt;Error: Unbound value no_converter_of_sexp
</code></pre>
</div>
<p> But with <code>[@sexp.opaque]</code>, we can embed our opaque
<code>no_converter</code> type within the other data structure without
an error.</p>
<div class="highlight">
<pre><code class="language-ocaml">type t =
  { a: (no_converter [@sexp.opaque]);
    b: string
  } [@@deriving sexp];;</code></pre>
</div>
<p> And if we now convert a value of this type to an s-expression, we’ll
see the contents of field <code>a</code> marked as opaque:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">sexp_of_t { a = (3,4); b = "foo" };;
&gt;- : Sexp.t = ((a &lt;opaque&gt;) (b foo))
</code></pre>
</div>
<p>Note that <code>t_of_sexp</code> is still generated, but will fail at
runtime when called.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">t_of_sexp (Sexp.of_string "((a whatever) (b foo))");;
&gt;Exception:
&gt;(Of_sexp_error "opaque_of_sexp: cannot convert opaque values"
&gt;  (invalid_sexp whatever))
</code></pre>
</div>
<p>It might seem perverse to create a parser for a type containing a
<code>[@sexp.opaque]</code> value, but it’s not as useless as it seems.
In particular, such a converter won’t necessarily fail on all inputs.
Consider a record containing a list of opaque values:</p>
<div class="highlight">
<pre><code class="language-ocaml">type t =
  { a: (no_converter [@sexp.opaque]) list;
    b: string
  } [@@deriving sexp];;</code></pre>
</div>
<p> The <code>t_of_sexp</code> function can still succeed, as long as
the list is empty.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">t_of_sexp (Sexp.of_string "((a ()) (b foo))");;
&gt;- : t = {a = []; b = "foo"}
</code></pre>
</div>
<p>Sometimes, though, one or other of the converters is useless, and you
want to explicitly choose what to generate. You can do that by using
<code>[@@deriving sexp_of]</code> or <code>[@@deriving of_sexp]</code>
instead of <code>[@@deriving sexp]</code>.</p>
</section>
<section class="level3" id="sexp_list">
<h3><code>@sexp.list</code></h3>
<p>Sometimes, sexp converters have more parentheses than one would
ideally like. Consider the following variant type. <a data-secondary="sexp.list" data-primary="ppx_sexp_conv" data-type="indexterm">&nbsp;</a></p>
<div class="highlight">
<pre><code class="language-ocaml">type compatible_versions =
  | Specific of string list
  | All
[@@deriving sexp];;</code></pre>
</div>
<p>Here’s what the concrete syntax looks like.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">sexp_of_compatible_versions
  (Specific ["3.12.0"; "3.12.1"; "3.13.0"]);;
&gt;- : Sexp.t = (Specific (3.12.0 3.12.1 3.13.0))
</code></pre>
</div>
<p>The set of parens around the list of versions is arguably excessive.
We can drop those parens using the <code>[@sexp.list]</code>
directive.</p>
<div class="highlight">
<pre><code class="language-ocaml">type compatible_versions =
  | Specific of string list [@sexp.list]
  | All [@@deriving sexp]</code></pre>
</div>
<p> And here’s the resulting lighter syntax.</p>
<div class="highlight">
<pre><code class="language-ocalm"># sexp_of_compatible_versions
    (Specific ["3.12.0"; "3.12.1"; "3.13.0"]);;
- : Sexp.t = (Specific 3.12.0 3.12.1 3.13.0)</code></pre>
</div>
</section>
<section class="level3" id="sexp_option">
<h3><code>@sexp.option</code></h3>
<p>By default, optional values are represented either as <code>()</code>
for <code>None</code>. Here’s an example of a record type containing an
option: <a data-secondary="sexp.option" data-primary="ppx_sexp_conv" data-type="indexterm">&nbsp;</a></p>
<div class="highlight">
<pre><code class="language-ocaml">type t =
  { a: int option;
    b: string;
  } [@@deriving sexp]</code></pre>
</div>
<p> And here’s what the concrete syntax looks like on some simple
examples.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">sexp_of_t { a = None; b = "hello" };;
&gt;- : Sexp.t = ((a ()) (b hello))
sexp_of_t { a = Some 3; b = "hello" };;
&gt;- : Sexp.t = ((a (3)) (b hello))
</code></pre>
</div>
<p>This all works as you might expect, but in the context of a record,
you might want a different behavior, which is to make the field itself
optional. The <code>[@sexp.option]</code> directive gives you just
that.</p>
<div class="highlight">
<pre><code class="language-ocaml">type t =
  { a: int option [@sexp.option];
    b: string;
  } [@@deriving sexp]</code></pre>
</div>
<p> And here is the new syntax. Note that when the value of
<code>a</code> is <code>Some</code>, it shows up in the s-expression
unadorned, and when it’s <code>None</code>, the entire record field is
omitted.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">sexp_of_t { a = Some 3; b = "hello" };;
&gt;- : Sexp.t = ((a 3) (b hello))
sexp_of_t { a = None; b = "hello" };;
&gt;- : Sexp.t = ((b hello))
</code></pre>
</div>
</section>
<section class="level3" id="specifying-defaults">
<h3>Specifying Defaults</h3>
<p><code>[@sexp.option]</code> gives you a way of interpreting the
s-expression for a record where some of the fields are left unspecified.
The <code>[@default]</code> directive provides another. <a data-secondary="specifying defaults in" data-primary="s-expressions" data-type="indexterm">&nbsp;</a> <a data-secondary="default" data-primary="ppx_sexp_conv" data-type="indexterm">&nbsp;</a></p>
<p>Consider the following type, which represents the configuration of a
very simple web server:</p>
<div class="highlight">
<pre><code class="language-ocaml">type http_server_config = {
  web_root: string;
  port: int;
  addr: string;
} [@@deriving sexp];;</code></pre>
</div>
<p>One could imagine making some of these parameters optional; in
particular, by default, we might want the web server to bind to port 80,
and to listen as localhost. We can do this as follows:</p>
<div class="highlight">
<pre><code class="language-ocaml">type http_server_config = {
  web_root: string;
  port: int [@default 80];
  addr: string [@default "localhost"];
} [@@deriving sexp];;</code></pre>
</div>
<p>Now, if we try to convert an s-expression that specifies only the
<code>web_root</code>, we’ll see that the other values are filled in
with the desired defaults:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let cfg =
  "((web_root /var/www/html))"
  |&gt; Sexp.of_string
  |&gt; http_server_config_of_sexp;;
&gt;val cfg : http_server_config =
&gt;  {web_root = "/var/www/html"; port = 80; addr = "localhost"}
</code></pre>
</div>
<p>If we convert the configuration back out to an s-expression, you’ll
notice that all of the fields are present, even though they’re not
strictly necessary:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">sexp_of_http_server_config cfg;;
&gt;- : Sexp.t = ((web_root /var/www/html) (port 80) (addr localhost))
</code></pre>
</div>
<p>We could make the generated s-expression also drop default values, by
using the <code>[@sexp_drop_default]</code> directive: <a data-secondary="sexp_drop_default" data-primary="ppx_sexp_conv" data-type="indexterm">&nbsp;</a></p>
<div class="highlight">
<pre><code class="language-ocaml">type http_server_config = {
  web_root: string;
  port: int [@default 80] [@sexp_drop_default.equal];
  addr: string [@default "localhost"] [@sexp_drop_default.equal];
} [@@deriving sexp];;</code></pre>
</div>
<p> And here’s an example of it in action:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let cfg =
  "((web_root /var/www/html))"
  |&gt; Sexp.of_string
  |&gt; http_server_config_of_sexp;;
&gt;val cfg : http_server_config =
&gt;  {web_root = "/var/www/html"; port = 80; addr = "localhost"}
sexp_of_http_server_config cfg;;
&gt;- : Sexp.t = ((web_root /var/www/html))
</code></pre>
</div>
<p>As you can see, the fields that are at their default values are
omitted from the generated s-expression. On the other hand, if we
convert a config with non-default values, they will show up in the
generated s-expression.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">sexp_of_http_server_config { cfg with port = 8080 };;
&gt;- : Sexp.t = ((web_root /var/www/html) (port 8080))
sexp_of_http_server_config
{ cfg with port = 8080; addr = "192.168.0.1" };;
&gt;- : Sexp.t = ((web_root /var/www/html) (port 8080) (addr 192.168.0.1))
</code></pre>
</div>
<p>This can be very useful in designing config file formats that are
both reasonably terse and easy to generate and maintain. It can also be
useful for backwards compatibility: if you add a new field to your
config record but make that field optional, then you should still be
able to parse older version of your config.</p>
<p>The exact attribute you use depends on the comparison functions
available over the type that you wish to drop:</p>
<ul>
<li><code>[@sexp_drop_default.compare]</code> if the type supports
<code>[%compare]</code></li>
<li><code>[@sexp_drop_default.equal]</code> if the type supports
<code>[%equal]</code></li>
<li><code>[@sexp_drop_default.sexp]</code> if you want to compare the
sexp representations</li>
<li><code>[@sexp_drop_default f]</code> and give an explicit equality
function</li>
</ul>
<p>Most of the type definitions supplied with Base and Core provide the
comparison and equality operations, so those are reasonable default
attributes to use.</p>
</section>
</section>
</section>
</article></div><a href="platform.html" class="next-chapter"><div class="content"><h1><small>Next: Chapter 21</small>The OCaml Platform</h1></div></a><footer><div class="content"><ul><li><a href="http://twitter.com/realworldocaml">@realworldocaml</a></li><li><a href="http://twitter.com/yminsky">@yminsky</a></li><li><a href="http://twitter.com/avsm">@avsm</a></li><li><a href="https://github.com/realworldocaml">GitHub</a></li><li><a href="http://www.goodreads.com/book/show/16087552-real-world-ocaml">goodreads</a></li></ul><p>Copyright 2012-2022 Anil Madhavapeddy and Yaron Minsky.</p></div></footer><script src="js/jquery.min.js"></script><script src="js/min/app-min.js"></script></body></html>