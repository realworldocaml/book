<section xmlns="http://www.w3.org/1999/xhtml" id="imperative-programming-1" data-type="chapter"><h1>Imperative Programming</h1><p>Most of the code shown so far in this book, and indeed, most OCaml
  code in general, is <em>pure</em>. Pure code works without
  mutating the program's internal state, performing I/O, reading the clock, or
  in any other way interacting with changeable parts of the world. Thus, a
  pure function behaves like a mathematical function, always returning the
  same results when given the same inputs, and never affecting the world
  except insofar as it returns the value of its computation.
  <em>Imperative</em> code, on the other hand, operates by side
  effects that modify a program's internal state or interact with the outside
  world. An imperative function has a new effect, and potentially returns
  different results, every time it's called.<a data-type="indexterm" data-primary="imperative programming" data-secondary="benefits of"/><a data-type="indexterm" data-primary="pure code"/><a data-type="indexterm" data-primary="programming" data-secondary="immutable vs. imperative"/><a data-type="indexterm" id="PROGimper" data-primary="programming" data-secondary="imperative programming"/></p><p>Pure code is the default in OCaml, and for good reason—it's generally
  easier to reason about, less error prone and more composable. But imperative
  code is of fundamental importance to any practical programming language,
  because real-world tasks require that you interact with the outside world,
  which is by its nature imperative. Imperative programming can also be
  important for performance. While pure code is quite efficient in OCaml,
  there are many algorithms that can only be implemented efficiently using
  imperative techniques.</p><p>OCaml offers a happy compromise here, making it easy and natural to
  program in a pure style, but also providing great support for imperative
  programming. This chapter will walk you through OCaml's imperative features,
  and help you use them to their fullest.</p><section id="example-imperative-dictionaries" data-type="sect1"><h1>Example: Imperative Dictionaries</h1><p>We'll start with the implementation of a simple imperative
    dictionary, i.e., a mutable mapping from keys to values. This is really
    for illustration purposes; both Core and the standard library provide
    imperative dictionaries, and for most real-world tasks, you should use one
    of those implementations. There's more advice on using Core's
    implementation in particular in <a href="#maps-and-hash-tables" data-type="xref"/>.<a data-type="indexterm" id="DICTimper" data-primary="dictionaries, imperative"/><a data-type="indexterm" data-primary="Core standard library" data-secondary="imperative dictionaries in"/><a data-type="indexterm" id="IPimpdict" data-primary="imperative programming" data-secondary="imperative dictionaries"/></p><p>The dictionary we'll describe now, like those in Core and the
    standard library, will be implemented as a hash table. In particular,
    we'll use an <em>open hashing</em> scheme, where the hash
    table will be an array of buckets, each bucket containing a list of
    key/value pairs that have been hashed into that bucket.<a data-type="indexterm" data-primary="open hashing"/></p><p>Here's the interface we'll match, provided as an <code>mli</code>. The type <code>('a, 'b)
    t</code> represents a dictionary with keys of type <code>'a</code> and data of type <code>'b</code>:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/dictionary.mli" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a>
    (part 1)</p><pre data-type="programlisting" data-code-language="ocaml">(* file: dictionary.mli *)
open Core.Std

type ('a, 'b) t

val create : unit -&gt; ('a, 'b) t
val length : ('a, 'b) t -&gt; int
val add    : ('a, 'b) t -&gt; key:'a -&gt; data:'b -&gt; unit
val find   : ('a, 'b) t -&gt; 'a -&gt; 'b option
val iter   : ('a, 'b) t -&gt; f:(key:'a -&gt; data:'b -&gt; unit) -&gt; unit
val remove : ('a, 'b) t -&gt; 'a -&gt; unit</pre><p>The <code>mli</code> also includes a
    collection of helper functions whose purpose and behavior should be
    largely inferrable from their names and type signatures. Notice that a
    number of the functions, in particular, ones like <code>add</code> that modify the dictionary, return
    <code>unit</code>. This is typical of functions that act by side
    effect.</p><p>We'll now walk through the implementation (contained in the
    corresponding <code>ml</code> file) piece by piece,
    explaining different imperative constructs as they come up.</p><p>Our first step is to define the type of a dictionary as a record
    with two fields:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/dictionary.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a>
    (part 1)</p><pre data-type="programlisting" data-code-language="ocaml">(* file: dictionary.ml *)
open Core.Std

type ('a, 'b) t = { mutable length: int;
                    buckets: ('a * 'b) list array;
                  }</pre><p>The first field, <code>length</code>, is
    declared as mutable. In OCaml, records are immutable by default, but
    individual fields are mutable when marked as such. The second field,
    <code>buckets</code>, is immutable but contains an
    array, which is itself a mutable data structure.<a data-type="indexterm" data-primary="fields" data-secondary="mutability of"/></p><p>Now we'll start putting together the basic functions for
    manipulating a dictionary:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/dictionary.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a>
    (part 2)</p><pre data-type="programlisting" data-code-language="ocaml">let num_buckets = 17

let hash_bucket key = (Hashtbl.hash key) mod num_buckets

let create () =
  { length = 0;
    buckets = Array.create ~len:num_buckets [];
  }

let length t = t.length

let find t key =
  List.find_map t.buckets.(hash_bucket key)
    ~f:(fun (key',data) -&gt; if key' = key then Some data else None)</pre><p>Note that <code>num_buckets</code> is a
    constant, which means our bucket array is of fixed length. A practical
    implementation would need to be able to grow the array as the number of
    elements in the dictionary increases, but we'll omit this to simplify the
    presentation.</p><p>The function <code>hash_bucket</code> is used
    throughout the rest of the module to choose the position in the array that
    a given key should be stored at. It is implemented on top of <code>Hashtbl.hash</code>, which is a hash function provided
    by the OCaml runtime that can be applied to values of any type. Thus, its
    own type is polymorphic: <code>'a -&gt;
    int</code>.</p><p>The other functions defined above are fairly straightforward:</p><dl><dt><code>create</code></dt><dd><p>Creates an empty dictionary.</p></dd><dt><code>length</code></dt><dd><p>Grabs the length from the corresponding record field, thus
          returning the number of entries stored in the dictionary.</p></dd><dt><code>find</code></dt><dd><p>Looks for a matching key in the table and returns the
          corresponding value if found as an option.</p></dd></dl><p>Another important piece of imperative syntax shows up in <code>find</code>: we write <code>array.(index)</code> to grab a value from an array.
    <code>find</code> also uses <code>List.find_map</code>, which you can see the type of by
    typing it into the toplevel:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/examples.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 1)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>List.find_map;;</code></strong>
<code class="computeroutput">- : 'a list -&gt; f:('a -&gt; 'b option) -&gt; 'b option = &lt;fun&gt;</code></pre><p><code>List.find_map</code> iterates over the
    elements of the list, calling <code>f</code> on each
    one until a <code>Some</code> is returned by
    <code>f</code>, at which point that value is
    returned. If <code>f</code> returns <code>None</code> on all values, then <code>None</code> is returned.</p><p>Now let's look at the implementation of <code>iter</code>:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/dictionary.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a>
    (part 3)</p><pre data-type="programlisting" data-code-language="ocaml">let iter t ~f =
  for i = 0 to Array.length t.buckets - 1 do
    List.iter t.buckets.(i) ~f:(fun (key, data) -&gt; f ~key ~data)
  done</pre><p><code>iter</code> is designed to walk over all
    the entries in the dictionary. In particular, <code>iter t ~f</code> will call <code>f</code> for each key/value pair in dictionary <code>t</code>. Note that <code>f</code> must return <code>unit</code>, since it is expected to work by side
    effect rather than by returning a value, and the overall <code>iter</code> function returns <code>unit</code> as well.</p><p>The code for <code>iter</code> uses two forms of iteration: a
        <code>for</code> loop to walk over the array of buckets; and within
      that loop a call to <code>List.iter</code> to walk over the values in a
      given bucket. We could have done the outer loop with a recursive function instead of a
        <code>for</code> loop, but <code>for</code>
      loops are syntactically convenient, and are more familiar and idiomatic in imperative
      contexts.</p><p>The following code is for adding and removing mappings from the
    dictionary:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/dictionary.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a>
    (part 4)</p><pre data-type="programlisting" data-code-language="ocaml">let bucket_has_key t i key =
  List.exists t.buckets.(i) ~f:(fun (key',_) -&gt; key' = key)

let add t ~key ~data =
  let i = hash_bucket key in
  let replace = bucket_has_key t i key in
  let filtered_bucket =
    if replace then
      List.filter t.buckets.(i) ~f:(fun (key',_) -&gt; key' &lt;&gt; key)
    else
      t.buckets.(i)
  in
  t.buckets.(i) &lt;- (key, data) :: filtered_bucket;
  if not replace then t.length &lt;- t.length + 1

let remove t key =
  let i = hash_bucket key in
  if bucket_has_key t i key then (
    let filtered_bucket =
      List.filter t.buckets.(i) ~f:(fun (key',_) -&gt; key' &lt;&gt; key)
    in
    t.buckets.(i) &lt;- filtered_bucket;
    t.length &lt;- t.length - 1
  )</pre><p>This preceding code is made more complicated by the fact that we
    need to detect whether we are overwriting or removing an existing binding,
    so we can decide whether <code>t.length</code> needs
    to be changed. The helper function <code>bucket_has_key</code> is used for this purpose.</p><p>Another piece of syntax shows up in both <code>add</code> and <code>remove</code>: the use of the <code>&lt;-</code> operator to update elements of an array
    (<code>array.(i) &lt;- expr</code>) and for updating
    a record field (<code>record.field &lt;-
    expression</code>).</p><p>We also use <code>;</code>, the sequencing
    operator, to express a sequence of imperative actions. We could have done
    the same using <code>let</code> bindings:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/dictionary2.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a>
    (part 1)</p><pre data-type="programlisting" data-code-language="ocaml">let () = t.buckets.(i) &lt;- (key, data) :: filtered_bucket in
  if not replace then t.length &lt;- t.length + 1</pre><p>but <code>;</code> is more concise and
    idiomatic. More generally,</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/semicolon.syntax" class="orm:hideurl:ital"><em class="hyperlink">Syntax</em></a></p><pre data-type="programlisting">&lt;expr1&gt;;
&lt;expr2&gt;;
...
&lt;exprN&gt;</pre><p>is equivalent to</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/let-unit.syntax" class="orm:hideurl:ital"><em class="hyperlink">Syntax</em></a></p><pre data-type="programlisting">let () = &lt;expr1&gt; in
let () = &lt;expr2&gt; in
...
&lt;exprN&gt;</pre><p>When a sequence expression <code>expr1;
    expr2</code> is evaluated, <code>expr1</code> is
    evaluated first, and then <code>expr2</code>. The
    expression <code>expr1</code> should have type
    <code>unit</code> (though this is a warning rather
    than a hard restriction. The <code>-strict-sequence</code> compiler flag makes this a hard
    restriction, which is generally a good idea), and the value of <code>expr2</code> is returned as the value of the entire
    sequence. For example, the sequence <code>print_string
    "hello world"; 1 + 2</code> first prints the string <code>"hello world"</code>, then returns the integer <code>3</code>.</p><p>Note also that we do all of the side-effecting operations at the
    very end of each function. This is good practice because it minimizes the
    chance that such operations will be interrupted with an exception, leaving
    the data structure in an inconsistent state.<a data-type="indexterm" data-startref="DICTimper"/><a data-type="indexterm" data-startref="IPimpdict"/></p></section><section id="primitive-mutable-data" data-type="sect1"><h1>Primitive Mutable Data</h1><p>Now that we've looked at a complete example, let's take a more
    systematic look at imperative programming in OCaml. We encountered two
    different forms of mutable data above: records with mutable fields and
    arrays. We'll now discuss these in more detail, along with the other
    primitive forms of mutable data that are available in OCaml.<a data-type="indexterm" data-primary="array-like data"/><a data-type="indexterm" data-primary="data structures" data-secondary="primitive mutable data"/><a data-type="indexterm" data-primary="mutable data"/><a data-type="indexterm" data-primary="primitive mutable data" data-secondary="array-like data"/><a data-type="indexterm" data-primary="imperative programming" data-secondary="primitive mutable data"/></p><section id="array-like-data" data-type="sect2"><h2>Array-Like Data</h2><p>OCaml supports a number of array-like data structures; i.e.,
      mutable integer-indexed containers that provide constant-time access to
      their elements. We'll discuss several of them in this section.</p><section id="ordinary-arrays" data-type="sect3"><h3>Ordinary arrays</h3><p>The <code>array</code> type is used for
        general-purpose polymorphic arrays. The <code>Array</code> module has a variety of utility
        functions for interacting with arrays, including a number of mutating
        operations. These include <code>Array.set</code>, for setting an individual
        element, and <code>Array.blit</code>, for
        efficiently copying values from one range of indices to
        another.<a data-type="indexterm" data-primary="values" data-secondary="copying with Array.blit"/><a data-type="indexterm" data-primary="elements" data-secondary="setting with Array.set"/><a data-type="indexterm" data-primary="Array module" data-secondary="Array.blit"/><a data-type="indexterm" data-primary="Array module" data-secondary="Array.set"/></p><p>Arrays also come with special syntax for retrieving an element
        from an array:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/array-get.syntax" class="orm:hideurl:ital"><em class="hyperlink">Syntax</em></a></p><pre data-type="programlisting" data-code-language="ocaml"><em>&lt;array_expr&gt;</em>.(<em>&lt;index_expr&gt;</em>)</pre><p>and for setting an element in an array:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/array-set.syntax" class="orm:hideurl:ital"><em class="hyperlink">Syntax</em></a></p><pre data-type="programlisting" data-code-language="ocaml"><em>&lt;array_expr&gt;</em>.(<em>&lt;index_expr&gt;</em>) &lt;- <em>&lt;value_expr&gt;</em></pre><p>Out-of-bounds accesses for arrays (and indeed for all the
        array-like data structures) will lead to an exception being
        thrown.</p><p>Array literals are written using <code>[|</code> and <code>|]</code>
        as delimiters. Thus, <code>[| 1; 2; 3 |]</code>
        is a literal integer array.</p></section><section id="strings" data-type="sect3"><h3>Strings</h3><p>Strings are essentially byte arrays which are often used for
        textual data. The main advantage of using a <code>string</code> in place of a <code>Char.t array</code> (a <code>Char.t</code> is an 8-bit character) is that the
        former is considerably more space-efficient; an array uses one word—8
        bytes on a 64-bit machine—to store a single entry, whereas strings use
        1 byte per character.<a data-type="indexterm" data-primary="byte arrays"/><a data-type="indexterm" data-primary="strings" data-secondary="vs. Char.t arrays"/></p><p>Strings also come with their own syntax for getting and setting
        values:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/string.syntax" class="orm:hideurl:ital"><em class="hyperlink">Syntax</em></a></p><pre data-type="programlisting" data-code-language="ocaml"><em>&lt;string_expr&gt;</em>.[<em>&lt;index_expr&gt;</em>]
          <em>&lt;string_expr&gt;</em>.[<em>&lt;index_expr&gt;</em>] &lt;- <em>&lt;char_expr&gt;</em></pre><p>And string literals are bounded by quotes. There's also a module
        <code>String</code> where you'll find useful
        functions for working with strings.</p></section><section id="bigarrays" data-type="sect3"><h3>Bigarrays</h3><p>A <code>Bigarray.t</code> is a handle to a
        block of memory stored outside of the OCaml heap. These are mostly
        useful for interacting with C or Fortran libraries, and are discussed
        in <a href="#memory-representation-of-values" data-type="xref"/>. Bigarrays too
        have their own getting and setting syntax:<a data-type="indexterm" data-primary="bigarrays"/></p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/bigarray.syntax" class="orm:hideurl:ital"><em class="hyperlink">Syntax</em></a></p><pre data-type="programlisting" data-code-language="ocaml"><em>&lt;bigarray_expr&gt;</em>.{<em>&lt;index_expr&gt;</em>}
         <em> &lt;bigarray_expr&gt;</em>.{<em>&lt;index_expr&gt;</em>} &lt;- <em>&lt;value_expr&gt;</em></pre></section></section><section id="mutable-record-and-object-fields-and-ref-cells" data-type="sect2"><h2>Mutable Record and Object Fields and Ref Cells</h2><p>As we've seen, records are immutable by default, but individual
      record fields can be declared as mutable. These mutable fields can be
      set using the <code>&lt;-</code> operator, i.e.,
      <code>record.field &lt;- expr</code>.<a data-type="indexterm" data-primary="fields" data-secondary="mutability of"/></p><p>As we'll see in <a href="#objects" data-type="xref"/>, fields of an object
      can similarly be declared as mutable, and can then be modified in much
      the same way as record fields.<a data-type="indexterm" data-primary="primitive mutable data" data-secondary="record/object fields and ref cells"/></p><section id="ref-cells" data-type="sect3"><h3>Ref cells</h3><p>Variables in OCaml are never mutable—they can refer to mutable
        data, but what the variable points to can't be changed. Sometimes,
        though, you want to do exactly what you would do with a mutable
        variable in another language: define a single, mutable value. In OCaml
        this is typically achieved using a <code>ref</code>, which is essentially a container with a
        single mutable polymorphic field.<a data-type="indexterm" data-primary="ref cells"/></p><p>The definition for the <code>ref</code> type is as
        follows:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/ref.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
        (part 1)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>type 'a ref = { mutable contents : 'a };;</code></strong>
<code class="computeroutput">type 'a ref = { mutable contents : 'a; }</code></pre><p>The standard library defines the following operators for working
        with <code>ref</code>s.</p><dl><dt><code>ref expr</code></dt><dd><p>Constructs a reference cell containing the value defined
              by the expression <code>expr</code>.</p></dd><dt><code>!refcell</code></dt><dd><p>Returns the contents of the reference cell.</p></dd><dt><code>refcell := expr</code></dt><dd><p>Replaces the contents of the reference cell.</p></dd></dl><p>You can see these in action:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/ref.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
        (part 3)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let x = ref 1;;</code></strong>
<code class="computeroutput">val x : int ref = {contents = 1}</code>
<code class="prompt"># </code><strong><code>  !x;;</code></strong>
<code class="computeroutput">- : int = 1</code>
<code class="prompt"># </code><strong><code>  x := !x + 1;;</code></strong>
<code class="computeroutput">- : unit = ()</code>
<code class="prompt"># </code><strong><code>  !x;;</code></strong>
<code class="computeroutput">- : int = 2</code></pre><p>The preceding are just ordinary OCaml functions, which could be
        defined as follows:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/ref.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
        (part 2)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let ref x = { contents = x };;</code></strong>
<code class="computeroutput">val ref : 'a -&gt; 'a ref = &lt;fun&gt;</code>
<code class="prompt"># </code><strong><code>  let (!) r = r.contents;;</code></strong>
<code class="computeroutput">val ( ! ) : 'a ref -&gt; 'a = &lt;fun&gt;</code>
<code class="prompt"># </code><strong><code>  let (:=) r x = r.contents &lt;- x;;</code></strong>
<code class="computeroutput">val ( := ) : 'a ref -&gt; 'a -&gt; unit = &lt;fun&gt;</code></pre></section></section><section id="foreign-functions" data-type="sect2"><h2>Foreign Functions</h2><p>Another source of imperative operations in OCaml is resources that come from interfacing
        with external libraries through OCaml's foreign function interface (FFI). The FFI opens
        OCaml up to imperative constructs that are exported by system calls or other external
        libraries. Many of these come built in, like access to the <code>write</code> system call or to the <code>clock</code>, while
        others come from user libraries, like LAPACK bindings. OCaml's FFI is discussed in more
        detail in <a href="#foreign-function-interface" data-type="xref"/>.<a data-type="indexterm" data-primary="libraries" data-secondary="interfacing with external"/><a data-type="indexterm" data-primary="external libraries" data-secondary="interfacing with"/><a data-type="indexterm" data-primary="LAPACK bindings"/><a data-type="indexterm" data-primary="foreign function interface (FFI)" data-secondary="imperative operations and"/><a data-type="indexterm" data-primary="primitive mutable data" data-secondary="foreign functions"/></p></section></section><section id="for-and-while-loops-1" data-type="sect1"><h1>for and while Loops</h1><p>OCaml provides support for traditional imperative looping
    constructs, in particular, <code>for</code> and
    <code>while</code> loops. Neither of these
    constructs is strictly necessary, since they can be simulated with
    recursive functions. Nonetheless, explicit <code>for</code> and <code>while</code>
    loops are both more concise and more idiomatic when programming
    imperatively.<a data-type="indexterm" data-primary="looping constructs"/><a data-type="indexterm" data-primary="while loops"/><a data-type="indexterm" data-primary="for loops"/></p><p>The <code>for</code> loop is the simpler of
    the two. Indeed, we've already seen the <code>for</code> loop in action—the <code>iter</code> function in <code>Dictionary</code> is built using it. Here's a simple
    example of <code>for</code>:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/for.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 1)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>for i = 0 to 3 do printf "i = %d\n" i done;;</code></strong>
<code class="computeroutput">i = 0</code>
<code class="computeroutput">i = 1</code>
<code class="computeroutput">i = 2</code>
<code class="computeroutput">i = 3</code>
<code class="computeroutput">- : unit = ()</code></pre><p>As you can see, the upper and lower bounds are inclusive. We can
    also use <code>downto</code> to iterate in the other
    direction:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/for.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 2)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>for i = 3 downto 0 do printf "i = %d\n" i done;;</code></strong>
<code class="computeroutput">i = 3</code>
<code class="computeroutput">i = 2</code>
<code class="computeroutput">i = 1</code>
<code class="computeroutput">i = 0</code>
<code class="computeroutput">- : unit = ()</code></pre><p>Note that the loop variable of a <code>for</code> loop, <code>i</code>
    in this case, is immutable in the scope of the loop and is also local to
    the loop, i.e., it can't be referenced outside of the loop.</p><p>OCaml also supports <code>while</code> loops,
    which include a condition and a body. The loop first evaluates the
    condition, and then, if it evaluates to true, evaluates the body and
    starts the loop again. Here's a simple example of a function for reversing
    an array in place:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/for.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 3)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let rev_inplace ar =</code></strong>
<strong><code>    let i = ref 0 in</code></strong>
<strong><code>    let j = ref (Array.length ar - 1) in</code></strong>
<strong><code>    (* terminate when the upper and lower indices meet *)</code></strong>
<strong><code>    while !i &lt; !j do</code></strong>
<strong><code>      (* swap the two elements *)</code></strong>
<strong><code>      let tmp = ar.(!i) in</code></strong>
<strong><code>      ar.(!i) &lt;- ar.(!j);</code></strong>
<strong><code>      ar.(!j) &lt;- tmp;</code></strong>
<strong><code>      (* bump the indices *)</code></strong>
<strong><code>      incr i;</code></strong>
<strong><code>      decr j</code></strong>
<strong><code>    done</code></strong>
<strong><code>  ;;</code></strong>
<code class="computeroutput">val rev_inplace : 'a array -&gt; unit = &lt;fun&gt;</code>
<code class="prompt"># </code><strong><code>let nums = [|1;2;3;4;5|];;</code></strong>
<code class="computeroutput">val nums : int array = [|1; 2; 3; 4; 5|]</code>
<code class="prompt"># </code><strong><code>rev_inplace nums;;</code></strong>
<code class="computeroutput">- : unit = ()</code>
<code class="prompt"># </code><strong><code>nums;;</code></strong>
<code class="computeroutput">- : int array = [|5; 4; 3; 2; 1|]</code></pre><p>In the preceding example, we used <code>incr</code> and <code>decr</code>, which are built-in functions for
    incrementing and decrementing an <code>int
    ref</code> by one, respectively.</p></section><section id="example-doubly-linked-lists" data-type="sect1"><h1>Example: Doubly Linked Lists</h1><p>Another common imperative data structure is the doubly linked list.
    Doubly linked lists can be traversed in both directions, and elements can
    be added and removed from the list in constant time. Core defines a doubly
    linked list (the module is called <code>Doubly_linked</code>), but we'll define our own linked
    list library as an illustration.<a data-type="indexterm" data-primary="lists" data-secondary="doubly-linked lists"/><a data-type="indexterm" data-primary="doubly-linked lists"/><a data-type="indexterm" id="IPdoublink" data-primary="imperative programming" data-secondary="doubly-linked lists"/></p><p>Here's the <code>mli</code> of the module
    we'll build:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/dlist.mli" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a></p><pre data-type="programlisting" data-code-language="ocaml">(* file: dlist.mli *)
open Core.Std

type 'a t
type 'a element

(** Basic list operations  *)
val create   : unit -&gt; 'a t
val is_empty : 'a t -&gt; bool

(** Navigation using [element]s *)
val first : 'a t -&gt; 'a element option
val next  : 'a element -&gt; 'a element option
val prev  : 'a element -&gt; 'a element option
val value : 'a element -&gt; 'a

(** Whole-data-structure iteration *)
val iter    : 'a t -&gt; f:('a -&gt; unit) -&gt; unit
val find_el : 'a t -&gt; f:('a -&gt; bool) -&gt; 'a element option

(** Mutation *)
val insert_first : 'a t -&gt; 'a -&gt; 'a element
val insert_after : 'a element -&gt; 'a -&gt; 'a element
val remove : 'a t -&gt; 'a element -&gt; unit</pre><p>Note that there are two types defined here: <code>'a t</code>, the type of a list; and <code>'a element</code>, the type of an element. Elements act
    as pointers to the interior of a list and allow us to navigate the list
    and give us a point at which to apply mutating operations.</p><p>Now let's look at the implementation. We'll start by defining
    <code>'a element</code> and <code>'a t</code>:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/dlist.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a>
    (part 1)</p><pre data-type="programlisting" data-code-language="ocaml">(* file: dlist.ml *)
open Core.Std

type 'a element =
  { value : 'a;
    mutable next : 'a element option;
    mutable prev : 'a element option
  }

type 'a t = 'a element option ref</pre><p>An <code>'a element</code> is a record
    containing the value to be stored in that node as well as optional (and
    mutable) fields pointing to the previous and next elements. At the
    beginning of the list, the <code>prev</code> field
    is <code>None</code>, and at the end of the list,
    the <code>next</code> field is <code>None</code>.</p><p>The type of the list itself, <code>'a
    t</code>, is a mutable reference to an optional <code>element</code>. This reference is <code>None</code> if the list is empty, and <code>Some</code> otherwise.</p><p>Now we can define a few basic functions that operate on lists and
    elements:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/dlist.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a>
    (part 2)</p><pre data-type="programlisting" data-code-language="ocaml">let create () = ref None
let is_empty t = !t = None

let value elt = elt.value

let first t = !t
let next elt = elt.next
let prev elt = elt.prev</pre><p>These all follow relatively straightforwardly from our type
    definitions.</p><div data-type="note"><h1>Cyclic Data Structures</h1><p>Doubly linked lists are a cyclic data structure, meaning that it
      is possible to follow a nontrivial sequence of pointers that closes in
      on itself. In general, building cyclic data structures requires the use
      of side effects. This is done by constructing the data elements first,
      and then adding cycles using assignment afterward.<a data-type="indexterm" data-primary="let rec"/><a data-type="indexterm" data-primary="data structures" data-secondary="cyclic"/><a data-type="indexterm" data-primary="cyclic data structures"/></p><p>There is an exception to this, though: you can construct
      fixed-size cyclic data structures using <code>let
      rec</code>:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/examples.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 2)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let rec endless_loop = 1 :: 2 :: 3 :: endless_loop;;</code></strong>
<code class="computeroutput">val endless_loop : int list =</code>
<code class="computeroutput">  [1; 2; 3; 1; 2; 3; 1; 2; 3;
   1; 2; 3; 1; 2; 3; 1; 2; 3;
   1; 2; 3; 1; 2; 3; 1; 2; 3;</code>
<code class="computeroutput">   ...]</code></pre><p>This approach is quite limited, however. General-purpose cyclic
      data structures require mutation.</p></div><section id="modifying-the-list" data-type="sect2"><h2>Modifying the List</h2><p>Now, we'll start considering operations that mutate the list,
      starting with <code>insert_first</code>, which
      inserts an element at the front of the list:<a data-type="indexterm" data-primary="elements" data-secondary="inserting in lists"/></p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/dlist.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a>
      (part 3)</p><pre data-type="programlisting" data-code-language="ocaml">let insert_first t value =
  let new_elt = { prev = None; next = !t; value } in
  begin match !t with
  | Some old_first -&gt; old_first.prev &lt;- Some new_elt
  | None -&gt; ()
  end;
  t := Some new_elt;
  new_elt</pre><p><code>insert_first</code> first defines a
      new element <code>new_elt</code>, and then links
      it into the list, finally setting the list itself to point to <code>new_elt</code>. Note that the precedence of a
      <code>match</code> expression is very low, so to
      separate it from the following assignment (<code>t :=
      Some new_elt</code>), we surround the match with <code>begin ... end</code>. We could have used parentheses
      for the same purpose. Without some kind of bracketing, the final
      assignment would incorrectly become part of the <code>None</code> case.<a data-type="indexterm" data-primary="elements" data-secondary="defining new"/></p><p>We can use <code>insert_after</code> to
      insert elements later in the list. <code>insert_after</code> takes as arguments both an
      <code>element</code> after which to insert the new
      node and a value to insert:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/dlist.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a>
      (part 4)</p><pre data-type="programlisting" data-code-language="ocaml">let insert_after elt value =
  let new_elt = { value; prev = Some elt; next = elt.next } in
  begin match elt.next with
  | Some old_next -&gt; old_next.prev &lt;- Some new_elt
  | None -&gt; ()
  end;
  elt.next &lt;- Some new_elt;
  new_elt</pre><p>Finally, we need a <code>remove</code>
      function:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/dlist.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a>
      (part 5)</p><pre data-type="programlisting" data-code-language="ocaml">let remove t elt =
  let { prev; next; _ } = elt in
  begin match prev with
  | Some prev -&gt; prev.next &lt;- next
  | None -&gt; t := next
  end;
  begin match next with
  | Some next -&gt; next.prev &lt;- prev;
  | None -&gt; ()
  end;
  elt.prev &lt;- None;
  elt.next &lt;- None</pre><p>Note that the preceding code is careful to change the <code>prev</code> pointer of the following element and the
      <code>next</code> pointer of the previous element,
      if they exist. If there's no previous element, then the list pointer
      itself is updated. In any case, the next and previous pointers of the
      element itself are set to <code>None</code>.</p><p>These functions are more fragile than they may seem. In
      particular, misuse of the interface may lead to corrupted data. For
      example, double-removing an element will cause the main list reference
      to be set to <code>None</code>, thus emptying the
      list. Similar problems arise from removing an element from a list it
      doesn't belong to.</p><p>This shouldn't be a big surprise. Complex imperative data
      structures can be quite tricky, considerably trickier than their pure
      equivalents. The issues described previously can be dealt with by more
      careful error detection, and such error correction is taken care of in
      modules like Core's <code>Doubly_linked</code>.
      You should use imperative data structures from a well-designed library
      when you can. And when you can't, you should make sure to put great care
      into your error handling.<a data-type="indexterm" data-primary="imperative programming" data-secondary="drawbacks of"/><a data-type="indexterm" data-primary="Doubly-linked module"/><a data-type="indexterm" data-primary="error handling" data-secondary="and imperative data&#xA;          structures"/></p></section><section id="iteration-functions" data-type="sect2"><h2>Iteration Functions</h2><p>When defining containers like lists, dictionaries, and trees,
      you'll typically want to define a set of iteration functions like
      <code>iter</code>, <code>map</code>, and <code>fold</code>, which let you concisely express common
      iteration patterns.<a data-type="indexterm" data-primary="functions" data-secondary="iteration functions"/><a data-type="indexterm" data-primary="iteration functions"/></p><p><code>Dlist</code> has two such iterators:
      <code>iter</code>, the goal of which is to call a
      <code>unit</code>-producing function on every
      element of the list, in order; and <code>find_el</code>, which runs a provided test function
      on each values stored in the list, returning the first <code>element</code> that passes the test. Both <code>iter</code> and <code>find_el</code> are implemented using simple recursive
      loops that use <code>next</code> to walk from
      element to element and <code>value</code> to
      extract the element from a given node:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/dlist.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a>
      (part 6)</p><pre data-type="programlisting" data-code-language="ocaml">let iter t ~f =
  let rec loop = function
    | None -&gt; ()
    | Some el -&gt; f (value el); loop (next el)
  in
  loop !t

let find_el t ~f =
  let rec loop = function
    | None -&gt; None
    | Some elt -&gt;
      if f (value elt) then Some elt
      else loop (next elt)
  in
  loop !t</pre><p>This completes our implementation, but there's still considerably
      more work to be done to make a really usable doubly linked list. As
      mentioned earlier, you're probably better off using something like
      Core's <code>Doubly_linked</code> module that has
      a more complete interface and has more of the tricky corner cases worked
      out. Nonetheless, this example should serve to demonstrate some of the
      techniques you can use to build nontrivial imperative data structure in
      OCaml, as well as some of the pitfalls.<a data-type="indexterm" data-startref="IPdoublink"/></p></section></section><section id="laziness-and-other-benign-effects" data-type="sect1"><h1>Laziness and Other Benign Effects</h1><p>There are many instances where you basically want to program in a
    pure style, but you want to make limited use of side effects to improve
    the performance of your code. Such side effects are sometimes called
    <em>benign effects</em>, and they are a useful way of
    leveraging OCaml's imperative features while still maintaining most of the
    benefits of pure programming.<a data-type="indexterm" data-primary="lazy keyword"/><a data-type="indexterm" data-primary="side effects"/><a data-type="indexterm" data-primary="laziness"/><a data-type="indexterm" data-primary="benign effects" data-secondary="laziness"/><a data-type="indexterm" data-primary="imperative programming" data-secondary="benign effects and"/></p><p>One of the simplest benign effects is <em>laziness</em>.
    A lazy value is one that is not computed until it is actually needed. In
    OCaml, lazy values are created using the <code>lazy</code> keyword, which can be used to convert any
    expression of type <code>s</code> into a lazy value
    of type <code>s Lazy.t</code>. The evaluation of
    that expression is delayed until forced with <code>Lazy.force</code>:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/lazy.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 1)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let v = lazy (print_string "performing lazy computation\n"; sqrt 16.);;</code></strong>
<code class="computeroutput">val v : float lazy_t = &lt;lazy&gt;</code>
<code class="prompt"># </code><strong><code>Lazy.force v;;</code></strong>
<code class="computeroutput">performing lazy computation</code>
<code class="computeroutput">- : float = 4.</code>
<code class="prompt"># </code><strong><code>Lazy.force v;;</code></strong>
<code class="computeroutput">- : float = 4.</code></pre><p>You can see from the <code>print</code> statement that the
    actual computation was performed only once, and only after <code>force</code> had been called.</p><p>To better understand how laziness works, let's walk through the
    implementation of our own lazy type. We'll start by declaring types to
    represent a lazy value:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/lazy.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 2)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>type 'a lazy_state =</code></strong>
<strong><code>    | Delayed of (unit -&gt; 'a)</code></strong>
<strong><code>    | Value of 'a</code></strong>
<strong><code>    | Exn of exn</code></strong>
<strong><code>  ;;</code></strong>
<code class="computeroutput">type 'a lazy_state = Delayed of (unit -&gt; 'a) | Value of 'a | Exn of exn</code></pre><p>A <code>lazy_state</code> represents the
    possible states of a lazy value. A lazy value is <code>Delayed</code> before it has been run, where <code>Delayed</code> holds a function for computing the value
    in question. A lazy value is in the <code>Value</code> state when it has been forced and the
    computation ended normally. The <code>Exn</code>
    case is for when the lazy value has been forced, but the computation ended
    with an exception. A lazy value is simply a <code>ref</code> containing a <code>lazy_state</code>, where the <code>ref</code> makes it possible to change from being in
    the <code>Delayed</code> state to being in the
    <code>Value</code> or <code>Exn</code> states.</p><p>We can create a lazy value from a thunk, i.e., a function that takes
    a unit argument. Wrapping an expression in a thunk is another way to
    suspend the computation of an expression:<a data-type="indexterm" data-primary="thunks"/></p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/lazy.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 3)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let create_lazy f = ref (Delayed f);;</code></strong>
<code class="computeroutput">val create_lazy : (unit -&gt; 'a) -&gt; 'a lazy_state ref = &lt;fun&gt;</code>
<code class="prompt"># </code><strong><code>let v = create_lazy</code></strong>
<strong><code>    (fun () -&gt; print_string "performing lazy computation\n"; sqrt 16.);;</code></strong>
<code class="computeroutput">val v : float lazy_state ref = {contents = Delayed &lt;fun&gt;}</code></pre><p>Now we just need a way to force a lazy value. The following function
    does just that:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/lazy.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 4)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let force v =</code></strong>
<strong><code>    match !v with</code></strong>
<strong><code>    | Value x -&gt; x</code></strong>
<strong><code>    | Exn e -&gt; raise e</code></strong>
<strong><code>    | Delayed f -&gt;</code></strong>
<strong><code>      try</code></strong>
<strong><code>        let x = f () in</code></strong>
<strong><code>        v := Value x;</code></strong>
<strong><code>        x</code></strong>
<strong><code>      with exn -&gt;</code></strong>
<strong><code>        v := Exn exn;</code></strong>
<strong><code>        raise exn</code></strong>
<strong><code>     ;;</code></strong>
<code class="computeroutput">val force : 'a lazy_state ref -&gt; 'a = &lt;fun&gt;</code></pre><p>Which we can use in the same way we used <code>Lazy.force</code>:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/lazy.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 5)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>force v;;</code></strong>
<code class="computeroutput">performing lazy computation</code>
<code class="computeroutput">- : float = 4.</code>
<code class="prompt"># </code><strong><code>force v;;</code></strong>
<code class="computeroutput">- : float = 4.</code></pre><p>The main user-visible difference between our implementation of
    laziness and the built-in version is syntax. Rather than writing <code>create_lazy (fun () -&gt; sqrt 16.)</code>, we can
    (with the built-in <code>lazy</code>) just write
    <code>lazy (sqrt 16.)</code>.</p><section id="memoization-and-dynamic-programming" data-type="sect2"><h2>Memoization and Dynamic Programming</h2><p>Another benign effect is <em>memoization</em>. A
      memoized function remembers the result of previous invocations of the
      function so that they can be returned without further computation when
      the same arguments are presented again.<a data-type="indexterm" data-primary="memoization" data-secondary="function of"/><a data-type="indexterm" id="BEmem" data-primary="benign effects" data-secondary="memoization"/></p><p>Here's a function that takes as an argument an arbitrary
      single-argument function and returns a memoized version of that
      function. Here we'll use Core's <code>Hashtbl</code> module, rather than our toy <code>Dictionary</code>:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/memo.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 1)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let memoize f =</code></strong>
<strong><code>    let table = Hashtbl.Poly.create () in</code></strong>
<strong><code>    (fun x -&gt;</code></strong>
<strong><code>      match Hashtbl.find table x with</code></strong>
<strong><code>      | Some y -&gt; y</code></strong>
<strong><code>      | None -&gt;</code></strong>
<strong><code>        let y = f x in</code></strong>
<strong><code>        Hashtbl.add_exn table ~key:x ~data:y;</code></strong>
<strong><code>        y</code></strong>
<strong><code>    );;</code></strong>
<code class="computeroutput">val memoize : ('a -&gt; 'b) -&gt; 'a -&gt; 'b = &lt;fun&gt;</code></pre><p>The preceding code is a bit tricky. <code>memoize</code> takes as its argument a function
      <code>f</code> and then allocates a hash table
      (called <code>table</code>) and returns a new
      function as the memoized version of <code>f</code>. When called, this new function looks in
      <code>table</code> first, and if it fails to find
      a value, calls <code>f</code> and stashes the
      result in <code>table</code>. Note that <code>table</code> doesn't go out of scope as long as the
      function returned by <code>memoize</code> is in
      scope.<a data-type="indexterm" data-primary="memoization" data-secondary="benefits and drawbacks of"/></p><p>Memoization can be useful whenever you have a function that is
      expensive to recompute and you don't mind caching old values
      indefinitely. One important caution: a memoized function by its nature
      leaks memory. As long as you hold on to the memoized function, you're
      holding every result it has returned thus far.</p><p>Memoization is also useful for efficiently implementing some recursive algorithms. One
        good example is the algorithm for computing the <em>edit distance</em> (also
        called the Levenshtein distance) between two strings. The edit distance is the number of
        single-character changes (including letter switches, insertions, and deletions) required to
          <span class="keep-together">convert</span> one string to the other. This kind of
        distance metric can be useful for a variety of approximate string-matching problems, like
          spellcheckers.<a data-type="indexterm" data-primary="string matching"/><a data-type="indexterm" data-primary="Levenshtein distance"/><a data-type="indexterm" data-primary="edit distance"/></p><p>Consider the following code for computing the edit distance.
      Understanding the algorithm isn't important here, but you should pay
      attention to the structure of the recursive calls:<a data-type="indexterm" data-primary="memoization" data-secondary="example of"/></p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/memo.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 2)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let rec edit_distance s t =</code></strong>
<strong><code>    match String.length s, String.length t with</code></strong>
<strong><code>    | (0,x) | (x,0) -&gt; x</code></strong>
<strong><code>    | (len_s,len_t) -&gt;</code></strong>
<strong><code>      let s' = String.drop_suffix s 1 in</code></strong>
<strong><code>      let t' = String.drop_suffix t 1 in</code></strong>
<strong><code>      let cost_to_drop_both =</code></strong>
<strong><code>        if s.[len_s - 1] = t.[len_t - 1] then 0 else 1</code></strong>
<strong><code>      in</code></strong>
<strong><code>      List.reduce_exn ~f:Int.min</code></strong>
<strong><code>        [ edit_distance s' t  + 1</code></strong>
<strong><code>        ; edit_distance s  t' + 1</code></strong>
<strong><code>        ; edit_distance s' t' + cost_to_drop_both</code></strong>
<strong><code>        ]</code></strong>
<strong><code>  ;;</code></strong>
<code class="computeroutput">val edit_distance : string -&gt; string -&gt; int = &lt;fun&gt;</code>
<code class="prompt"># </code><strong><code>edit_distance "OCaml" "ocaml";;</code></strong>
<code class="computeroutput">- : int = 2</code></pre><p>The thing to note is that if you call <code>edit_distance "OCaml" "ocaml"</code>, then that will
      in turn dispatch the following calls:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/edit_distance.ascii" class="orm:hideurl:ital"><em class="hyperlink">Diagram</em></a></p><figure style="float: 0"><img src="images/rwoc_0801.png"/><figcaption/></figure><p>And these calls will in turn dispatch other calls:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/edit_distance2.ascii" class="orm:hideurl:ital"><em class="hyperlink">Diagram</em></a></p><figure style="float: 0"><img src="images/rwoc_0802.png"/><figcaption/></figure><p>As you can see, some of these calls are repeats. For example,
      there are two different calls to <code>edit_distance
      "OCam" "oca"</code>. The number of redundant calls grows
      exponentially with the size of the strings, meaning that our
      implementation of <code>edit_distance</code> is
      brutally slow for large strings. We can see this by writing a small
      timing function:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/memo.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 3)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let time f =</code></strong>
<strong><code>    let start = Time.now () in</code></strong>
<strong><code>    let x = f () in</code></strong>
<strong><code>    let stop = Time.now () in</code></strong>
<strong><code>    printf "Time: %s\n" (Time.Span.to_string (Time.diff stop start));</code></strong>
<strong><code>    x ;;</code></strong>
<code class="computeroutput">val time : (unit -&gt; 'a) -&gt; 'a = &lt;fun&gt;</code></pre><p>And now we can use this to try out some examples:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/memo.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 4)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>time (fun () -&gt; edit_distance "OCaml" "ocaml");;</code></strong>
<code class="computeroutput">Time: 1.40405ms</code>
<code class="computeroutput">- : int = 2</code>
<code class="prompt"># </code><strong><code>time (fun () -&gt; edit_distance "OCaml 4.01" "ocaml 4.01");;</code></strong>
<code class="computeroutput">Time: 6.79065s</code>
<code class="computeroutput">- : int = 2</code></pre><p>Just those few extra characters made it thousands of times
      slower!</p><p>Memoization would be a huge help here, but to fix the problem, we
      need to memoize the calls that <code>edit_distance</code> makes to itself. This technique
      is sometimes referred to as <em>dynamic programming</em>. To
      see how to do this, let's step away from <code>edit_distance</code> and instead consider a much
      simpler example: computing the <em>n</em>th element of the
      Fibonacci sequence. The Fibonacci sequence by definition starts out with
      two <code>1</code>s, with every subsequent element
      being the sum of the previous two. The classic recursive definition of
      Fibonacci is as follows:<a data-type="indexterm" data-primary="programming" data-secondary="dynamic programming"/><a data-type="indexterm" data-primary="dynamic programming"/></p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/fib.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 1)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let rec fib i =</code></strong>
<strong><code>    if i &lt;= 1 then 1 else fib (i - 1) + fib (i - 2);;</code></strong>
<code class="computeroutput">val fib : int -&gt; int = &lt;fun&gt;</code></pre><p>This is, however, exponentially slow, for the same reason that
      <code>edit_distance</code> was slow: we end up
      making many redundant calls to <code>fib</code>.
      It shows up quite dramatically in the performance:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/fib.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 2)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>time (fun () -&gt; fib 20);;</code></strong>
<code class="computeroutput">Time: 0.844955ms</code>
<code class="computeroutput">- : int = 10946</code>
<code class="prompt"># </code><strong><code>time (fun () -&gt; fib 40);;</code></strong>
<code class="computeroutput">Time: 12.7751s</code>
<code class="computeroutput">- : int = 165580141</code></pre><p>As you can see, <code>fib 40</code> takes
      thousands of times longer to compute than <code>fib
      20</code>.</p><p>So, how can we use memoization to make this faster? The tricky bit
      is that we need to insert the memoization before the recursive calls
      within <code>fib</code>. We can't just define
      <code>fib</code> in the ordinary way and memoize
      it after the fact and expect the first call to <code>fib</code> to be improved:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/fib.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 3)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let fib = memoize fib;;</code></strong>
<code class="computeroutput">val fib : int -&gt; int = &lt;fun&gt;</code>
<code class="prompt"># </code><strong><code>time (fun () -&gt; fib 40);;</code></strong>
<code class="computeroutput">Time: 12.774s</code>
<code class="computeroutput">- : int = 165580141</code>
<code class="prompt"># </code><strong><code>time (fun () -&gt; fib 40);;</code></strong>
<code class="computeroutput">Time: 0.00309944ms</code>
<code class="computeroutput">- : int = 165580141</code></pre><p>In order to make <code>fib</code> fast, our
      first step will be to rewrite <code>fib</code> in
      a way that unwinds the recursion. The following version expects as its
      first argument a function (called <code>fib</code>) that will be called in lieu of the usual
      recursive call:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/fib.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 4)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let fib_norec fib i =</code></strong>
<strong><code>    if i &lt;= 1 then i</code></strong>
<strong><code>    else fib (i - 1) + fib (i - 2) ;;</code></strong>
<code class="computeroutput">val fib_norec : (int -&gt; int) -&gt; int -&gt; int = &lt;fun&gt;</code></pre><p>We can now turn this back into an ordinary Fibonacci function by
      tying the recursive knot:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/fib.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 5)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let rec fib i = fib_norec fib i;;</code></strong>
<code class="computeroutput">val fib : int -&gt; int = &lt;fun&gt;</code>
<code class="prompt"># </code><strong><code>fib 20;;</code></strong>
<code class="computeroutput">- : int = 6765</code></pre><p>We can even write a polymorphic function that we'll call <code>make_rec</code> that can tie the recursive knot for
      any function of this form:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/fib.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 6)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let make_rec f_norec =</code></strong>
<strong><code>    let rec f x = f_norec f x in</code></strong>
<strong><code>    f</code></strong>
<strong><code>  ;;</code></strong>
<code class="computeroutput">val make_rec : (('a -&gt; 'b) -&gt; 'a -&gt; 'b) -&gt; 'a -&gt; 'b = &lt;fun&gt;</code>
<code class="prompt"># </code><strong><code>let fib = make_rec fib_norec;;</code></strong>
<code class="computeroutput">val fib : int -&gt; int = &lt;fun&gt;</code>
<code class="prompt"># </code><strong><code>fib 20;;</code></strong>
<code class="computeroutput">- : int = 6765</code></pre><p>This is a pretty strange piece of code, and it may take a few moments of thought to
        figure out what's going on. Like <code>fib_norec</code>, the function
          <code>f_norec</code> passed into <code>make_rec</code> is a function that isn't recursive but takes as an argument a function
        that it will call. What <code>make_rec</code> does is to essentially
        feed <code>f_norec</code> to itself, thus making it a true recursive
        function.</p><p>This is clever enough, but all we've really done is find a new way
      to implement the same old slow Fibonacci function. To make it faster, we
      need a variant of <code>make_rec</code> that
      inserts memoization when it ties the recursive knot. We'll call that
      function <code>memo_rec</code>:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/fib.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 7)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let memo_rec f_norec x =</code></strong>
<strong><code>    let fref = ref (fun _ -&gt; assert false) in</code></strong>
<strong><code>    let f = memoize (fun x -&gt; f_norec !fref x) in</code></strong>
<strong><code>    fref := f;</code></strong>
<strong><code>    f x</code></strong>
<strong><code>  ;;</code></strong>
<code class="computeroutput">val memo_rec : (('a -&gt; 'b) -&gt; 'a -&gt; 'b) -&gt; 'a -&gt; 'b = &lt;fun&gt;</code></pre><p>Note that <code>memo_rec</code> has the same
      signature as <code>make_rec</code>.</p><p>We're using the reference here as a way of tying the recursive
      knot without using a <code>let rec</code>, which
      for reasons we'll describe later wouldn't work here.</p><p>Using <code>memo_rec</code>, we can now
      build an efficient version of <code>fib</code>:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/fib.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 8)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let fib = memo_rec fib_norec;;</code></strong>
<code class="computeroutput">val fib : int -&gt; int = &lt;fun&gt;</code>
<code class="prompt"># </code><strong><code>time (fun () -&gt; fib 40);;</code></strong>
<code class="computeroutput">Time: 0.0591278ms</code>
<code class="computeroutput">- : int = 102334155</code></pre><p>And as you can see, the exponential time complexity is now
      gone.</p><p>The memory behavior here is important. If you look back at the
      definition of <code>memo_rec</code>, you'll see
      that the call <code>memo_rec fib_norec</code> does
      not trigger a call to <code>memoize</code>. Only
      when <code>fib</code> is called and thereby the
      final argument to <code>memo_rec</code> is
      presented does <code>memoize</code> get called.
      The result of that call falls out of scope when the <code>fib</code> call returns, and so calling <code>memo_rec</code> on a function does not create a
      memory leak—the memoization table is collected after the computation
      completes.</p><p>We can use <code>memo_rec</code> as part of
      a single declaration that makes this look like it's little more than a
      special form of <code>let rec</code>:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/fib.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 9)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let fib = memo_rec (fun fib i -&gt;</code></strong>
<strong><code>    if i &lt;= 1 then 1 else fib (i - 1) + fib (i - 2));;</code></strong>
<code class="computeroutput">val fib : int -&gt; int = &lt;fun&gt;</code></pre><p>Memoization is overkill for implementing Fibonacci, and indeed,
      the <code>fib</code> defined above is not
      especially efficient, allocating space linear in the number passed in to
      <code>fib</code>. It's easy enough to write a
      Fibonacci function that takes a constant amount of space.</p><p>But memoization is a good approach for optimizing <code>edit_distance</code>, and we can apply the same
      approach we used on <code>fib</code> here. We will
      need to change <code>edit_distance</code> to take
      a pair of strings as a single argument, since <code>memo_rec</code> only works on single-argument
      functions. (We can always recover the original interface with a wrapper
      function.) With just that change and the addition of the <code>memo_rec</code> call, we can get a memoized version
      of <code>edit_distance</code>:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/memo.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 6)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let edit_distance = memo_rec (fun edit_distance (s,t) -&gt;</code></strong>
<strong><code>    match String.length s, String.length t with</code></strong>
<strong><code>    | (0,x) | (x,0) -&gt; x</code></strong>
<strong><code>    | (len_s,len_t) -&gt;</code></strong>
<strong><code>      let s' = String.drop_suffix s 1 in</code></strong>
<strong><code>      let t' = String.drop_suffix t 1 in</code></strong>
<strong><code>      let cost_to_drop_both =</code></strong>
<strong><code>        if s.[len_s - 1] = t.[len_t - 1] then 0 else 1</code></strong>
<strong><code>      in</code></strong>
<strong><code>      List.reduce_exn ~f:Int.min</code></strong>
<strong><code>        [ edit_distance (s',t ) + 1</code></strong>
<strong><code>        ; edit_distance (s ,t') + 1</code></strong>
<strong><code>        ; edit_distance (s',t') + cost_to_drop_both</code></strong>
<strong><code>        ]) ;;</code></strong>
<code class="computeroutput">val edit_distance : string * string -&gt; int = &lt;fun&gt;</code></pre><p>This new version of <code>edit_distance</code> is much more efficient than the
      one we started with; the following call is many thousands of times
      faster than it was without memoization:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/memo.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 7)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>time (fun () -&gt; edit_distance ("OCaml 4.01","ocaml 4.01"));;</code></strong>
<code class="computeroutput">Time: 0.500917ms</code>
<code class="computeroutput">- : int = 2</code></pre><div class="allow_break" data-type="note"><h1>Limitations of let rec</h1><p>You might wonder why we didn't tie the recursive knot in
        <code>memo_rec</code> using <code>let rec</code>, as we did for <code>make_rec</code> earlier. Here's code that tries to
        do just that:<a data-type="indexterm" data-primary="let rec"/></p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/letrec.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
        (part 1)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let memo_rec f_norec =</code></strong>
<strong><code>    let rec f = memoize (fun x -&gt; f_norec f x) in</code></strong>
<strong><code>    f</code></strong>
<strong><code>  ;;</code></strong>
<code class="computeroutput">Characters 39-69:</code>
<code class="computeroutput">Error: This kind of expression is not allowed as right-hand side of `let rec'</code></pre><p>OCaml rejects the definition because OCaml, as a strict
        language, has limits on what it can put on the righthand side of a
        <code>let rec</code>. In particular, imagine how
        the following code snippet would be compiled:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/let_rec.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a></p><pre data-type="programlisting" data-code-language="ocaml">let rec x = x + 1</pre><p>Note that <code>x</code> is an ordinary
        value, not a function. As such, it's not clear how this definition
        should be handled by the compiler. You could imagine it compiling down
        to an infinite loop, but <code>x</code> is of
        type <code>int</code>, and there's no <code>int</code> that corresponds to an infinite loop. As
        such, this construct is effectively impossible to compile.</p><p>To avoid such impossible cases, the compiler only allows three
        possible constructs to show up on the righthand side of a <code>let rec</code>: a function definition, a
        constructor, or the lazy keyword. This excludes some reasonable
        things, like our definition of <code>memo_rec</code>, but it also blocks things that
        don't make sense, like our definition of <code>x</code>.</p><p>It's worth noting that these restrictions don't show up in a
        lazy language like Haskell. Indeed, we can make something like our
        definition of <code>x</code> work if we use
        OCaml's laziness:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/letrec.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
        (part 2)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let rec x = lazy (Lazy.force x + 1);;</code></strong>
<code class="computeroutput">val x : int lazy_t = &lt;lazy&gt;</code></pre><p>Of course, actually trying to compute this will fail. OCaml's
        <code>lazy</code> throws an exception when a
        lazy value tries to force itself as part of its own evaluation.</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/letrec.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
        (part 3)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>Lazy.force x;;</code></strong>
<code class="computeroutput">Exception: Lazy.Undefined.</code></pre><p>But we can also create useful recursive definitions with
        <code>lazy</code>. In particular, we can use
        laziness to make our definition of <code>memo_rec</code> work without explicit
        mutation:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/letrec.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
        (part 5)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let lazy_memo_rec f_norec x =</code></strong>
<strong><code>    let rec f = lazy (memoize (fun x -&gt; f_norec (Lazy.force f) x)) in</code></strong>
<strong><code>    (Lazy.force f) x</code></strong>
<strong><code>  ;;</code></strong>
<code class="computeroutput">val lazy_memo_rec : (('a -&gt; 'b) -&gt; 'a -&gt; 'b) -&gt; 'a -&gt; 'b = &lt;fun&gt;</code>
<code class="prompt"># </code><strong><code>time (fun () -&gt; lazy_memo_rec fib_norec 40);;</code></strong>
<code class="computeroutput">Time: 0.0650883ms</code>
<code class="computeroutput">- : int = 102334155</code></pre><p>Laziness is more constrained than explicit mutation, and so in
        some cases can lead to code whose behavior is easier to think
        about.<a data-type="indexterm" data-startref="BEmem"/></p></div></section></section><section id="input-and-output" data-type="sect1"><h1>Input and Output</h1><p>Imperative programming is about more than modifying in-memory data
    structures. Any function that doesn't boil down to a deterministic
    transformation from its arguments to its return value is imperative in
    nature. That includes not only things that mutate your program's data, but
    also operations that interact with the world outside of your program. An
    important example of this kind of interaction is I/O, i.e., operations for
    reading or writing data to things like files, terminal input and output,
    and network sockets.<a data-type="indexterm" data-primary="I/O (input/output) operations" data-secondary="terminal I/O"/><a data-type="indexterm" id="IPinpout" data-primary="imperative programming" data-secondary="input and output"/></p><p>There are multiple I/O libraries in OCaml. In this section we'll discuss OCaml's buffered
      I/O library that can be used through the <code>In_channel</code> and
        <code>Out_channel</code> modules in Core. Other I/O primitives are
      also available through the <code>Unix</code> module in Core as well as
        <code>Async</code>, the asynchronous I/O library that is covered in
        <a href="#concurrent-programming-with-async" data-type="xref"/>. Most of the functionality in Core's
        <code>In_channel</code> and <code>Out_channel</code> (and in Core's <code>Unix</code> module)
      derives from the standard library, but we'll use Core's interfaces here.</p><section id="terminal-io" data-type="sect2"><h2>Terminal I/O</h2><p>OCaml's buffered I/O library is organized around two types:
      <code>in_channel</code>, for channels you read
      from, and <code>out_channel</code>, for channels
      you write to. The <code>In_channel</code> and
      <code>Out_channel</code> modules only have direct
      support for channels corresponding to files and terminals; other kinds
      of channels can be created through the <code>Unix</code> module.<a data-type="indexterm" data-primary="Out_channel module" data-secondary="Out_channel.stderr"/><a data-type="indexterm" data-primary="Out_channel module" data-secondary="Out_channel.stdout"/><a data-type="indexterm" data-primary="In_channel module"/></p><p>We'll start our discussion of I/O by focusing on the terminal.
      Following the UNIX model, communication with the terminal is organized
      around three channels, which correspond to the three standard file
      descriptors in Unix:</p><dl><dt><code>In_channel.stdin</code></dt><dd><p>The "standard input" channel. By default, input comes from
            the terminal, which handles keyboard input.</p></dd><dt><code>Out_channel.stdout</code></dt><dd><p>The "standard output" channel. By default, output written to
            <code>stdout</code> appears on the user
            terminal.</p></dd><dt><code>Out_channel.stderr</code></dt><dd><p>The "standard error" channel. This is similar to <code>stdout</code> but is intended for error
            messages.</p></dd></dl><p>The values <code>stdin</code>, <code>stdout</code>, and <code>stderr</code> are useful enough that they are also
      available in the global namespace directly, without having to go through
      the <code>In_channel</code> and <code>Out_channel</code> modules.</p><p>Let's see this in action in a simple interactive application. The
      following program, <code>time_converter</code>,
      prompts the user for a time zone, and then prints out the current time
      in that time zone. Here, we use Core's <code>Zone</code> module for looking up a time zone, and
      the <code>Time</code> module for computing the
      current time and printing it out in the time zone in question:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/time_converter.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a></p><pre data-type="programlisting" data-code-language="ocaml">open Core.Std

let () =
  Out_channel.output_string stdout "Pick a timezone: ";
  Out_channel.flush stdout;
  match In_channel.input_line stdin with
  | None -&gt; failwith "No timezone provided"
  | Some zone_string -&gt;
    let zone = Zone.find_exn zone_string in
    let time_string = Time.to_string_abs (Time.now ()) ~zone in
    Out_channel.output_string stdout
      (String.concat
         ["The time in ";Zone.to_string zone;" is ";time_string;".\n"]);
    Out_channel.flush stdout</pre><p>We can build this program using <span class="command"><em>corebuild</em></span> and run it. You'll see that it
      prompts you for input, as follows:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/time_converter.out" class="orm:hideurl:ital"><em class="hyperlink">Terminal</em></a></p><pre data-type="programlisting" data-code-language="console"><code class="prompt">$ </code><strong><code>corebuild time_converter.byte</code></strong>
<code class="prompt">$ </code><strong><code>./time_converter.byte</code></strong>
<code class="computeroutput">Pick a timezone:</code></pre><p>You can then type in the name of a time zone and hit Return, and
      it will print out the current time in the time zone in question:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/time_converter2.out" class="orm:hideurl:ital"><em class="hyperlink">Terminal</em></a></p><pre data-type="programlisting" data-code-language="console"><code class="computeroutput">Pick a timezone: Europe/London</code>
<code class="computeroutput">The time in Europe/London is 2013-08-15 00:03:10.666220+01:00.</code></pre><p>We called <code>Out_channel.flush</code> on
      <code>stdout</code> because <code>out_channel</code>s are buffered, which is to say
      that OCaml doesn't immediately do a write every time you call <code>output_string</code>. Instead, writes are buffered
      until either enough has been written to trigger the flushing of the
      buffers, or until a flush is explicitly requested. This greatly
      increases the efficiency of the writing process by reducing the number
      of system calls.</p><p>Note that <code>In_channel.input_line</code>
      returns a <code>string option</code>, with
      <code>None</code> indicating that the input stream
      has ended (i.e., an end-of-file condition). <code>Out_channel.output_string</code> is used to print the
      final output, and <code>Out_channel.flush</code>
      is called to flush that output to the screen. The final flush is not
      technically required, since the program ends after that instruction, at
      which point all remaining output will be flushed anyway, but the
      explicit flush is nonetheless good practice.</p></section><section id="formatted-output-with-printf" data-type="sect2"><h2>Formatted Output with printf</h2><p>Generating output with functions like <code>Out_channel.output_string</code> is simple and easy
      to understand, but can be a bit verbose. OCaml also supports formatted
      output using the <code>printf</code> function,
      which is modeled after <code>printf</code> in the
      C standard library. <code>printf</code> takes a
      <em>format string</em> that describes what to print and how
      to format it, as well as arguments to be printed, as determined by the
      formatting directives embedded in the format string. So, for example, we
      can write:<a data-type="indexterm" data-primary="strings" data-secondary="format strings"/><a data-type="indexterm" data-primary="format strings"/><a data-type="indexterm" data-primary="printf function"/><a data-type="indexterm" data-primary="I/O (input/output) operations" data-secondary="formatted output"/></p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/printf.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 1)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>printf "%i is an integer, %F is a float, \"%s\" is a string\n"</code></strong>
<strong><code>    3 4.5 "five";;</code></strong>
<code class="computeroutput">3 is an integer, 4.5 is a float, "five" is a string</code>
<code class="computeroutput">- : unit = ()</code></pre><p>Unlike C's <code>printf</code>, the <code>printf</code> in OCaml is type-safe. In particular,
      if we provide an argument whose type doesn't match what's presented in
      the format string, we'll get a type error:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/printf.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 2)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>printf "An integer: %i\n" 4.5;;</code></strong>
<code class="computeroutput">Characters 26-29:</code>
<code class="computeroutput">Error: This expression has type float but an expression was expected of type</code>
<code class="computeroutput">         int</code></pre><aside data-type="sidebar"><h5>Understanding Format Strings</h5><p>The format strings used by <code>printf</code> turn out to be quite different from
        ordinary strings. This difference ties to the fact that OCaml format
        strings, unlike their equivalent in C, are type-safe. In particular,
        the compiler checks that the types referred to by the format string
        match the types of the rest of the arguments passed to <code>printf</code>.</p><p>To check this, OCaml needs to analyze the contents of the format
        string at compile time, which means the format string needs to be
        available as a string literal at compile time. Indeed, if you try to
        pass an ordinary string to <code>printf</code>,
        the compiler will complain:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/printf.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
        (part 3)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let fmt = "%i is an integer, %F is a float, \"%s\" is a string\n";;</code></strong>
<code class="computeroutput">val fmt : string = "%i is an integer, %F is a float, \"%s\" is a string\n"</code>
<code class="prompt"># </code><strong><code>printf fmt 3 4.5 "five";;</code></strong>
<code class="computeroutput">Characters 9-12:</code>
<code class="computeroutput">Error: This expression has type string but an expression was expected of type</code>
<code class="computeroutput">         ('a -&gt; 'b -&gt; 'c -&gt; 'd, out_channel, unit) format =</code>
<code class="computeroutput">           ('a -&gt; 'b -&gt; 'c -&gt; 'd, out_channel, unit, unit, unit, unit)</code>
<code class="computeroutput">           format6</code></pre><p>If OCaml infers that a given string literal is a format string,
        then it parses it at compile time as such, choosing its type in
        accordance with the formatting directives it finds. Thus, if we add a
        type annotation indicating that the string we're defining is actually
        a format string, it will be interpreted as such:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/printf.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
        (part 4)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let fmt : ('a, 'b, 'c) format =</code></strong>
<strong><code>    "%i is an integer, %F is a float, \"%s\" is a string\n";;</code></strong>
<code class="computeroutput">val fmt : (int -&gt; float -&gt; string -&gt; 'c, 'b, 'c) format = &lt;abstr&gt;</code></pre><p>And accordingly, we can pass it to <code>printf</code>:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/printf.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
        (part 5)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>printf fmt 3 4.5 "five";;</code></strong>
<code class="computeroutput">3 is an integer, 4.5 is a float, "five" is a string - : unit = ()</code>
        </pre><?hard-pagebreak?><p>If this looks different from everything else you've seen so far,
        that's because it is. This is really a special case in the type
        system. Most of the time, you don't need to worry about this special
        handling of format strings—you can just use <code>printf</code> and not worry about the details. But
        it's useful to keep the broad outlines of the story in the back of
        your head.</p></aside><p>Now let's see how we can rewrite our time conversion program to be
      a little more concise using <code>printf</code>:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/time_converter2.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a></p><pre data-type="programlisting" data-code-language="ocaml">open Core.Std

let () =
  printf "Pick a timezone: %!";
  match In_channel.input_line stdin with
  | None -&gt; failwith "No timezone provided"
  | Some zone_string -&gt;
    let zone = Zone.find_exn zone_string in
    let time_string = Time.to_string_abs (Time.now ()) ~zone in
    printf "The time in %s is %s.\n%!" (Zone.to_string zone) time_string</pre><p>In the preceding example, we've used only two formatting
      directives: <code>%s</code>, for including a
      string, and <code>%!</code> which causes <code>printf</code> to flush the channel.</p><p><code>printf</code>'s formatting directives
      offer a significant amount of control, allowing you to specify things
      like:<a data-type="indexterm" data-primary="binary numbers, formatting with printf"/><a data-type="indexterm" data-primary="hex numbers, formatting with printf"/><a data-type="indexterm" data-primary="decimals, formatting with printf"/><a data-type="indexterm" data-primary="alignment, formatting with printf"/></p><ul><li><p>Alignment and padding</p></li><li><p>Escaping rules for strings</p></li><li><p>Whether numbers should be formatted in decimal, hex, or
          binary</p></li><li><p>Precision of float conversions</p></li></ul><p>There are also <code>printf</code>-style
      functions that target outputs other than <code>stdout</code>, including:<a data-type="indexterm" data-primary="sprintf function"/><a data-type="indexterm" data-primary="fprintf function"/><a data-type="indexterm" data-primary="eprintf function"/></p><ul><li><p><code>eprintf</code>, which prints to
          <code>stderr</code></p></li><li><p><code>fprintf</code>, which prints to an
          arbitrary <code>out_channel</code></p></li><li><p><code>sprintf</code>, which returns a
          formatted string</p></li></ul><p>All of this, and a good deal more, is described in the API
      documentation for the <code>Printf</code> module
      in the OCaml Manual.</p></section><section id="file-io" data-type="sect2"><h2>File I/O</h2><p>Another common use of <code>in_channel</code>s and <code>out_channel</code>s is for working with files. Here
      are a couple of functions—one that creates a file full of numbers, and
      the other that reads in such a file and returns the sum of those
      numbers:<a data-type="indexterm" data-primary="files" data-secondary="file I/O"/><a data-type="indexterm" data-primary="I/O (input/output) operations" data-secondary="file I/O"/></p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/file.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 1)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let create_number_file filename numbers =</code></strong>
<strong><code>    let outc = Out_channel.create filename in</code></strong>
<strong><code>    List.iter numbers ~f:(fun x -&gt; fprintf outc "%d\n" x);</code></strong>
<strong><code>    Out_channel.close outc</code></strong>
<strong><code>  ;;</code></strong>
<code class="computeroutput">val create_number_file : string -&gt; int list -&gt; unit = &lt;fun&gt;</code>
<code class="prompt"># </code><strong><code>let sum_file filename =</code></strong>
<strong><code>     let file = In_channel.create filename in</code></strong>
<strong><code>     let numbers = List.map ~f:Int.of_string (In_channel.input_lines file) in</code></strong>
<strong><code>     let sum = List.fold ~init:0 ~f:(+) numbers in</code></strong>
<strong><code>     In_channel.close file;</code></strong>
<strong><code>     sum</code></strong>
<strong><code>  ;;</code></strong>
<code class="computeroutput">val sum_file : string -&gt; int = &lt;fun&gt;</code>
<code class="prompt"># </code><strong><code>create_number_file "numbers.txt" [1;2;3;4;5];;</code></strong>
<code class="computeroutput">- : unit = ()</code>
<code class="prompt"># </code><strong><code>sum_file "numbers.txt";;</code></strong>
<code class="computeroutput">- : int = 15</code></pre><p>For both of these functions, we followed the same basic sequence:
      we first create the channel, then use the channel, and finally close the
      channel. The closing of the channel is important, since without it, we
      won't release resources associated with the file back to the operating
      system.</p><p>One problem with the preceding code is that if it throws an
      exception in the middle of its work, it won't actually close the file.
      If we try to read a file that doesn't actually contain numbers, we'll
      see such an error:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/file.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 2)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>sum_file "/etc/hosts";;</code></strong>
<code class="computeroutput">Exception: (Failure "Int.of_string: \"127.0.0.1    localhost\"").</code></pre><p>And if we do this over and over in a loop, we'll eventually run
      out of file descriptors:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/file.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 3)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>for i = 1 to 10000 do try ignore (sum_file "/etc/hosts") with _ -&gt; () done;;</code></strong>
<code class="computeroutput">- : unit = ()</code>
<code class="prompt"># </code><strong><code>sum_file "numbers.txt";;</code></strong>
<code class="computeroutput">Exception: (Sys_error "numbers.txt: Too many open files").</code></pre><p>And now, you'll need to restart your toplevel if you want to open
      any more files!</p><p>To avoid this, we need to make sure that our code cleans up after
      itself. We can do this using the <code>protect</code> function described in <a href="#error-handling" data-type="xref"/>, as follows:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/file2.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 1)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let sum_file filename =</code></strong>
<strong><code>    let file = In_channel.create filename in</code></strong>
<strong><code>    protect ~f:(fun () -&gt;</code></strong>
<strong><code>        let numbers = List.map ~f:Int.of_string (In_channel.input_lines file) in</code></strong>
<strong><code>        List.fold ~init:0 ~f:(+) numbers)</code></strong>
<strong><code>      ~finally:(fun () -&gt; In_channel.close file)</code></strong>
<strong><code>  ;;</code></strong>
<code class="computeroutput">val sum_file : string -&gt; int = &lt;fun&gt;</code></pre><p>And now, the file descriptor leak is gone:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/file2.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 2)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>for i = 1 to 10000 do try ignore (sum_file "/etc/hosts") with _ -&gt; () done;;</code></strong>
<code class="computeroutput">- : unit = ()</code>
<code class="prompt"># </code><strong><code>sum_file "numbers.txt";;</code></strong>
<code class="computeroutput">- : int = 15</code></pre><p>This is really an example of a more general issue with imperative
      programming. When programming imperatively, you need to be quite careful
      to make sure that exceptions don't leave you in an awkward state.</p><p><code>In_channel</code> has functions that
      automate the handling of some of these details. For example, <code>In_channel.with_file</code> takes a filename and a
      function for processing data from an <code>in_channel</code> and takes care of the bookkeeping
      associated with opening and closing the file. We can rewrite <code>sum_file</code> using this function, as shown
      here:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/file2.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 3)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let sum_file filename =</code></strong>
<strong><code>    In_channel.with_file filename ~f:(fun file -&gt;</code></strong>
<strong><code>      let numbers = List.map ~f:Int.of_string (In_channel.input_lines file) in</code></strong>
<strong><code>      List.fold ~init:0 ~f:(+) numbers)</code></strong>
<strong><code>  ;;</code></strong>
<code class="computeroutput">val sum_file : string -&gt; int = &lt;fun&gt;</code></pre><p>Another misfeature of our implementation of <code>sum_file</code> is that we read the entire file into
      memory before processing it. For a large file, it's more efficient to
      process a line at a time. You can use the <code>In_channel.fold_lines</code> function to do just
      that:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/file2.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 4)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let sum_file filename =</code></strong>
<strong><code>    In_channel.with_file filename ~f:(fun file -&gt;</code></strong>
<strong><code>      In_channel.fold_lines file ~init:0 ~f:(fun sum line -&gt;</code></strong>
<strong><code>        sum + Int.of_string line))</code></strong>
<strong><code>  ;;</code></strong>
<code class="computeroutput">val sum_file : string -&gt; int = &lt;fun&gt;</code></pre><p>This is just a taste of the functionality of <code>In_channel</code> and <code>Out_channel</code>. To get a fuller understanding,
      you should review the API documentation for those modules.<a data-type="indexterm" data-startref="IPinpout"/></p></section></section><section id="order-of-evaluation" data-type="sect1"><h1>Order of Evaluation</h1><p>The order in which expressions are evaluated is an important part of the definition of a
      programming language, and it is particularly important when programming imperatively. Most
      programming languages you're likely to have encountered are <em>strict</em>, and
      OCaml is, too. In a strict language, when you bind an identifier to the result of some
      expression, the expression is evaluated before the variable is bound. Similarly, if you call a
      function on a set of arguments, those arguments are evaluated before they are passed to the
        function.<a data-type="indexterm" data-primary="strict evaluation"/><a data-type="indexterm" data-primary="expressions, order of evaluation"/><a data-type="indexterm" data-primary="evaluation, order of"/><a data-type="indexterm" data-primary="order of evaluation"/><a data-type="indexterm" data-primary="imperative programming" data-secondary="order of evaluation"/></p><p>Consider the following simple example. Here, we have a collection of
    angles, and we want to determine if any of them have a negative <code>sin</code>. The following snippet of code would answer
    that question:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/order.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 1)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let x = sin 120. in</code></strong>
<strong><code>  let y = sin 75.  in</code></strong>
<strong><code>  let z = sin 128. in</code></strong>
<strong><code>  List.exists ~f:(fun x -&gt; x &lt; 0.) [x;y;z]</code></strong>
<strong><code>  ;;</code></strong>
<code class="computeroutput">- : bool = true</code></pre><p>In some sense, we don't really need to compute the <code>sin 128.</code> because <code>sin
    75.</code> is negative, so we could know the answer before even
    computing <code>sin 128.</code>.</p><p>It doesn't have to be this way. Using the <code>lazy</code> keyword, we can write the original
    computation so that <code>sin 128.</code> won't ever
    be computed:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/order.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 2)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let x = lazy (sin 120.) in</code></strong>
<strong><code>  let y = lazy (sin 75.)  in</code></strong>
<strong><code>  let z = lazy (sin 128.) in</code></strong>
<strong><code>  List.exists ~f:(fun x -&gt; Lazy.force x &lt; 0.) [x;y;z]</code></strong>
<strong><code>  ;;</code></strong>
<code class="computeroutput">- : bool = true</code></pre><p>We can confirm that fact by a few well-placed <code>printf</code>s:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/order.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 3)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let x = lazy (printf "1\n"; sin 120.) in</code></strong>
<strong><code>  let y = lazy (printf "2\n"; sin 75.)  in</code></strong>
<strong><code>  let z = lazy (printf "3\n"; sin 128.) in</code></strong>
<strong><code>  List.exists ~f:(fun x -&gt; Lazy.force x &lt; 0.) [x;y;z]</code></strong>
<strong><code>  ;;</code></strong>
<code class="computeroutput">1</code>
<code class="computeroutput">2</code>
<code class="computeroutput">- : bool = true</code></pre><p>OCaml is strict by default for a good reason: lazy evaluation and
    imperative programming generally don't mix well because laziness makes it
    harder to reason about when a given side effect is going to occur.
    Understanding the order of side effects is essential to reasoning about
    the behavior of an imperative program.</p><p>In a strict language, we know that expressions that are bound by a
    sequence of <code>let</code> bindings will be evaluated in the order
    that they're defined. But what about the evaluation order within a single
    expression? Officially, the answer is that evaluation order within an
    expression is undefined. In practice, OCaml has only one compiler, and
    that behavior is a kind of de facto standard. Unfortunately, the
    evaluation order in this case is often the opposite of what one might
    expect.</p><p>Consider the following example:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/order.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 4)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>List.exists ~f:(fun x -&gt; x &lt; 0.)</code></strong>
<strong><code>  [ (printf "1\n"; sin 120.);</code></strong>
<strong><code>    (printf "2\n"; sin 75.);</code></strong>
<strong><code>    (printf "3\n"; sin 128.); ]</code></strong>
<strong><code>  ;;</code></strong>
<code class="computeroutput">3</code>
<code class="computeroutput">2</code>
<code class="computeroutput">1</code>
<code class="computeroutput">- : bool = true</code></pre><p>Here, you can see that the subexpression that came last was actually
    evaluated first! This is generally the case for many different kinds of
    expressions. If you want to make sure of the evaluation order of different
    subexpressions, you should express them as a series of <code>let</code> bindings.</p></section><section id="side-effects-and-weak-polymorphism" data-type="sect1"><h1>Side Effects and Weak Polymorphism</h1><p>Consider the following simple, imperative function:<a data-type="indexterm" data-primary="polymorphism" data-secondary="weak polymorphism"/><a data-type="indexterm" data-primary="weak polymorphism"/><a data-type="indexterm" data-primary="side effects"/><a data-type="indexterm" id="IPsideweak" data-primary="imperative programming" data-secondary="side effects/weak polymorphism"/></p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/weak.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 1)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let remember =</code></strong>
<strong><code>    let cache = ref None in</code></strong>
<strong><code>    (fun x -&gt;</code></strong>
<strong><code>       match !cache with</code></strong>
<strong><code>       | Some y -&gt; y</code></strong>
<strong><code>       | None -&gt; cache := Some x; x)</code></strong>
<strong><code>  ;;</code></strong>
<code class="computeroutput">val remember : '_a -&gt; '_a = &lt;fun&gt;</code></pre><p><code>remember</code> simply caches the first
    value that's passed to it, returning that value on every call. That's
    because <code>cache</code> is created and
    initialized once and is shared across invocations of <code>remember</code>.</p><p><code>remember</code> is not a terribly useful
    function, but it raises an interesting question: what is its type?</p><p>On its first call, <code>remember</code>
    returns the same value it's passed, which means its input type and return
    type should match. Accordingly, <code>remember</code> should have type <code>t -&gt; t</code> for some type <code>t</code>. There's nothing about <code>remember</code> that ties the choice of <code>t</code> to any particular type, so you might expect
    OCaml to generalize, replacing <code>t</code> with a
    polymorphic type variable. It's this kind of generalization that gives us
    polymorphic types in the first place. The identity function, as an
    example, gets a polymorphic type in this way:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/weak.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 2)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let identity x = x;;</code></strong>
<code class="computeroutput">val identity : 'a -&gt; 'a = &lt;fun&gt;</code>
<code class="prompt"># </code><strong><code>identity 3;;</code></strong>
<code class="computeroutput">- : int = 3</code>
<code class="prompt"># </code><strong><code>identity "five";;</code></strong>
<code class="computeroutput">- : string = "five"</code></pre><p>As you can see, the polymorphic type of <code>identity</code> lets it operate on values with
    different types.</p><p>This is not what happens with <code>remember</code>, though. As you
      can see from the above examples, the type that OCaml infers for <code>remember</code> looks almost, but not quite, like the type of the identity function.
      Here it is again:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/remember_type.ml" class="orm:hideurl:ital"><em class="hyperlink">OCaml</em></a></p><pre data-type="programlisting" data-code-language="ocaml">val remember : '_a -&gt; '_a = &lt;fun&gt;</pre><p>The underscore in the type variable <code>'_a</code> tells us that the variable is only
    <em>weakly polymorphic</em>, which is to say that it can be
    used with any <em>single</em> type. That makes sense because,
    unlike <code>identity</code>, <code>remember</code> always returns the value it was passed
    on its first invocation, which means its return value must always have the
    same type.<a data-type="indexterm" data-primary="type variables"/></p><p>OCaml will convert a weakly polymorphic variable to a concrete type
    as soon as it gets a clue as to what concrete type it is to be used
    as:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/weak.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
    (part 3)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let remember_three () = remember 3;;</code></strong>
<code class="computeroutput">val remember_three : unit -&gt; int = &lt;fun&gt;</code>
<code class="prompt"># </code><strong><code>remember;;</code></strong>
<code class="computeroutput">- : int -&gt; int = &lt;fun&gt;</code>
<code class="prompt"># </code><strong><code>remember "avocado";;</code></strong>
<code class="computeroutput">Characters 9-18:</code>
<code class="computeroutput">Error: This expression has type string but an expression was expected of type</code>
<code class="computeroutput">         int</code></pre><p>Note that the type of <code>remember</code>
    was settled by the definition of <code>remember_three</code>, even though <code>remember_three</code> was never called!</p><section id="the-value-restriction" data-type="sect2"><h2>The Value Restriction</h2><p>So, when does the compiler infer weakly polymorphic types? As
      we've seen, we need weakly polymorphic types when a value of unknown
      type is stored in a persistent mutable cell. Because the type system
      isn't precise enough to determine all cases where this might happen,
      OCaml uses a rough rule to flag cases that don't introduce any
      persistent mutable cells, and to only infer polymorphic types in those
      cases. This rule is called <em>the value
      restriction</em>.<a data-type="indexterm" data-primary="value restriction"/></p><p>The core of the value restriction is the observation that some
      kinds of expressions, which we'll refer to as <em>simple
      values</em>, by their nature can't introduce persistent mutable
      cells, including:</p><ul><li><p>Constants (i.e., things like integer and floating-point
          literals)</p></li><li><p>Constructors that only contain other simple values</p></li><li><p>Function declarations, i.e., expressions that begin with
          <code>fun</code> or <code>function</code>, or the equivalent let binding,
          <code>let f x = ...</code></p></li><li><p><code>let</code> bindings of the form
          <code>let</code> <em><code>var</code></em> <code>=</code> <em><code>expr1</code></em> <code>in</code> <em><code>expr2</code></em>, where both
          <em><code>expr1</code></em> and
          <em><code>expr2</code></em> are
          simple values</p></li></ul><p>Thus, the following expression is a simple value, and as a result,
      the types of values contained within it are allowed to be
      polymorphic:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/value_restriction.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 1)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>(fun x -&gt; [x;x]);;</code></strong>
<code class="computeroutput">- : 'a -&gt; 'a list = &lt;fun&gt;</code></pre><p>But, if we write down an expression that isn't a simple value by
      the preceding definition, we'll get different results. For example,
      consider what happens if we try to memoize the function defined
      previously.</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/value_restriction.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 2)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>memoize (fun x -&gt; [x;x]);;</code></strong>
<code class="computeroutput">- : '_a -&gt; '_a list = &lt;fun&gt;</code></pre><p>The memoized version of the function does in fact need to be
      restricted to a single type because it uses mutable state behind the
      scenes to cache values returned by previous invocations of the function.
      But OCaml would make the same determination even if the function in
      question did no such thing. Consider this example:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/value_restriction.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 3)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>identity (fun x -&gt; [x;x]);;</code></strong>
<code class="computeroutput">- : '_a -&gt; '_a list = &lt;fun&gt;</code></pre><p>It would be safe to infer a fully polymorphic variable here, but
      because OCaml's type system doesn't distinguish between pure and impure
      functions, it can't separate those two cases.</p><p>The value restriction doesn't require that there is no mutable
      state, only that there is no <em>persistent</em> mutable
      state that could share values between uses of the same function. Thus, a
      function that produces a fresh reference every time it's called can have
      a fully polymorphic type:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/value_restriction.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 4)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let f () = ref None;;</code></strong>
<code class="computeroutput">val f : unit -&gt; 'a option ref = &lt;fun&gt;</code></pre><p>But a function that has a mutable cache that persists across
      calls, like <code>memoize</code>, can only be weakly
      polymorphic.</p></section><section id="partial-application-and-the-value-restriction" data-type="sect2"><h2>Partial Application and the Value Restriction</h2><p>Most of the time, when the value restriction kicks in, it's for a
      good reason, i.e., it's because the value in question can actually only
      safely be used with a single type. But sometimes, the value restriction
      kicks in when you don't want it. The most common such case is partially
      applied functions. A partially applied function, like any function
      application, is not a simple value, and as such, functions created by
      partial application are sometimes less general than you might
      expect.<a data-type="indexterm" data-primary="partial application"/></p><p>Consider the <code>List.init</code>
      function, which is used for creating lists where each element is created
      by calling a function on the index of that element:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/value_restriction.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 5)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>List.init;;</code></strong>
<code class="computeroutput">- : int -&gt; f:(int -&gt; 'a) -&gt; 'a list = &lt;fun&gt;</code>
<code class="prompt"># </code><strong><code>List.init 10 ~f:Int.to_string;;</code></strong>
<code class="computeroutput">- : string list = ["0"; "1"; "2"; "3"; "4"; "5"; "6"; "7"; "8"; "9"]</code></pre><p>Imagine we wanted to create a specialized version of <code>List.init</code> that always created lists of length
      10. We could do that using partial application, as follows:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/value_restriction.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 6)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let list_init_10 = List.init 10;;</code></strong>
<code class="computeroutput">val list_init_10 : f:(int -&gt; '_a) -&gt; '_a list = &lt;fun&gt;</code></pre><p>As you can see, we now infer a weakly polymorphic type for the
      resulting function. That's because there's nothing that guarantees that
      <code>List.init</code> isn't creating a persistent
      <code>ref</code> somewhere inside of it that would
      be shared across multiple calls to <code>list_init_10</code>. We can eliminate this
      possibility, and at the same time get the compiler to infer a
      polymorphic type, by avoiding partial application:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/value_restriction.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 7)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>let list_init_10 ~f = List.init 10 ~f;;</code></strong>
<code class="computeroutput">val list_init_10 : f:(int -&gt; 'a) -&gt; 'a list = &lt;fun&gt;</code></pre><p>This transformation is referred to as <em>eta
      expansion</em> and is often useful to resolve problems that arise
      from the value restriction.</p></section><section id="relaxing-the-value-restriction" data-type="sect2"><h2>Relaxing the Value Restriction</h2><p>OCaml is actually a little better at inferring polymorphic types
      than was suggested previously. The value restriction as we described it
      is basically a syntactic check: you can do a few operations that count
      as simple values, and anything that's a simple value can be
      generalized.</p><p>But OCaml actually has a relaxed version of the value restriction that can make use of
        type information to allow polymorphic types for things that are not simple values.</p><p>For example, we saw that a function application, even a simple
      application of the identity function, is not a simple value and thus can
      turn a polymorphic value into a weakly polymorphic one:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/value_restriction.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 8)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>identity (fun x -&gt; [x;x]);;</code></strong>
<code class="computeroutput">- : '_a -&gt; '_a list = &lt;fun&gt;</code></pre><p>But that's not always the case. When the type of the returned
      value is immutable, then OCaml can typically infer a fully polymorphic
      type:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/value_restriction.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 9)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>identity [];;</code></strong>
<code class="computeroutput">- : 'a list = []</code></pre><p>On the other hand, if the returned type is potentially mutable,
      then the result will be weakly polymorphic:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/value_restriction.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 10)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>[||];;</code></strong>
<code class="computeroutput">- : 'a array = [||]</code>
<code class="prompt"># </code><strong><code>identity [||];;</code></strong>
<code class="computeroutput">- : '_a array = [||]</code></pre><p>A more important example of this comes up when defining abstract
      data types. Consider the following simple data structure for an
      immutable list type that supports constant-time concatenation:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/value_restriction.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 11)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>module Concat_list : sig</code></strong>
<strong><code>    type 'a t</code></strong>
<strong><code>    val empty : 'a t</code></strong>
<strong><code>    val singleton : 'a -&gt; 'a t</code></strong>
<strong><code>    val concat  : 'a t -&gt; 'a t -&gt; 'a t  (* constant time *)</code></strong>
<strong><code>    val to_list : 'a t -&gt; 'a list       (* linear time   *)</code></strong>
<strong><code>  end = struct</code></strong>
<strong><code/></strong>
<strong><code>    type 'a t = Empty | Singleton of 'a | Concat of 'a t * 'a t</code></strong>
<strong><code/></strong>
<strong><code>    let empty = Empty</code></strong>
<strong><code>    let singleton x = Singleton x</code></strong>
<strong><code>    let concat x y = Concat (x,y)</code></strong>
<strong><code/></strong>
<strong><code>    let rec to_list_with_tail t tail =</code></strong>
<strong><code>      match t with</code></strong>
<strong><code>      | Empty -&gt; tail</code></strong>
<strong><code>      | Singleton x -&gt; x :: tail</code></strong>
<strong><code>      | Concat (x,y) -&gt; to_list_with_tail x (to_list_with_tail y tail)</code></strong>
<strong><code/></strong>
<strong><code>    let to_list t =</code></strong>
<strong><code>      to_list_with_tail t []</code></strong>
<strong><code/></strong>
<strong><code>  end;;</code></strong>
<code class="computeroutput">module Concat_list :</code>
<code class="computeroutput">  sig</code>
<code class="computeroutput">    type 'a t</code>
<code class="computeroutput">    val empty : 'a t</code>
<code class="computeroutput">    val singleton : 'a -&gt; 'a t</code>
<code class="computeroutput">    val concat : 'a t -&gt; 'a t -&gt; 'a t</code>
<code class="computeroutput">    val to_list : 'a t -&gt; 'a list</code>
<code class="computeroutput">  end</code></pre><p>The details of the implementation don't matter so much, but it's
      important to note that a <code>Concat_list.t</code> is unquestionably an immutable
      value. However, when it comes to the value restriction, OCaml treats it
      as if it were mutable:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/value_restriction.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 12)</p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>Concat_list.empty;;</code></strong>
<code class="computeroutput">- : 'a Concat_list.t = &lt;abstr&gt;</code>
<code class="prompt"># </code><strong><code>identity Concat_list.empty;;</code></strong>
<code class="computeroutput">- : '_a Concat_list.t = &lt;abstr&gt;</code></pre><p>The issue here is that the signature, by virtue of being abstract,
      has obscured the fact that <code>Concat_list.t</code> is in fact an immutable data
      type. We can resolve this in one of two ways: either by making the type
      concrete (i.e., exposing the implementation in the <code>mli</code>), which is often not desirable; or by
      marking the type variable in question as <em>covariant</em>.
      We'll learn more about covariance and contravariance in <a href="#objects" data-type="xref"/>, but for now, you can think of it as an annotation
      that can be put in the interface of a pure data structure.<a data-type="indexterm" data-primary="datatypes" data-secondary="covariant"/></p><p>In particular, if we replace <code>type 'a
      t</code> in the interface with <code>type +'a
      t</code>, that will make it explicit in the interface that the data
      structure doesn't contain any persistent references to values of type
      <code>'a</code>, at which point, OCaml can infer
      polymorphic types for expressions of this type that are not simple
      values:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/value_restriction-13.rawscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a></p><pre data-type="programlisting" data-code-language="ocaml"><strong><code># module Concat_list : sig
    type +'a t
    val empty : 'a t
    val singleton : 'a -&gt; 'a t
    val concat  : 'a t -&gt; 'a t -&gt; 'a t  (* constant time *)
    val to_list : 'a t -&gt; 'a list       (* linear time   *)
  end = struct

    type 'a t = Empty | Singleton of 'a | Concat of 'a t * 'a t

    ...

  end;;</code></strong>
<code class="computeroutput"> module Concat_list :
  sig
    type '+a t
    val empty : 'a t
    val singleton : 'a -&gt; 'a t
    val concat : 'a t -&gt; 'a t -&gt; 'a t
    val to_list : 'a t -&gt; 'a list
  end</code></pre><p>Now, we can apply the identity function to <code>Concat_list.empty</code> without without losing any
      polymorphism:</p><p><a href="https://github.com/realworldocaml/examples/tree/v1/code/imperative-programming/value_restriction.topscript" class="orm:hideurl:ital"><em class="hyperlink">OCaml utop</em></a>
      (part 14)<a data-type="indexterm" data-startref="IPsideweak"/></p><pre data-type="programlisting" data-code-language="ocaml"><code class="prompt"># </code><strong><code>identity Concat_list.empty;;</code></strong>
<code class="computeroutput">- : 'a Concat_list.t = &lt;abstr&gt;</code></pre></section></section><section id="summary" data-type="sect1"><h1>Summary</h1><p>This chapter has covered quite a lot of ground, including:<a data-type="indexterm" data-primary="imperative programming" data-secondary="overview of"/></p><ul><li><p>Discussing the building blocks of mutable data structures as
        well as the basic imperative constructs like <code>for</code> loops, <code>while</code> loops, and the sequencing operator
        <code>;</code></p></li><li><p>Walking through the implementation of a couple of classic
        imperative data structures</p></li><li><p>Discussing so-called benign effects like memoization and
        laziness</p></li><li><p>Covering OCaml's API for blocking I/O</p></li><li><p>Discussing how language-level issues like order of evaluation
        and weak polymorphism interact with OCaml's imperative features</p></li></ul><p>The scope and sophistication of the material here is an indication
    of the importance of OCaml's imperative features. The fact that OCaml
    defaults to immutability shouldn't obscure the fact that imperative
    programming is a fundamental part of building any serious application, and
    that if you want to be an effective OCaml programmer, you need to
    understand OCaml's approach to imperative programming.<a data-type="indexterm" data-startref="PROGimper"/></p></section></section>