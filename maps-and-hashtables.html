<html style="" lang="en" class="js flexbox fontface"><head><meta charset="utf-8"><meta content="width=device-width, initial-scale=1.0" name="viewport"><title>Maps and Hash Tables - Real World OCaml</title><link href="css/app.css" rel="stylesheet"><link href="css/prism.css" rel="stylesheet"><script src="js/min/modernizr-min.js"></script><script src="js/prism.js"></script><script src="//use.typekit.net/gfj8wez.js"></script><script>try{Typekit.load();}catch(e){}</script></head><body><div class="title-bar"><div class="title"><h1>Real World OCaml</h1><h5>2<sup>nd</sup> Edition (published in Q4 2021)</h5><nav><a href="index.html">Home</a><a href="toc.html">Table of Contents</a><a href="faqs.html">FAQs</a><a href="install.html">Install</a><a href="https://ocaml.janestreet.com/ocaml-core/">API Docs</a></nav></div></div><div class="wrap"><div class="left-column"><a class="to-chapter" href="toc.html"><small>Back</small><h5>Table of Contents</h5></a></div><article class="main-body"><section class="level1" id="maps-and-hash-tables">
<h1>Maps and Hash Tables</h1>
<p>Lots of programming problems require dealing with data organized as
key/value pairs. Maybe the simplest way of representing such data in
OCaml is an <em>association list</em>, which is simply a list of pairs
of keys and values. For example, you could represent a mapping between
the 10 digits and their English names as follows: <a data-primary="key-value pairs" data-type="indexterm">&nbsp;</a><a data-secondary="key-value pairs" data-primary="data
structures" data-type="indexterm">&nbsp;</a><a data-secondary="association
lists" data-primary="lists" data-type="indexterm">&nbsp;</a><a data-primary="association lists" data-type="indexterm">&nbsp;</a></p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">open Base;;
let digit_alist =
  [ 0, "zero"; 1, "one"; 2, "two"  ; 3, "three"; 4, "four"
  ; 5, "five"; 6, "six"; 7, "seven"; 8, "eight"; 9, "nine" ];;
&gt;val digit_alist : (int * string) list =
&gt;  [(0, "zero"); (1, "one"); (2, "two"); (3, "three"); (4, "four");
&gt;   (5, "five"); (6, "six"); (7, "seven"); (8, "eight"); (9, "nine")]
</code></pre>
</div>
<p>We can use functions from the <code>List.Assoc</code> module to
manipulate this data:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">List.Assoc.find ~equal:Int.equal digit_alist 6;;
&gt;- : string option = Some "six"
List.Assoc.find ~equal:Int.equal digit_alist 22;;
&gt;- : string option = None
List.Assoc.add ~equal:Int.equal digit_alist 0 "zilch";;
&gt;- : (int, string) Base.List.Assoc.t =
&gt;[(0, "zilch"); (1, "one"); (2, "two"); (3, "three"); (4, "four");
&gt; (5, "five"); (6, "six"); (7, "seven"); (8, "eight"); (9, "nine")]
</code></pre>
</div>
<p>Association lists are simple and easy to use, but their performance
is not ideal, since almost every nontrivial operation on an association
list requires a linear-time scan of the list.</p>
<p>In this chapter, we’ll talk about two more efficient alternatives to
association lists: <em>maps</em> and <em>hash tables</em>. A map is an
immutable tree-based data structure where most operations take time
logarithmic in the size of the map, whereas a hash table is a mutable
data structure where most operations have constant time complexity.
We’ll describe both of these data structures in detail and provide some
advice as to how to choose between them. <a data-secondary="basics of" data-primary="hash
tables" data-type="indexterm">&nbsp;</a><a data-secondary="basics of" data-primary="maps" data-type="indexterm">&nbsp;</a></p>
<section class="level2" id="maps">
<h2>Maps</h2>
<p>Let’s consider an example of how one might use a map in practice. In
<a data-type="xref" href="files-modules-and-programs.html#files-modules-and-programs">Chapter 4, Files Modules And Programs</a>, we showed a module
<code>Counter</code> for keeping frequency counts on a set of strings.
Here’s the interface:</p>
<div class="highlight">
<pre><code class="language-ocaml">open Base

(** A collection of string frequency counts *)
type t

(** The empty set of frequency counts *)
val empty : t

(** Bump the frequency count for the given string. *)
val touch : t -&gt; string -&gt; t

(** Converts the set of frequency counts to an association list. Every
    string in the list will show up at most once, and the integers
    will be at least 1. *)
val to_list : t -&gt; (string * int) list</code></pre>
</div>
<p>The intended behavior here is straightforward.
<code>Counter.empty</code> represents an empty collection of frequency
counts; <code>touch</code> increments the frequency count of the
specified string by 1; and <code>to_list</code> returns the list of
nonzero frequencies.</p>
<p>Here’s the implementation.</p>
<div class="highlight">
<pre><code class="language-ocaml">open Base

type t = (string, int, String.comparator_witness) Map.t

let empty = Map.empty (module String)
let to_list t = Map.to_alist t

let touch t s =
  let count =
    match Map.find t s with
    | None -&gt; 0
    | Some x -&gt; x
  in
  Map.set t ~key:s ~data:(count + 1)</code></pre>
</div>
<p>Take a look at the definition of the type <code>t</code> above.
You’ll see that the <code>Map.t</code> has three type parameters. The
first two are what you might expect; one for the type of the key, and
one for the type of the data. The third type parameter, the
<em>comparator witness</em>, requires some explaining. <a data-secondary="comparator witness" data-primary="comparator" data-type="indexterm">&nbsp;</a></p>
<p>The comparator witness is used to indicate which comparison function
was used to construct the map, rather than saying something about the
type of data stored in the map. The type
<code>String.comparator_witness</code> in particular indicates that this
map was built with the default comparison function from the
<code>String</code> module. We’ll talk about why the comparator witness
is important later in the chapter.</p>
<p>The call to <code>Map.empty</code> is also worth explaining, in that,
unusually, it takes a first-class module as an argument. The point of
the first class module is to provide the comparison function that is
required for building the map, along with an s-expression converter for
generating useful error messages (we’ll talk more about s-expressions in
<a data-type="xref" href="data-serialization.html#data-serialization-with-s-expressions">Chapter 20, Data Serialization with S-Expressions</a>). We don’t
need to provide the module again for functions like
<code>Map.find</code> or <code>Map.add</code>, because the map itself
contains a reference to the comparison function it uses.</p>
<p>Not every module can be used for creating maps, but the standard ones
in <code>Base</code> can. Later in the chapter, we’ll show how you can
set up a module of your own so it can be used in this way.</p>
<section class="level3" id="sets">
<h3>Sets</h3>
<p>In addition to maps, <code>Base</code> also provides a set data type
that’s designed along similar lines. In some sense, sets are little more
than maps where you ignore the data. But while you could encode sets in
terms of maps, it’s more natural, and more efficient, to use
<code>Base</code>’s specialized set type. Here’s a simple example. <a data-primary="set types" data-type="indexterm">&nbsp;</a></p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Set.of_list (module Int) [1;2;3] |&gt; Set.to_list;;
&gt;- : int list = [1; 2; 3]
Set.union
  (Set.of_list (module Int) [1;2;3;2])
  (Set.of_list (module Int) [3;5;1])
|&gt; Set.to_list;;
&gt;- : int list = [1; 2; 3; 5]
</code></pre>
</div>
<p>In addition to the operators you would expect to have for maps, sets
support the traditional set operations, including union, intersection,
and set difference.</p>
</section>
<section class="level3" id="modules-and-comparators">
<h3>Modules and Comparators</h3>
<p>It’s easy enough to create a map or set based on a type represented
by a module in <code>Base</code>. Here, we’ll create a map from digits
to their English names, based on <code>digit_alist</code>, which was
defined earlier in the chapter.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let digit_map = Map.of_alist_exn (module Int) digit_alist;;
&gt;val digit_map : (int, string, Int.comparator_witness) Map.t = &lt;abstr&gt;
Map.find digit_map 3;;
&gt;- : string option = Some "three"
</code></pre>
</div>
<p>The function <code>Map.of_alist_exn</code> constructs a map from a
provided association list, throwing an exception if a key is used more
than once. Let’s take a look at the type signature of
<code>Map.of_alist_exn</code>.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">#show Map.of_alist_exn;;
&gt;val of_alist_exn :
&gt;  ('a, 'cmp) Map.comparator -&gt; ('a * 'b) list -&gt; ('a, 'b, 'cmp) Map.t
</code></pre>
</div>
<p>The type <code>Map.comparator</code> is actually an alias for a
first-class module type, representing any module that matches the
signature <code>Comparator.S</code>, shown below.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">#show Base.Comparator.S;;
&gt;module type S =
&gt;  sig
&gt;    type t
&gt;    type comparator_witness
&gt;    val comparator : (t, comparator_witness) Comparator.t
&gt;  end
</code></pre>
</div>
<p>Such a module must contain the type of the key itself, as well as the
<code>comparator_witness</code> type, which serves as a type-level
identifier of the comparison function in question, and finally, the
concrete comparator itself, a value that contains the necessary
comparison function.</p>
<p>Modules from <code>Base</code> like <code>Int</code> and
<code>String</code> already satisfy this interface. But what if you want
to satisfy this interface with a new module? Consider, for example, the
following type representing a book, for which we’ve written a comparison
function and an s-expression serializer.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">module Book = struct

  type t = { title: string; isbn: string }

  let compare t1 t2 =
    let cmp_title = String.compare t1.title t2.title in
    if cmp_title &lt;&gt; 0 then cmp_title
    else String.compare t1.isbn t2.isbn

  let sexp_of_t t : Sexp.t =
    List [ Atom t.title; Atom t.isbn ]
end;;
&gt;module Book :
&gt;  sig
&gt;    type t = { title : string; isbn : string; }
&gt;    val compare : t -&gt; t -&gt; int
&gt;    val sexp_of_t : t -&gt; Sexp.t
&gt;  end
</code></pre>
</div>
<p>This module has the basic functionality we need, but doesn’t satisfy
the <code>Comparator.S</code> interface, so we can’t use it for creating
a map, as you can see.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Map.empty (module Book);;
&gt;Line 1, characters 19-23:
&gt;Error: Signature mismatch:
&gt;       ...
&gt;       The type `comparator_witness' is required but not provided
&gt;       File "duniverse/base/src/comparator.mli", line 19, characters 2-25:
&gt;         Expected declaration
&gt;       The value `comparator' is required but not provided
&gt;       File "duniverse/base/src/comparator.mli", line 21, characters 2-53:
&gt;         Expected declaration
</code></pre>
</div>
<p>In order to satisfy the interface, we need to use the
<code>Comparator.Make</code> functor to extend the module. Here, we use
a common idiom where we create a submodule, called <code>T</code>
containing the basic functionality for the type in question, and then
include both that module and the result of applying a functor to that
module. <a data-secondary="Comparator module" data-primary="comparator" data-type="indexterm">&nbsp;</a></p>
<div class="highlight">
<pre><code class="language-ocaml">module Book = struct
  module T = struct

    type t = { title: string; isbn: string }

    let compare t1 t2 =
      let cmp_title = String.compare t1.title t2.title in
      if cmp_title &lt;&gt; 0 then cmp_title
      else String.compare t1.isbn t2.isbn

    let sexp_of_t t : Sexp.t =
      List [ Atom t.title; Atom t.isbn ]

  end
  include T
  include Comparator.Make(T)
end;;</code></pre>
</div>
<p>With this module in hand, we can now build a set of
<code>Book.t</code>’s.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let some_programming_books =
  Set.of_list (module Book)
    [ { title = "Real World OCaml"
      ; isbn = "978-1449323912" }
    ; { title = "Structure and Interpretation of Computer Programs"
      ; isbn = "978-0262510875" }
    ; { title = "The C Programming Language"
      ; isbn = "978-0131101630" } ];;
&gt;val some_programming_books : (Book.t, Book.comparator_witness) Set.t =
&gt;  &lt;abstr&gt;
</code></pre>
</div>
<p>While we used <code>Comparator.Make</code> in the above, it’s often
preferable to use <code>Comparable.Make</code> instead, since it
provides extra helper functions, like infix comparison operators and min
and max functions, in addition to the comparator itself. <a data-primary="Comparable module" data-type="indexterm">&nbsp;</a></p>
</section>
<section class="level3" id="why-comparator-witnesses">
<h3>Why Do We Need Comparator Witnesses?</h3>
<p>The comparator witness is quite different from other types that we’ve
seen. Instead of tracking the kind of data being used, it’s used to
single out a particular value, a comparison function. Why do we even
need such a thing?</p>
<p>The comparator witness matters because some of the operations on maps
and sets, in particular those that combine multiple maps or sets
together, depend for their correctness on the fact that both objects
being combined are ordered according to the same total order, which in
turn is determined by the comparison function.</p>
<p>Consider, for example, <code>Map.symmetric_diff</code>, which
computes the difference between two maps.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let left = Map.of_alist_exn (module String) ["foo",1; "bar",3; "snoo",0];;
&gt;val left : (string, int, String.comparator_witness) Map.t = &lt;abstr&gt;
let right = Map.of_alist_exn (module String) ["foo",0; "snoo",0];;
&gt;val right : (string, int, String.comparator_witness) Map.t = &lt;abstr&gt;
Map.symmetric_diff ~data_equal:Int.equal left right |&gt; Sequence.to_list;;
&gt;- : (string, int) Map.Symmetric_diff_element.t list =
&gt;[("bar", `Left 3); ("foo", `Unequal (1, 0))]
</code></pre>
</div>
<p>As you can see below, the type of <code>Map.symmetric_diff</code>
requires that the two maps it compares have the same comparator witness,
in addition to the same key and value type.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">#show Map.symmetric_diff;;
&gt;val symmetric_diff :
&gt;  ('k, 'v, 'cmp) Map.t -&gt;
&gt;  ('k, 'v, 'cmp) Map.t -&gt;
&gt;  data_equal:('v -&gt; 'v -&gt; bool) -&gt;
&gt;  ('k, 'v) Map.Symmetric_diff_element.t Sequence.t
</code></pre>
</div>
<p>Without this constraint, we could run <code>Map.symmetric_diff</code>
on maps that are sorted in different orders, which could lead to garbled
results.</p>
<p>To see this constraint in action, we’ll need to create two maps with
the same key and data types, but different comparison functions. In the
following, we do this by minting a new module <code>Reverse</code>,
which represents strings sorted in the reverse of the usual
lexicographic order.</p>
<div class="highlight">
<pre><code class="language-ocaml">module Reverse = struct
  module T = struct
    type t = string
    let sexp_of_t = String.sexp_of_t
    let t_of_sexp = String.t_of_sexp
    let compare x y = String.compare y x
  end
  include T
  include Comparator.Make(T)
end;;</code></pre>
</div>
<p>As you can see in the following, both <code>Reverse</code> and
<code>String</code> can be used to create maps with a key type of
<code>string</code>:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let alist = ["foo", 0; "snoo", 3];;
&gt;val alist : (string * int) list = [("foo", 0); ("snoo", 3)]
let ord_map = Map.of_alist_exn (module String) alist;;
&gt;val ord_map : (string, int, String.comparator_witness) Map.t = &lt;abstr&gt;
let rev_map = Map.of_alist_exn (module Reverse) alist;;
&gt;val rev_map : (string, int, Reverse.comparator_witness) Map.t = &lt;abstr&gt;
</code></pre>
</div>
<p><code>Map.min_elt</code> returns the key and value for the smallest
key in the map, which confirms that these two maps do indeed use
different comparison functions.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Map.min_elt ord_map;;
&gt;- : (string * int) option = Some ("foo", 0)
Map.min_elt rev_map;;
&gt;- : (string * int) option = Some ("snoo", 3)
</code></pre>
</div>
<p>As a result, the algorithm in <code>Map.symmetric_diff</code> just
wouldn’t work correctly when applied to these values. Happily, the type
system will give us a compile-time error if we try, instead of throwing
an error at run time, or worse, silently returning the wrong result.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Map.symmetric_diff ord_map rev_map;;
&gt;Line 1, characters 28-35:
&gt;Error: This expression has type
&gt;         (string, int, Reverse.comparator_witness) Map.t
&gt;       but an expression was expected of type
&gt;         (string, int, String.comparator_witness) Map.t
&gt;       Type Reverse.comparator_witness is not compatible with type
&gt;         String.comparator_witness
</code></pre>
</div>
</section>
<section class="level3" id="the-polymorphic-comparator">
<h3>The Polymorphic Comparator</h3>
<p>We don’t need to generate specialized comparators for every type we
want to build a map on. We can instead build a map based on OCaml’s
built-in polymorphic comparison function, which was discussed in <a data-type="xref" href="lists-and-patterns.html#lists-and-patterns">Chapter 3, Lists
And Patterns</a>. <a data-secondary="polymorphic comparison
in" data-primary="maps" data-type="indexterm">&nbsp;</a><a data-primary="polymorphic comparisons" data-type="indexterm">&nbsp;</a></p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Map.Poly.of_alist_exn digit_alist;;
&gt;- : (int, string) Map.Poly.t = &lt;abstr&gt;
</code></pre>
</div>
<p>Note that maps based on the polymorphic comparator have different
comparator witnesses than those based on the type-specific comparison
function. Thus, the compiler rejects the following:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Map.symmetric_diff
  (Map.Poly.singleton 3 "three")
  (Map.singleton (module Int) 3 "four" );;
&gt;Line 3, characters 5-43:
&gt;Error: This expression has type (int, string, Int.comparator_witness) Map.t
&gt;       but an expression was expected of type
&gt;         (int, string, Comparator.Poly.comparator_witness) Map.t
&gt;       Type Int.comparator_witness is not compatible with type
&gt;         Comparator.Poly.comparator_witness
</code></pre>
</div>
<p>This is rejected for good reason: there’s no guarantee that the
comparator associated with a given type will order things in the same
way that polymorphic compare does.</p>
<section data-type="warning" class="level5" id="the-perils-of-polymorphic-compare">
<h5>The Perils of Polymorphic Compare</h5>
<p>Polymorphic compare is awfully convenient, but it has serious
downsides and should mostly be avoided in production code. To understand
why, it helps to understand how polymorphic compare works.</p>
<p>Polymorphic compare operates directly on the runtime representation
of OCaml values, walking the structure of those values without regard
for their type.</p>
<p>And despite ignoring types, it mostly behaves as you would hope.
Comparisons on <code>int</code>s and <code>float</code>s respect the
ordinary ordering of numeric values, and containers like strings, lists,
and arrays are compared lexicographically. And it works on almost every
OCaml type, with some important exceptions like functions.</p>
<p>But the type-oblivious nature of polymorphic compare means that it
peeks under ordinary abstraction boundaries, and that can lead to some
deeply confusing results. Maps themselves provide a great example of
this. Consider the following two maps.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let m1 = Map.of_alist_exn (module Int) [1, "one";2, "two"];;
&gt;val m1 : (int, string, Int.comparator_witness) Map.t = &lt;abstr&gt;
let m2 = Map.of_alist_exn (module Int) [2, "two";1, "one"];;
&gt;val m2 : (int, string, Int.comparator_witness) Map.t = &lt;abstr&gt;
</code></pre>
</div>
<p>Logically, these two maps should be equal, and that’s the result that
you get if you call <code>Map.equal</code> on them:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Map.equal String.equal m1 m2;;
&gt;- : bool = true
</code></pre>
</div>
<p>But because the elements were added in different orders, the layout
of the trees underlying the maps will be different. As such, polymorphic
compare will conclude that they’re different.</p>
<p>We can see this below. Note that <code>Base</code> hides polymorphic
comparison by default, but it is available within the <code>Poly</code>
module. <a data-primary="Base.Poly" data-type="indexterm">&nbsp;</a></p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Poly.(m1 = m2);;
&gt;Exception: (Invalid_argument "compare: functional value")
</code></pre>
</div>
<p>This comparison failed because polymorphic compare doesn’t work on
functions, and maps store the comparison function they were created
with. Happily, there’s a function,
<code>Map.Using_comparator.to_tree</code> which exposes the underlying
binary tree without the attached comparison function. We can use that to
compare the underlying trees:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Poly.((Map.Using_comparator.to_tree m1) =
(Map.Using_comparator.to_tree m2));;
&gt;- : bool = false
</code></pre>
</div>
<p> As you can see, polymorphic compare now produces a result, but it’s
not the result we want.</p>
<p>The abstraction-breaking nature of polymorphic compare can cause real
and quite subtle bugs. If, for example, you build a map whose keys are
sets (which have the same issues with polymorphic compare that maps do),
then the map built with the polymorphic comparator will behave
incorrectly, separating out keys that should be aggregated together.
Even worse, it will behave inconsistently, since the behavior of
polymorphic compare will depend on the order in which the sets were
built.</p>
</section>
</section>
<section class="level3" id="satisfying-comparator.s-with-deriving">
<h3>Satisfying <code>Comparator.S</code> with
<code>[@@deriving]</code></h3>
<p>Using maps and sets on a new type requires satisfying the
<code>Comparator.S</code> interface, which in turn requires s-expression
converters and comparison functions for the type in question. Writing
such functions by hand is annoying and error prone, but there’s a better
way. <code>Base</code> comes along with a set of syntax extensions that
automate these tasks away.</p>
<p>Let’s return to an example from earlier in the chapter, where we
created a type <code>Book.t</code> and set it up for use in creating
maps and sets.</p>
<div class="highlight">
<pre><code class="language-ocaml">module Book = struct
  module T = struct

    type t = { title: string; isbn: string }

    let compare t1 t2 =
      let cmp_title = String.compare t1.title t2.title in
      if cmp_title &lt;&gt; 0 then cmp_title
      else String.compare t1.isbn t2.isbn

    let sexp_of_t t : Sexp.t =
      List [ Atom t.title; Atom t.isbn ]

  end
  include T
  include Comparator.Make(T)
end</code></pre>
</div>
<p>Much of the code here is devoted to creating a comparison function
and s-expression converter for the type <code>Book.t</code>. But if we
have the <code>ppx_sexp_conv</code> and <code>ppx_compare</code> syntax
extensions enabled, then we can request that default implementations of
these functions be created for us. We can enable both of these
extensions via the omnibus <code>ppx_jane</code> package. <a data-secondary="ppx_jane" data-primary="syntax extension" data-type="indexterm">&nbsp;</a> <a data-secondary="ppx_compare" data-primary="syntax
extension" data-type="indexterm">&nbsp;</a> <a data-secondary="ppx_sexp_conv" data-primary="syntax
extension" data-type="indexterm">&nbsp;</a> <a data-primary="ppx_jane" data-type="indexterm">&nbsp;</a> <a data-primary="ppx_compare" data-type="indexterm">&nbsp;</a> <a data-primary="ppx_sexp_conv" data-type="indexterm">&nbsp;</a></p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">#require "ppx_jane";;
</code></pre>
</div>
<p>And we can use the extensions in our definition of <code>Book</code>
as follows:</p>
<div class="highlight">
<pre><code class="language-ocaml">module Book = struct
  module T = struct
    type t = { title: string; isbn: string }
    [@@deriving compare, sexp_of]
  end
  include T
  include Comparator.Make(T)
end;;</code></pre>
</div>
<p>If you want a comparison function that orders things in a particular
way, you can always write your own by hand; but if all you need is a
total order suitable for creating maps and sets with, then
<code>[@@deriving compare]</code> is a good choice.</p>
<section data-type="note" class="level4" id="and-phys_equal">
<h4>=, ==, and phys_equal</h4>
<p>OCaml has multiple notions of equality, and picking the right one can
be tricky. If you don’t open <code>Base</code>, you’ll find that the
<code>==</code> operator tests for <em>physical</em> equality, while the
<code>=</code> operator is the polymorphic equality function.</p>
<p>Two values are considered physically equal if they are the same
pointer in memory. Two data structures that have identical contents but
are constructed separately will not be considered equal by
<code>==</code>. Polymorphic equality, on the other hand, is
<em>structural</em>, which effectively means that it considers values to
be equal if they have the same contents.</p>
<p>Most of the time you don’t want either of these forms of equality!
Polymorphic equality is problematic for reasons we explained earlier in
the chapter, and physical equality, while useful, is something that’s
needed in particular cases, most often when you’re dealing with mutable
objects, where the physical identity of the object matters.</p>
<p><code>Base</code> hides polymorphic equality, instead reserving
<code>=</code> for equality functions associated with particular types.
At the top-level <code>=</code> is specialized to integers.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">1 = 2;;
&gt;- : bool = false
"one" = "two";;
&gt;Line 1, characters 1-6:
&gt;Error: This expression has type string but an expression was expected of type
&gt;         int
</code></pre>
</div>
<p>Other type-specific equality functions are found in their associated
modules</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">String.("one" = "two");;
&gt;- : bool = false
</code></pre>
</div>
<p>It’s quite easy to mix up <code>=</code> and <code>==</code>, and so
<code>Base</code> deprecates <code>==</code> and provides
<code>phys_equal</code> instead, a function with a clear and descriptive
name.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">ref 1 == ref 1;;
&gt;Line 1, characters 7-9:
&gt;Alert deprecated: Base.==
&gt;[2016-09] this element comes from the stdlib distributed with OCaml.
&gt;Use [phys_equal] instead.
&gt;- : bool = false
phys_equal (ref 1) (ref 1);;
&gt;- : bool = false
</code></pre>
</div>
<p>This is just a small way in which <code>Base</code> tries to avoid
error-prone APIs.</p>
</section>
</section>
<section class="level3" id="applying-deriving-to-maps-and-sets">
<h3>Applying <code>[@@deriving]</code> to Maps and Sets</h3>
<p>In the previous section, we showed how to use
<code>[@@deriving]</code> annotations to set up a type so it could be
used to create a map or set type. But what if we want to put a
<code>[@@deriving]</code> annotation on a map or set type itself?</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">type string_int_map =
  (string,int,String.comparator_witness) Map.t [@@deriving sexp];;
&gt;Line 2, characters 44-49:
&gt;Error: Unbound value Map.t_of_sexp
&gt;Hint: Did you mean m__t_of_sexp?
</code></pre>
</div>
<p>This fails because there is no existing <code>Map.t_of_sexp</code>.
This isn’t a simple omission; there’s no reasonable way to define a
useful <code>Map.t_of_sexp</code>, because a comparator witness isn’t
something that can be parsed out of the s-expression.</p>
<p>Happily, there’s another way of writing the type of a map that does
work with the various <code>[@@deriving]</code> extensions, which you
can see below.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">type string_int_map = int Map.M(String).t [@@deriving sexp];;
&gt;type string_int_map = int Base.Map.M(Base.String).t
&gt;val string_int_map_of_sexp : Sexp.t -&gt; string_int_map = &lt;fun&gt;
&gt;val sexp_of_string_int_map : string_int_map -&gt; Sexp.t = &lt;fun&gt;
</code></pre>
</div>
<p>Here, we use a functor, <code>Map.M</code>, to define the type we
need. While this looks different than the ordinary type signature, the
meaning of the type is the same, as we can see below.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let m = Map.singleton (module String) "one" 1;;
&gt;val m : (string, int, String.comparator_witness) Map.t = &lt;abstr&gt;
(m : int Map.M(String).t);;
&gt;- : int Base.Map.M(Base.String).t = &lt;abstr&gt;
</code></pre>
</div>
<p>This same type works with other derivers as well, like those for
comparison and hash functions. Since this way of writing the type is
also shorter, it’s what you should use most of the time.</p>
</section>
<section class="level3" id="trees">
<h3>Trees</h3>
<p>As we’ve discussed, maps carry within them the comparator that they
were created with. Sometimes, for space efficiency reasons, you want a
version of the map data structure that doesn’t include the comparator.
You can get such a representation with
<code>Map.Using_comparator.to_tree</code>, which returns just the tree
underlying the map, without the comparator. <a data-primary="Map.to_tree" data-type="indexterm">&nbsp;</a><a data-secondary="tree
structure" data-primary="maps" data-type="indexterm">&nbsp;</a></p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let ord_tree = Map.Using_comparator.to_tree ord_map;;
&gt;val ord_tree :
&gt;  (string, int, String.comparator_witness) Map.Using_comparator.Tree.t =
&gt;  &lt;abstr&gt;
</code></pre>
</div>
<p>Even though the tree doesn’t physically include a comparator, it does
include the comparator in its type. This is what is known as a
<em>phantom type</em>, because it reflects something about the logic of
the value in question, even though it doesn’t correspond to any values
directly represented in the underlying physical structure of the
value.</p>
<p>Since the comparator isn’t included in the tree, we need to provide
the comparator explicitly when we, say, search for a key, as shown
below:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Map.Using_comparator.Tree.find ~comparator:String.comparator ord_tree "snoo";;
&gt;- : int option = Some 3
</code></pre>
</div>
<p>The algorithm of <code>Map.Tree.find</code> depends on the fact that
it’s using the same comparator when looking up a value as you were when
you stored it. That’s the invariant that the phantom type is there to
enforce. As you can see in the following example, using the wrong
comparator will lead to a type error:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Map.Using_comparator.Tree.find ~comparator:Reverse.comparator ord_tree "snoo";;
&gt;Line 1, characters 63-71:
&gt;Error: This expression has type
&gt;         (string, int, String.comparator_witness) Map.Using_comparator.Tree.t
&gt;       but an expression was expected of type
&gt;         (string, int, Reverse.comparator_witness)
&gt;         Map.Using_comparator.Tree.t
&gt;       Type String.comparator_witness is not compatible with type
&gt;         Reverse.comparator_witness
</code></pre>
</div>
</section>
</section>
<section class="level2" id="hash-tables">
<h2>Hash Tables</h2>
<p>Hash tables are the imperative cousin of maps. We walked through a
basic hash table implementation in <a data-type="xref" href="imperative-programming.html#imperative-programming-1">Chapter 8, Imperative Programming</a>, so in this section we’ll
mostly discuss the pragmatics of Core’s <code>Hashtbl</code> module.
We’ll cover this material more briefly than we did with maps because
many of the concepts are shared. <a data-secondary="basics
of" data-primary="hash tables" data-type="indexterm">&nbsp;</a></p>
<p>Hash tables differ from maps in a few key ways. First, hash tables
are mutable, meaning that adding a key/value pair to a hash table
modifies the table, rather than creating a new table with the binding
added. Second, hash tables generally have better time-complexity than
maps, providing constant-time lookup and modifications, as opposed to
logarithmic for maps. And finally, just as maps depend on having a
comparison function for creating the ordered binary tree that underlies
a map, hash tables depend on having a <em>hash function</em>, i.e., a
function for converting a key to an integer. <a data-secondary="hash functions" data-primary="functions" data-type="indexterm">&nbsp;</a><a data-primary="Hashtbl
module" data-type="indexterm">&nbsp;</a><a data-secondary="time complexity of" data-primary="hash tables" data-type="indexterm">&nbsp;</a></p>
<section data-type="warning" class="level3 allow_break" id="time-complexity-of-hash-tables">
<h3>Time Complexity of Hash Tables</h3>
<p>The statement that hash tables provide constant-time access hides
some complexities. First of all, most hash table implementations,
OCaml’s included, need to resize the table when it gets too full. A
resize requires allocating a new backing array for the hash table and
copying over all entries, and so it is quite an expensive operation.
That means adding a new element to the table is only <em>amortized</em>
constant, which is to say, it’s constant on average over a long sequence
of operations, but some of the individual operations can cost more.</p>
<p>Another hidden cost of hash tables has to do with the hash function
you use. If you end up with a pathologically bad hash function that
hashes all of your data to the same number, then all of your insertions
will hash to the same underlying bucket, meaning you no longer get
constant-time access at all. <code>Base</code>’s hash table
implementation uses binary trees for the hash-buckets, so this case only
leads to logarithmic time, rather than linear for a traditional
implementation.</p>
<p>The logarithmic behavior of Base’s hash tables in the presence of
hash collisions also helps protect against some denial-of-service
attacks. One well-known type of attack is to send queries to a service
with carefully chosen keys to cause many collisions. This, in
combination with the linear behavior of most hashtables, can cause the
service to become unresponsive due to high CPU load. Base’s hash tables
would be much less susceptible to such an attack because the amount of
degradation would be far less. <a data-secondary="denial-of-service attacks" data-primary="security
issues" data-type="indexterm">&nbsp;</a><a data-primary="denial-of-service attacks, avoiding" data-type="indexterm">&nbsp;</a></p>
</section>
<p>We create a hashtable in a way that’s similar to how we create maps,
by providing a first-class module from which the required operations for
building a hashtable can be obtained.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let table = Hashtbl.create (module String);;
&gt;val table : (string, '_weak1) Base.Hashtbl.t = &lt;abstr&gt;
Hashtbl.set table ~key:"three" ~data:3;;
&gt;- : unit = ()
Hashtbl.find table "three";;
&gt;- : int option = Some 3
</code></pre>
</div>
<p>As with maps, most modules in Base are ready to be used for this
purpose, but if you want to create a hash table from one of your own
types, you need to do some work to prepare it. In order for a module to
be suitable for passing to <code>Hashtbl.create</code>, it has to match
the following interface.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">#show Base.Hashtbl.Key.S;;
&gt;module type S =
&gt;  sig
&gt;    type t
&gt;    val compare : t -&gt; t -&gt; int
&gt;    val sexp_of_t : t -&gt; Sexp.t
&gt;    val hash : t -&gt; int
&gt;  end
</code></pre>
</div>
<p>Note that there’s no equivalent to the comparator witness that came
up for maps and sets. That’s because the requirement for multiple
objects to share a comparison function or a hash function mostly just
doesn’t come up for hash tables. That makes building a module suitable
for use with a hash table simpler.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">module Book = struct
  type t = { title: string; isbn: string }
  [@@deriving compare, sexp_of, hash]
end;;
&gt;module Book :
&gt;  sig
&gt;    type t = { title : string; isbn : string; }
&gt;    val compare : t -&gt; t -&gt; int
&gt;    val sexp_of_t : t -&gt; Sexp.t
&gt;    val hash_fold_t :
&gt;      Base_internalhash_types.state -&gt; t -&gt; Base_internalhash_types.state
&gt;    val hash : t -&gt; int
&gt;  end
let table = Hashtbl.create (module Book);;
&gt;val table : (Book.t, '_weak2) Base.Hashtbl.t = &lt;abstr&gt;
</code></pre>
</div>
<p>You can also create a hashtable based on OCaml’s polymorphic hash and
comparison functions.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let table = Hashtbl.Poly.create ();;
&gt;val table : ('_weak3, '_weak4) Base.Hashtbl.t = &lt;abstr&gt;
Hashtbl.set table ~key:("foo",3,[1;2;3]) ~data:"random data!";;
&gt;- : unit = ()
Hashtbl.find table ("foo",3,[1;2;3]);;
&gt;- : string option = Some "random data!"
</code></pre>
</div>
<p>This is highly convenient, but polymorphic comparison can behave in
surprising ways, so it’s generally best to avoid this for code where
correctness matters.</p>
<section data-type="warning" class="level3" id="collisions-with-the-polymorphic-hash-function">
<h3>Collisions with the Polymorphic Hash Function</h3>
<p>The polymorphic hash function, like polymorphic compare, has problems
that derive from the fact that it doesn’t pay any attention to the type,
just blindly walking down the structure of a data type and computing a
hash from what it sees. That means that for data structures like maps
and sets where equivalent instances can have different structures, it
will do the wrong thing.</p>
<p>But there’s another problem with polymorphic hash, which is that it
is prone to creating hash collisions. OCaml’s polymorphic hash function
works by walking over the data structure it’s given using a
breadth-first traversal that is bounded in the number of nodes it’s
willing to traverse. By default, that bound is set at 10 “meaningful”
nodes. <a data-secondary="polymorphic hash
function" data-primary="hash tables" data-type="indexterm">&nbsp;</a></p>
<p>The bound on the traversal means that the hash function may ignore
part of the data structure, and this can lead to pathological cases
where every value you store has the same hash value. We’ll demonstrate
this below, using the function <code>List.range</code> to allocate lists
of integers of different length:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Hashtbl.Poly.hashable.hash (List.range 0 9);;
&gt;- : int = 209331808
Hashtbl.Poly.hashable.hash (List.range 0 10);;
&gt;- : int = 182325193
Hashtbl.Poly.hashable.hash (List.range 0 11);;
&gt;- : int = 182325193
Hashtbl.Poly.hashable.hash (List.range 0 100);;
&gt;- : int = 182325193
</code></pre>
</div>
<p>As you can see, the hash function stops after the first 10 elements.
The same can happen with any large data structure, including records and
arrays. When building hash functions over large custom data structures,
it is generally a good idea to write one’s own hash function, or to use
the ones provided by <code>[@@deriving]</code>, which don’t have this
problem, as you can see below.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">[%hash: int list] (List.range 0 9);;
&gt;- : int = 999007935
[%hash: int list] (List.range 0 10);;
&gt;- : int = 195154657
[%hash: int list] (List.range 0 11);;
&gt;- : int = 527899773
[%hash: int list] (List.range 0 100);;
&gt;- : int = 594983280
</code></pre>
</div>
<p>Note that rather than declaring a type and using
<code>[@@deriving hash]</code> to invoke ppx_hash, we use
<code>[%hash]</code>, a shorthand for creating a hash function inline in
an expression.</p>
</section>
</section>
<section class="level2" id="choosing-between-maps-and-hash-tables">
<h2>Choosing Between Maps and Hash Tables</h2>
<p>Maps and hash tables overlap enough in functionality that it’s not
always clear when to choose one or the other. Maps, by virtue of being
immutable, are generally the default choice in OCaml. OCaml also has
good support for imperative programming, though, and when programming in
an imperative idiom, hash tables are often the more natural choice.
<a data-secondary="vs. hashtables" data-primary="maps" data-type="indexterm">&nbsp;</a><a data-secondary="vs.&nbsp;maps" data-primary="hash
tables" data-type="indexterm">&nbsp;</a></p>
<p>Programming idioms aside, there are significant performance
differences between maps and hash tables. For code that is dominated by
updates and lookups, hash tables are a clear performance win, and the
win is clearer the larger the amount of data.</p>
<p>The best way of answering a performance question is by running a
benchmark, so let’s do just that. The following benchmark uses the
<code>core_bench</code> library, and it compares maps and hash tables
under a very simple workload. Here, we’re keeping track of a set of
1,000 different integer keys and cycling over the keys and updating the
values they contain. Note that we use the <code>Map.change</code> and
<code>Hashtbl.change</code> functions to update the respective data
structures:</p>
<div class="highlight">
<pre><code class="language-ocaml">open Base
open Core_bench

let map_iter ~num_keys ~iterations =
  let rec loop i map =
    if i &lt;= 0
    then ()
    else
      loop
        (i - 1)
        (Map.change map (i % num_keys) ~f:(fun current -&gt;
             Some (1 + Option.value ~default:0 current)))
  in
  loop iterations (Map.empty (module Int))

let table_iter ~num_keys ~iterations =
  let table = Hashtbl.create (module Int) ~size:num_keys in
  let rec loop i =
    if i &lt;= 0
    then ()
    else (
      Hashtbl.change table (i % num_keys) ~f:(fun current -&gt;
          Some (1 + Option.value ~default:0 current));
      loop (i - 1))
  in
  loop iterations

let tests ~num_keys ~iterations =
  let t name f = Bench.Test.create f ~name in
  [ t "table" (fun () -&gt; table_iter ~num_keys ~iterations)
  ; t "map" (fun () -&gt; map_iter ~num_keys ~iterations)
  ]

let () =
  tests ~num_keys:1000 ~iterations:100_000
  |&gt; Bench.make_command
  |&gt; Core.Command.run</code></pre>
</div>
<p>The results show the hash table version to be around four times
faster than the map version:</p>
<div class="highlight">
<pre><code class="language-scheme">(executable
  (name      map_vs_hash)
  (libraries base core_bench))</code></pre>
</div>
<div class="highlight">
<pre data-filter-output=">" data-host="lama" data-user="fun" class="command-line"><code class="language-bash">dune build map_vs_hash.exe
./_build/default/map_vs_hash.exe -ascii -quota 1 -clear-columns time speedup
&gt;Estimated testing time 2s (2 benchmarks x 1s). Change using -quota SECS.
&gt;
&gt;  Name    Time/Run   Speedup
&gt; ------- ---------- ---------
&gt;  table    13.34ms      1.00
&gt;  map      44.54ms      3.34
</code></pre>
</div>
<p>We can make the speedup smaller or larger depending on the details of
the test; for example, it will vary with the number of distinct keys.
But overall, for code that is heavy on sequences of querying and
updating a set of key/value pairs, hash tables will significantly
outperform maps.</p>
<p>Hash tables are not always the faster choice, though. In particular,
maps excel in situations where you need to keep multiple related
versions of the data structure in memory at once. That’s because maps
are immutable, and so operations like <code>Map.add</code> that modify a
map do so by creating a new map, leaving the original undisturbed.
Moreover, the new and old maps share most of their physical structure,
so keeping multiple versions around can be space-efficient.</p>
<p>Here’s a benchmark that demonstrates this. In it, we create a list of
maps (or hash tables) that are built up by iteratively applying small
updates, keeping these copies around. In the map case, this is done by
using <code>Map.change</code> to update the map. In the hash table
implementation, the updates are done using <code>Hashtbl.change</code>,
but we also need to call <code>Hashtbl.copy</code> to take snapshots of
the table:</p>
<div class="highlight">
<pre><code class="language-ocaml">open Base
open Core_bench

let create_maps ~num_keys ~iterations =
  let rec loop i map =
    if i &lt;= 0
    then []
    else (
      let new_map =
        Map.change map (i % num_keys) ~f:(fun current -&gt;
            Some (1 + Option.value ~default:0 current))
      in
      new_map :: loop (i - 1) new_map)
  in
  loop iterations (Map.empty (module Int))

let create_tables ~num_keys ~iterations =
  let table = Hashtbl.create (module Int) ~size:num_keys in
  let rec loop i =
    if i &lt;= 0
    then []
    else (
      Hashtbl.change table (i % num_keys) ~f:(fun current -&gt;
          Some (1 + Option.value ~default:0 current));
      let new_table = Hashtbl.copy table in
      new_table :: loop (i - 1))
  in
  loop iterations

let tests ~num_keys ~iterations =
  let t name f = Bench.Test.create f ~name in
  [ t "table" (fun () -&gt; ignore (create_tables ~num_keys ~iterations))
  ; t "map" (fun () -&gt; ignore (create_maps ~num_keys ~iterations))
  ]

let () =
  tests ~num_keys:50 ~iterations:1000
  |&gt; Bench.make_command
  |&gt; Core.Command.run</code></pre>
</div>
<p>Unsurprisingly, maps perform far better than hash tables on this
benchmark, in this case by more than a factor of 10:</p>
<div class="highlight">
<pre><code class="language-scheme">(executable
  (name      map_vs_hash2)
  (libraries core_bench))</code></pre>
</div>
<div class="highlight">
<pre data-filter-output=">" data-host="lama" data-user="fun" class="command-line"><code class="language-bash">dune build map_vs_hash2.exe
./_build/default/map_vs_hash2.exe -ascii -clear-columns time speedup
&gt;Estimated testing time 20s (2 benchmarks x 10s). Change using -quota SECS.
&gt;
&gt;  Name      Time/Run   Speedup
&gt; ------- ------------ ---------
&gt;  table   4_453.95us     25.80
&gt;  map       172.61us      1.00
</code></pre>
</div>
<p>These numbers can be made more extreme by increasing the size of the
tables or the length of the list.</p>
<p>As you can see, the relative performance of trees and maps depends a
great deal on the details of how they’re used, and so whether to choose
one data structure or the other will depend on the details of the
application. <a data-primary="phys_equal function" data-type="indexterm">&nbsp;</a><a data-primary="equal equal (= =) operator" data-type="indexterm">&nbsp;</a><a data-primary="equal (=)
operator" data-type="indexterm">&nbsp;</a><a data-primary="structural equality" data-type="indexterm">&nbsp;</a><a data-primary="physical equality" data-type="indexterm">&nbsp;</a><a data-primary="equality, tests
of" data-type="indexterm">&nbsp;</a></p>
</section>
</section>
</article></div><a href="command-line-parsing.html" class="next-chapter"><div class="content"><h1><small>Next: Chapter 15</small>Command-Line Parsing</h1></div></a><footer><div class="content"><ul><li><a href="http://twitter.com/realworldocaml">@realworldocaml</a></li><li><a href="http://twitter.com/yminsky">@yminsky</a></li><li><a href="http://twitter.com/avsm">@avsm</a></li><li><a href="https://github.com/realworldocaml">GitHub</a></li><li><a href="http://www.goodreads.com/book/show/16087552-real-world-ocaml">goodreads</a></li></ul><p>Copyright 2012-2022 Anil Madhavapeddy and Yaron Minsky.</p></div></footer><script src="js/jquery.min.js"></script><script src="js/min/app-min.js"></script></body></html>