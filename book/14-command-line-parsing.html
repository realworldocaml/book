<section id="command-line-parsing" data-type="chapter">
  <h1>Command-Line Parsing</h1>

  <p>
    Many of the OCaml programs that you'll write will end up as
    binaries that need to be run from a command prompt. Any
    nontrivial command line should support a collection of basic
    features:</p>

  <ul><li><p>
	Parsing of command-line arguments</p></li>

    <li> <p>
	Generation of error messages in response to incorrect
        inputs</p></li>

    <li> <p>
	Help for all the available options </p> </li>

    <li> <p>
	Interactive autocompletion</p> </li>
  </ul>

  <p>
    It's tedious and error-prone to code all of this manually for
    every program you write. Core provides the Command library,
    which simplifies all of this by letting you declare your
    command-line options in one place and by deriving all of the
    above functionality from these declarations.

    <idx>command-line parsing/Command library for</idx></p>

  <p>
    Command is simple to use for simple applications but also
    scales well as your needs grow more complex. In particular,
    Command provides a sophisticated subcommand mode that groups
    related commands together as the complexity of your user
    interface grows. You may already be familiar with this
    command-line style from the Git or Mercurial version control
    systems.</p>

  <p>
    In this chapter, we'll:</p>

  <ul>
    <li> <p>
	Learn how to use Command to construct basic and grouped
        command-line interfaces</p> </li>

    <li> <p>
	We will build simple equivalents to the cryptographic
        <code>md5</code> and <code>shasum</code> utilities</p> </li>

    <li> <p>
	Demonstrate how to declare complex command-line interfaces
	in a type-safe and elegant way

	<idx>combinators/functional combinators</idx></p> </li>
  </ul>

  <section id="basic-command-line-parsing" data-type="sect1">
    <h1>Basic Command-Line Parsing</h1>

    <p>
      Let's start by working through a clone of the
      <code>md5sum</code> command that is present on most Linux
      installations (the equivalent command on Mac OS X is simply
      <code>md5</code>). The following function defined below reads
      in the contents of a file, applies the MD5 one-way
      cryptographic hash function to the data, and outputs an ASCII
      hex representation of the result:

      <idx>MD5 one-way cryptographic hash function</idx>
      <idx>command-line parsing/basic approach to</idx></p>

    <link rel="import" href="code/command-line-parsing/basic_md5/md5.ml"/>

    <p>
      The <code>do_hash</code> function accepts
      a <code>filename</code> parameter and prints the
      human-readable MD5 string to the console standard
      output. The first step toward turning this function into a
      command-line program is to create a parser for the command
      line arguments.  The module <code>Command.Param</code>
      provides a set of combinators that can be combined together
      to define a parameter parser for optional flags and
      positional arguments, including documentation, the types
      they should map to, and whether to take special actions such
      as pausing for interactive input if certain inputs are
      encountered.</p>

    <section id="anonymous-arguments" data-type="sect2">
      <h2>Defining an anonymous argument</h2>

      <p>
	Let's build a parser for a command line UI with a
	single <em>anonymous</em> argument, i.e., an argument that
	is passed in without a flag.</p>

      <link rel="import" part="1"
	    href="code/command-line-parsing/basic_md5/md5.ml" />

      <p>
	Here, <code>anon</code> is used to signal the parsing of
	an anonymous argument, and the expression <code>("filename"
	  %: string)</code> indicates the textual name of the argument
	and specification that describes the kind of value that is
	expected. The textual name is used for generating help text,
	and the specification is used both to nail down the OCaml type
	of the returned value (<code>string</code>, in this case) and
	to guide features like input validation. The
	values <code>anon</code>, <code>string</code>
	and <code>%:</code> all come from
	the <code>Command.Param</code> module.</p>

    </section>

    <section id="defining-basic-commands" data-type="sect2">
      <h2>Defining basic commands</h2>

      <p>
	Once we've defined a specification, we need to put it to
        work on real input. The simplest way is to directly create
        a command-line interface with <code>Command.basic</code>.

	<idx>Command.basic</idx></p>

      <link rel="import" href="code/command-line-parsing/basic_md5/md5.ml" part="2"/>

      <p>
	The <code>summary</code> argument is a one-line
	description which goes at the top of the help screen,
	while the (optional) <code>readme</code> argument is for
	providing a more detailed description that will be
	provided on demand.</p>

      <p>
	The final argument is the most interesting one, which is
	the parameter parser. This will be easier to understand if
	we first learn a bit more about the type signatures of the
	various components we've been using. Let's do that by
	recreating some of this code in the toplevel.</p>

      <link rel="import" part="1"
	    href="code/command-line-parsing/command_types.mlt"/>

      <p>
	The type parameter of <code>filename_param</code> is there
	to indicate the type of the value returned by the parser;
	in this case, <code>string</code>. </p>

      <p>
	But <code>Command.basic</code> requires a parameter parser
	that returns a value of type <code>unit -> unit</code>. We
	can see that by using <code>#show</code> to explore the
	types.</p>

      <link rel="import" part="2"
	    href="code/command-line-parsing/command_types.mlt"/>

      <p>
	Note that the <code>'result</code> parameter of the type alias
	<code>basic_command</code> is instantiated
	as <code>unit</code> for the type of <code>Command.basic</code>.</p>

      <p>
	It makes sense that <code>Command.basic</code> wants a
	parser that returns a function; after all, in the end, it
	needs a function it can run that constitutes the execution
	of the program. But how do we get such a parser, given the
	parser we have returns just a filename? </p>

      <p>
	The answer is to use a <code>map</code> function to
	change the value returned by the parser. As you can see below,
	the type of <code>Command.Param.map</code> is very similar to
	the code of <code>List.map</code>.
      </p>

      <link rel="import" part="3"
	    href="code/command-line-parsing/command_types.mlt"/>

      <p>
	And that's exactly what we did in our invocation
	of <code>Command.basic</code> earlier, converting
	the <code>filename_param</code>, which returns a string
	representing the file name, into a parser that returns a
	function of type <code>unit -> unit</code>, which holds the
	code that will be run when the command executes.</p>

    </section>

    <section id="running-basic-commands" data-type="sect2">
      <h2>Running commands</h2>

      <p>
	Once we've defined the basic command, running it is just
        one function call away.</p>

      <link rel="import" part="3"
	    href="code/command-line-parsing/basic_md5/md5.ml" />

      <p>
	<code>Command.run</code> takes a couple of optional
        arguments that are useful to identify which version of the
        binary you are running in production. You'll need to
        install Cryptokit via <code>opam install cryptokit</code>
        before building this example. Once that's completed, run
        the following to compile the binary.</p>

      <link rel="import"
	    href="code/command-line-parsing/basic_md5/jbuild"/>
      <link rel="import" part="build"
	    href="code/command-line-parsing/basic_md5/md5.sh" />

      <p>
	You can now query the version information for the binary
        you just compiled:</p>

      <link rel="import" part="get version"
	    href="code/command-line-parsing/basic_md5/md5.sh" />

      <p>
	The versions that you see in the output were defined via
        the optional arguments to <code>Command.run</code>. You can
        leave these blank in your own programs or get your build
        system to generate them directly from your version control
        system (e.g., by running <code>hg id</code> to generate a
        build revision number, in the case of Mercurial).</p>

      <p>
	When we invoke our binary with <code>-help</code> as an
	argument, it helpfully displays all of the command-line
	options available, along with a message to the standard error
	that informs you that a required
	argument <code>filename</code> is missing.</p>

      <link rel="import" part="get help"
	    href="code/command-line-parsing/basic_md5/md5.sh" />

      <p>
	If you do supply the <code>filename</code> argument,
        then <code>do_hash</code> is called with the argument and
        the MD5 output is displayed to the standard output:</p>

      <link rel="import" part="run"
	    href="code/command-line-parsing/basic_md5/md5.sh"/>

      <p>
	And that's all it took to build our little MD5 utility!
        Here's a complete version of the example we just walked
        through, made slightly more succinct by removing
        intermediate variables.</p>

      <link rel="import"
	    href="code/command-line-parsing/basic_md5_succinct/md5.ml"/>
      <p>
	Now that we have the basics in place, the rest of the
        chapter will examine some of the more advanced features of
        Command.</p>
    </section>

    <section id="multiple-arguments" data-type="sect2">
      <h2>Multi-argument commands</h2>

      <p>
	All of the examples thus far have involved single argument
	commands. We can create parsers that take multiple arguments
	by binding together simpler parsers, using the
	function <code>Command.Param.both</code>. Here is its
	type.</p>

      <link rel="import" part="4"
	    href="code/command-line-parsing/command_types.mlt"/>

      <p>
	<code>both</code> allows us to take two parameter parsers and
	combine them into a single parser that returns the two
	arguments as a pair. In the following, we rewrite
	our <code>md5</code> program so it takes two anonymous
	arguments: the first is an integer saying how many characters
	of the hash to print out, and the second is the filename.</p>

      <link rel="import"
	    href="code/command-line-parsing/basic_md5_multiarg/md5.ml" />

      <p>
	Building and running this command, we can see that it now
	indeed expects two arguments.</p>

      <link rel="import"
	    href="code/command-line-parsing/basic_md5_multiarg/md5.sh" />

      <p>
	This works well enough for two parameters, but if you want
	longer parameter lists, this approach gets old fast. A better
	way is to use let-syntax, which was discussed
	in <a href="07-error-handling.html#bind-and-other-error-handling-idioms"
	data-type="xref">Error Handling</a>.</p>

      <link rel="import" part="1"
	    href="code/command-line-parsing/basic_md5_let_syntax/md5.ml" />

      <p>
	Here, we take advantage of let-syntax's support for parallel
	let bindings, using <code>and</code> to join the definitions
	together. This syntax translates down to the same pattern
	based on <code>both</code> that we showed above, but it's
	easier to read and use, and scales better to more
	arguments. <p>

      <p>
	The need to open both modules is a little awkward, and
	the <code>Param</code> module in particular you really only
	need on the right-hand-side of the equals-sign. This is
	achieved automatically by using the <code>let%map_open</code>
	syntax, demonstrated below.</p>

      <link rel="import" part="1"
	    href="code/command-line-parsing/basic_md5_let_syntax2/md5.ml"
	    />

      <p>
	Let-syntax is the most common way of writing parsers
	for <code>Command</code>, and we'll use that idiom for the
	remainder of the chapter. </p>

      </section>
  </section>

  <section id="argument-types" data-type="sect1">
    <h1>Argument Types</h1>

    <p>
      You aren't just limited to parsing command lines of strings and
      ints. <code>Command.Param</code> defines several other
      conversion functions (shown
      in <a href="14-command-line-parsing.html#table14_1"
      data-type="xref">Table14_1</a>) that validate and parse input
      into various types.

      <idx>arguments/argument types</idx>
      <idx>command-line parsing/argument types</idx></p>

    <table id="table14_1">
      <caption>
        Conversion functions defined in <code>Command.Param</code>
      </caption>

      <thead>
        <tr>
          <th>Argument type</th>
          <th>OCaml type</th>
          <th>Example</th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td><code>string</code></td>
          <td><code>string</code></td>
          <td><code>foo</code></td>
        </tr>

        <tr>
          <td><code>int</code></td>
          <td><code>int</code></td>
          <td><code>123</code></td>
        </tr>

        <tr>
          <td><code>float</code></td>
          <td><code>float</code></td>
          <td><code>123.01</code></td>
        </tr>

        <tr>
          <td><code>bool</code></td>
          <td><code>bool</code></td>
          <td><code>true</code></td>
        </tr>

        <tr>
          <td><code>date</code></td>
          <td><code>Date.t</code></td>
          <td><code>2013-12-25</code></td>
        </tr>

        <tr>
          <td><code>time_span</code></td>
          <td><code>Span.t</code></td>
          <td><code>5s</code></td>
        </tr>

        <tr>
          <td><code>file</code></td>
          <td><code>string</code></td>
          <td><code>/etc/passwd</code></td>
        </tr>
      </tbody>
    </table>

    <p>
      We can tighten up the specification of the command
      to <code>file</code> to reflect that the argument must be a
      valid filename, and not just any string.</p>

      <link rel="import" part="1"
	    href="code/command-line-parsing/basic_md5_as_filename/md5.ml" />

    <p>
      This doesn't change the validation of the provided value, but it
      does enable interactive command-line completion. We'll explain
      how to enable that later in the chapter.</p>

j    <section id="defining-custom-argument-types" data-type="sect2">
      <h2>Defining Custom Argument Types</h2>

      <p>
	We can also define our own argument types if the
        predefined ones aren't sufficient. For instance, let's make
        a <code>regular_file</code> argument type that ensures that
        the input file isn't a character device or some other odd
        UNIX file type that can't be fully read.

	<idx>arguments/defining custom types</idx></p>

      <link rel="import"
	    href="code/command-line-parsing/basic_md5_with_custom_arg/md5.ml"/>

      <p>
	The <code>regular_file</code> function transforms a
        <code>filename</code> string parameter into the same string
        but first checks that the file exists and is a regular file
        type. When you build and run this code, you will see the
        new error messages if you try to open a special device such
        as <code>/dev/null</code>:</p>

      <link rel="import" href="code/command-line-parsing/basic_md5_with_custom_arg/run.errsh"/>
    </section>

    <section id="optional-and-default-arguments" data-type="sect2">
      <h2>Optional and Default Arguments</h2>

      <p>
	A more realistic MD5 binary could also read from the
        standard input if a <code>filename</code> isn't
        specified:

	<idx>arguments/default arguments</idx>
	<idx>default arguments</idx>
	<idx>optional arguments/and default arguments</idx>
	<idx>arguments/optional arguments</idx></p>

      <link rel="import" href="code/command-line-parsing/basic_md5_with_optional_file_broken/basic_md5_with_optional_file_broken.ml" part="1"/>

      <p>
	This just wraps the <code>filename</code> argument
        declaration in the <code>maybe</code> function to mark it
        as an optional argument. However, building this results in
        a compile-time error:</p>
      <link rel="import" href="code/command-line-parsing/basic_md5_with_optional_file_broken/jbuild"/>
      <link rel="import" href="code/command-line-parsing/basic_md5_with_optional_file_broken/build_basic_md5_with_optional_file_broken.errsh"/>

      <p>
	This is because changing the argument type has also
        changed the type of the callback function. It now wants a
        <code>string option</code> instead of a
        <code>string</code>, since the value has become optional.
        We can adapt our example to use the new information and
        read from standard input if no file is specified:</p>

      <link rel="import" href="code/command-line-parsing/basic_md5_with_optional_file/basic_md5_with_optional_file.ml"/>

      <p>
	The <code>filename</code> parameter to
        <code>do_hash</code> is now a <code>string option</code>
        type. This is resolved into an input channel via
        <code>get_inchan</code> to determine whether to open the
        standard input or a file, and then the rest of the command
        is similar to our previous examples.</p>

      <p>
	Another possible way to handle this would be to supply a
        dash as the default filename if one isn't specified. The
        <code>maybe_with_default</code> function can do just this,
        with the benefit of not having to change the callback
        parameter type (which may be a problem in more complex
        applications).</p>

      <p>
	The following example behaves exactly the same as the
        previous example, but replaces <code>maybe</code> with
        <code>maybe_with_default</code>:</p>

      <link rel="import" href="code/command-line-parsing/basic_md5_with_optional_file/basic_md5_with_default_file.ml"/>

      <p>
	Building and running both against a system file confirms
        that they have the same behavior:</p>

      <link rel="import" href="code/command-line-parsing/basic_md5_with_optional_file/jbuild"/>
      <link rel="import" href="code/command-line-parsing/basic_md5_with_optional_file/basic_and_default_md5.sh" part="build"/>
      <link rel="import" href="code/command-line-parsing/basic_md5_with_optional_file/basic_and_default_md5.sh" part="run"/>
    </section>

    <section id="sequences-of-arguments" data-type="sect2">
      <h2>Sequences of Arguments</h2>

      <p>
	One last transformation that's useful is to obtain lists
        of anonymous arguments rather than a single one. As an
        example, let's modify our MD5 code to take a collection of
        files to process on the command line:

	<idx>arguments/sequences of</idx></p>

      <link rel="import" href="code/command-line-parsing/basic_md5_sequence.ml"/>

      <p>
	The callback function is a little more complex now, to
        handle the extra options. The <code>files</code> are now a
        <code>string list</code>, and an empty list reverts to
        using standard input, just as our previous
        <code>maybe</code> and <code>maybe_with_default</code>
        examples did. If the list of files isn't empty, then it
        opens up each file and runs them through
        <code>do_hash</code> sequentially.</p>
    </section>
  </section>

  <section id="adding-labeled-flags-to-the-command-line" data-type="sect1">
    <h1>Adding Labeled Flags to the Command Line</h1>

    <p>
      You aren't just limited to anonymous arguments on the
      command line. A <em>flag</em> is a named field that can be
      followed by an optional argument. These flags can appear in
      any order on the command line, or multiple times, depending
      on how they're declared in the specification.

      <idx>flags</idx>
      <idx>command-line parsing/labeled flags and</idx></p>

    <p>
      Let's add two arguments to our <code>md5</code> command
      that mimics the Mac OS X version. A <code>-s</code> flag
      specifies the string to be hashed directly on the command
      line and <code>-t</code> runs a self-test. The complete
      example follows:</p>

    TODO: build_basic_md5_with_flags.sh
    <link rel="import" href="code/command-line-parsing/basic_md5_with_flags/jbuild"/>
    <link rel="import" href="code/command-line-parsing/basic_md5_with_flags/basic_md5_with_flags.sh" part="build"/>
    <link rel="import" href="code/command-line-parsing/basic_md5_with_flags/basic_md5_with_flags.ml"/>

    <p>
      The specification now uses the <code>flag</code> function
      to define the two new labeled, command-line arguments. The
      <code>doc</code> string is formatted so that the first word
      is the short name that appears in the usage text, with the
      remainder being the full help text. Notice that the
      <code>-t</code> flag has no argument, and so we prepend its
      <code>doc</code> text with a blank space. The help text for
      the preceding code looks like this:</p>

    <link rel="import" href="code/command-line-parsing/basic_md5_with_flags/basic_md5_with_flags.sh" part="run"/>

    <p>
      The <code>-s</code> flag in our specification requires a
      <code>string</code> argument and isn't optional. The Command
      parser outputs an error message if the flag isn't supplied,
      as with the anonymous arguments in earlier examples. <a href="14-command-line-parsing.html#table14-2" data-type="xref">Table14 2</a> contains a list of some of the functions
      that you can wrap flags in to control how they are
      parsed.

      <idx>flag functions</idx></p>

    <table id="table14-2">
      <caption>
        Flag functions
      </caption>

      <thead>
        <tr>
          <th>Flag function</th>

          <th>OCaml type</th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td><code>required</code> <em>arg</em></td>

          <td><em>arg</em> and error if not present</td>
        </tr>

        <tr>
          <td><code>optional</code> <em>arg</em></td>

          <td><em>arg</em> <code>option</code></td>
        </tr>

        <tr>
          <td><code>optional_with_default</code> <em>val</em>
	    <em>arg</em></td>

          <td><em>arg</em> with default <em>val</em> if not
	    present</td>
        </tr>

        <tr>
          <td><code>listed</code> <em>arg</em></td>

          <td><em>arg</em> <code>list</code>, flag may appear
	    multiple times</td>
        </tr>

        <tr>
          <td><code>no_arg</code></td>

          <td><code>bool</code> that is true if flag is
	    present</td>
        </tr>
      </tbody>
    </table>

    <p>
      The flags affect the type of the callback function in
      exactly the same way as anonymous arguments do. This lets you
      change the specification and ensure that all the callback
      functions are updated appropriately, without runtime
      errors.</p>
  </section>

  <section id="grouping-sub-commands-together" data-type="sect1">
    <h1>Grouping Subcommands Together</h1>

    <p>
      You can get pretty far by using flags and anonymous
      arguments to assemble complex, command-line interfaces. After
      a while, though, too many options can make the program very
      confusing for newcomers to your application. One way to solve
      this is by grouping common operations together and adding
      some hierarchy to the command-line interface.

      <idx>subcommands, grouping of</idx>
      <idx>OPAM package manager</idx>
      <idx>command-line parsing/subcommand grouping</idx></p>

    <p>
      You'll have run across this style already when using the
      OPAM package manager (or, in the non-OCaml world, the Git or
      Mercurial commands). OPAM exposes commands in this form:</p>

    <link rel="import" href="code/command-line-parsing/opam.rawsh"/>

    <p>
      The <code>config</code>, <code>remote</code>, and
      <code>install</code> keywords form a logical grouping of
      commands that factor out a set of flags and arguments. This
      lets you prevent flags that are specific to a particular
      subcommand from leaking into the general configuration
      space.

      <idx>install keyword</idx>
      <idx>remote keyword</idx></p>

    <p>
      This usually only becomes a concern when your application
      organically grows features. Luckily, it's simple to extend
      your application to do this in Command: just swap the
      <code>Command.basic</code> for <code>Command.group</code>,
      which takes an association list of specifications and handles
      the subcommand parsing and help output for you:

      <idx>Command.group</idx></p>

    <link rel="import" href="code/command-line-parsing/group.mlt" part="1"/>

    <p>
      The <code>group</code> signature accepts a list of basic
      <code>Command.t</code> values and their corresponding names.
      When executed, it looks for the appropriate subcommand from
      the name list, and dispatches it to the right command
      handler.</p>

    <p>
      Let's build the outline of a calendar tool that does a few
      operations over dates from the command line. We first need to
      define a command that adds days to an input date and prints
      the resulting date:</p>

    <link rel="import" href="code/command-line-parsing/cal_add_days.ml"/>

    <p>
      Everything in this command should be familiar to you by
      now. Once you've tested it and made sure it works, we can
      define another new command that takes the difference of two
      dates. However, instead of creating a new binary, we group
      both operations as subcommands using
      <code>Command.group</code>:</p>

    <link rel="import" href="code/command-line-parsing/cal_add_sub_days/cal_add_sub_days.ml"/>

    <p>
      And that's all you really need to add subcommand support!
      Let's build the example first in the usual way and inspect
      the help output, which now reflects the subcommands we just
      added.</p>
    <link rel="import" href="code/command-line-parsing/cal_add_sub_days/jbuild"/>
    <link rel="import" href="code/command-line-parsing/cal_add_sub_days/cal_add_sub_days.sh" part="build"/>

    <p>
      We can invoke the two commands we just defined to verify
      that they work and see the date parsing in action:</p>

    <link rel="import" href="code/command-line-parsing/cal_add_sub_days/cal_add_sub_days.sh" part="run"/>
  </section>

  <section id="advanced-control-over-parsing" data-type="sect1">
    <h1>Advanced Control over Parsing</h1>

    <p>
      The functions for generating a specification may seem like
      magic. In particular, even if you know how to use them, it's
      not entirely clear how they work, and in particular, why the
      types work out the way they do.

      <idx id="CLPadv">command-line parsing/advanced control over</idx></p>

    <p>
      Understanding the details of how these specifications fit
      together becomes more useful as your command-line interfaces
      get more complex. In particular, you may want to factor out
      common functionality between specifications or interrupt the
      parsing to perform special processing, such as requesting an
      interactive passphrase from the user before proceeding. All
      of this is helped by a deeper understanding of the Command
      library.</p>

    <p>
      In the following sections we'll explain the logic behind
      the combinators we've already described and show you some new
      combinators that let you use Command even more
      effectively.</p>

    <section id="the-types-behind-command.spec" data-type="sect2">
      <h2>The Types Behind Command.Spec</h2>

      <p>
	The Command module's safety relies on the
        specification's output values precisely matching the
        callback function which invokes the main program. In order
        to prevent any such mismatches, Command uses some
        interesting type machinery to guarantee they remain in
        sync. You don't have to understand this section to use the
        more advanced combinators, but it'll help you debug type
        errors as you use Command more.

	<idx>callback function</idx>
	<idx>debugging/Command mode</idx>
	<idx>Command module</idx></p>

      <p>
	The <code>Command.Spec.t</code> type looks deceptively
        simple: <code>('a, 'b) t</code>. You can think of
        <code>('a, 'b) t</code> here as a function of type <code>'a
          -&gt; 'b</code>, but embellished with information
        about:</p>

      <ul>
        <li>
          <p>
	    How to parse the command line</p>
        </li>

        <li>
          <p>
	    What the command does and how to call it</p>
        </li>

        <li>
          <p>
	    How to autocomplete a partial command line</p>
        </li>
      </ul>

      <p>
	The type of a specification transforms a <code>'a</code>
        to a <code>'b</code> value. For instance, a value of
        <code>Spec.t</code> might have type <code>(arg1 -&gt; ...
          -&gt; argN -&gt; 'r, 'r) Spec.t</code>.</p>

      <p>
	Such a value transforms a main function of type
        <code>arg1 -&gt; ... -&gt; argN -&gt; 'r</code> by
        supplying all the argument values, leaving a main function
        that returns a value of type <code>'r</code>. Let's look at
        some examples of specs, and their types:</p>

      <link rel="import" href="code/command-line-parsing/command_types.mlt" part="1"/>

      <p>
	The empty specification is simple, as it doesn't add any
        parameters to the callback type. The second example adds an
        <code>int</code> anonymous parameter that is reflected in
        the inferred type. One forms a command by combining a spec
        of type <code>('main, unit) Spec.t</code> with a function
        of type <code>'main</code>. The combinators we've shown so
        far incrementally build the type of <code>'main</code>
        according to the command-line parameters it expects, so the
        resulting type of <code>'main</code> is something like
        <code>arg1 -&gt; ... -&gt; argN -&gt; unit</code>.</p>

      <p>
	The type of <code>Command.basic</code> should make more
        sense now:</p>

      <link rel="import" href="code/command-line-parsing/basic.mlt" part="1"/>

      <p>
	The parameters to <code>Spec.t</code> are important
        here. They show that the callback function for a spec
        should consume identical arguments to the supplied
        <code>main</code> function, except for an additional
        <code>unit</code> argument. This final <code>unit</code> is
        there to make sure the callback is evaluated as a function,
        since if zero command-line arguments are specified (i.e.,
        <span class="keep-together"><code>Spec.empty</code></span>), the
        callback would otherwise have no arguments and be evaluated
        immediately. That's why you have to supply an additional
        <code>()</code> to the callback function in all the
        previous examples.</p>
    </section>

    <section id="composing-specification-fragments-together" data-type="sect2">
      <h2>Composing Specification Fragments Together</h2>

      <p>
	If you want to factor out common command-line
        operations, the <code>++</code> operator will append two
        specifications together. Let's add some dummy verbosity and
        debug flags to our calendar application to illustrate
        this.</p>

      <link rel="import" href="code/command-line-parsing/cal_append.ml"/>

      <p>
	The definitions of the specifications are very similar
        to the earlier example, except that they append a
        <code>common</code> parameter after each specification. We
        can supply these flags when defining the groups.</p>

      <link rel="import" href="code/command-line-parsing/cal_append.ml" part="1"/>

      <p>
	Both of these flags will now be applied and passed to
        all the callback functions. This makes code refactoring a
        breeze by using the compiler to spot places where you use
        commands. Just add a parameter to the common definition,
        run the compiler, and fix type errors until everything
        works again.

	<idx>refactoring</idx></p>

      <p>
	For example, if we remove the <code>verbose</code> flag
        and recompile, we'll get this impressively long type
        error:</p>
      <link rel="import" href="code/command-line-parsing/cal_append_broken/jbuild"/>
      <link rel="import" href="code/command-line-parsing/cal_append_broken/build_cal_append_broken.errsh"/>

      <p>
	While this does look scary, the key line to scan is the
        last one, where it's telling you that you have supplied too
        many arguments in the callback function (<code>unit -&gt;
          unit</code> versus <code>unit</code>). If you started with
        a working program and made this single change, you
        typically don't even need to read the type error, as the
        filename and location information is sufficient to make the
        obvious fix.</p>
    </section>

    <section id="prompting-for-interactive-input" data-type="sect2">
      <h2>Prompting for Interactive Input</h2>

      <p>
	The <code>step</code> combinator lets you control the
        normal course of parsing by supplying a function that maps
        callback arguments to a new set of values. For instance,
        let's revisit our first calendar application that added a
        number of days onto a supplied base date:

	<idx>interactive input/prompts for</idx></p>

      <link rel="import" href="code/command-line-parsing/cal_add_days.ml"/>

      <p>
	This program requires you to specify both the
        <code>base</code> date and the number of <code>days</code>
        to add onto it. If <code>days</code> isn't supplied on the
        command line, an error is output. Now let's modify it to
        interactively prompt for a number of days if only the
        <code>base</code> date is supplied:</p>

      <link rel="import" href="code/command-line-parsing/cal_add_interactive/cal_add_interactive.ml"/>

      <p>
	The <code>days</code> anonymous argument is now an
        optional integer in the spec, and we want to transform it
        into a nonoptional value before calling our
        <code>add_days</code> callback. The <code>step</code>
        combinator lets us perform this transformation by applying
        its supplied callback function first. In the example, the
        callback first checks if <code>days</code> is defined. If
        it's undefined, then it interactively reads an integer from
        the standard input.</p>

      <p>
	The first <code>m</code> argument to the
        <code>step</code> callback is the next callback function in
        the chain. The transformation is completed by calling
        <code>m base days</code> to continue processing with the
        new values we've just calculated. The <code>days</code>
        value that is passed onto the next callback now has a
        nonoptional <code>int</code> type:</p>

      <link rel="import" href="code/command-line-parsing/cal_add_interactive/build_and_run_cal_add_interactive.sh"/>

      <p>
	The transformation means that the <code>add_days</code>
        callback can just keep its original definition of
        <code>Date.t -&gt; int -&gt; unit</code>. The
        <code>step</code> function transformed the <code>int
          option</code> argument from the parsing into an
        <code>int</code> suitable for <code>add_days</code>. This
        transformation is explicitly represented in the type of the
        <code>step</code> return value:</p>

      <link rel="import" href="code/command-line-parsing/step.mlt" part="1"/>

      <p>
	The first half of the <code>Spec.t</code> shows that the
        callback type is <code>Date.t -&gt; int</code>, whereas the
        resulting value expected from the next specification in the
        chain is a <code>Date.t -&gt; int option</code>.</p>
    </section>

    <section id="adding-labeled-arguments-to-callbacks" data-type="sect2">
      <h2>Adding Labeled Arguments to Callbacks</h2>

      <p>
	The <code>step</code> chaining lets you control the
        types of your callbacks very easily. This can help you
        match existing interfaces or make things more explicit by
        adding labeled arguments:

	<idx>callback function</idx>
	<idx>arguments/labeled arguments</idx>
	<idx>labeled arguments</idx></p>

      <link rel="import" href="code/command-line-parsing/cal_add_labels.ml"/>

      <p>
	This <code>cal_add_labels</code> example goes back to
        our noninteractive calendar addition program, but the
        <code>add_days</code> main function now expects labeled
        arguments. The <code>step</code> <span class="keep-together">function</span> in the specification simply
        converts the default <code>base</code> and
        <code>days</code> arguments into a labeled function.</p>

      <p>
	Labeled arguments are more verbose but can also help
        prevent errors with command-line arguments with similar
        types but different names and purposes. It's good form to
        use labels when you have a lot of otherwise anonymous
        <code>int</code> and <code>string</code> arguments.
        <a data-type="indexterm" data-startref="CLPadv">&nbsp;</a></p>
    </section>
  </section>

  <section id="command-line-auto-completion-with-bash" data-type="sect1">
    <h1>Command-Line Autocompletion with bash</h1>

    <p>
      Modern UNIX shells usually have a tab-completion feature
      to interactively help you figure out how to build a command
      line. These work by pressing the Tab key in the middle of
      typing a command, and seeing the options that pop up. You've
      probably used this most often to find the files in the
      current directory, but it can actually be extended for other
      parts of the command, too.

      <idx>tab-autocompletion</idx>
      <idx>autocompletion</idx>
      <idx>command-line parsing/autocompletion with bash</idx></p>

    <p>
      The precise mechanism for autocompletion varies depending
      on what shell you are using, but we'll assume you are using
      the most common one: <span class="command"><em>bash</em></span>. This is the default
      interactive shell on most Linux distributions and Mac OS X,
      but you may need to switch to it on *BSD or Windows (when
      using Cygwin). The rest of this section assumes that you're
      using <span class="command"><em>bash</em></span>.

      <idx>bash autocompletion</idx></p>

    <p>
      Bash autocompletion isn't always installed by default, so
      check your OS package manager to see if you have it
      available.</p>

    <table>
      <thead>
        <tr>
          <th>Operating system</th>

          <th>Package manager</th>

          <th>Package</th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>Debian Linux</td>

          <td><code>apt</code></td>

          <td><code>bash-completion</code></td>
        </tr>

        <tr>
          <td>Mac OS X</td>

          <td>Homebrew</td>

          <td><code>bash-completion</code></td>
        </tr>

        <tr>
          <td>FreeBSD</td>

          <td>Ports system</td>

          <td><em class="filename">/usr/ports/shells/bash-completion</em></td>
        </tr>
      </tbody>
    </table>

    <p>
      Once <em>bash</em> completion is installed and configured,
      check that it works by typing the <code>ssh</code> command
      and pressing the Tab key. This should show you the list of
      known hosts from your <em>~/.ssh/known_hosts</em> file. If it
      lists some hosts that you've recently connected to, you can
      continue on. If it lists the files in your current directory
      instead, then check your OS documentation to configure
      completion correctly.</p>

    <p>
      One last bit of information you'll need to find is the
      location of the <em class="filename">bash_completion.d</em>
      directory. This is where all the shell fragments that contain
      the completion logic are held. On Linux, this is often in
      <em class="filename">/etc/bash_completion.d</em>, and in
      Homebrew on Mac OS X, it would be <em class="filename">/usr/local/etc/bash_completion.d</em> by
      default.</p>

    <section id="generating-completion-fragments-from-command" data-type="sect2">
      <h2>Generating Completion Fragments from Command</h2>

      <p>
	The Command library has a declarative description of all
        the possible valid options, and it can use this information
        to generate a shell script that provides completion support
        for that command. To generate the fragment, just run the
        command with the
        <code>COMMAND_OUTPUT_INSTALLATION_BASH</code> environment
        variable set to any value.</p>

      <p>
	For example, let's try it on our MD5 example from
        earlier, assuming that the binary is called <span class="command"><em>basic_md5_with_flags</em></span> in the
        current directory:</p>

      <link rel="import" href="code/command-line-parsing/basic_md5_with_flags/basic_md5_with_flags.sh" part="completion"/>

      <p>
	Recall that we used the <code>Arg_type.file</code> to
        specify the argument type. This also supplies the
        completion logic so that you can just press Tab to complete
        files in your current directory.</p>
    </section>

    <section id="installing-the-completion-fragment" data-type="sect2">
      <h2>Installing the Completion Fragment</h2>

      <p>
	You don't need to worry about what the preceding output
        script actually does (unless you have an unhealthy
        fascination with shell scripting internals, that is).
        Instead, redirect the output to a file in your current
        directory and source it into your current shell:</p>

      <link rel="import" href="code/command-line-parsing/cal_completion.rawsh"/>

      <p>
	Command completion support works for flags and grouped
        commands and is very useful when building larger
        command-line interfaces. Don't forget to install the shell
        fragment into your
        global <em class="filename">bash_completion.d</em>
        directory if you want it to be loaded in all of your login
        shells.

	<idx>completion handlers</idx></p>

      <div data-type="note">
        <h1>Installing a Generic Completion Handler</h1>

        <p>
	  Sadly, <span class="command"><em>bash</em></span>
          doesn't support installing a generic handler for all
          Command-based applications. This means you have to
          install the completion script for every application, but
          you should be able to automate this in the build and
          packaging system for your application.</p>

        <p>
	  It will help to check out how other applications
          install tab-completion scripts and follow their lead, as
          the details are very OS-specific.</p>
      </div>
    </section>
  </section>

  <section id="alternative-command-line-parsers" data-type="sect1">
    <h1>Alternative Command-Line Parsers</h1>

    <p>
      This rounds up our tour of the Command library. This isn't
      the only way to parse command-line arguments of course; there
      are several alternatives available on OPAM. Three of the most
      prominent ones follow:

      <idx>Cmdliner</idx>
      <idx>OCaml toolchain/ocaml-getopt</idx>
      <idx>Arg module</idx>
      <idx>command-line parsing/alternatives to Command library</idx>
      <idx>OPAM package manager</idx></p>

    <dl>
      <dt>The <code>Arg</code> module</dt>

      <dd>
        <p>
	  The <code>Arg</code> module is from the OCaml standard
          library, which is used by the compiler itself to handle
          its command-line interface. Command is generally more
          featureful than Arg (mainly via support for subcommands,
          the <code>step</code> combinator to transform inputs, and
          help generation), but there's absolutely nothing wrong
          with using Arg either.</p>

        <p>
	  You can use the
          <code>Command.Spec.flags_of_args_exn</code> function to
          convert Arg specifications into ones compatible with
          Command. This is quite often used to help port older
          non-Core code into the Core standard library world.</p>
      </dd>

      <dt>
        <a href="https://forge.ocamlcore.org/projects/ocaml-getopt/">ocaml-getopt</a>
      </dt>

      <dd>
        <p>
	  <code>ocaml-getopt</code> provides the general
          command-line syntax of GNU <code>getopt</code> and
          <code>getopt_long</code>. The GNU conventions are widely
          used in the open source world, and this library lets your
          OCaml programs obey the same rules.</p>
      </dd>

      <dt>
        <a href="http://erratique.ch/software/cmdliner">Cmdliner</a>
      </dt>

      <dd>
        <p>
	  Cmdliner is a mix between the Command and Getopt
          libraries. It allows for the declarative definition of
          command-line interfaces but exposes a more
          <code>getopt</code>-like interface. It also automates the
          generation of UNIX man pages as part of the
          specification. Cmdliner is the parser used by OPAM to
          manage its command line.</p>
      </dd>
    </dl>
  </section>
</section>
