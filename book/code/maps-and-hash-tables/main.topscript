;;
#part 1
open Core_kernel.Std;;
let digit_alist =
    [ 0, "zero"; 1, "one"; 2, "two"  ; 3, "three"; 4, "four"
    ; 5, "five"; 6, "six"; 7, "seven"; 8, "eight"; 9, "nine" ]
  ;;




#part 2
List.Assoc.find digit_alist 6;;

List.Assoc.find digit_alist 22;;

List.Assoc.add digit_alist 0 "zilch";;




#part 3
let digit_map = Map.of_alist_exn digit_alist
                     ~comparator:Int.comparator;;

Map.find digit_map 3;;


#part 4
let zilch_map = Map.add digit_map ~key:0 ~data:"zilch";;


#part 5
let left = String.Map.of_alist_exn ["foo",1; "bar",3; "snoo",0];;
  let right = String.Map.of_alist_exn ["foo",0; "snoo",0];;
  let diff = Map.symmetric_diff ~data_equal:Int.equal left right
  ;;






#part 6
Map.symmetric_diff;;






#part 7
module Reverse = Comparator.Make(struct
    type t = string
    let sexp_of_t = String.sexp_of_t
    let t_of_sexp = String.t_of_sexp
    let compare x y = String.compare y x
  end);;










#part 8
let alist = ["foo", 0; "snoo", 3];;

let ord_map = Map.of_alist_exn ~comparator:String.comparator alist;;

let rev_map = Map.of_alist_exn ~comparator:Reverse.comparator alist;;


#part 9
Map.min_elt ord_map;;

Map.min_elt rev_map;;


#part 10
Map.symmetric_diff ord_map rev_map;;






#part 11
let ord_tree = Map.to_tree ord_map;;


#part 12
Map.Tree.find ~comparator:String.comparator ord_tree "snoo";;


#part 13
Map.Tree.find ~comparator:Reverse.comparator ord_tree "snoo";;






#part 14
Map.of_alist_exn ~comparator:Comparator.Poly.comparator digit_alist;;


#part 15
Map.Poly.of_alist_exn digit_alist;;


#part 16
Map.symmetric_diff (Map.Poly.singleton 3 "three")
                     (Int.Map.singleton  3 "four" ) ;;








#part 17
let dedup ~comparator l =
    List.fold l ~init:(Set.empty ~comparator) ~f:Set.add
    |> Set.to_list
  ;;


dedup ~comparator:Int.comparator [8;3;2;3;7;8;10];;


#part 18
let (s1,s2) = (Int.Set.of_list [1;2],
                 Int.Set.of_list [2;1]);;



#part 19
Set.equal s1 s2;;


#part 20
s1 = s2;;


#part 21
Set.to_tree s1 = Set.to_tree s2;;

#part 22
module Foo_and_bar : sig
    type t = { foo: Int.Set.t; bar: string }
    include Comparable.S with type t := t
  end = struct
    module T = struct
      type t = { foo: Int.Set.t; bar: string } with sexp
      let compare t1 t2 =
        let c = Int.Set.compare t1.foo t2.foo in
        if c <> 0 then c else String.compare t1.bar t2.bar
    end
    include T
    include Comparable.Make(T)
  end;;

#part 23
module Foo_and_bar : sig
    type t = { foo: Int.Set.t; bar: string }
    include Comparable.S with type t := t
  end = struct
    module T = struct
      type t = { foo: Int.Set.t; bar: string } with sexp, compare
    end
    include T
    include Comparable.Make(T)
  end;;

#part 24
module Foo_and_bar : sig
    type t = { foo: int; bar: string }
    include Comparable.S with type t := t
  end = struct
    module T = struct
      type t = { foo: int; bar: string } with sexp
    end
    include T
    include Comparable.Poly(T)
  end;;



#part 25
let table = Hashtbl.create ~hashable:String.hashable ();;

Hashtbl.replace table ~key:"three" ~data:3;;

Hashtbl.find table "three";;


#part 26
let table = String.Table.create ();;


#part 27
let table = Hashtbl.create ~hashable:Hashtbl.Poly.hashable ();;


#part 28
let table = Hashtbl.Poly.create ();;


#part 29
Caml.Hashtbl.hash (List.range 0 9);;

Caml.Hashtbl.hash (List.range 0 10);;

Caml.Hashtbl.hash (List.range 0 11);;

Caml.Hashtbl.hash (List.range 0 100);;

#part 30
module Foo_and_bar : sig
    type t = { foo: int; bar: string }
    include Hashable.S with type t := t
  end = struct
    module T = struct
      type t = { foo: int; bar: string } with sexp, compare
      let hash t =
        (Int.hash t.foo) lxor (String.hash t.bar)
    end
    include T
    include Hashable.Make(T)
  end;;
