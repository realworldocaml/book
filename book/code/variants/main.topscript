#use "topfind";;
#thread;;
#camlp4o;;
#require "core";;
#require "core.syntax";;
(* part 0.5 *)
open Core_kernel.Std;;
type basic_color =
  | Black | Red | Green | Yellow | Blue | Magenta | Cyan | White ;;

Cyan ;;

[Blue; Magenta; Red] ;;

(* part 1 *)
let basic_color_to_int = function
  | Black -> 0 | Red     -> 1 | Green -> 2 | Yellow -> 3
  | Blue  -> 4 | Magenta -> 5 | Cyan  -> 6 | White  -> 7 ;;

List.map ~f:basic_color_to_int [Blue;Red];;

(* part 2 *)
let color_by_number number text =
  sprintf "\027[38;5;%dm%s\027[0m" number text;;

let blue = color_by_number (basic_color_to_int Blue) "Blue";;

printf "Hello %s World!\n" blue;;

(* part 3 *)
type weight = Regular | Bold;;
type color =
  | Basic of basic_color * weight (* basic colors, regular and bold *)
  | RGB   of int * int * int       (* 6x6x6 color cube *)
  | Gray  of int                   (* 24 grayscale levels *)
;;

[RGB (250,70,70); Basic (Green, Regular)];;

(* part 4 *)
let color_to_int = function
  | Basic (basic_color,weight) ->
    let base = match weight with Bold -> 8 | Regular -> 0 in
    base + basic_color_to_int basic_color
  | RGB (r,g,b) -> 16 + b + g * 6 + r * 36
  | Gray i -> 232 + i ;;

(* part 5 *)
let color_print color s =
  printf "%s\n" (color_by_number (color_to_int color) s);;

color_print (Basic (Red,Bold)) "A bold red!";;

color_print (Gray 4) "A muted gray...";;


(* part 6 *)
let three = `Int 3;;

let four = `Float 4.;;

let nan = `Not_a_number;;

[three; four; nan];;



(* part 7 *)
let five = `Int "five";;

[three; four; five];;

(* part 8 *)
let is_positive = function
  | `Int   x -> x > 0
  | `Float x -> x > 0.
;;


(* part 9 *)
let exact = List.filter ~f:is_positive [three;four];;


(* part 10 *)
let is_positive = function
  | `Int   x -> Ok (x > 0)
  | `Float x -> Ok (x > 0.)
  | `Not_a_number -> Error "not a number";;



List.filter [three; four] ~f:(fun x ->
  match is_positive x with Error _ -> false | Ok b -> b);;



(* part 11 *)
type extended_color =
  | Basic of basic_color * weight  (* basic colors, regular and bold *)
  | RGB   of int * int * int       (* 6x6x6 color space *)
  | Gray  of int                   (* 24 grayscale levels *)
  | RGBA  of int * int * int * int (* 6x6x6x6 color space *)
;;






(* part 12 *)
let extended_color_to_int = function
  | RGBA (r,g,b,a) -> 256 + a + b * 6 + g * 36 + r * 216
  | (Basic _ | RGB _ | Gray _) as color -> color_to_int color
;;




(* part 13 *)
let basic_color_to_int = function
  | `Black -> 0 | `Red     -> 1 | `Green -> 2 | `Yellow -> 3
  | `Blue  -> 4 | `Magenta -> 5 | `Cyan  -> 6 | `White  -> 7
;;
let color_to_int = function
  | `Basic (basic_color,weight) ->
    let base = match weight with `Bold -> 8 | `Regular -> 0 in
    base + basic_color_to_int basic_color
  | `RGB (r,g,b) -> 16 + b + g * 6 + r * 36
  | `Gray i -> 232 + i
;;


















(* part 14 *)
let extended_color_to_int = function
  | `RGBA (r,g,b,a) -> 256 + a + b * 6 + g * 36 + r * 216
  | (`Basic _ | `RGB _ | `Gray _) as color -> color_to_int color
;;
















(* part 15 *)
let extended_color_to_int = function
  | `RGBA (r,g,b,a) -> 256 + a + b * 6 + g * 36 + r * 216
  | color -> color_to_int color
;;

















(* part 16 *)
let is_positive_permissive = function
  | `Int   x -> Ok (x > 0)
  | `Float x -> Ok (x > 0.)
  | _ -> Error "Unknown number type"
;;


is_positive_permissive (`Int 0);;

is_positive_permissive (`Ratio (3,4));;


(* part 17 *)
is_positive_permissive (`Floot 3.5);;

