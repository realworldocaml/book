

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="generator" content="HTML Tidy for HTML5 (experimental) for Mac OS X https://github.com/w3c/tidy-html5/tree/c63cc39"/>

  <title></title>
</head>

<body>
  <section xmlns="http://www.w3.org/1999/xhtml" id="files-modules-and-programs" data-type="chapter">
    <h1>Files, Modules, and Programs</h1>

    <p>We've so far experienced OCaml largely through the toplevel.
    As you move from exercises to real-world programs, you'll need
    to leave the toplevel behind and start building programs from
    files. Files are more than just a convenient way to store and
    manage your code; in OCaml, they also correspond to modules,
    which act as boundaries that divide your program into
    conceptual units.</p>

    <p>In this chapter, we'll show you how to build an OCaml
    program from a collection of files, as well as the basics of
    working with modules and module signatures.</p>

    <section id="single-file-programs" data-type="sect1">
      <h1>Single-File Programs</h1>

      <p>We'll start with an example: a utility that reads lines
      from <code>stdin</code>, computes a frequency count of the
      lines, and prints out the ten most frequent lines. We'll start
      with a simple implementation, which we'll save as the
      file <em>freq.ml</em>.

      <idx id="FILEsnglprog">files/single-file programs</idx>
      <idx id="Psingfil">programs/single-file programs</idx></p>

      <p>This implementation will use two functions from
      the <code>List.Assoc</code> module, which provides utility
      functions for interacting with <em>association
      lists</em>, <em>i.e.</em>, lists of key/value pairs. In
      particular, we use the function <code>List.Assoc.find</code>,
      which looks up a key in an association list;
      and <code>List.Assoc.add</code>, which adds a new binding to an
      association list, as shown here:

      <idx>List.Assoc module/List.Assoc.add</idx>
      <idx>List.Assoc module/List.Assoc.find</idx>
      <idx>lists/adding new bindings in</idx>
      <idx>lists/finding key associations in</idx></p>

      <link rel="import" part="1" href="code/files-modules-and-programs/intro.topscript"/>

      <p>Note that <code>List.Assoc.add</code> doesn't modify the
      original list, but instead allocates a new list with the
      requisite key/value pair added.</p>

      <p>Now we can write <code>freq.ml</code>.</p>

      <link rel="import"
	    href="code/files-modules-and-programs/freq/freq.ml"/>

      <p>
	The function <code>build_counts</code> reads in lines
	from <code>stdin</code>, constructing from those lines an
	association list with the frequencies of each line. It does
	this by invoking <code>In_channel.fold_lines</code> (similar
	to the function <code>List.fold</code> described in
	<a href="03-lists-and-patterns.html#lists-and-patterns"
	   data-type="xref">Lists And Patterns</a>), which reads
	through the lines one by one, calling the
	provided <code>fold</code> function for each line to update
	the accumulator. That accumulator is initialized to the empty
	list.</p>

      <p>
	With <code>build_counts</code> defined, we then call the
	function to build the association list, sort that list by
	frequency in descending order, grab the first 10 elements off
	the list, and then iterate over those 10 elements and print
	them to the screen. These operations are tied together using
	the <code>|&gt;</code> operator described
	in <a href="02-variables-and-functions.html#prefix-and-infix-operators"
	      data-type="xref">Variables And Functions</a>.

	<idx>let ( ) declaration</idx>
	<idx>main function</idx></p>

      <div class="allow_break" data-type="note">
        <h1>Where Is <code>main</code>?</h1>

        <p>Unlike programs in C, Java or C#, programs in OCaml don't
        have a unique <code>main</code> function. When an OCaml
        program is evaluated, all the statements in the implementation
        files are evaluated in the order in which they were linked
        together. These implementation files can contain arbitrary
        expressions, not just function definitions. In this example,
        the declaration starting with <code>let () =</code> plays the
        role of the <code>main</code> function, kicking off the
        processing. But really the entire file is evaluated at
        startup, and so in some sense the full codebase is one
        big <code>main</code> function.</p>

        <p>The idiom of writing <code>let () =</code> may seem a
        bit odd, but it has a purpose. The <code>let</code> binding
        here is a pattern-match to a value of type
        <code>unit</code>, which is there to ensure that the
        expression on the righthand side returns <code>unit</code>,
        as is common for functions that operate primarily by side
        effect.</p>
      </div>

      <p>If we weren't using <code>Base</code> or any other
      external libraries, we could build the executable like
      this:</p>
      <link rel="import" href="code/files-modules-and-programs/freq/simple_build_fail.errsh"/>

      <p>But as you can see, it fails because it can't
      find <code>Base</code> and <code>Stdio</code>. We need a
      somewhat more complex invocation to get them linked in:

      <idx>OCaml toolchain/ocamlc</idx>
      <idx>OCaml toolchain/ocamlfind</idx>
      <idx>Base standard library/finding with ocamlfind</idx></p>

      <link rel="import" 
	    href="code/files-modules-and-programs/freq/simple_build.sh"/>

      <p>This uses <span class="command"><em>ocamlfind</em></span>, a
      tool which itself invokes other parts of the OCaml toolchain (in
      this case, <span class="command"><em>ocamlc</em></span>) with
      the appropriate flags to link in particular libraries and
      packages. Here, <code>-package base</code> is
      asking <span class="command"><em>ocamlfind</em></span> to link
      in the <code>Base</code> library; <code>-linkpkg</code> asks
      ocamlfind to link in the packages as is necessary for building
      an executable, while <code>-thread</code> turns on threading
      support, which is required for Base.

      <idx>threads/turning on with -thread</idx>
      <idx data-primary-sortas="linkpkg">-linkpkg</idx></p>

      <p>While this works well enough for a one-file project, more
	complicated projects require a tool to orchestrate the build.
	One good tool for this task
	is <span class="command"><em>jbuilder</em></span>. To
	invoke <span class="command"><em>jbuilder</em></span>, you
	need to have a <code>jbuild</code> file that specifies the
	details of the build.  <idx>jbuilder</idx></p>

      <link rel="import" href="code/files-modules-and-programs/freq-obuild/jbuild"/>

      <p>With that in place, we can
	invoke <span class="command"><em>jbuilder</em></span> as
	follows.

      <link rel="import" href="code/files-modules-and-programs/freq-obuild/freq.sh" part="build"/>

      <p>We can run the resulting executable, <code>freq.bc</code>,
      from the command line.  The following invocation extracts
      strings from the <span class="command"><em>ocamlopt</em></span>
      binary, reporting the most frequently occurring ones. Note that
      the specific results will vary from platform to platform, since
      the binary itself will differ between platforms.

	<idx>OCaml toolchain/jbuilder</idx>
	<idx>native-code compiler/vs. bytecode compiler</idx>
	<idx>bytecode compiler/vs. native-code compiler</idx>
	<idx>OCaml toolchain/ocamlopt</idx>
	<idx>OCaml toolchain/ocamlc</idx>
	<idx>code compilers/bytecode vs. native code</idx>
	<a data-type="indexterm" data-startref="FILEsnglprog">&nbsp;</a>
	<a data-type="indexterm" data-startref="Psingfil">&nbsp;</a>
      </p>

      <link rel="import" href="code/files-modules-and-programs/freq-obuild/freq.sh" part="test"/>

      <div data-type="note">
        <h1>Bytecode Versus Native Code</h1>

        <p>OCaml ships with two compilers:
        the <span class="command"><em>ocamlc</em></span> bytecode
        compiler and
        the <span class="command"><em>ocamlopt</em></span> native-code
        compiler. Programs compiled
        with <span class="command"><em>ocamlc</em></span> are
        interpreted by a virtual machine, while programs compiled
        with <span class="command"><em>ocamlopt</em></span> are
        compiled to native machine code to be run on a specific
        operating system and processor
        architecture. With <span class="command"><em>jbuilder</em></span>,
        targets ending with <code>.bc</code> are built as bytecode
        executables, and those ending with <code>.exe</code> are built
        as native code.</p>

        <p>Aside from performance, executables generated by the two
        compilers have nearly identical behavior. There are a few
        things to be aware of. First, the bytecode compiler can be
        used on more architectures, and has some tools that are not
        available for native code. For example, the OCaml debugger
        only works with bytecode
        (although <span class="command"><em>gdb</em></span>, the GNU
        Debugger, works with OCaml native-code applications). The
        bytecode compiler is also quicker than the native-code
        compiler. In addition, in order to run a bytecode executable,
        you typically need to have OCaml installed on the system in
        question. That's not strictly required, though, since you can
        build a bytecode executable with an embedded runtime, using
        the <code>-custom</code> compiler flag.</p>

        <p>As a general matter, production executables should usually
        be built using the native-code compiler, but it sometimes
        makes sense to use bytecode for development builds. And, of
        course, bytecode makes sense when targeting a platform not
        supported by the native-code compiler. We'll cover both
        compilers in more detail
        in <a href="23-compiler-backend.html#the-compiler-backend-byte-code-and-native-code"
        data-type="xref">The Compiler Backend: Byte Code And Native
        Code</a>.</p>
      </div>
    </section>

    <section id="multi-file-programs-and-modules" data-type="sect1">
      <h1>Multifile Programs and Modules</h1>

      <p>Source files in OCaml are tied into the module system,
      with each file compiling down into a module whose name is
      derived from the name of the file. We've encountered modules
      before, such as when we used functions like <code>find</code>
      and <code>add</code> from the <code>List.Assoc</code> module.
      At its simplest, you can think of a module as a collection of
      definitions that are stored within a
      namespace.

	<idx>modules/basics of</idx>
	<idx>files/multi-file programs</idx>
	<idx>programs/multi-file programs</idx></p>

      <p>Let's consider how we can use modules to refactor the
      implementation of <code>freq.ml</code>. Remember that the
      variable <code>counts</code> contains an association list
      representing the counts of the lines seen so far. But
      updating an association list takes time linear in the length
      of the list, meaning that the time complexity of processing a
      file is quadratic in the number of distinct lines in the
      file.</p>

      <p>We can fix this problem by replacing association lists
      with a more efficient data structure. To do that, we'll first
      factor out the key functionality into a separate module with
      an explicit interface. We can consider alternative (and more
      efficient) implementations once we have a clear interface to
      program against.</p>

      <p>We'll start by creating a file, <code>counter.ml</code>, that
      contains the logic for maintaining the association list used to
      represent the frequency counts. The key function,
      called <code>touch</code>, bumps the frequency count of a given
      line by one.</p> 

      <link rel="import"
	    href="code/files-modules-and-programs/freq-with-counter/counter.ml"/>

      <p>The file <em>counter.ml</em> will be compiled into a
      module named <code>Counter</code>, where the name of the
      module is derived automatically from the filename. The module
      name is capitalized even if the file is not. Indeed, module
      names are always capitalized.

	<idx>modules/naming of</idx></p>

      <p>We can now rewrite <code>freq.ml</code> to
      use <code>Counter</code>. 

      <link rel="import" href="code/files-modules-and-programs/freq-with-counter/freq.ml"/>

      <p>The resulting code can still
      be built with <span class="command"><em>jbuilder</em></span>,
      which will discover dependencies and realize
      that <code>counter.ml</code> needs to be compiled.</p>
      </p>

      <link rel="import" href="code/files-modules-and-programs/freq-with-counter/build.sh"/>
      </section>

    <section id="signatures-and-abstract-types" data-type="sect1">
      <h1>Signatures and Abstract Types</h1>

      <p>While we've pushed some of the logic to the
      <code>Counter</code> module, the code in <code>freq.ml</code>
      can still depend on the details of the implementation of
      <code>Counter</code>. Indeed, if you look at the definition
      of <code>build_counts</code>, you'll see that it depends on
      the fact that the empty set of frequency counts is
      represented as an empty list. We'd like to prevent this kind
      of dependency, so we can change the implementation of
      <code>Counter</code> without needing to change client code
      like that in <code>freq.ml</code>.

      <idx>abstract types</idx>
      <idx>modules/module type</idx>
      <idx>signatures/abstract types</idx>
      <idx>interfaces/hiding implementation details with</idx>
      <idx>modules/hiding implementation details</idx></p>

      <p>The implementation details of a module can be hidden by
      attaching an <em>interface</em>. (Note that in the context of
      OCaml, the terms <em>interface</em>, <em>signature</em>, and
      <em>module type</em> are all used interchangeably.) A module
      defined by a file <code>filename.ml</code> can be constrained
      by a signature placed in a file called
      <code>filename.mli</code>.

      <idx>interfaces/synonyms for</idx></p>

      <p>For <code>counter.mli</code>, we'll start by writing down
      an interface that describes what's currently available in
      <code>counter.ml</code>, without hiding anything.
      <code>val</code> declarations are used to specify values in a
      signature. The syntax of a <code>val</code> declaration is as
      follows:</p>
      <link rel="import" href="code/files-modules-and-programs/val.syntax"/>

      <p>Using this syntax, we can write the signature
      of <code>counter.ml</code> as follows. </p> 

      <link rel="import"
	    href="code/files-modules-and-programs/freq-with-sig/counter.mli"/>

      <p>Note that <span class="command"><em>jbuilder</em></span>
      will detect the presence of the <code>mli</code> file
      automatically and include it in the build.</p>

      <!-- <div data-type="note"> -->
      <!--   <h1>Autogenerating mli Files</h1> -->

      <!--   <p>If you don't want to construct an <code>mli</code> -->
      <!--   entirely by hand, you can ask OCaml to autogenerate one for -->
      <!--   you from the source, which you can then adjust to fit your -->
      <!--   needs. Here's how you can do that using <em>corebuild</em>: -->

      <!--   <idx>files/mli files</idx></p> -->

      <!--   <link rel="import" -->
      <!--   href="code/files-modules-and-programs/freq-with-counter/infer_mli.sh"/> -->

      <!--   <p>The generated code is basically equivalent to -->
      <!--   the <code>mli</code> that we wrote by hand but is a bit uglier -->
      <!--   and more verbose and, of course, has no comments. In general, -->
      <!--   autogenerated <code>mli</code>s are only useful as a starting -->
      <!--   point. In OCaml, the <code>mli</code> is the key place where -->
      <!--   you present and document your interface, and there's no -->
      <!--   replacement for careful human editing and organization.</p> -->
      <!-- </div> -->

      <p>To hide the fact that frequency counts are represented as
      association lists, we'll need to make the type of frequency
      counts <em>abstract</em>. A type is abstract if its name is
      exposed in the interface, but its definition is not. Here's
      an abstract interface for <code>Counter</code>:</p>

      <link rel="import" href="code/files-modules-and-programs/freq-with-sig-abstract/counter.mli"/>

      <p>Note that we needed to add <code>empty</code> and
      <code>to_list</code> to <code>Counter</code>, since otherwise
      there would be no way to create a <code>Counter.t</code> or
      get data out of one.</p>

      <p>We also used this opportunity to document the
      module. The <code>mli</code> file is the place where you specify
      your module's interface, and as such is a natural place to put
      documentation. We started our comments with a double asterisk to
      cause them to be picked up by
      the <span class="command"><em>odoc</em></span> tool when
      generating API documentation. We'll
      discuss <span class="command"><em>odoc</em></span> more
      in <a href="22-compiler-frontend.html#the-compiler-frontend-parsing-and-type-checking"
      data-type="xref">The Compiler Frontend Parsing And Type
      Checking</a>.</p>

      <p>Here's a rewrite of <code>counter.ml</code> to match the
      new <code>counter.mli</code>:</p>

      <link rel="import"
      href="code/files-modules-and-programs/freq-with-sig-abstract/counter.ml"/>

      <p>If we now try to compile <code>freq.ml</code>, we'll get
      the following error:</p>

      <link rel="import"
	    href="code/files-modules-and-programs/freq-with-sig-abstract/build.errsh"/>

      <p>This is because <code>freq.ml</code> depends on the fact that
      frequency counts are represented as association lists, a fact
      that we've just hidden. We just need to
      fix <code>build_counts</code> to use <code>Counter.empty</code>
      instead of <code>[]</code> and to
      use <code>Counter.to_list</code> to convert the completed counts
      to an association list. The resulting implementation is shown
      below.</p>

      <link rel="import"
	    href="code/files-modules-and-programs/freq-with-sig-abstract-fixed/freq.ml"/>

      <p>With this implementation, the build now succeeds!</p>

      <link rel="import"
	    href="code/files-modules-and-programs/freq-with-sig-abstract-fixed/build.sh"/>

      <p>Now we can turn to optimizing the implementation
      of <code>Counter</code>. Here's an alternate and far more
      efficient implementation, based on the <code>Map</code> data
      structure in <code>Core_kernel</code>.</p> 
      
      <link rel="import"
	    href="code/files-modules-and-programs/freq-fast/counter.ml"/>

      <p>
	There's some unfamiliar syntax in the above example, in
	particular, writing <code>Map.M(String).t</code> to refer to
	the type of a map with string keys, and <code>Map.empty
	(module String)</code> to generate an empty map.  Here, we're
	making use of some more advanced features of the language
	(specifically, <em>functors</em> and <em>first-class
	modules</em>, which we'll get to in later chapters).  The use
	of these features for the Map data-structure in particular is
	covered in
	<a href="13-maps-and-hashtables.html#maps-and-hash-tables"
	      data-type="xref">Maps And Hash Tables</a>.</p>
    </section>

    <section id="concrete-types-in-signatures" data-type="sect1">
      <h1>Concrete Types in Signatures</h1>

      <p>In our frequency-count example, the module
      <code>Counter</code> had an abstract type
      <code>Counter.t</code> for representing a collection of
      frequency counts. Sometimes, you'll want to make a type in
      your interface <em>concrete</em>, by including the type
      definition in the interface.

      <idx>concrete types</idx>
      <idx>signatures/concrete types</idx></p>

      <p>For example, imagine we wanted to add a function
      to <code>Counter</code> for returning the line with the median
      frequency count. If the number of lines is even, then there is
      no precise median, and the function would return the lines
      before and after the median instead. We'll use a custom type to
      represent the fact that there are two possible return
      values. Here's a possible implementation:</p>

      <link rel="import" 
	    href="code/files-modules-and-programs/freq-median/counter.ml" part="1"/>

      <p>In the above, we use <code>failwith</code> to throw an
      exception for the case of the empty list. We'll discuss
      exceptions more
      in <a href="07-error-handling.html#error-handling"
      data-type="xref">Error Handling</a>. Note also that the
      function <code>fst</code> simply returns the first element of
      any two-tuple.</p>

      <p>Now, to expose this usefully in the interface, we need to
      expose both the function and the type <code>median</code> with
      its definition. Note that values (of which functions are an
      example) and types have distinct namespaces, so there's no name
      clash here. Adding the following two lines
      to <code>counter.mli</code> does the trick.</p>

      <link rel="import" 
	    href="code/files-modules-and-programs/freq-median/counter.mli" part="1"/>

      <p>The decision of whether a given type should be abstract or
      concrete is an important one. Abstract types give you more
      control over how values are created and accessed, and make it
      easier to enforce invariants beyond what is enforced by the
      type itself; concrete types let you expose more detail and
      structure to client code in a lightweight way. The right
      choice depends very much on the context.</p>
    </section>

    <section id="nested-modules" data-type="sect1">
      <h1>Nested Modules</h1>

      <p>Up until now, we've only considered modules that
      correspond to files, like <code>counter.ml</code>. But
      modules (and module signatures) can be nested inside other
      modules. As a simple example, consider a program that needs
      to deal with multiple identifiers like usernames and
      hostnames. If you just represent these as strings, then it
      becomes easy to confuse one with the
      other.

	<idx>identifiers/dealing with multiple</idx>
	<idx>nested modules</idx>
	<idx>modules/nested modules</idx></p>

      <p>A better approach is to mint new abstract types for each
      identifier, where those types are under the covers just
      implemented as strings. That way, the type system will
      prevent you from confusing a username with a hostname, and if
      you do need to convert, you can do so using explicit
      conversions to and from the string type.</p>

      <p>
	Here's how you might create such an abstract type, within a
	submodule:

	<idx>abstract types</idx></p>

      <link rel="import" 
	    href="code/files-modules-and-programs/abstract_username.ml"/>

      <p>
	Note that the <code>to_string</code>
	and <code>of_string</code> functions above are implemented
	simply as the identity function, which means they have no
	runtime effect. They are there purely as part of the
	discipline that they enforce on the code through the type
	system. We also chose to put in an equality function, so you
	can check if two usernames match. In a real application, we
	might want more functionality, like the ability to hash and
	compare usernames, but we've kept this example purposefully
	simple.
      </p>

      <p>
	The basic structure of a module declaration like this is:</p>

      <link rel="import" href="code/files-modules-and-programs/module.syntax"/>

      <p>We could have written this slightly differently, by giving
      the signature its own top-level <code>module type</code>
      declaration, making it possible to create multiple distinct
      types with the same underlying implementation in a
      lightweight way:</p>

      <link rel="import" href="code/files-modules-and-programs/session_info/session_info.ml"/>

      <p>The preceding code has a bug: it compares the username in
      one session to the host in the other session, when it should
      be comparing the usernames in both cases. Because of how we
      defined our types, however, the compiler will flag this bug
      for us.</p>
      <link rel="import" 
	    href="code/files-modules-and-programs/session_info/build_session_info.errsh"/>

      <p>This is a trivial example, but confusing different kinds
      of identifiers is a very real source of bugs, and the
      approach of minting abstract types for different classes of
      identifiers is an effective way of avoiding such issues.</p>
    </section>

    <section id="opening-modules" data-type="sect1">
      <h1>Opening Modules</h1>

      <p>Most of the time, you refer to values and types within a
      module by using the module name as an explicit qualifier. For
      example, you write <code>List.map</code> to refer to the
      <code>map</code> function in the <code>List</code> module.
      Sometimes, though, you want to be able to refer to the
      contents of a module without this explicit qualification.
      That's what the <code>open</code> statement is
      for.

      <idx>identifiers/open modules and</idx>
      <idx>modules/opening</idx></p>

      <p>We've encountered <code>open</code> already, specifically
      where we've written <code>open Base</code> to get
      access to the standard definitions in the
      <code>Base</code> library. In general, opening a
      module adds the contents of that module to the environment
      that the compiler looks at to find the definition of various
      identifiers. Here's an example:</p>

      <link rel="import" href="code/files-modules-and-programs/main.topscript" part="0.5"/>

      <p><code>open</code> is essential when you want to modify
      your environment for a standard library like
      <code>Base</code>, but it's generally good style to
      keep the opening of modules to a minimum. Opening a module is
      basically a trade-off between terseness and explicitnessâ€”the
      more modules you open, the fewer module qualifications you
      need, and the harder it is to look at an identifier and
      figure out where it comes from.</p>

      <p>Here's some general advice on how to deal with
      <code>open</code>s:

      <idx>local opens</idx></p>

      <ul>
        <li>
          <p>Opening modules at the toplevel of a module should be
          done quite sparingly, and generally only with modules
            that have been specifically designed to be opened, like
            <code>Base</code> or
            <code>Option.Monad_infix</code>.</p>
        </li>

        <li>
          <p>If you do need to do an open, it's better to do a
            <em>local open</em>. There are two syntaxes for local
            opens. For example, you can write:</p>

	  <link rel="import" 
		href="code/files-modules-and-programs/main.topscript" 
		part="1"/>

	  <p>Here, <code>of_int</code> and the infix operators are the
	    ones from the <code>Int64</code> module.</p>

	  <p>There's another, even more lightweight syntax for local
	    <code>open</code>s, which is particularly useful for small
	    expressions:</p>

	  <link rel="import" 
		href="code/files-modules-and-programs/main.topscript" 
		part="2"/>

	</li>

        <li>
          <p>An alternative to local <code>open</code>s that makes
          your code terser without giving up on explicitness is to
          locally rebind the name of a module. So, when using the
          <code>Counter.median</code> type, instead of writing:</p>
        </li>

        <li style="list-style: none; display: inline">

          <link rel="import" 
		href="code/files-modules-and-programs/freq-median/use_median_1.ml" 
		part="1"/>

          <p>you could write:</p>

          <link rel="import" 
		href="code/files-modules-and-programs/freq-median/use_median_2.ml" 
		part="1"/>

          <p>Because the module name <code>C</code> only exists for
          a short scope, it's easy to read and remember what
          <code>C</code> stands for. Rebinding modules to very
          short names at the top level of your module is usually a
          mistake.</p>
        </li>
      </ul>
    </section>

    <section id="including-modules" data-type="sect1">
      <h1>Including Modules</h1>

      <p>
	While opening a module affects the environment used to search
	for identifiers, <em>including</em> a module is a way of
	adding new identifiers to a module proper.  Consider the
	following simple module for representing a range of integer
	values:

	<idx>modules/including</idx>
	<idx>identifiers/adding to modules</idx></p>

      <link rel="import" href="code/files-modules-and-programs/main.topscript" part="3"/>

      <p>We can use the <code>include</code> directive to create a
      new, extended version of the <code>Interval</code>
      module:</p>

      <link rel="import" href="code/files-modules-and-programs/main.topscript" part="4"/>

      <p>The difference between <code>include</code> and
      <code>open</code> is that we've done more than change how
      identifiers are searched for: we've changed what's in the
      module. If we'd used <code>open</code>, we'd have gotten a
      quite different result:</p>

      <link rel="import" href="code/files-modules-and-programs/main.topscript" part="5"/>

      <p>
	To consider a more realistic example, imagine you wanted to
	build an extended version of the <code>List</code> module,
	where you've added some functionality not present in the
	module as distributed in <code>Base</code>. That's a job
	for <code>include</code>.</p>

      <link rel="import" href="code/files-modules-and-programs/ext_list.ml"/>

      <p>Now, how do we write an interface for this new module? It
      turns out that <code>include</code> works on signatures as
      well, so we can pull essentially the same trick to write our
      <code>mli</code>. The only issues is that we need to get our
      hands on the signature for the <code>List</code> module. This
      can be done using <code>module type of</code>, which computes
      a signature from a module:</p>

      <link rel="import" href="code/files-modules-and-programs/ext_list.mli"/>

      <p>Note that the order of declarations in the
      <code>mli</code> does not need to match the order of
      declarations in the <code>ml</code>. The order of
      declarations in the <code>ml</code> mostly matters insofar as
      it affects which values are shadowed. If we wanted to replace
      a function in <code>List</code> with a new function of the
      same name, the declaration of that function in the
      <code>ml</code> would have to come after the <code>include
      List</code> declaration.</p>

      <p>We can now use <code>Ext_list</code> as a replacement for
      <code>List</code>. If we want to use <code>Ext_list</code> in
      preference to <code>List</code> in our project, we can create
      a file of common definitions:</p>

      <link rel="import" href="code/files-modules-and-programs/common.ml"/>

      <p>And if we then put <code>open Common</code> after
      <code>open Base</code> at the top of each file in
      our project, then references to <code>List</code> will
      automatically go to <code>Ext_list</code> instead.</p>
    </section>

    <section id="common-errors-with-modules" data-type="sect1">
      <h1>Common Errors with Modules</h1>

      <p>When OCaml compiles a program with an <code>ml</code> and
      an <code>mli</code>, it will complain if it detects a
      mismatch between the two. Here are some of the common errors
      you'll run into.</p>

      <section id="type-mismatches" data-type="sect2">
        <h2>Type Mismatches</h2>

        <p>The simplest kind of error is where the type specified
        in the signature does not match the type in the
        implementation of the module. As an example, if we replace
        the <code>val</code> declaration in
        <code>counter.mli</code> by swapping the types of the first
        two arguments:

	<idx>errors/module type mismatches</idx>
	<idx>type mismatches</idx>
	<idx>modules/type mismatches in</idx></p>

        <link rel="import"
        href="code/files-modules-and-programs/freq-with-sig-mismatch/counter.mli"
        part="1"/>

        <p>and we try to compile, we'll get the following error.</p>

        <link rel="import"
              href="code/files-modules-and-programs/freq-with-sig-mismatch/build.errsh"/>

        </section>

      <section id="missing-definitions" data-type="sect2">
        <h2>Missing Definitions</h2>

        <p>We might decide that we want a new function in
        <code>Counter</code> for pulling out the frequency count of
        a given string. We can update the <code>mli</code> by
        adding the following line:

	<idx>errors/missing module definitions</idx>
	<idx>modules/missing definitions in</idx></p>

        <link rel="import" 
	      href="code/files-modules-and-programs/freq-with-missing-def/counter.mli" part="1"/>

        <p>Now if we try to compile without actually adding the
        implementation, we'll get this error.</p>

        <link rel="import" 
	      href="code/files-modules-and-programs/freq-with-missing-def/build.errsh"/>

        <p>A missing type definition will lead to a similar
        error.</p>
      </section>

      <section id="type-definition-mismatches" data-type="sect2">
        <h2>Type Definition Mismatches</h2>

        <p>Type definitions that show up in an <code>mli</code>
        need to match up with corresponding definitions in the
        <code>ml</code>. Consider again the example of the type
        <code>median</code>. The order of the declaration of
        variants matters to the OCaml compiler, so the definition
        of <code>median</code> in the implementation listing those
        options in a different order:
	<idx>type definition mismatches</idx>
	<idx>errors/module type definition mismatches</idx>
	<idx>modules/type definition mismatches</idx></p>

        <link rel="import" 
	      href="code/files-modules-and-programs/freq-with-type-mismatch/counter.mli"
	      part="1"/>

        <p>will lead to a compilation error.</p>
        <link rel="import" 
	      href="code/files-modules-and-programs/freq-with-type-mismatch/build.errsh"/>

        <p>Order is similarly important to other type declarations,
        including the order in which record fields are declared and
        the order of arguments (including labeled and optional
        arguments) to a function.</p>
      </section>

      <section id="cyclic-dependencies" data-type="sect2">
        <h2>Cyclic Dependencies</h2>

        <p>In most cases, OCaml doesn't allow cyclic dependencies,
        i.e., a collection of definitions that all refer to one
        another. If you want to create such definitions, you typically
        have to mark them specially. For example, when defining a set
        of mutually recursive values (like the definition
        of <code>is_even</code> and <code>is_odd</code>
        in <a href="02-variables-and-functions.html#recursive-functions"
        data-type="xref">Recursive Functions</a>), you need to define
        them using <code>let rec</code> rather than
        ordinary <code>let</code>.

	<idx>dependencies, cyclic</idx>
	<idx>cyclic dependencies</idx>
	<idx>errors/cyclic dependencies</idx>
	<idx>modules/cyclic dependencies</idx></p>

        <p>The same is true at the module level. By default, cyclic
        dependencies between modules are not allowed, and cyclic
        dependencies among files are never allowed. Recursive
        modules are possible but are a rare case, and we won't
        discuss them further here.</p>

        <p>The simplest example of a forbidden circular reference is a
        module referring to its own module name. So, if we tried to
        add a reference to <code>Counter</code> from
        within <code>counter.ml</code>.</p>

        <link rel="import" href="code/files-modules-and-programs/freq-cyclic1/counter.ml" part="1"/>

        <p>we'll see this error when we try to build:</p>
        <link rel="import" href="code/files-modules-and-programs/freq-cyclic1/build.errsh"/>

        <p>The problem manifests in a different way if we create
        cyclic references between files. We could create such a
        situation by adding a reference to <code>Freq</code> from
        <code>counter.ml</code>, e.g., by adding the following
        line.</p>

        <link rel="import" href="code/files-modules-and-programs/freq-cyclic2/counter.ml" part="1"/>

        <p>In this case, 
	  <span class="command"><em>jbuilder</em></span> will
        notice the error and complain explicitly about the cycle:</p>
        <link rel="import"
        href="code/files-modules-and-programs/freq-cyclic2/build.errsh"/>
      </section>
    </section>

    <section data-type="sect1">
      <h1>Designing with Modules</h1>

      <p>The module system is a key part of how an OCaml program is
      structured. As such, we'll close this chapter with some
      advice on how to think about designing that structure
      effectively.</p>

      <section data-type="sect2">
        <h2>Expose Concrete Types Rarely</h2>

        <p>When designing an <code>mli</code>, one choice that you
        need to make is whether to expose the concrete definition
        of your types or leave them abstract. Most of the time,
        abstraction is the right choice, for two reasons: it
        enhances the flexibility of your design, and it makes it
        possible to enforce invariants on the use of your
        module.</p>

        <p>Abstraction enhances flexibility by restricting how
        users can interact with your types, thus reducing the ways
        in which users can depend on the details of your
        implementation. If you expose types explicitly, then users
        can depend on any and every detail of the types you choose.
        If they're abstract, then only the specific operations you
        want to expose are available. This means that you can
        freely change the implementation without affecting clients,
        as long as you preserve the semantics of those
        operations.</p>

        <p>In a similar way, abstraction allows you to enforce
        invariants on your types. If your types are exposed, then
        users of the module can create new instances of that type
        (or if mutable, modify existing instances) in any way
        allowed by the underlying type. That may violate a desired
        invariant <em>i.e.</em>, a property about your type that is
        always supposed to be true. Abstract types allow you to
        protect invariants by making sure that you only expose
        functions that preserves your invariants.</p>

        <p>Despite these benefits, there is a trade-off here. In
        particular, exposing types concretely makes it possible to
        use pattern-matching with those types, which as we saw in
        <span class="keep-together"><a href="03-lists-and-patterns.html#lists-and-patterns" data-type="xref">Lists And Patterns</a></span> is a powerful and
        important tool. You should generally only expose the
        concrete implementation of your types when there's
        significant value in the ability to pattern match, and when
        the invariants that you care about are already enforced by
        the data type itself.</p>
      </section>

      <section data-type="sect2">
        <h2>Design for the Call Site</h2>

        <p>When writing an interface, you should think not just
        about how easy it is to understand the interface for
        someone who reads your carefully documented
        <code>mli</code> file, but more importantly, you want the
        call to be as obvious as possible for someone who is
        reading it at the call site.</p>

        <p>The reason for this is that most of the time, people
        interacting with your API will be doing so by reading and
        modifying code that uses the API, not by reading the
        interface definition. By making your API as obvious as
        possible from that perspective, you simplify the lives of
        your users.</p>

        <p>There are many ways of improving readability at the call
        site. One example is labeled arguments (discussed in
        <a href="02-variables-and-functions.html#labeled-arguments" data-type="xref">Labeled Arguments</a>), which act as
        documentation that is available at the call site.</p>

        <p>You can also improve readability simply by choosing good
        names for your functions, variant tags and record fields.
        Good names aren't always long, to be clear. If you wanted
        to write an anonymous function for doubling a number:
        <code>(fun x -&gt; x * 2)</code>, a short variable name
        like <code>x</code> is best. A good rule of thumb is that
        names that have a small scope should be short, whereas
        names that have a large scope, like the name of a function
        in an a module interface, should be longer and more
        explicit.</p>

        <p>There is of course a tradeoff here, in that making your
        APIs more explicit tends to make them more verbose as well.
        Another useful rule of thumb is that more rarely used names
        should be longer and more explicit, since the cost of
        concision and the benefit of explicitness become more
        important the more often a name is used.</p>
      </section>

      <section data-type="sect2">
        <h2>Create Uniform Interfaces</h2>

        <p>Designing the interface of a module is a task that
        should not be thought of in isolation. The interfaces that
        appear in your codebase should play together harmoniously.
        Part of achieving that is standardizing aspects of those
        interfaces.</p>

        <p><code>Base</code>, <code>Core</code> and other libraries
        from the same family have been designed with a uniform set of
        standards in mind around the design of module interfaces. Here
        are some of the guidelines that they use.</p>

        <ul>
          <li>
            <p><em>A module for (almost) every type.</em> You
            should mint a module for almost every type in your
            program, and the primary type of a given module should
            be called <code>t</code>.</p>
          </li>

          <li>
            <p><em>Put <code>t</code> first</em>. If you have a
            module <code>M</code> whose primary type is
            <code>M.t</code>, the functions in <code>M</code> that
            take a value of <code>M.t</code> should take it as
            their first argument.</p>
          </li>

          <li>
            <p>Functions that routinely throw an exception should
            end in <code>_exn</code>. Otherwise, errors should be
            signaled by returning an <code>option</code> or an
            <code>Or_error.t</code> (both of which are discussed in
            <a href="07-error-handling.html#error-handling" data-type="xref">Error Handling</a> ).</p>
          </li>
        </ul>

        <p>There are also standards in Base about what the type
        signature for specific functions should be. For example,
        the signature for <code>map</code> is always essentially
        the same, no matter what the underlying type it is applied
        to. This kind of function-by-function API uniformity is
        achieved through the use of <em>signature includes</em>,
        which allow for different modules to share components of
        their interface. This approach is described in <a href="09-functors.html#using-multiple-interfaces" data-type="xref">Using Multiple Interfaces</a>.</p>

        <p>Base's standards may or may not fit your projects, but you
        can improve the usability of your codebase by finding some
        consistent set of standards to apply.</p>
      </section>

      <section data-type="sect2">
        <h2>Interfaces before implementations</h2>

        <p>OCaml's concise and flexible type language enables a
        type-oriented approach to software design. Such an approach
        involves thinking through and writing out the types you're
        going to use before embarking on the implementation
        itself.</p>

        <p>This is a good approach both when working in the core
        language, where you would write your type definitions
        before writing the logic of your computations, as well as
        at the module level, where you would write a first draft of
        your <code>mli</code> before working on the
        <code>ml</code>.</p>

        <p>Of course, the design process goes in both directions.
        You'll often find yourself going back and modifying your
        types in response to things you learn by working on the
        implementation. But types and signatures provide a
        lightweight tool for constructing a skeleton of your design
        in a way that helps clarify your goals and intent, before
        you spend a lot of time and effort fleshing it out.</p>
      </section>
    </section>
  </section>
</body>
</html>
