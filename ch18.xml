<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="concurrent-programming-with-async">
      <title>Concurrent Programming with Async</title>

      <para>The logic of building programs that interact with the outside
      world is often dominated by waiting: waiting for the click of a mouse,
      or for data to be fetched from disk, or for space to be available on an
      outgoing network buffer. Even mildly sophisticated interactive
      applications are typically <emphasis>concurrent</emphasis>, needing to
      wait for multiple different events at the same time, responding
      immediately to whatever event happens first.</para>

      <para>One approach to concurrency is to use preemptive system threads,
      which is the dominant approach in languages like Java or C#. In this
      model, each task that may require simultaneous waiting is given an
      operating system thread of its own, so it can block without stopping the
      entire program.</para>

      <para>Another approach is to have a single-threaded program where that
      single thread runs an <emphasis>event loop</emphasis>, whose job is to
      react to external events like timeouts or mouse clicks by invoking a
      callback function that has been registered for that purpose. This
      approach shows up in languages like JavaScript that have single-threaded
      runtimes as well as in many GUI toolkits.</para>

      <para>Each of these mechanisms has its own trade-offs. System threads
      require significant memory and other resources per thread. Also, the
      operating system can arbitrarily interleave the execution of system
      threads, requiring the programmer to carefully protect shared resources
      with locks and condition variables, which is exceedingly
      error-prone.</para>

      <para>Single-threaded event-driven systems, on the other hand, execute a
      single task at a time and do not require the same kind of complex
      synchronization that preemptive threads do. However, the inverted
      control structure of an event-driven program often means that your own
      control flow has to be threaded awkwardly through the system's event
      loop, leading to a maze of event callbacks.</para>

      <para>This chapter covers the Async library, which offers a hybrid model
      that aims to provide the best of both worlds, avoiding the performance
      compromises and synchronization woes of preemptive threads without the
      confusing inversion of control that usually comes with event-driven
      systems.</para>

      <sect1 id="async-basics">
        <title>Async basics</title>

        <para>Recall how I/O is typically done in Core. Here's a simple
        example.</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">async/main.topscript</filename> (part 1)</para>

        <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">In_channel.read_all;;</userinput>
<computeroutput moreinfo="none">- : string -&gt; string = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Out_channel.write_all "test.txt" ~data:"This is only a test.";;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">In_channel.read_all "test.txt";;</userinput>
<computeroutput moreinfo="none">- : string = "This is only a test."</computeroutput></programlisting>

        <para>From the type of <literal moreinfo="none">In_channel.read_all</literal>, you can
        see that it must be a blocking operation. In particular, the fact that
        it returns a concrete string means it can't return until the read has
        completed. The blocking nature of the call means that no progress can
        be made on anything else until the read is completed.</para>

        <para>In Async, well-behaved functions never block. Instead, they
        return a value of type <literal moreinfo="none">Deferred.t</literal> that acts as a
        placeholder that will eventually be filled in with the result. As an
        example, consider the signature of the Async equivalent of
        <literal moreinfo="none">In_channel.read_all</literal>.</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">async/main.topscript</filename> (part 3)</para>

        <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">#require "async";;</userinput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">open Async.Std;;</userinput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Reader.file_contents;;</userinput>
<computeroutput moreinfo="none">- : string -&gt; string Deferred.t = &lt;fun&gt;</computeroutput></programlisting>

        <para>We first load the Async package in the toplevel using
        <literal moreinfo="none">#require</literal>, and then open
        <literal moreinfo="none">Async.Std</literal>, which adds a number of new identifiers
        and modules into our environment that make using Async more
        convenient. Opening <literal moreinfo="none">Async.Std</literal> is standard practice
        for writing programs using Async, much like opening
        <literal moreinfo="none">Core.Std</literal> is for using Core.</para>

        <para>A deferred is essentially a handle to a value that may be
        computed in the future. As such, if we call
        <literal moreinfo="none">Reader.file_contents</literal>, the resulting deferred will
        initially be empty, as you can see by calling
        <literal moreinfo="none">Deferred.peek</literal> on the resulting deferred.</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">async/main.topscript</filename> (part 4)</para>

        <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let contents = Reader.file_contents "test.txt";;</userinput>
<computeroutput moreinfo="none">val contents : string Deferred.t = &lt;abstr&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Deferred.peek contents;;</userinput>
<computeroutput moreinfo="none">- : string option = None</computeroutput></programlisting>

        <para>The value in <literal moreinfo="none">contents</literal> isn't yet determined in
        part because there's nothing running that could do the necessary I/O.
        When using Async, processing of I/O and other events is handled by the
        Async scheduler. When writing a standalone program, you need to start
        the scheduler explicitly, but <command moreinfo="none">utop</command> knows about
        Async, and can start the scheduler automatically. More than that,
        <command moreinfo="none">utop</command> knows about deferred values, and when you type
        in an expression of type <literal moreinfo="none">Deferred.t</literal>, it will make
        sure the scheduler is running and block until the deferred is
        determined. Thus, we can write:</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">async/main.topscript</filename> (part 5)</para>

        <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">contents;;</userinput>
<computeroutput moreinfo="none">- : string = "This is only a test."</computeroutput></programlisting>

        <para>If we peek again, we'll see that the value of
        <literal moreinfo="none">contents</literal> has been determined.</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">async/main.topscript</filename> (part 6)</para>

        <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Deferred.peek contents;;</userinput>
<computeroutput moreinfo="none">- : string option = Some "This is only a test."</computeroutput></programlisting>

        <para>In order to do real work with deferreds, we need a way of
        waiting for a deferred computation to finish, which we do using
        <literal moreinfo="none">Deferred.bind</literal>. First, let's consider the
        type-signature of bind.</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">async/main.topscript</filename> (part 7)</para>

        <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Deferred.bind ;;</userinput>
<computeroutput moreinfo="none">- : 'a Deferred.t -&gt; ('a -&gt; 'b Deferred.t) -&gt; 'b Deferred.t = &lt;fun&gt;</computeroutput></programlisting>

        <para><literal moreinfo="none">Deferred.bind d f</literal> takes a deferred value
        <literal moreinfo="none">d</literal> and a function <literal moreinfo="none">f</literal> that is to be
        run with the value of <literal moreinfo="none">d</literal> once it's determined. You
        can think of <literal moreinfo="none">Deferred.bind</literal> as a kind of sequencing
        operator, and what we're doing is essentially taking an asynchronous
        computation <literal moreinfo="none">d</literal> and tacking on another stage
        comprised by the actions of the function <literal moreinfo="none">f</literal>.</para>

        <para>At a more concrete level, the call to
        <literal moreinfo="none">Deferred.bind</literal> returns a new deferred that becomes
        determined when the deferred returned by <literal moreinfo="none">f</literal> is
        determined. It also implicitly registers with the scheduler an
        <emphasis>Async job</emphasis> that is responsible for running
        <literal moreinfo="none">f</literal> once <literal moreinfo="none">d</literal> is determined.</para>

        <para>Here's a simple use of bind for a function that replaces a file
        with an uppercase version of its contents.</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">async/main.topscript</filename> (part 8)</para>

        <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let uppercase_file filename =</userinput>
<userinput moreinfo="none">    Deferred.bind (Reader.file_contents filename)</userinput>
<userinput moreinfo="none">     (fun text -&gt;</userinput>
<userinput moreinfo="none">         Writer.save filename ~contents:(String.uppercase text))</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val uppercase_file : string -&gt; unit Deferred.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">uppercase_file "test.txt";;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Reader.file_contents "test.txt";;</userinput>
<computeroutput moreinfo="none">- : string = "THIS IS ONLY A TEST."</computeroutput></programlisting>

        <para>Writing out <literal moreinfo="none">Deferred.bind</literal> explicitly can be
        rather verbose, and so <literal moreinfo="none">Async.Std</literal> includes an infix
        operator for it: <literal moreinfo="none">&gt;&gt;=</literal>. Using this operator, we
        can rewrite <literal moreinfo="none">uppercase_file</literal> as follows.</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">async/main.topscript</filename> (part 9)</para>

        <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let uppercase_file filename =</userinput>
<userinput moreinfo="none">    Reader.file_contents filename</userinput>
<userinput moreinfo="none">    &gt;&gt;= fun text -&gt;</userinput>
<userinput moreinfo="none">    Writer.save filename ~contents:(String.uppercase text)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val uppercase_file : string -&gt; unit Deferred.t = &lt;fun&gt;</computeroutput></programlisting>

        <para>In the above we've dropped the parentheses around the function
        on the right-hand side of the bind, and we didn't add a level of
        indentation for the contents of that function. This is standard
        practice for using the bind operator.</para>

        <para>Now let's look at another potential use of bind. In this case,
        we'll write a function that counts the number of lines in a
        file.</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">async/main.topscript</filename> (part 10)</para>

        <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let count_lines filename =</userinput>
<userinput moreinfo="none">    Reader.file_contents filename</userinput>
<userinput moreinfo="none">    &gt;&gt;= fun text -&gt;</userinput>
<userinput moreinfo="none">    List.length (String.split text ~on:'\n')</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">Characters 85-125:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type int but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         'a Deferred.t</computeroutput></programlisting>

        <para>This looks reasonable enough, but as you can see, the compiler
        is unhappy. The issue here is that bind expects a function that
        returns a deferred, but we've provided it a function that returns the
        non-deferred result directly. To make these signatures match, we need
        a function for taking an ordinary value and wrapping it in a deferred.
        This function is a standard part of Async, and is called
        <literal moreinfo="none">return</literal>:</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">async/main.topscript</filename> (part 11)</para>

        <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">return;;</userinput>
<computeroutput moreinfo="none">- : 'a -&gt; 'a Deferred.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let three = return 3;;</userinput>
<computeroutput moreinfo="none">val three : int Deferred.t = &lt;abstr&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">three;;</userinput>
<computeroutput moreinfo="none">- : int = 3</computeroutput></programlisting>

        <para>Using <literal moreinfo="none">return</literal>, we can make
        <literal moreinfo="none">count_lines</literal> compile.</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">async/main.topscript</filename> (part 12)</para>

        <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let count_lines filename =</userinput>
<userinput moreinfo="none">    Reader.file_contents filename</userinput>
<userinput moreinfo="none">    &gt;&gt;= fun text -&gt;</userinput>
<userinput moreinfo="none">    return (List.length (String.split text ~on:'\n'))</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val count_lines : string -&gt; int Deferred.t = &lt;fun&gt;</computeroutput></programlisting>

        <para>Together, <literal moreinfo="none">bind</literal> and <literal moreinfo="none">return</literal>
        form a design pattern in functional programming known as a
        <emphasis>monad</emphasis>. You'll run across this signature in many
        applications beyond just threads. Indeed, we already ran across monads
        in <xref linkend="bind-and-other-error-handling-idioms"/>.</para>

        <para>Calling <literal moreinfo="none">bind</literal> and <literal moreinfo="none">return</literal>
        together is a fairly common pattern, and as such there is a standard
        shortcut for it called <literal moreinfo="none">Deferred.map</literal>, which has the
        following signature:</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">async/main.topscript</filename> (part 13)</para>

        <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Deferred.map;;</userinput>
<computeroutput moreinfo="none">- : 'a Deferred.t -&gt; f:('a -&gt; 'b) -&gt; 'b Deferred.t = &lt;fun&gt;</computeroutput></programlisting>

        <para>and comes with its own infix equivalent,
        <literal moreinfo="none">&gt;&gt;|</literal>. Using it, we can rewrite
        <literal moreinfo="none">count_lines</literal> again a bit more succinctly:</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">async/main.topscript</filename> (part 14)</para>

        <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let count_lines filename =</userinput>
<userinput moreinfo="none">    Reader.file_contents filename</userinput>
<userinput moreinfo="none">    &gt;&gt;| fun text -&gt;</userinput>
<userinput moreinfo="none">    List.length (String.split text ~on:'\n')</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val count_lines : string -&gt; int Deferred.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">count_lines "/etc/hosts";;</userinput>
<computeroutput moreinfo="none">- : int = 12</computeroutput></programlisting>

        <para>Note that <literal moreinfo="none">count_lines</literal> returns a deferred, but
        <command moreinfo="none">utop</command> waits for that deferred to become determined,
        and shows us the contents of the deferred instead.</para>

        <sect2 id="ivars-and-upon">
          <title>Ivars and upon</title>

          <para>Deferreds are usually built using combinations of
          <literal moreinfo="none">bind</literal>, <literal moreinfo="none">map</literal> and
          <literal moreinfo="none">return</literal>, but sometimes you want to construct a
          deferred that you can determine explicitly with user-code. This is
          done using an <emphasis>ivar</emphasis>. (The term ivar dates back
          to a language called Concurrent ML that was developed by John Reppy
          in the early 90's. The "i" in ivar stands for incremental.)</para>

          <para>There are three fundamental operations for working with an
          ivar; you can create one, using <literal moreinfo="none">Ivar.create</literal>, you
          can read off the deferred that corresponds to the ivar in question,
          using <literal moreinfo="none">Ivar.read</literal>, and you can fill an ivar, thus
          causing the corresponding deferred to become determined, using
          <literal moreinfo="none">Ivar.fill</literal>. These operations are illustrated
          below.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">async/main.topscript</filename> (part 15)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let ivar = Ivar.create ();;</userinput>
<computeroutput moreinfo="none">val ivar : '_a Ivar.t = &lt;abstr&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let def = Ivar.read ivar;;</userinput>
<computeroutput moreinfo="none">val def : '_a Deferred.t = &lt;abstr&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Deferred.peek def;;</userinput>
<computeroutput moreinfo="none">- : '_a option = None</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Ivar.fill ivar "Hello";;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Deferred.peek def;;</userinput>
<computeroutput moreinfo="none">- : string option = Some "Hello"</computeroutput></programlisting>

          <para>Ivars are something of a low-level feature; operators like
          map, bind and return are typically easier to use and think about.
          But ivars can be useful when you want to build a synchronization
          patterns that isn't already well supported.</para>

          <para>As an example, imagine we wanted a way of scheduling a
          sequence of actions that would run after a fixed delay. In addition,
          we'd like to guarantee that these delayed actions are executed in
          the same order they were scheduled in. Here's a reasonable signature
          that captures this idea.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">async/main.topscript</filename> (part 16)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module type Delayer_intf = sig</userinput>
<userinput moreinfo="none">    type t</userinput>
<userinput moreinfo="none">    val create : Time.Span.t -&gt; t</userinput>
<userinput moreinfo="none">    val schedule : t -&gt; (unit -&gt; 'a Deferred.t) -&gt; 'a Deferred.t</userinput>
<userinput moreinfo="none">  end;;</userinput>
<computeroutput moreinfo="none">module type Delayer_intf =</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type t</computeroutput>
<computeroutput moreinfo="none">    val create : Core.Span.t -&gt; t</computeroutput>
<computeroutput moreinfo="none">    val schedule : t -&gt; (unit -&gt; 'a Deferred.t) -&gt; 'a Deferred.t</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

          <para>An action is handed to <literal moreinfo="none">schedule</literal> in the form
          of a deferred-returning thunk (a thunk is a function whose argument
          is of type <literal moreinfo="none">unit</literal>). A deferred is handed back to
          the caller of <literal moreinfo="none">schedule</literal> that will eventually be
          filled with the contents of the deferred value returned by the
          thunk. To implement this, we'll use an operator called
          <literal moreinfo="none">upon</literal>, which has the following signature.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">async/main.topscript</filename> (part 17)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">upon;;</userinput>
<computeroutput moreinfo="none">- : 'a Deferred.t -&gt; ('a -&gt; unit) -&gt; unit = &lt;fun&gt;</computeroutput></programlisting>

          <para>Like <literal moreinfo="none">bind</literal> and <literal moreinfo="none">return</literal>,
          <literal moreinfo="none">upon</literal> schedules a callback to be executed when the
          deferred it is passed is determined; but unlike those calls, it
          doesn't create a new deferred for this callback to fill.</para>

          <para>Our delayer implementation is organized around a queue of
          thunks, where every call to <literal moreinfo="none">schedule</literal> adds a thunk
          to the queue, and also schedules a job in the future to grab a thunk
          off the queue and run it. The waiting will be done using the
          function <literal moreinfo="none">after</literal> which takes a time span and
          returns a deferred which becomes determined after that time span
          elapses.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">async/main.topscript</filename> (part 18)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">module Delayer : Delayer_intf = struct</userinput>
<userinput moreinfo="none">    type t = { delay: Time.Span.t;</userinput>
<userinput moreinfo="none">               jobs: (unit -&gt; unit) Queue.t;</userinput>
<userinput moreinfo="none">             }</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    let create delay =</userinput>
<userinput moreinfo="none">      { delay; jobs = Queue.create () }</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    let schedule t thunk =</userinput>
<userinput moreinfo="none">      let ivar = Ivar.create () in</userinput>
<userinput moreinfo="none">      Queue.enqueue t.jobs (fun () -&gt;</userinput>
<userinput moreinfo="none">        upon (thunk ()) (fun x -&gt; Ivar.fill ivar x));</userinput>
<userinput moreinfo="none">      upon (after t.delay) (fun () -&gt;</userinput>
<userinput moreinfo="none">        let job = Queue.dequeue_exn t.jobs in</userinput>
<userinput moreinfo="none">        job ());</userinput>
<userinput moreinfo="none">      Ivar.read ivar</userinput>
<userinput moreinfo="none">  end;;</userinput>
<computeroutput moreinfo="none">module Delayer : Delayer_intf</computeroutput></programlisting>

          <para>This code isn't particularly long, but it is subtle. In
          particular, note how the queue of thunks is used to ensure that the
          enqueued actions are run in order, even if the thunks scheduled by
          <literal moreinfo="none">upon</literal> are run out-of-order. This kind of subtlety
          is typical of code that involves ivars and <literal moreinfo="none">upon</literal>,
          and because of this, you should stick to the simpler map/bind/return
          style of working with deferreds when you can.</para>
        </sect2>
      </sect1>

      <sect1 id="examples-an-echo-server">
        <title>Examples: an echo server</title>

        <para>Now that we have the basics of Async under our belt, let's look
        at a small standalone Async program. In particular, we'll write an
        echo server, <emphasis>i.e.</emphasis>, a program that accepts
        connections from clients and spits back whatever is sent to it.</para>

        <para>The first step is to create a function that can copy data from
        an input to an output. Here, we'll use Async's
        <literal moreinfo="none">Reader</literal> and <literal moreinfo="none">Writer</literal> modules which
        provide a convenient abstraction for working with input and output
        channels.</para>

        <para role="sourcecode">OCaml:
        <filename moreinfo="none">async/echo.ml</filename></para>

        <programlisting language="ocaml" format="linespecific">open Core.Std
open Async.Std

(* Copy data from the reader to the writer, using the provided buffer
   as scratch space *)
let rec copy_blocks buffer r w =
  Reader.read r buffer
  &gt;&gt;= function
  | `Eof -&gt; return ()
  | `Ok bytes_read -&gt;
    Writer.write w buffer ~len:bytes_read;
    Writer.flushed w
    &gt;&gt;= fun () -&gt;
    copy_blocks buffer r w</programlisting>

        <para>Bind is used in the above code to sequence the operations:
        first, we call <literal moreinfo="none">Reader.read</literal> to get a block of input.
        Then, when that's complete and if a new block was returned, we write
        that block to the writer. Finally, we wait until the writer's buffers
        are flushed, waiting on the deferred returned by
        <literal moreinfo="none">Writer.flushed</literal>, at which point we recurse. If we
        hit an end-of-file condition, the loop is ended. The deferred returned
        by a call to <literal moreinfo="none">copy_blocks</literal> becomes determined only
        once the end-of-file condition is hit.</para>

        <para>One important aspect of how this is written is that it uses
        <emphasis>pushback</emphasis>, which is to say that if the writer
        can't make progress writing, the reader will stop reading. If you
        don't implement pushback in your servers, then a stopped client can
        cause your program to leak memory, since you'll need to allocate space
        for the data that's been read in but not yet written out.</para>

        <para>You might also be concerned that the chain of deferreds that is
        built up as you go through the loop would lead to a memory leak. After
        all, this code constructs an ever-growing chain of binds, each of
        which creates a deferred. In this case, however, all of the deferreds
        should become determined precisely when the final deferred in the
        chain is determined, in this case, when the <literal moreinfo="none">Eof</literal>
        condition is hit. Because of this, we could safely replace all of
        these deferreds with a single deferred. Async has logic to do just
        this, and so there's no memory leak after all. This is essentially a
        form of tail-call optimization, lifted to the Async monad.</para>

        <para><literal moreinfo="none">copy_blocks</literal> provides the logic for handling a
        client connection, but we still need to set up a server to receive
        such connections and dispatch to <literal moreinfo="none">copy_blocks</literal>. For
        this, we'll use Async's <literal moreinfo="none">Tcp</literal> module, which has a
        collection of utilities for creating TCP clients and servers.</para>

        <para role="sourcecode">OCaml: <filename moreinfo="none">async/echo.ml</filename>
        (part 1)</para>

        <programlisting language="ocaml" format="linespecific">(** Starts a TCP server, which listens on the specified port, invoking
    copy_blocks every time a client connects. *)
let run () =
  let host_and_port =
    Tcp.Server.create
      ~on_handler_error:`Raise
      (Tcp.on_port 8765)
      (fun _addr r w -&gt;
         let buffer = String.create (16 * 1024) in
         copy_blocks buffer r w)
  in
  ignore (host_and_port : (Socket.Address.Inet.t, int) Tcp.Server.t Deferred.t)</programlisting>

        <para>The result of calling <literal moreinfo="none">Tcp.Server.create</literal> is a
        <literal moreinfo="none">Tcp.Server.t</literal>, which is a handle to the server that
        lets you shut the server down. We don't use that functionality here,
        so we explicitly ignore <literal moreinfo="none">server</literal> to suppress the
        unused-variables error. We put in a type annotation around the ignored
        value to make the nature of the value we're ignoring explicit.</para>

        <para>The most important argument to
        <literal moreinfo="none">Tcp.Server.create</literal> is the final one, which is the
        client connection handler. Notably, the above code does nothing
        explicit to close down the client connections when the communication
        is done. That's because the server will automatically shut down the
        connection once the deferred returned by the handler becomes
        determined.</para>

        <para>Finally, we need to initiate the server and start the Async
        scheduler.</para>

        <para role="sourcecode">OCaml: <filename moreinfo="none">async/echo.ml</filename>
        (part 2)</para>

        <programlisting language="ocaml" format="linespecific">(* Call [run], and then start the scheduler *)
let () =
  run ();
  never_returns (Scheduler.go ())</programlisting>

        <para>One of the most common newbie errors with Async is to forget to
        run the scheduler. It can be a bewildering mistake, because without
        the scheduler, your program won't do anything at all; even calls to
        <literal moreinfo="none">printf</literal> won't reach the terminal.</para>

        <para>It's worth noting that even though we didn't spend much explicit
        effort on thinking about multiple clients, this server is able to
        handle many concurrent clients without further modification.</para>

        <para>Now that we have the echo server, we can connect to the echo
        server using the netcat tool, which is invoked as
        <literal moreinfo="none">nc</literal>.</para>

        <para role="sourcecode">Terminal:
        <filename moreinfo="none">async/run_echo.out</filename></para>

        <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./echo.native &amp;</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">nc 127.0.0.1 8765</userinput>
<computeroutput moreinfo="none">This is an echo server</computeroutput>
<computeroutput moreinfo="none">This is an echo server</computeroutput>
<computeroutput moreinfo="none">It repeats whatever I write.</computeroutput>
<computeroutput moreinfo="none">It repeats whatever I write.</computeroutput></programlisting>

        <sidebar>
          <title>Functions that never return</title>

          <para>You might wonder what's going on with the call to
          <literal moreinfo="none">never_returns</literal> above.
          <literal moreinfo="none">never_returns</literal> is an idiom that comes from
          <literal moreinfo="none">Core</literal> that is used to mark functions that don't
          return. Typically, a function that doesn't return is inferred as
          having return type <literal moreinfo="none">'a</literal>.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">async/main.topscript</filename> (part 19)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec loop_forever () = loop_forever ();;</userinput>
<computeroutput moreinfo="none">val loop_forever : unit -&gt; 'a = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let always_fail () = assert false;;</userinput>
<computeroutput moreinfo="none">val always_fail : unit -&gt; 'a = &lt;fun&gt;</computeroutput></programlisting>

          <para>This can be surprising when you call a function like this
          expecting it to return unit. The type-checker won't necessarily
          complain in such a case.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">async/main.topscript</filename> (part 20)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let do_stuff n =</userinput>
<userinput moreinfo="none">    let x = 3 in</userinput>
<userinput moreinfo="none">    if n &gt; 0 then loop_forever ();</userinput>
<userinput moreinfo="none">    x + n</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val do_stuff : int -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

          <para>With a name like <literal moreinfo="none">loop_forever</literal>, the meaning
          is clear enough. But with something like
          <literal moreinfo="none">Scheduler.go</literal>, the fact that it never returns is
          less clear, and so we use the type system to make it more explicit
          by giving it a return type of <literal moreinfo="none">never_returns</literal>.
          Let's do the same trick with <literal moreinfo="none">loop_forever</literal>.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">async/main.topscript</filename> (part 21)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let rec loop_forever () : never_returns = loop_forever ();;</userinput>
<computeroutput moreinfo="none">val loop_forever : unit -&gt; never_returns = &lt;fun&gt;</computeroutput></programlisting>

          <para>The type <literal moreinfo="none">never_returns</literal> is uninhabited, so a
          function can't return a value of type
          <literal moreinfo="none">never_returns</literal>, which means only a function that
          never return can have <literal moreinfo="none">never_returns</literal> as its return
          type! Now, if we rewrite our <literal moreinfo="none">do_stuff</literal> function,
          we'll get a helpful type error.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">async/main.topscript</filename> (part 22)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let do_stuff n =</userinput>
<userinput moreinfo="none">    let x = 3 in</userinput>
<userinput moreinfo="none">    if n &gt; 0 then loop_forever ();</userinput>
<userinput moreinfo="none">    x + n</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">Characters 38-67:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type unit but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         never_returns</computeroutput></programlisting>

          <para>We can resolve the error by calling the function
          <literal moreinfo="none">never_returns</literal>.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">async/main.topscript</filename> (part 23)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">never_returns;;</userinput>
<computeroutput moreinfo="none">- : never_returns -&gt; 'a = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let do_stuff n =</userinput>
<userinput moreinfo="none">    let x = 3 in</userinput>
<userinput moreinfo="none">    if n &gt; 0 then never_returns (loop_forever ());</userinput>
<userinput moreinfo="none">    x + n</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val do_stuff : int -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

          <para>Thus, we got the compilation to go through by explicitly
          marking in the source that the call to
          <literal moreinfo="none">loop_forever</literal> never returns.</para>
        </sidebar>

        <sect2 id="improving-the-echo-server">
          <title>Improving the echo server</title>

          <para>Let's try to go a little bit farther with our echo server by
          walking through a few improvements. In particular, we will</para>

          <itemizedlist>
            <listitem>
              <para>add a proper command-line interface with
              <literal moreinfo="none">Command</literal>,</para>
            </listitem>

            <listitem>
              <para>add a flag to specify the port to listen on, and a flag to
              make the server echo back the capitalized version of whatever
              was sent to it,</para>
            </listitem>

            <listitem>
              <para>simplify the code using Async's <literal moreinfo="none">Pipe</literal>
              interface.</para>
            </listitem>
          </itemizedlist>

          <para>The code below does all of this.</para>

          <para role="sourcecode">OCaml:
          <filename moreinfo="none">async/better_echo.ml</filename></para>

          <programlisting language="ocaml" format="linespecific">open Core.Std
open Async.Std

let run ~uppercase ~port =
  let host_and_port =
    Tcp.Server.create
      ~on_handler_error:`Raise
      (Tcp.on_port port)
      (fun _addr r w -&gt;
        Pipe.transfer (Reader.pipe r) (Writer.pipe w)
           ~f:(if uppercase then String.uppercase else Fn.id))
  in
  ignore (host_and_port : (Socket.Address.Inet.t, int) Tcp.Server.t Deferred.t);
  Deferred.never ()

let () =
  Command.async_basic
    ~summary:"Start an echo server"
    Command.Spec.(
      empty
      +&gt; flag "-uppercase" no_arg
        ~doc:" Convert to uppercase before echoing back"
      +&gt; flag "-port" (optional_with_default 8765 int)
        ~doc:" Port to listen on (default 8765)"
    )
    (fun uppercase port () -&gt; run ~uppercase ~port)
  |&gt; Command.run</programlisting>

          <para>Note the use of <literal moreinfo="none">Deferred.never</literal> in the
          <literal moreinfo="none">run</literal> function. As you might guess from the name
          <literal moreinfo="none">Deferred.never</literal> returns a deferred that is never
          determined. In this case, that indicates that the echo server
          doesn't ever shut down.</para>

          <para>The biggest change in the above code is the use of Async's
          <literal moreinfo="none">Pipe</literal>. A <literal moreinfo="none">Pipe</literal> is an
          asynchronous communication channel that's used for connecting
          different parts of your program. You can think of it as a
          consumer/producer queue that uses deferreds for communicating when
          the pipe is ready to be read from or written to. Our use of pipes is
          fairly minimal here, but they are an important part of Async, so
          it's worth discussing them in some detail.</para>

          <para>Pipes are created in connected read/write pairs, as you can
          see below.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">async/main.topscript</filename> (part 24)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let (r,w) = Pipe.create ();;</userinput>
<computeroutput moreinfo="none">val r : '_a Pipe.Reader.t = &lt;abstr&gt;</computeroutput>
<computeroutput moreinfo="none">val w : '_a Pipe.Writer.t = &lt;abstr&gt;</computeroutput></programlisting>

          <para><literal moreinfo="none">r</literal> and <literal moreinfo="none">w</literal> are really just
          read and write handles to the same underlying object. Note that
          <literal moreinfo="none">r</literal> and <literal moreinfo="none">w</literal> have weakly
          polymorphic types, as discussed in <xref linkend="imperative-programming"/>, and so can only contain values
          of a single yet to be determined type.</para>

          <para>If we just try and write to the writer, we'll see that we
          block indefinitely in <command moreinfo="none">utop</command>. You can break out of
          the wait by hitting <literal moreinfo="none">Control-C</literal>.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">async/pipe_write_break.rawscript</filename></para>

          <programlisting language="ocaml" format="linespecific"><userinput moreinfo="none"># Pipe.write w "Hello World!";;</userinput>
<computeroutput moreinfo="none">Interrupted.</computeroutput></programlisting>

          <para>The deferred returned by write completes on its own once the
          value written into the pipe has been read out:</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">async/main.topscript</filename> (part 25)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let (r,w) = Pipe.create ();;</userinput>
<computeroutput moreinfo="none">val r : '_a Pipe.Reader.t = &lt;abstr&gt;</computeroutput>
<computeroutput moreinfo="none">val w : '_a Pipe.Writer.t = &lt;abstr&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let write_complete = Pipe.write w "Hello World!";;</userinput>
<computeroutput moreinfo="none">val write_complete : unit Deferred.t = &lt;abstr&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Pipe.read r;;</userinput>
<computeroutput moreinfo="none">- : [ `Eof | `Ok of string ] = `Ok "Hello World!"</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">write_complete;;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput></programlisting>

          <para>In the function <literal moreinfo="none">run</literal> above, we're taking
          advantage of one of the many utility functions provided for pipes in
          the <literal moreinfo="none">Pipe</literal> module. In particular, we're using
          <literal moreinfo="none">Pipe.transfer</literal> to set up a process that takes data
          from a reader-pipe and moves it to a writer-pipe. Here's the type of
          <literal moreinfo="none">Pipe.transfer</literal>:</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">async/main.topscript</filename> (part 26)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Pipe.transfer;;</userinput>
<computeroutput moreinfo="none">- : 'a Pipe.Reader.t -&gt; 'b Pipe.Writer.t -&gt; f:('a -&gt; 'b) -&gt; unit Deferred.t =</computeroutput>
<computeroutput moreinfo="none">&lt;fun&gt;</computeroutput></programlisting>

          <para>The two pipes being connected are generated by the
          <literal moreinfo="none">Reader.pipe</literal> and <literal moreinfo="none">Writer.pipe</literal>
          call respectively. Note that pushback is preserved throughout the
          process, so that if the writer gets blocked, the writer's pipe will
          stop pulling data from the reader's pipe, which will prevent the
          reader from reading in more data.</para>

          <para>Importantly, the deferred returned by
          <literal moreinfo="none">Pipe.transfer</literal> becomes determined once the reader
          has been closed and the last element is transferred from the reader
          to the writer. Once that deferred becomes determined, the server
          will shut down that client connection. So, when a client
          disconnects, the rest of the shutdown happens transparently.</para>

          <para>The command-line parsing for this program is based on the
          <literal moreinfo="none">Command</literal> library that we introduced in <xref linkend="command-line-parsing"/>. Opening
          <literal moreinfo="none">Async.Std</literal>, shadows the <literal moreinfo="none">Command</literal>
          module with an extended version that contains the
          <literal moreinfo="none">async_basic</literal> call.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">async/main.topscript</filename> (part 27)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Command.async_basic;;</userinput>
<computeroutput moreinfo="none">- : summary:string -&gt;</computeroutput>
<computeroutput moreinfo="none">    ?readme:(unit -&gt; string) -&gt;</computeroutput>
<computeroutput moreinfo="none">    ('a, unit -&gt; unit Deferred.t) Command.Spec.t -&gt; 'a -&gt; Command.t</computeroutput>
<computeroutput moreinfo="none">= &lt;fun&gt;</computeroutput></programlisting>

          <para>This differs from the ordinary
          <literal moreinfo="none">Command.basic</literal> call in that the main function must
          return a <literal moreinfo="none">Deferred.t</literal>, and that the running of the
          command (using <literal moreinfo="none">Command.run</literal>) automatically starts
          the async scheduler, without requiring an explicit call to
          <literal moreinfo="none">Scheduler.go</literal>.</para>
        </sect2>
      </sect1>

      <sect1 id="example-searching-definitions-with-duckduckgo">
        <title>Example: searching definitions with DuckDuckGo</title>

        <para>DuckDuckGo is a search engine with a freely available search
        interface. In this section, we'll use Async to write a small
        command-line utility for querying DuckDuckGo to extract definitions
        for a collection of terms.</para>

        <para>Our code is going to rely on a number of other libraries, all of
        which can be installed using OPAM. Refer to <xref linkend="installation"/> if you need help on the installation. Here's
        the list of libraries we'll need.</para>

        <itemizedlist>
          <listitem>
            <para><literal moreinfo="none">textwrap</literal>, a library for wrapping long
            lines. We'll use this for printing out our results.</para>
          </listitem>

          <listitem>
            <para><literal moreinfo="none">uri</literal>, a library for handling URIs, or
            "Uniform Resource Identifiers", of which HTTP URL's are an
            example.</para>
          </listitem>

          <listitem>
            <para><literal moreinfo="none">yojson</literal>, a JSON parsing library that was
            described in <xref linkend="handling-json-data"/></para>
          </listitem>

          <listitem>
            <para><literal moreinfo="none">cohttp</literal>, a library for creating HTTP
            clients and servers. We need Async support, which comes with the
            <literal moreinfo="none">cohttp.async</literal> package.</para>
          </listitem>
        </itemizedlist>

        <para>Now let's dive into the implementation.</para>

        <sect2 id="uri-handling">
          <title>URI handling</title>

          <para>HTTP URLs, which identify endpoints across the web, are
          actually part of a more general family known as Uniform Resource
          Identifiers (URIs). The full URI specification is defined in <ulink url="http://tools.ietf.org/html/rfc3986">RFC3986</ulink>, and is
          rather complicated. Luckily, the <literal moreinfo="none">uri</literal> library
          provides a strongly-typed interface which takes care of much of the
          hassle.</para>

          <para>We'll need a function for generating the URIs that we're going
          to use to query the DuckDuckGo servers.</para>

          <para role="sourcecode">OCaml:
          <filename moreinfo="none">async/search.ml</filename></para>

          <programlisting language="ocaml" format="linespecific">open Core.Std
open Async.Std

(* Generate a DuckDuckGo search URI from a query string *)
let query_uri query =
  let base_uri = Uri.of_string "http://api.duckduckgo.com/?format=json" in
  Uri.add_query_param base_uri ("q", [query])</programlisting>

          <para>A <literal moreinfo="none">Uri.t</literal> is constructed from the
          <literal moreinfo="none">Uri.of_string</literal> function, and a query parameter
          <literal moreinfo="none">q</literal> is added with the desired search query. The
          library takes care of encoding the URI correctly when outputting it
          in the network protocol.</para>
        </sect2>

        <sect2 id="parsing-json-strings">
          <title>Parsing JSON strings</title>

          <para>The HTTP response from DuckDuckGo is in JSON, a common (and
          thankfully simple) format that is specified in <ulink url="http://www.ietf.org/rfc/rfc4627.txt">RFC4627</ulink>. We'll
          parse the JSON data using the Yojson library, which was introduced
          in <xref linkend="handling-json-data"/>.</para>

          <para>We expect the response from DuckDuckGo to come across as a
          JSON record, which is represented by the <literal moreinfo="none">Assoc</literal>
          tag in Yojson's JSON variant. We expect the definition itself to
          come across under either the key "Abstract" or "Definition", and so
          the code below looks under both keys, returning the first one for
          which a non-empty value is defined.</para>

          <para role="sourcecode">OCaml: <filename moreinfo="none">async/search.ml</filename>
          (part 1)</para>

          <programlisting language="ocaml" format="linespecific">(* Extract the "Definition" or "Abstract" field from the DuckDuckGo results *)
let get_definition_from_json json =
  match Yojson.Safe.from_string json with
  | `Assoc kv_list -&gt;
    let find key =
      begin match List.Assoc.find kv_list key with
      | None | Some (`String "") -&gt; None
      | Some s -&gt; Some (Yojson.Safe.to_string s)
      end
    in
    begin match find "Abstract" with
    | Some _ as x -&gt; x
    | None -&gt; find "Definition"
    end
  | _ -&gt; None</programlisting>
        </sect2>

        <sect2 id="executing-an-http-client-query">
          <title>Executing an HTTP client query</title>

          <para>Now let's look at the code for dispatching the search queries
          over HTTP, using the Cohttp library.</para>

          <para role="sourcecode">OCaml: <filename moreinfo="none">async/search.ml</filename>
          (part 2)</para>

          <programlisting language="ocaml" format="linespecific">(* Execute the DuckDuckGo search *)
let get_definition word =
  Cohttp_async.Client.get (query_uri word)
  &gt;&gt;= fun (_, body) -&gt;
  Pipe.to_list body
  &gt;&gt;| fun strings -&gt;
  (word, get_definition_from_json (String.concat strings))</programlisting>

          <para>To better understand what's going on, it's useful to look at
          the type for <literal moreinfo="none">Cohttp_async.Client.get</literal>, which we
          can do in <command moreinfo="none">utop</command>.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">async/main.topscript</filename> (part 28)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">#require "cohttp.async";;</userinput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Cohttp_async.Client.get;;</userinput>
<computeroutput moreinfo="none">- : ?interrupt:unit Deferred.t -&gt;</computeroutput>
<computeroutput moreinfo="none">    ?headers:Cohttp.Header.t -&gt;</computeroutput>
<computeroutput moreinfo="none">    Uri.t -&gt; (Cohttp.Response.t * string Pipe.Reader.t) Deferred.t</computeroutput>
<computeroutput moreinfo="none">= &lt;fun&gt;</computeroutput></programlisting>

          <para>The <literal moreinfo="none">get</literal> call takes as a required argument a
          URI, and returns a deferred value containing a
          <literal moreinfo="none">Cohttp.Response.t</literal> (which we ignore) and a pipe
          reader to which the body of the request will be written.</para>

          <para>In this case, the HTTP body probably isn't very large, so we
          call <literal moreinfo="none">Pipe.to_list</literal> to collect the strings from the
          pipe as a single deferred list of strings. We then join those
          strings using <literal moreinfo="none">String.concat</literal> and pass the result
          through our parsing function.</para>

          <para>Running a single search isn't that interesting from a
          concurrency perspective, so let's write code for dispatching
          multiple searches in parallel. First, we need code for formatting
          and printing out the search result.</para>

          <para role="sourcecode">OCaml: <filename moreinfo="none">async/search.ml</filename>
          (part 3)</para>

          <programlisting language="ocaml" format="linespecific">(* Print out a word/definition pair *)
let print_result (word,definition) =
  printf "%s\n%s\n\n%s\n\n"
    word
    (String.init (String.length word) ~f:(fun _ -&gt; '-'))
    (match definition with
    | None -&gt; "No definition found"
    | Some def -&gt;
      String.concat ~sep:"\n"
        (Wrapper.wrap (Wrapper.make 70) def))</programlisting>

          <para>We use the <literal moreinfo="none">Wrapper</literal> module from the
          <literal moreinfo="none">textwrap</literal> package to do the line-wrapping. It may
          not be obvious that this routine is using Async, but it does: the
          version of <literal moreinfo="none">printf</literal> that's called here is actually
          Async's specialized <literal moreinfo="none">printf</literal> that goes through the
          Async scheduler rather than printing directly. The original
          definition of <literal moreinfo="none">printf</literal> is shadowed by this new one
          when you open <literal moreinfo="none">Async.Std</literal>. An important side effect
          of this is that if you write an Async program and forget to start
          the scheduler, calls like <literal moreinfo="none">printf</literal> won't actually
          generate any output!</para>

          <para>The next function dispatches the searches in parallel, waits
          for the results, and then prints.</para>

          <para role="sourcecode">OCaml: <filename moreinfo="none">async/search.ml</filename>
          (part 4)</para>

          <programlisting language="ocaml" format="linespecific">(* Run many searches in parallel, printing out the results after they're all
   done. *)
let search_and_print words =
  Deferred.all (List.map words ~f:get_definition)
  &gt;&gt;| fun results -&gt;
  List.iter results ~f:print_result</programlisting>

          <para>We used <literal moreinfo="none">List.map</literal> to call
          <literal moreinfo="none">get_definition</literal> on each word, and
          <literal moreinfo="none">Deferred.all</literal> to wait for all the results. Here's
          the type of <literal moreinfo="none">Deferred.all</literal>:</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">async/main.topscript</filename> (part 29)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Deferred.all;;</userinput>
<computeroutput moreinfo="none">- : 'a Deferred.t list -&gt; 'a list Deferred.t = &lt;fun&gt;</computeroutput></programlisting>

          <para>Note that the list returned by <literal moreinfo="none">Deferred.all</literal>
          reflects the order of the deferreds passed to it. As such, the
          definitions will be printed out in the same order that the search
          words are passed in, no matter what orders the queries return in. We
          could rewrite this code to print out the results as they're received
          (and thus potentially out of order) as follows.</para>

          <para role="sourcecode">OCaml:
          <filename moreinfo="none">async/search_out_of_order.ml</filename> (part 1)</para>

          <programlisting language="ocaml" format="linespecific">(* Run many searches in parallel, printing out the results as you go *)
let search_and_print words =
  Deferred.all_unit (List.map words ~f:(fun word -&gt;
    get_definition word &gt;&gt;| print_result))</programlisting>

          <para>The difference is that we both dispatch the query and print
          out the result in the closure passed to <literal moreinfo="none">map</literal>,
          rather than waiting for all of the results to get back and then
          printing them out together. We use
          <literal moreinfo="none">Deferred.all_unit</literal>, which takes a list of
          <literal moreinfo="none">unit</literal> deferreds and returns a single
          <literal moreinfo="none">unit</literal> deferred that becomes determined when every
          deferred on the input list is determined. We can see the type of
          this function in <command moreinfo="none">utop</command>.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">async/main.topscript</filename> (part 30)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Deferred.all_unit;;</userinput>
<computeroutput moreinfo="none">- : unit Deferred.t list -&gt; unit Deferred.t = &lt;fun&gt;</computeroutput></programlisting>

          <para>Finally, we create a command line interface using
          <literal moreinfo="none">Command.async_basic</literal>.</para>

          <para role="sourcecode">OCaml: <filename moreinfo="none">async/search.ml</filename>
          (part 5)</para>

          <programlisting language="ocaml" format="linespecific">let () =
  Command.async_basic
    ~summary:"Retrieve definitions from duckduckgo search engine"
    Command.Spec.(
      empty
      +&gt; anon (sequence ("word" %: string))
    )
    (fun words () -&gt; search_and_print words)
  |&gt; Command.run</programlisting>

          <para>And that's all we need for a simple but usable definition
          searcher.</para>

          <para role="sourcecode">Terminal:
          <filename moreinfo="none">async/run_search.out</filename></para>

          <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg cohttp.async,yojson,textwrap search.native</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./search.native "Concurrent Programming" "OCaml"</userinput>
<computeroutput moreinfo="none">Concurrent Programming</computeroutput>
<computeroutput moreinfo="none">----------------------</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">"Concurrent computing is a form of computing in which programs are</computeroutput>
<computeroutput moreinfo="none">designed as collections of interacting computational processes that</computeroutput>
<computeroutput moreinfo="none">may be executed in parallel."</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">OCaml</computeroutput>
<computeroutput moreinfo="none">-----</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">"OCaml, originally known as Objective Caml, is the main implementation</computeroutput>
<computeroutput moreinfo="none">of the Caml programming language, created by Xavier Leroy, Jrme</computeroutput>
<computeroutput moreinfo="none">Vouillon, Damien Doligez, Didier Rmy and others in 1996."</computeroutput>
<computeroutput moreinfo="none"> </computeroutput></programlisting>
        </sect2>
      </sect1>

      <sect1 id="exception-handling">
        <title>Exception handling</title>

        <para>When programming with external resources, errors are everywhere:
        everything from a flaky server to a network outage to exhausting of
        local resources can lead to a runtime error. When programming in
        OCaml, some of these errors will show up explicitly in a function's
        return type, and some of them will show up as exceptions. We covered
        exception handling in OCaml in <xref linkend="exceptions"/>, but as
        we'll see, exception handling in a concurrent program presents some
        new challenges.</para>

        <para>Let's get a better sense of how exceptions work in Async by
        creating an asynchronous computation that (sometimes) fails with an
        exception. The function <literal moreinfo="none">maybe_raise</literal> below blocks
        for half a second, and then either throws an exception or returns
        unit, alternating between the two behaviors on subsequent
        calls.</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">async/main.topscript</filename> (part 31)</para>

        <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let maybe_raise =</userinput>
<userinput moreinfo="none">    let should_fail = ref false in</userinput>
<userinput moreinfo="none">    fun () -&gt;</userinput>
<userinput moreinfo="none">      let will_fail = !should_fail in</userinput>
<userinput moreinfo="none">      should_fail := not will_fail;</userinput>
<userinput moreinfo="none">      after (Time.Span.of_sec 0.5)</userinput>
<userinput moreinfo="none">      &gt;&gt;= fun () -&gt;</userinput>
<userinput moreinfo="none">      if will_fail then raise Exit else return ()</userinput>
<userinput moreinfo="none"> ;;</userinput>
<computeroutput moreinfo="none">val maybe_raise : unit -&gt; unit Deferred.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">maybe_raise ();;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">maybe_raise ();;</userinput>
<computeroutput moreinfo="none">Exception:</computeroutput>
<computeroutput moreinfo="none">(lib/monitor.ml.Error_</computeroutput>
<computeroutput moreinfo="none"> ((exn Exit) (backtrace (""))</computeroutput>
<computeroutput moreinfo="none">  (monitor</computeroutput>
<computeroutput moreinfo="none">   (((name block_on_async) (here ()) (id 55) (has_seen_error true)</computeroutput>
<computeroutput moreinfo="none">     (someone_is_listening true) (kill_index 0))</computeroutput>
<computeroutput moreinfo="none">    ((name main) (here ()) (id 1) (has_seen_error false)</computeroutput>
<computeroutput moreinfo="none">     (someone_is_listening false) (kill_index 0)))))).</computeroutput></programlisting>

        <para>In <command moreinfo="none">utop</command>, the exception thrown by
        <literal moreinfo="none">maybe_raise ()</literal> terminates the evaluation of just
        that expression, but in a standalone program, an uncaught exception
        would bring down the entire process.</para>

        <para>So, how could we capture and handle such an exception? You might
        try to do this using OCaml's built-in <literal moreinfo="none">try/with</literal>
        statement, but as you can see below, that doesn't quite do the
        trick.</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">async/main.topscript</filename> (part 32)</para>

        <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let handle_error () =</userinput>
<userinput moreinfo="none">    try</userinput>
<userinput moreinfo="none">      maybe_raise ()</userinput>
<userinput moreinfo="none">      &gt;&gt;| fun () -&gt; "success"</userinput>
<userinput moreinfo="none">    with _ -&gt; return "failure"</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val handle_error : unit -&gt; string Deferred.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">handle_error ();;</userinput>
<computeroutput moreinfo="none">- : string = "success"</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">handle_error ();;</userinput>
<computeroutput moreinfo="none">Exception:</computeroutput>
<computeroutput moreinfo="none">(lib/monitor.ml.Error_</computeroutput>
<computeroutput moreinfo="none"> ((exn Exit) (backtrace (""))</computeroutput>
<computeroutput moreinfo="none">  (monitor</computeroutput>
<computeroutput moreinfo="none">   (((name block_on_async) (here ()) (id 59) (has_seen_error true)</computeroutput>
<computeroutput moreinfo="none">     (someone_is_listening true) (kill_index 0))</computeroutput>
<computeroutput moreinfo="none">    ((name main) (here ()) (id 1) (has_seen_error false)</computeroutput>
<computeroutput moreinfo="none">     (someone_is_listening false) (kill_index 0)))))).</computeroutput></programlisting>

        <para>This didn't work because <literal moreinfo="none">try/with</literal> only
        captures exceptions that are thrown in the code directly executed
        within it, while <literal moreinfo="none">maybe_raise</literal> schedules an Async job
        to run in the future, and it's that job that throws an
        exception.</para>

        <para>We can capture this kind of asynchronous error use the
        <literal moreinfo="none">try_with</literal> function provided by Async:</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">async/main.topscript</filename> (part 33)</para>

        <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let handle_error () =</userinput>
<userinput moreinfo="none">    try_with (fun () -&gt; maybe_raise ())</userinput>
<userinput moreinfo="none">    &gt;&gt;| function</userinput>
<userinput moreinfo="none">    | Ok ()   -&gt; "success"</userinput>
<userinput moreinfo="none">    | Error _ -&gt; "failure"</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val handle_error : unit -&gt; string Deferred.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">handle_error ();;</userinput>
<computeroutput moreinfo="none">- : string = "success"</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">handle_error ();;</userinput>
<computeroutput moreinfo="none">- : string = "failure"</computeroutput></programlisting>

        <para><literal moreinfo="none">try_with f</literal> takes as its argument a
        deferred-returning thunk <literal moreinfo="none">f</literal>, and returns a deferred
        that becomes determined either as <literal moreinfo="none">Ok</literal> of whatever
        <literal moreinfo="none">f</literal> returned, or <literal moreinfo="none">Error exn</literal> if
        <literal moreinfo="none">f</literal> threw an exception before its return value became
        determined.</para>

        <sect2 id="monitors">
          <title>Monitors</title>

          <para><literal moreinfo="none">try_with</literal> is a great way of handling
          exceptions in Async, but it's not the whole story. All of Async's
          exception-handling mechanisms, <literal moreinfo="none">try_with</literal> included,
          are built on top of Async's system of <emphasis>monitors</emphasis>,
          which are inspired by the error-handling mechanism in Erlang of the
          same name. Monitors are fairly low-level and are only occasionally
          used directly, but it's nonetheless worth understanding how they
          work.</para>

          <para>In Async, a monitor is a context that determines what to do
          when there is an unhandled exception. Every Async job runs within
          the context of some monitor, which, when the job is running, is
          referred to as the current monitor. When a new Async job is
          scheduled, say, using <literal moreinfo="none">bind</literal> or
          <literal moreinfo="none">map</literal>, it inherits the current monitor of the job
          that spawned it.</para>

          <para>Monitors are arranged in a treewhen a new monitor is created
          (say, using <literal moreinfo="none">Monitor.create</literal>) it is a child of the
          current monitor. You can explicitly run jobs within a monitor using
          <literal moreinfo="none">within</literal>, which takes a thunk that returns a
          non-deferred value, or <literal moreinfo="none">within'</literal>, which takes a
          thunk that returns a deferred. Here's an example.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">async/main.topscript</filename> (part 34)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let blow_up () =</userinput>
<userinput moreinfo="none">    let monitor = Monitor.create ~name:"blow up monitor" () in</userinput>
<userinput moreinfo="none">    within' ~monitor maybe_raise</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val blow_up : unit -&gt; unit Deferred.t = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">blow_up ();;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">blow_up ();;</userinput>
<computeroutput moreinfo="none">Exception:</computeroutput>
<computeroutput moreinfo="none">(lib/monitor.ml.Error_</computeroutput>
<computeroutput moreinfo="none"> ((exn Exit) (backtrace (""))</computeroutput>
<computeroutput moreinfo="none">  (monitor</computeroutput>
<computeroutput moreinfo="none">   (((name "blow up monitor") (here ()) (id 71) (has_seen_error true)</computeroutput>
<computeroutput moreinfo="none">     (someone_is_listening false) (kill_index 0))</computeroutput>
<computeroutput moreinfo="none">    ((name block_on_async) (here ()) (id 70) (has_seen_error false)</computeroutput>
<computeroutput moreinfo="none">     (someone_is_listening true) (kill_index 0))</computeroutput>
<computeroutput moreinfo="none">    ((name main) (here ()) (id 1) (has_seen_error false)</computeroutput>
<computeroutput moreinfo="none">     (someone_is_listening false) (kill_index 0)))))).</computeroutput></programlisting>

          <para>In addition to the ordinary stack-trace, the exception
          displays the trace of monitors through which the exception traveled,
          starting at the one we created, called "blow up monitor". The other
          monitors you see come from <command moreinfo="none">utop</command>'s special
          handling of deferreds.</para>

          <para>Monitors can do more than just augment the error-trace of an
          exception. You can also use a monitor to explicitly handle errors
          delivered to that monitor. The <literal moreinfo="none">Monitor.errors</literal>
          call is a particularly important one. It detaches the monitor from
          its parent, handing back the stream of errors that would otherwise
          have been delivered to the parent monitor. This allows one to do
          custom handling of errors, which may include re-raising errors to
          the parent. Here is a very simple example of a function that
          captures and ignores errors in the processes it spawns.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">async/main-35.rawscript</filename></para>

          <programlisting language="ocaml" format="linespecific"><userinput moreinfo="none"># let swallow_error () =
    let monitor = Monitor.create () in
    Stream.iter (Monitor.errors monitor) ~f:(fun _exn -&gt;
      printf "an error happened\n");
    within' ~monitor (fun () -&gt;
      after (Time.Span.of_sec 0.5) &gt;&gt;= fun () -&gt; failwith "Kaboom!")
  ;;</userinput>
<computeroutput moreinfo="none">val swallow_error : unit -&gt; 'a Deferred.t = &lt;fun&gt;</computeroutput>
<userinput moreinfo="none"># swallow_error ();;</userinput>
<computeroutput moreinfo="none">an error happened
</computeroutput></programlisting>

          <para>The message "an error happened" is printed out, but the
          deferred returned by <literal moreinfo="none">swallow_error</literal> is never
          determined. This makes sense, since the calculation never actually
          completes, so there's no value to return. You can break out of this
          in <command moreinfo="none">utop</command> by hitting <keycombo moreinfo="none">
              <keycap moreinfo="none">Control</keycap>

              <keycap moreinfo="none">C</keycap>
            </keycombo>.</para>

          <para>Here's an example of a monitor which passes some exceptions
          through to the parent, and handles others. Exceptions are sent to
          the parent using <literal moreinfo="none">Monitor.send_exn</literal>, with
          <literal moreinfo="none">Monitor.current</literal> being called to find the current
          monitor, which is the parent of the newly created monitor.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">async/main.topscript</filename> (part 36)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">exception Ignore_me;;</userinput>
<computeroutput moreinfo="none">exception Ignore_me</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let swallow_some_errors exn_to_raise =</userinput>
<userinput moreinfo="none">    let child_monitor  = Monitor.create  () in</userinput>
<userinput moreinfo="none">    let parent_monitor = Monitor.current () in</userinput>
<userinput moreinfo="none">    Stream.iter (Monitor.errors child_monitor) ~f:(fun error -&gt;</userinput>
<userinput moreinfo="none">      match Monitor.extract_exn error with</userinput>
<userinput moreinfo="none">      | Ignore_me -&gt; printf "ignoring exn\n"</userinput>
<userinput moreinfo="none">      | _ -&gt; Monitor.send_exn parent_monitor error);</userinput>
<userinput moreinfo="none">    within' ~monitor:child_monitor (fun () -&gt;</userinput>
<userinput moreinfo="none">       after (Time.Span.of_sec 0.5)</userinput>
<userinput moreinfo="none">       &gt;&gt;= fun () -&gt; raise exn_to_raise)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val swallow_some_errors : exn -&gt; 'a Deferred.t = &lt;fun&gt;</computeroutput></programlisting>

          <para>Note that we use <literal moreinfo="none">Monitor.extract_exn</literal> to
          grab the underlying exception that was thrown. Async wraps
          exceptions it catches with extra information, including the monitor
          trace, so you need to grab the underlying exception to match on
          it.</para>

          <para>If we pass in an exception other than
          <literal moreinfo="none">Ignore_me</literal>, like, say, the built-in exception
          <literal moreinfo="none">Not_found</literal>, then the exception will be passed to
          the parent monitor and delivered as usual.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">async/main.topscript</filename> (part 37)</para>

          <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">swallow_some_errors Not_found;;</userinput>
<computeroutput moreinfo="none">Exception:</computeroutput>
<computeroutput moreinfo="none">(lib/monitor.ml.Error_</computeroutput>
<computeroutput moreinfo="none"> ((exn Not_found) (backtrace (""))</computeroutput>
<computeroutput moreinfo="none">  (monitor</computeroutput>
<computeroutput moreinfo="none">   (((name (id 75)) (here ()) (id 75) (has_seen_error true)</computeroutput>
<computeroutput moreinfo="none">     (someone_is_listening true) (kill_index 0))</computeroutput>
<computeroutput moreinfo="none">    ((name block_on_async) (here ()) (id 74) (has_seen_error true)</computeroutput>
<computeroutput moreinfo="none">     (someone_is_listening true) (kill_index 0))</computeroutput>
<computeroutput moreinfo="none">    ((name main) (here ()) (id 1) (has_seen_error false)</computeroutput>
<computeroutput moreinfo="none">     (someone_is_listening false) (kill_index 0)))))).</computeroutput></programlisting>

          <para>If instead we use <literal moreinfo="none">Ignore_me</literal>, the exception
          will be ignored, and we again see that the deferred never returns,
          but the exception was caught and ignored.</para>

          <para role="sourcecode">OCaml Utop:
          <filename moreinfo="none">async/main-38.rawscript</filename></para>

          <programlisting language="ocaml" format="linespecific"><userinput moreinfo="none"># swallow_some_errors Ignore_me;;</userinput>
<computeroutput moreinfo="none">ignoring exn</computeroutput></programlisting>

          <para>In practice, you should rarely use monitors directly, instead
          using functions like <literal moreinfo="none">try_with</literal> and
          <literal moreinfo="none">Monitor.protect</literal> that are built on top of
          monitors. One example of a library that uses monitors directly is
          <literal moreinfo="none">Tcp.Server.create</literal>, which tracks both exceptions
          thrown by the logic that handles the network connection and by the
          callback for responding to an individual request, in either case
          responding to an exception by closing the connection. It is for
          building this kind of custom error handling that monitors can be
          helpful.</para>
        </sect2>

        <sect2 id="example-handling-exceptions-with-duckduckgo">
          <title>Example: Handling exceptions with DuckDuckGo</title>

          <para>Let's now go back and improve the exception handling of our
          DuckDuckGo client. In particular, we'll change it so that any
          individual queries that fail are reported as such, without
          preventing other queries from succeeding.</para>

          <para>The search code as it is fails rarely, so let's make a change
          that allows us to trigger failures more predictably. We'll do this
          by making it possible to distribute the requests over multiple
          servers. Then, we'll handle the errors that occur when one of those
          servers is misspecified.</para>

          <para>First we'll need to change <literal moreinfo="none">query_uri</literal> to
          take an argument specifying the server to connect to, as
          follows.</para>

          <para role="sourcecode">OCaml:
          <filename moreinfo="none">async/search_with_configurable_server.ml</filename> (part
          1)</para>

          <programlisting language="ocaml" format="linespecific">(* Generate a DuckDuckGo search URI from a query string *)
let query_uri ~server query =
  let base_uri =
    Uri.of_string (String.concat ["http://";server;"/?format=json"])
  in
  Uri.add_query_param base_uri ("q", [query])</programlisting>

          <para>and then making the appropriate changes to get the list of
          servers on the command-line, and to distribute the search queries
          round-robin over the list of servers. Now, let's see what happens if
          we rebuild the application and run it giving it a list of servers,
          some of which won't respond to the query.</para>

          <para role="sourcecode">Terminal:
          <filename moreinfo="none">async/run_search_with_configurable_server.out</filename></para>

          <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg cohttp.async,yojson,textwrap \</userinput>
<computeroutput moreinfo="none">    search_with_configurable_server.native</computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./search_with_configurable_server.native \</userinput>
<computeroutput moreinfo="none">    -servers localhost,api.duckduckgo.com \</computeroutput>
<computeroutput moreinfo="none">    "Concurrent Programming" OCaml</computeroutput>
<computeroutput moreinfo="none">("unhandled exception"</computeroutput>
<computeroutput moreinfo="none"> ((lib/monitor.ml.Error_</computeroutput>
<computeroutput moreinfo="none">   ((exn (Unix.Unix_error "Connection refused" connect 127.0.0.1:80))</computeroutput>
<computeroutput moreinfo="none">    (backtrace</computeroutput>
<computeroutput moreinfo="none">     ("Raised by primitive operation at file \"lib/unix_syscalls.ml\", line 797, characters 12-69"</computeroutput>
<computeroutput moreinfo="none">      "Called from file \"lib/deferred.ml\", line 20, characters 62-65"</computeroutput>
<computeroutput moreinfo="none">      "Called from file \"lib/scheduler.ml\", line 125, characters 6-17"</computeroutput>
<computeroutput moreinfo="none">      "Called from file \"lib/jobs.ml\", line 65, characters 8-13" ""))</computeroutput>
<computeroutput moreinfo="none">    (monitor</computeroutput>
<computeroutput moreinfo="none">     (((name Tcp.close_sock_on_error) (here ()) (id 5) (has_seen_error true)</computeroutput>
<computeroutput moreinfo="none">       (someone_is_listening true) (kill_index 0))</computeroutput>
<computeroutput moreinfo="none">      ((name main) (here ()) (id 1) (has_seen_error true)</computeroutput>
<computeroutput moreinfo="none">       (someone_is_listening false) (kill_index 0))))))</computeroutput>
<computeroutput moreinfo="none">  (Pid 15971)))</computeroutput></programlisting>

          <para>As you can see, we got a "Connection refused" failure which
          ends the entire program, even though one of the two queries would
          have gone through successfully. We can handle the failures of
          individual connections separately by using the
          <literal moreinfo="none">try_with</literal> function within each call to
          <literal moreinfo="none">get_definition</literal>, as follows.</para>

          <para role="sourcecode">OCaml:
          <filename moreinfo="none">async/search_with_error_handling.ml</filename> (part
          1)</para>

          <programlisting language="ocaml" format="linespecific">(* Execute the DuckDuckGo search *)
let get_definition ~server word =
  try_with (fun () -&gt;
    Cohttp_async.Client.get (query_uri ~server word)
    &gt;&gt;= fun  (_, body) -&gt;
    Pipe.to_list body
    &gt;&gt;| fun strings -&gt;
    (word, get_definition_from_json (String.concat strings)))
  &gt;&gt;| function
  | Ok (word,result) -&gt; (word, Ok result)
  | Error _          -&gt; (word, Error "Unexpected failure")</programlisting>

          <para>Here, we first use <literal moreinfo="none">try_with</literal> to capture the
          exception, and then use map (the <literal moreinfo="none">&gt;&gt;|</literal>
          operator) to convert the error into the form we want: a pair whose
          first element is the word being searched for, and the second element
          is the (possibly erroneous) result.</para>

          <para>Now we just need to change the code for
          <literal moreinfo="none">print_result</literal> so that it can handle the new
          type.</para>

          <para role="sourcecode">OCaml:
          <filename moreinfo="none">async/search_with_error_handling.ml</filename> (part
          2)</para>

          <programlisting language="ocaml" format="linespecific">(* Print out a word/definition pair *)
let print_result (word,definition) =
  printf "%s\n%s\n\n%s\n\n"
    word
    (String.init (String.length word) ~f:(fun _ -&gt; '-'))
    (match definition with
     | Error s -&gt; "DuckDuckGo query failed: " ^ s
     | Ok None -&gt; "No definition found"
     | Ok (Some def) -&gt;
       String.concat ~sep:"\n"
         (Wrapper.wrap (Wrapper.make 70) def))</programlisting>

          <para>Now, if we run that same query, we'll get individualized
          handling of the connection failures:</para>

          <para role="sourcecode">Terminal:
          <filename moreinfo="none">async/run_search_with_error_handling.out</filename></para>

          <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg cohttp.async,yojson,textwrap \</userinput>
<computeroutput moreinfo="none">    search_with_error_handling.native</computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./search_with_error_handling.native \</userinput>
<computeroutput moreinfo="none">    -servers localhost,api.duckduckgo.com \</computeroutput>
<computeroutput moreinfo="none">    "Concurrent Programming" OCaml</computeroutput>
<computeroutput moreinfo="none">Concurrent Programming</computeroutput>
<computeroutput moreinfo="none">----------------------</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">DuckDuckGo query failed: Unexpected failure</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">OCaml</computeroutput>
<computeroutput moreinfo="none">-----</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">"OCaml, originally known as Objective Caml, is the main implementation</computeroutput>
<computeroutput moreinfo="none">of the Caml programming language, created by Xavier Leroy, Jrme</computeroutput>
<computeroutput moreinfo="none">Vouillon, Damien Doligez, Didier Rmy and others in 1996."</computeroutput>
<computeroutput moreinfo="none"> </computeroutput></programlisting>

          <para>Now, only the query that went to <literal moreinfo="none">localhost</literal>
          failed.</para>

          <para>Note that in this code, we're relying on the fact that
          <literal moreinfo="none">Cohttp_async.Client.get</literal> will clean up after
          itself after an exception, in particular by closing its file
          descriptors. If you need to implement such functionality directly,
          you may want to use the <literal moreinfo="none">Monitor.protect</literal> call,
          which is analogous to the <literal moreinfo="none">protect</literal> call described
          in <xref linkend="cleaning-up-in-the-presence-of-exceptions"/>.</para>
        </sect2>
      </sect1>

      <sect1 id="timeouts-cancellation-and-choices">
        <title>Timeouts, cancellation and choices</title>

        <para>In a concurrent program, one often needs to combine results from
        multiple distinct concurrent sub-computations going on in the same
        program. We already saw this in our DuckDuckGo example, where we used
        <literal moreinfo="none">Deferred.all</literal> and
        <literal moreinfo="none">Deferred.all_unit</literal> to wait for a list of deferreds
        to become determined. Another useful primitive is
        <literal moreinfo="none">Deferred.both</literal>, which lets you wait until two
        deferreds of different types have returned, returning both values as a
        tuple. Here, we use the function <literal moreinfo="none">sec</literal>, which is
        shorthand for creating a time-span equal to a given number of
        seconds.</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">async/main.topscript</filename> (part 39)</para>

        <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let string_and_float = Deferred.both</userinput>
<userinput moreinfo="none">   (after (sec 0.5)  &gt;&gt;| fun () -&gt; "A")</userinput>
<userinput moreinfo="none">   (after (sec 0.25) &gt;&gt;| fun () -&gt; 32.33);;</userinput>
<computeroutput moreinfo="none">val string_and_float : (string * float) Deferred.t = &lt;abstr&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">string_and_float;;</userinput>
<computeroutput moreinfo="none">- : string * float = ("A", 32.33)</computeroutput></programlisting>

        <para>Sometimes, however, we want to wait only for the first of
        multiple events to occur. This happens particularly when dealing with
        timeouts. In that case, we can use the call
        <literal moreinfo="none">Deferred.any</literal>, which, given a list of deferreds,
        returns a single deferred that will become determined once any of the
        values on the list is determined.</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">async/main.topscript</filename> (part 40)</para>

        <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">Deferred.any [ (after (sec 0.5) &gt;&gt;| fun () -&gt; "half a second")</userinput>
<userinput moreinfo="none">               ; (after (sec 10.) &gt;&gt;| fun () -&gt; "ten seconds") ] ;;</userinput>
<computeroutput moreinfo="none">- : string = "half a second"</computeroutput></programlisting>

        <para>Let's use this to add timeouts to our DuckDuckGo searches. The
        code below is a wrapper for <literal moreinfo="none">get_definition</literal> that
        takes a timeout (in the form of a <literal moreinfo="none">Time.Span.t</literal>), and
        returns either the definition, or, if that takes too long, an
        error.</para>

        <para role="sourcecode">OCaml:
        <filename moreinfo="none">async/search_with_timeout.ml</filename> (part 1)</para>

        <programlisting language="ocaml" format="linespecific">let get_definition_with_timeout ~server ~timeout word =
  Deferred.any
    [ (after timeout &gt;&gt;| fun () -&gt; (word,Error "Timed out"))
    ; (get_definition ~server word
       &gt;&gt;| fun (word,result) -&gt;
       let result' = match result with
         | Ok _ as x -&gt; x
         | Error _ -&gt; Error "Unexpected failure"
       in
       (word,result')
      )
    ]</programlisting>

        <para>We use <literal moreinfo="none">&gt;&gt;|</literal> above to transform the
        deferred values we're waiting for so that
        <literal moreinfo="none">Deferred.any</literal> can choose between values of the same
        type.</para>

        <para>A problem with this code is that the HTTP query kicked off by
        <literal moreinfo="none">get_definition</literal> is not actually shut down when the
        timeout fires. As such, <literal moreinfo="none">get_definition_with_timeout</literal>
        essentially leaks an open connection. Happily, Cohttp does provide a
        way of shutting down a client. You can pass a deferred under the label
        <literal moreinfo="none">interrupt</literal> to
        <literal moreinfo="none">Cohttp_async.Client.get</literal>. Once
        <literal moreinfo="none">interrupt</literal> is determined, the client connection will
        terminated and the corresponding connections closed.</para>

        <para>The following code shows how you can change
        <literal moreinfo="none">get_definition</literal> and
        <literal moreinfo="none">get_definition_with_timeout</literal> to cancel the
        <literal moreinfo="none">get</literal> call if the timeout expires.</para>

        <para role="sourcecode">OCaml:
        <filename moreinfo="none">async/search_with_timeout_no_leak_simple.ml</filename> (part
        1)</para>

        <programlisting language="ocaml" format="linespecific">(* Execute the DuckDuckGo search *)
let get_definition ~server ~interrupt word =
  try_with (fun () -&gt;
    Cohttp_async.Client.get ~interrupt (query_uri ~server word)
    &gt;&gt;= fun  (_, body) -&gt;
    Pipe.to_list body
    &gt;&gt;| fun strings -&gt;
    (word, get_definition_from_json (String.concat strings)))
  &gt;&gt;| function
  | Ok (word,result) -&gt; (word, Ok result)
  | Error exn        -&gt; (word, Error exn)</programlisting>

        <para>Next, we'll modify
        <literal moreinfo="none">get_definition_with_timeout</literal> to create a deferred to
        pass in to <literal moreinfo="none">get_definition</literal> which will become
        determined when our timeout expires.</para>

        <para role="sourcecode">OCaml:
        <filename moreinfo="none">async/search_with_timeout_no_leak_simple.ml</filename> (part
        2)</para>

        <programlisting language="ocaml" format="linespecific">let get_definition_with_timeout ~server ~timeout word =
  get_definition ~server ~interrupt:(after timeout) word
  &gt;&gt;| fun (word,result) -&gt;
  let result' = match result with
    | Ok _ as x -&gt; x
    | Error _ -&gt; Error "Unexpected failure"
  in
  (word,result')</programlisting>

        <para>This will work, and will cause the connection to shutdown
        cleanly when we time out; but our code no longer explicitly knows
        whether or not the timeout has kicked in. In particular, the error
        message on a timeout will now be <literal moreinfo="none">"Unexpected
        failure"</literal> rather than <literal moreinfo="none">"Timed out"</literal>, which
        it was in our previous implementation.</para>

        <para>We can get more precise handling of timeouts using Async's
        <literal moreinfo="none">choose</literal> function. <literal moreinfo="none">choose</literal> lets you
        pick between a collection of different deferreds, reacting to exactly
        one of them. Each deferred is paired, using the function
        <literal moreinfo="none">choice</literal>, with a function that is called if and only
        if that is deferred is chosen. Here's the type signature of
        <literal moreinfo="none">choice</literal> and <literal moreinfo="none">choose</literal>:</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">async/main.topscript</filename> (part 41)</para>

        <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">choice;;</userinput>
<computeroutput moreinfo="none">- : 'a Deferred.t -&gt; ('a -&gt; 'b) -&gt; 'b Deferred.choice = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">choose;;</userinput>
<computeroutput moreinfo="none">- : 'a Deferred.choice list -&gt; 'a Deferred.t = &lt;fun&gt;</computeroutput></programlisting>

        <para>Note that there's no guarantee that the winning deferred will be
        the one that becomes determined first. But <literal moreinfo="none">choose</literal>
        does guarantee that only one <literal moreinfo="none">choice</literal> will be chosen,
        and only the chosen <literal moreinfo="none">choice</literal> will execute the
        attached function.</para>

        <para>In the following, we use <literal moreinfo="none">choose</literal> to ensure
        that the <literal moreinfo="none">interrupt</literal> deferred becomes determined if
        and only if the timeout-deferred is chosen. Here's the code.</para>

        <para role="sourcecode">OCaml:
        <filename moreinfo="none">async/search_with_timeout_no_leak.ml</filename> (part
        2)</para>

        <programlisting language="ocaml" format="linespecific">let get_definition_with_timeout ~server ~timeout word =
  let interrupt = Ivar.create () in
  choose
    [ choice (after timeout) (fun () -&gt;
       Ivar.fill interrupt ();
       (word,Error "Timed out"))
    ; choice (get_definition ~server ~interrupt:(Ivar.read interrupt) word)
        (fun (word,result) -&gt;
           let result' = match result with
             | Ok _ as x -&gt; x
             | Error _ -&gt; Error "Unexpected failure"
           in
           (word,result')
        )
    ]</programlisting>

        <para>Now, if we run this with a suitably small timeout, we'll see
        that one query succeeds and the other fails reporting a
        timeout.</para>

        <para role="sourcecode">Terminal:
        <filename moreinfo="none">async/run_search_with_timeout_no_leak.out</filename></para>

        <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg cohttp.async,yojson,textwrap \</userinput>
<computeroutput moreinfo="none">     search_with_timeout_no_leak.native</computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./search_with_timeout_no_leak.native \</userinput>
<computeroutput moreinfo="none">     "concurrent programming" ocaml -timeout 0.2s</computeroutput>
<computeroutput moreinfo="none">concurrent programming</computeroutput>
<computeroutput moreinfo="none">----------------------</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">DuckDuckGo query failed: Timed out</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">ocaml</computeroutput>
<computeroutput moreinfo="none">-----</computeroutput>
<computeroutput moreinfo="none"> </computeroutput>
<computeroutput moreinfo="none">"OCaml or Objective Caml, is the main implementation of the Caml</computeroutput>
<computeroutput moreinfo="none">programming language, created by Xavier Leroy, Jrme Vouillon,</computeroutput>
<computeroutput moreinfo="none">Damien Doligez, Didier Rmy and others in 1996."</computeroutput></programlisting>
      </sect1>

      <sect1 id="working-with-system-threads">
        <title>Working with system threads</title>

        <para>Although we haven't worked with them yet, OCaml does have
        built-in support for true system threads, <emphasis>i.e.</emphasis>,
        kernel-level threads whose interleaving is controlled by the operating
        system. We discussed in the beginning of the chapter why Async is
        generally a better choice than system threads, but even if you mostly
        use Async, OCaml's system threads are sometimes necessary, and it's
        worth understanding them.</para>

        <para>The most surprising aspect of OCaml's system threads is that
        they don't afford you any access to physical parallelism. That's
        because OCaml's runtime has a single runtime lock which at most one
        thread can be holding at a time.</para>

        <para>Given that threads don't provide physical parallelism, why are
        they useful at all?</para>

        <para>The most common reason for using system threads is that there
        are some operating system calls that have no non-blocking alternative,
        which means that you can't run them directly in a system like Async
        without blocking your entire program. For this reason, Async maintains
        a thread pool for running such calls. Most of the time, as a user of
        Async you don't need to think about this, but it is happening under
        the covers.</para>

        <para>Another reason to have multiple threads is to deal with
        non-OCaml libraries that have their own event loop or for another
        reason need their own threads. In that case, it's sometimes useful to
        run some OCaml code on the foreign thread as part of the communication
        to your main program. OCaml's foreign function interface is discussed
        in more detail in <xref linkend="foreign-function-interface"/>.</para>

        <para>Another occasional use for system threads is to better
        interoperate with compute-intensive OCaml code. In Async, if you have
        a long-running computation that never calls <literal moreinfo="none">bind</literal> or
        <literal moreinfo="none">map</literal>, then that computation will block out the async
        runtime until it completes.</para>

        <para>One way of dealing with this is to explicitly break up the
        calculation into smaller pieces that are separated by binds. But
        sometimes this explicit yielding is impractical, since it may involve
        intrusive changes to an existing codebase. Another solution is to run
        the code in question in a separate thread. Async's
        <literal moreinfo="none">In_thread</literal> module provides multiple facilities for
        doing just this, <literal moreinfo="none">In_thread.run</literal> being the simplest.
        We can simply write</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">async/main.topscript</filename> (part 42)</para>

        <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let def = In_thread.run (fun () -&gt; List.range 1 10);;</userinput>
<computeroutput moreinfo="none">val def : int list Deferred.t = &lt;abstr&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">def;;</userinput>
<computeroutput moreinfo="none">- : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9]</computeroutput></programlisting>

        <para>to cause <literal moreinfo="none">List.range 1 10</literal> to be run on one of
        Async's worker threads. When the computation is complete, the result
        is placed in the deferred, where it can be used in the ordinary way
        from Async.</para>

        <para>Interoperability between Async and system threads can be quite
        tricky. Consider the following function for testing how responsive
        Async is. The function takes a deferred-returning thunk, and it first
        runs that thunk, and then uses <literal moreinfo="none">Clock.every</literal> to wake
        up every 100 milliseconds and print out a timestamp, until the
        returned deferred becomes determined, at which point it prints out one
        last timestamp.</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">async/main.topscript</filename> (part 43)</para>

        <programlisting language="ocaml" format="linespecific"><prompt moreinfo="none"># </prompt><userinput moreinfo="none">let log_delays thunk =</userinput>
<userinput moreinfo="none">    let start = Time.now () in</userinput>
<userinput moreinfo="none">    let print_time () =</userinput>
<userinput moreinfo="none">      let diff = Time.diff (Time.now ()) start in</userinput>
<userinput moreinfo="none">      printf "%s, " (Time.Span.to_string diff)</userinput>
<userinput moreinfo="none">    in</userinput>
<userinput moreinfo="none">    let d = thunk () in</userinput>
<userinput moreinfo="none">    Clock.every (sec 0.1) ~stop:d print_time;</userinput>
<userinput moreinfo="none">    d &gt;&gt;| fun () -&gt; print_time (); printf "\n"</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val log_delays : (unit -&gt; unit Deferred.t) -&gt; unit Deferred.t = &lt;fun&gt;</computeroutput></programlisting>

        <para>If we feed this function a simple timeout deferred, it works as
        you might expect, waking up roughly every 100 milliseconds.</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">async/main-44.rawscript</filename></para>

        <programlisting language="ocaml" format="linespecific"><userinput moreinfo="none"># log_delays (fun () -&gt; after (sec 0.5));;</userinput>
<computeroutput moreinfo="none">0.154972ms, 102.126ms, 203.658ms, 305.73ms, 407.903ms, 501.563ms,
- : unit = ()</computeroutput></programlisting>

        <para>Now see what happens if, instead of waiting on a clock event, we
        wait for a busy-loop to finish running.</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">async/main-45.rawscript</filename></para>

        <programlisting language="ocaml" format="linespecific"><userinput moreinfo="none"># let busy_loop n =
    let x = ref None in
    for i = 1 to 100_000_000 do x := Some i done
  ;;</userinput>
<computeroutput moreinfo="none">val busy_loop : 'a -&gt; unit = &lt;fun&gt;</computeroutput>
<userinput moreinfo="none"># log_delays (fun () -&gt; return (busy_loop ()));;</userinput>
<computeroutput moreinfo="none">19.2185s,
- : unit = ()</computeroutput></programlisting>

        <para>As you can see, instead of waking up ten times a second,
        <literal moreinfo="none">log_delays</literal> is blocked out entirely while
        <literal moreinfo="none">busy_loop</literal> churns away.</para>

        <para>If, on the other hand, we use <literal moreinfo="none">In_thread.run</literal>
        to offload this to a different system thread, the behavior will be
        different.</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">async/main-46.rawscript</filename></para>

        <programlisting language="ocaml" format="linespecific"><userinput moreinfo="none"># log_delays (fun () -&gt; In_thread.run busy_loop);;</userinput>
<computeroutput moreinfo="none">0.332117ms, 16.6319s, 18.8722s,
- : unit = ()</computeroutput></programlisting>

        <para>Now <literal moreinfo="none">log_delays</literal> does get a chance to run, but
        not nearly as often as every 100 milliseconds. The reason for this is
        that now that we're using system threads, we are at the mercy of the
        operating system to decide when each thread gets scheduled. The
        behavior of threads is very much dependent on the operating system and
        how it is configured.</para>

        <para>Another tricky aspect of dealing with OCaml threads has to do
        with allocation. When compiling to native-code, OCaml's threads only
        get a chance to give up the runtime lock when they interact with the
        allocator, so if there's a piece of code that doesn't allocate at all,
        then it will never allow another OCaml thread to run. Byte-code
        doesn't have this behavior, so if we run a non-allocating loop in
        byte-code, our timer process will get to run.</para>

        <para role="sourcecode">OCaml Utop:
        <filename moreinfo="none">async/main-47.rawscript</filename></para>

        <programlisting language="ocaml" format="linespecific"><userinput moreinfo="none"># let noalloc_busy_loop () =
    for i = 0 to 100_000_000 do () done
;;</userinput>
<computeroutput moreinfo="none">val noalloc_busy_loop : unit -&gt; unit = &lt;fun&gt;</computeroutput>
<userinput moreinfo="none"># log_delays (fun () -&gt; In_thread.run noalloc_busy_loop);;</userinput>
<computeroutput moreinfo="none">0.169039ms, 4.58345s, 4.77866s, 4.87957s, 12.4723s, 15.0134s,
- : unit = ()</computeroutput></programlisting>

        <para>But if we compile this to a native-code executable, then the
        non-allocating busy-loop will block anything else from running.</para>

        <para role="sourcecode">Terminal:
        <filename moreinfo="none">async/run_native_code_log_delays.out</filename></para>

        <programlisting language="console" format="linespecific"><prompt moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild -pkg async native_code_log_delays.native</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./native_code_log_delays.native</userinput>
<computeroutput moreinfo="none">15.5686s, </computeroutput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none"/></programlisting>

        <para>The takeaway from these examples is that predicting thread
        interleavings is a subtle business. Staying within the bounds of Async
        has its limitations, but it leads to more predictable behavior.</para>

        <sect2 id="thread-safety-and-locking">
          <title>Thread-safety and locking</title>

          <para>Once you start working with system threads, you'll need to be
          careful about mutable data structures. Most mutable OCaml data
          structures do not have well-defined semantics when accessed
          concurrently by multiple threads. The issues you can run into range
          from runtime exceptions to corrupted data structures to, in some
          rare cases, segfaults. That means you should always use mutexes when
          sharing mutable data between different systems threads. Even data
          structures that seem like they should be safe but are mutable under
          the covers, like lazy values, can have undefined behavior when
          accessed from multiple threads.</para>

          <para>There are two commonly available mutex packages for OCaml: the
          <literal moreinfo="none">Mutex</literal> module that's part of the standard library,
          which is just a wrapper over OS-level mutexes, and
          <literal moreinfo="none">Nano_mutex</literal>, a more efficient alternative that
          takes advantage of some of the locking done by the OCaml runtime to
          avoid needing to create an OS-level mutex much of the time. As a
          result, creating a <literal moreinfo="none">Nano_mutex.t</literal> is 20x faster
          than creating a <literal moreinfo="none">Mutex.t</literal>, and acquiring the mutex
          is about 40% faster.</para>

          <para>Overall, combining Async and threads is quite tricky, but it
          can be done safely if you follow the following hold:</para>

          <itemizedlist>
            <listitem>
              <para>There is no shared mutable state between the various
              threads involved.</para>
            </listitem>

            <listitem>
              <para>The computations executed by
              <literal moreinfo="none">In_thread.run</literal> do not make any calls to the
              async library.</para>
            </listitem>
          </itemizedlist>

          <para>It is possible to safely use threads in ways that violate
          these constraints. In particular, foreign threads can acquire the
          Async lock using calls from the <literal moreinfo="none">Thread_safe</literal>
          module in Async, and thereby run Async computations safely. This is
          a very flexible way of connecting threads to the Async world, but
          it's a complex use-case that is beyond the scope of this
          chapter.</para>
        </sect2>
      </sect1>
    </chapter>
