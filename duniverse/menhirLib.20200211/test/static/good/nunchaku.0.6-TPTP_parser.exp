Grammar has 95 nonterminal symbols, among which 7 start symbols.
Grammar has 55 terminal symbols.
Grammar has 205 productions.
nullable(unary_connective) = false
nullable(type_decl(thf_type)) = false
nullable(type_decl(tff_type)) = false
nullable(type_const) = false
nullable(ty_args) = false
nullable(toplevel_form(role_as_goal)) = false
nullable(toplevel_form(role_as_axiom)) = false
nullable(thf_unitary_formula) = false
nullable(thf_unary_type) = false
nullable(thf_unary_formula) = false
nullable(thf_type) = false
nullable(thf_quantifier) = false
nullable(thf_ite) = false
nullable(thf_formula) = false
nullable(thf_def) = false
nullable(thf_const) = false
nullable(thf_atomic_term) = false
nullable(thf_atom_type) = false
nullable(thf_apply_term) = false
nullable(tff_unary_type) = false
nullable(tff_type) = false
nullable(tff_formula) = false
nullable(tff_atom_type) = false
nullable(term) = false
nullable(system_term) = false
nullable(system_functor) = false
nullable(system_constant) = false
nullable(statement) = false
nullable(separated_nonempty_list(VLINE,literal)) = false
nullable(separated_nonempty_list(VLINE,answer_tuple)) = false
nullable(separated_nonempty_list(COMMA,tff_type)) = false
nullable(separated_nonempty_list(COMMA,term)) = false
nullable(separated_nonempty_list(COMMA,raw_typed_variable(thf_type))) = false
nullable(separated_nonempty_list(COMMA,raw_typed_variable(tff_unary_type))) = false
nullable(separated_nonempty_list(COMMA,raw_ty_variable)) = false
nullable(separated_nonempty_list(COMMA,name)) = false
nullable(separated_nonempty_list(COMMA,general_term)) = false
nullable(separated_nonempty_list(COMMA,fof_logic_formula)) = false
nullable(role_as_goal) = false
nullable(role_as_def) = false
nullable(role_as_decl) = false
nullable(role_as_axiom) = false
nullable(raw_variable) = false
nullable(raw_typed_variable(thf_type)) = false
nullable(raw_typed_variable(tff_unary_type)) = false
nullable(raw_ty_variable) = false
nullable(quantified_type(thf_type)) = false
nullable(quantified_type(tff_type)) = false
nullable(plain_term) = false
nullable(parse_ty) = false
nullable(parse_term) = false
nullable(parse_statement_list) = false
nullable(parse_statement) = false
nullable(parse_ho_form) = false
nullable(parse_fo_form) = false
nullable(parse_answer_tuples) = false
nullable(name_list) = true
nullable(name) = false
nullable(loption(separated_nonempty_list(COMMA,name))) = true
nullable(loption(separated_nonempty_list(COMMA,general_term))) = true
nullable(loption(separated_nonempty_list(COMMA,fof_logic_formula))) = true
nullable(literal) = false
nullable(list(statement)) = true
nullable(general_term) = false
nullable(general_list) = false
nullable(general_function) = false
nullable(general_data) = false
nullable(functor_) = false
nullable(function_term) = false
nullable(fol_quantifier) = false
nullable(fof_unitary_formula) = false
nullable(fof_unary_formula) = false
nullable(fof_tuple) = false
nullable(fof_sequent) = false
nullable(fof_quantified_formula) = false
nullable(fof_logic_formula) = false
nullable(fof_formula) = false
nullable(disjunction) = false
nullable(defined_term) = false
nullable(defined_plain_term) = false
nullable(defined_functor) = false
nullable(defined_constant) = false
nullable(defined_atomic_term) = false
nullable(defined_atom) = false
nullable(conditional_term(fof_formula,term)) = false
nullable(cnf_formula) = false
nullable(binary_connective) = false
nullable(atomic_word) = false
nullable(atomic_system_word) = false
nullable(atomic_formula) = false
nullable(atomic_defined_word) = false
nullable(arguments) = false
nullable(answer_tuples) = false
nullable(answer_tuple) = false
nullable(annotations) = true
first(unary_connective) = NOT
first(type_decl(thf_type)) = SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOLLAR_WORD
first(type_decl(tff_type)) = SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOLLAR_WORD
first(type_const) = WILDCARD TY_TYPE TY_PROP LOWER_WORD DOLLAR_WORD
first(ty_args) = WILDCARD UPPER_WORD TY_TYPE TY_PROP LOWER_WORD LEFT_PAREN DOLLAR_WORD
first(toplevel_form(role_as_goal)) = THF TFF FOF CNF
first(toplevel_form(role_as_axiom)) = THF TFF FOF CNF
first(thf_unitary_formula) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED NOT LOWER_WORD LEFT_PAREN LAMBDA ITE_T ITE_F HO_FORALL HO_EXISTS FORALL FALSE EXISTS
first(thf_unary_type) = WILDCARD UPPER_WORD TY_TYPE TY_PROP LOWER_WORD LEFT_PAREN DOLLAR_WORD
first(thf_unary_formula) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED NOT LOWER_WORD LEFT_PAREN ITE_T ITE_F HO_FORALL HO_EXISTS FALSE
first(thf_type) = WILDCARD UPPER_WORD TY_TYPE TY_PROP LOWER_WORD LEFT_PAREN DOLLAR_WORD
first(thf_quantifier) = LAMBDA FORALL EXISTS
first(thf_ite) = ITE_T ITE_F
first(thf_formula) = error WILDCARD UPPER_WORD TRUE SINGLE_QUOTED NOT LOWER_WORD LEFT_PAREN LAMBDA ITE_T ITE_F HO_FORALL HO_EXISTS FORALL FALSE EXISTS
first(thf_def) = SINGLE_QUOTED LOWER_WORD LEFT_PAREN
first(thf_const) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED LOWER_WORD HO_FORALL HO_EXISTS FALSE
first(thf_atomic_term) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED LOWER_WORD LEFT_PAREN ITE_T ITE_F HO_FORALL HO_EXISTS FALSE
first(thf_atom_type) = WILDCARD UPPER_WORD TY_TYPE TY_PROP LOWER_WORD DOLLAR_WORD
first(thf_apply_term) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED NOT LOWER_WORD LEFT_PAREN LAMBDA ITE_T ITE_F HO_FORALL HO_EXISTS FORALL FALSE EXISTS
first(tff_unary_type) = WILDCARD UPPER_WORD TY_TYPE TY_PROP LOWER_WORD LEFT_PAREN DOLLAR_WORD
first(tff_type) = WILDCARD UPPER_WORD TY_TYPE TY_PROP LOWER_WORD LEFT_PAREN DOLLAR_WORD
first(tff_formula) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LEFT_PAREN LEFT_BRACKET ITE_T INTEGER FORALL FALSE EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(tff_atom_type) = WILDCARD UPPER_WORD TY_TYPE TY_PROP LOWER_WORD DOLLAR_WORD
first(term) = WILDCARD UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD ITE_T INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(system_term) = DOLLAR_DOLLAR_WORD
first(system_functor) = DOLLAR_DOLLAR_WORD
first(system_constant) = DOLLAR_DOLLAR_WORD
first(statement) = error THF TFF INCLUDE FOF CNF
first(separated_nonempty_list(VLINE,literal)) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD ITE_T INTEGER FALSE DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(separated_nonempty_list(VLINE,answer_tuple)) = UNDERSCORE LEFT_BRACKET
first(separated_nonempty_list(COMMA,tff_type)) = WILDCARD UPPER_WORD TY_TYPE TY_PROP LOWER_WORD LEFT_PAREN DOLLAR_WORD
first(separated_nonempty_list(COMMA,term)) = WILDCARD UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD ITE_T INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(separated_nonempty_list(COMMA,raw_typed_variable(thf_type))) = UPPER_WORD
first(separated_nonempty_list(COMMA,raw_typed_variable(tff_unary_type))) = UPPER_WORD
first(separated_nonempty_list(COMMA,raw_ty_variable)) = UPPER_WORD
first(separated_nonempty_list(COMMA,name)) = SINGLE_QUOTED LOWER_WORD INTEGER
first(separated_nonempty_list(COMMA,general_term)) = UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_BRACKET INTEGER DISTINCT_OBJECT
first(separated_nonempty_list(COMMA,fof_logic_formula)) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LEFT_PAREN ITE_T INTEGER FORALL FALSE EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(role_as_goal) = ROLE_CONJECTURE
first(role_as_def) = ROLE_DEFINITION
first(role_as_decl) = ROLE_TYPE
first(role_as_axiom) = ROLE_AXIOM
first(raw_variable) = UPPER_WORD
first(raw_typed_variable(thf_type)) = UPPER_WORD
first(raw_typed_variable(tff_unary_type)) = UPPER_WORD
first(raw_ty_variable) = UPPER_WORD
first(quantified_type(thf_type)) = WILDCARD UPPER_WORD TY_TYPE TY_PROP LOWER_WORD LEFT_PAREN FORALL_TY DOLLAR_WORD
first(quantified_type(tff_type)) = WILDCARD UPPER_WORD TY_TYPE TY_PROP LOWER_WORD LEFT_PAREN FORALL_TY DOLLAR_WORD
first(plain_term) = WILDCARD SINGLE_QUOTED LOWER_WORD
first(parse_ty) = WILDCARD UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD ITE_T INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(parse_term) = WILDCARD UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD ITE_T INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(parse_statement_list) = error THF TFF INCLUDE FOF EOI CNF
first(parse_statement) = error THF TFF INCLUDE FOF CNF
first(parse_ho_form) = error WILDCARD UPPER_WORD TRUE SINGLE_QUOTED NOT LOWER_WORD LEFT_PAREN LAMBDA ITE_T ITE_F HO_FORALL HO_EXISTS FORALL FALSE EXISTS
first(parse_fo_form) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LEFT_PAREN LEFT_BRACKET ITE_T INTEGER FORALL FALSE EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(parse_answer_tuples) = LEFT_BRACKET
first(name_list) = SINGLE_QUOTED LOWER_WORD INTEGER
first(name) = SINGLE_QUOTED LOWER_WORD INTEGER
first(loption(separated_nonempty_list(COMMA,name))) = SINGLE_QUOTED LOWER_WORD INTEGER
first(loption(separated_nonempty_list(COMMA,general_term))) = UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_BRACKET INTEGER DISTINCT_OBJECT
first(loption(separated_nonempty_list(COMMA,fof_logic_formula))) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LEFT_PAREN ITE_T INTEGER FORALL FALSE EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(literal) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD ITE_T INTEGER FALSE DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(list(statement)) = error THF TFF INCLUDE FOF CNF
first(general_term) = UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_BRACKET INTEGER DISTINCT_OBJECT
first(general_list) = LEFT_BRACKET
first(general_function) = SINGLE_QUOTED LOWER_WORD
first(general_data) = UPPER_WORD SINGLE_QUOTED LOWER_WORD INTEGER DISTINCT_OBJECT
first(functor_) = SINGLE_QUOTED LOWER_WORD
first(function_term) = WILDCARD SINGLE_QUOTED REAL RATIONAL LOWER_WORD INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(fol_quantifier) = FORALL EXISTS
first(fof_unitary_formula) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LEFT_PAREN ITE_T INTEGER FORALL FALSE EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(fof_unary_formula) = NOT
first(fof_tuple) = LEFT_BRACKET
first(fof_sequent) = LEFT_PAREN LEFT_BRACKET
first(fof_quantified_formula) = FORALL EXISTS
first(fof_logic_formula) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LEFT_PAREN ITE_T INTEGER FORALL FALSE EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(fof_formula) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LEFT_PAREN LEFT_BRACKET ITE_T INTEGER FORALL FALSE EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(disjunction) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD ITE_T INTEGER FALSE DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(defined_term) = REAL RATIONAL INTEGER DOLLAR_WORD DISTINCT_OBJECT
first(defined_plain_term) = DOLLAR_WORD
first(defined_functor) = DOLLAR_WORD
first(defined_constant) = DOLLAR_WORD
first(defined_atomic_term) = DOLLAR_WORD
first(defined_atom) = REAL RATIONAL INTEGER DISTINCT_OBJECT
first(conditional_term(fof_formula,term)) = ITE_T
first(cnf_formula) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LEFT_PAREN ITE_T INTEGER FALSE DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(binary_connective) = XOR VLINE NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV AND
first(atomic_word) = SINGLE_QUOTED LOWER_WORD
first(atomic_system_word) = DOLLAR_DOLLAR_WORD
first(atomic_formula) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL LOWER_WORD ITE_T INTEGER FALSE DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(atomic_defined_word) = DOLLAR_WORD
first(arguments) = WILDCARD UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD ITE_T INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(answer_tuples) = LEFT_BRACKET
first(answer_tuple) = UNDERSCORE LEFT_BRACKET
first(annotations) = COMMA
minimal(unary_connective) = (* 1 *) NOT
minimal(type_decl(thf_type)) = (* 3 *) SINGLE_QUOTED COLUMN UPPER_WORD
minimal(type_decl(tff_type)) = (* 3 *) SINGLE_QUOTED COLUMN UPPER_WORD
minimal(type_const) = (* 1 *) WILDCARD
minimal(ty_args) = (* 3 *) UPPER_WORD STAR UPPER_WORD
minimal(toplevel_form(role_as_goal)) = (* 9 *) TFF LEFT_PAREN SINGLE_QUOTED COMMA ROLE_CONJECTURE COMMA TRUE RIGHT_PAREN DOT
minimal(toplevel_form(role_as_axiom)) = (* 9 *) TFF LEFT_PAREN SINGLE_QUOTED COMMA ROLE_AXIOM COMMA TRUE RIGHT_PAREN DOT
minimal(thf_unitary_formula) = (* 1 *) TRUE
minimal(thf_unary_type) = (* 1 *) UPPER_WORD
minimal(thf_unary_formula) = (* 1 *) TRUE
minimal(thf_type) = (* 1 *) UPPER_WORD
minimal(thf_quantifier) = (* 1 *) FORALL
minimal(thf_ite) = (* 1 *) ITE_T
minimal(thf_formula) = (* 1 *) TRUE
minimal(thf_def) = (* 3 *) SINGLE_QUOTED EQUAL TRUE
minimal(thf_const) = (* 1 *) TRUE
minimal(thf_atomic_term) = (* 1 *) TRUE
minimal(thf_atom_type) = (* 1 *) UPPER_WORD
minimal(thf_apply_term) = (* 1 *) TRUE
minimal(tff_unary_type) = (* 1 *) UPPER_WORD
minimal(tff_type) = (* 1 *) UPPER_WORD
minimal(tff_formula) = (* 1 *) TRUE
minimal(tff_atom_type) = (* 1 *) UPPER_WORD
minimal(term) = (* 1 *) WILDCARD
minimal(system_term) = (* 1 *) DOLLAR_DOLLAR_WORD
minimal(system_functor) = (* 1 *) DOLLAR_DOLLAR_WORD
minimal(system_constant) = (* 1 *) DOLLAR_DOLLAR_WORD
minimal(statement) = (* 1 *) error
minimal(separated_nonempty_list(VLINE,literal)) = (* 1 *) TRUE
minimal(separated_nonempty_list(VLINE,answer_tuple)) = (* 1 *) UNDERSCORE
minimal(separated_nonempty_list(COMMA,tff_type)) = (* 1 *) UPPER_WORD
minimal(separated_nonempty_list(COMMA,term)) = (* 1 *) WILDCARD
minimal(separated_nonempty_list(COMMA,raw_typed_variable(thf_type))) = (* 1 *) UPPER_WORD
minimal(separated_nonempty_list(COMMA,raw_typed_variable(tff_unary_type))) = (* 1 *) UPPER_WORD
minimal(separated_nonempty_list(COMMA,raw_ty_variable)) = (* 1 *) UPPER_WORD
minimal(separated_nonempty_list(COMMA,name)) = (* 1 *) SINGLE_QUOTED
minimal(separated_nonempty_list(COMMA,general_term)) = (* 1 *) SINGLE_QUOTED
minimal(separated_nonempty_list(COMMA,fof_logic_formula)) = (* 1 *) TRUE
minimal(role_as_goal) = (* 1 *) ROLE_CONJECTURE
minimal(role_as_def) = (* 1 *) ROLE_DEFINITION
minimal(role_as_decl) = (* 1 *) ROLE_TYPE
minimal(role_as_axiom) = (* 1 *) ROLE_AXIOM
minimal(raw_variable) = (* 1 *) UPPER_WORD
minimal(raw_typed_variable(thf_type)) = (* 1 *) UPPER_WORD
minimal(raw_typed_variable(tff_unary_type)) = (* 1 *) UPPER_WORD
minimal(raw_ty_variable) = (* 1 *) UPPER_WORD
minimal(quantified_type(thf_type)) = (* 1 *) UPPER_WORD
minimal(quantified_type(tff_type)) = (* 1 *) UPPER_WORD
minimal(plain_term) = (* 1 *) WILDCARD
minimal(parse_ty) = (* 2 *) WILDCARD EOI
minimal(parse_term) = (* 2 *) WILDCARD EOI
minimal(parse_statement_list) = (* 1 *) EOI
minimal(parse_statement) = (* 2 *) error EOI
minimal(parse_ho_form) = (* 2 *) TRUE EOI
minimal(parse_fo_form) = (* 2 *) TRUE EOI
minimal(parse_answer_tuples) = (* 4 *) LEFT_BRACKET UNDERSCORE RIGHT_BRACKET EOI
minimal(name_list) = (* 0 *) 
minimal(name) = (* 1 *) SINGLE_QUOTED
minimal(loption(separated_nonempty_list(COMMA,name))) = (* 0 *) 
minimal(loption(separated_nonempty_list(COMMA,general_term))) = (* 0 *) 
minimal(loption(separated_nonempty_list(COMMA,fof_logic_formula))) = (* 0 *) 
minimal(literal) = (* 1 *) TRUE
minimal(list(statement)) = (* 0 *) 
minimal(general_term) = (* 1 *) SINGLE_QUOTED
minimal(general_list) = (* 2 *) LEFT_BRACKET RIGHT_BRACKET
minimal(general_function) = (* 4 *) SINGLE_QUOTED LEFT_PAREN SINGLE_QUOTED RIGHT_PAREN
minimal(general_data) = (* 1 *) SINGLE_QUOTED
minimal(functor_) = (* 1 *) SINGLE_QUOTED
minimal(function_term) = (* 1 *) WILDCARD
minimal(fol_quantifier) = (* 1 *) FORALL
minimal(fof_unitary_formula) = (* 1 *) TRUE
minimal(fof_unary_formula) = (* 2 *) NOT TRUE
minimal(fof_tuple) = (* 2 *) LEFT_BRACKET RIGHT_BRACKET
minimal(fof_sequent) = (* 5 *) LEFT_BRACKET RIGHT_BRACKET GENTZEN_ARROW LEFT_BRACKET RIGHT_BRACKET
minimal(fof_quantified_formula) = (* 6 *) FORALL LEFT_BRACKET UPPER_WORD RIGHT_BRACKET COLUMN TRUE
minimal(fof_logic_formula) = (* 1 *) TRUE
minimal(fof_formula) = (* 1 *) TRUE
minimal(disjunction) = (* 1 *) TRUE
minimal(defined_term) = (* 1 *) INTEGER
minimal(defined_plain_term) = (* 1 *) DOLLAR_WORD
minimal(defined_functor) = (* 1 *) DOLLAR_WORD
minimal(defined_constant) = (* 1 *) DOLLAR_WORD
minimal(defined_atomic_term) = (* 1 *) DOLLAR_WORD
minimal(defined_atom) = (* 1 *) INTEGER
minimal(conditional_term(fof_formula,term)) = (* 8 *) ITE_T LEFT_PAREN TRUE COMMA WILDCARD COMMA WILDCARD RIGHT_PAREN
minimal(cnf_formula) = (* 1 *) TRUE
minimal(binary_connective) = (* 1 *) EQUIV
minimal(atomic_word) = (* 1 *) SINGLE_QUOTED
minimal(atomic_system_word) = (* 1 *) DOLLAR_DOLLAR_WORD
minimal(atomic_formula) = (* 1 *) TRUE
minimal(atomic_defined_word) = (* 1 *) DOLLAR_WORD
minimal(arguments) = (* 1 *) WILDCARD
minimal(answer_tuples) = (* 3 *) LEFT_BRACKET UNDERSCORE RIGHT_BRACKET
minimal(answer_tuple) = (* 1 *) UNDERSCORE
minimal(annotations) = (* 0 *) 
follow(unary_connective) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LEFT_PAREN ITE_T INTEGER FORALL FALSE EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
follow(type_decl(thf_type)) = RIGHT_PAREN COMMA
follow(type_decl(tff_type)) = RIGHT_PAREN COMMA
follow(type_const) = STAR RIGHT_PAREN RIGHT_BRACKET LEFT_PAREN COMMA ARROW
follow(ty_args) = RIGHT_PAREN
follow(toplevel_form(role_as_goal)) = error THF TFF INCLUDE FOF EOI CNF
follow(toplevel_form(role_as_axiom)) = error THF TFF INCLUDE FOF EOI CNF
follow(thf_unitary_formula) = XOR VLINE RIGHT_PAREN NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AT AND
follow(thf_unary_type) = RIGHT_PAREN RIGHT_BRACKET COMMA ARROW
follow(thf_unary_formula) = XOR VLINE RIGHT_PAREN NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AT AND
follow(thf_type) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(thf_quantifier) = LEFT_BRACKET
follow(thf_ite) = LEFT_PAREN
follow(thf_formula) = XOR VLINE RIGHT_PAREN NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AND
follow(thf_def) = RIGHT_PAREN COMMA
follow(thf_const) = XOR VLINE RIGHT_PAREN NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AT AND
follow(thf_atomic_term) = XOR VLINE RIGHT_PAREN NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AT AND
follow(thf_atom_type) = RIGHT_PAREN RIGHT_BRACKET COMMA ARROW
follow(thf_apply_term) = XOR VLINE RIGHT_PAREN NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AT AND
follow(tff_unary_type) = STAR RIGHT_PAREN RIGHT_BRACKET COMMA ARROW
follow(tff_type) = RIGHT_PAREN COMMA
follow(tff_formula) = RIGHT_PAREN COMMA
follow(tff_atom_type) = STAR RIGHT_PAREN RIGHT_BRACKET COMMA ARROW
follow(term) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AND
follow(system_term) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AND
follow(system_functor) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AND
follow(system_constant) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AND
follow(statement) = error THF TFF INCLUDE FOF EOI CNF
follow(separated_nonempty_list(VLINE,literal)) = RIGHT_PAREN COMMA
follow(separated_nonempty_list(VLINE,answer_tuple)) = RIGHT_BRACKET
follow(separated_nonempty_list(COMMA,tff_type)) = RIGHT_PAREN
follow(separated_nonempty_list(COMMA,term)) = RIGHT_PAREN RIGHT_BRACKET
follow(separated_nonempty_list(COMMA,raw_typed_variable(thf_type))) = RIGHT_BRACKET
follow(separated_nonempty_list(COMMA,raw_typed_variable(tff_unary_type))) = RIGHT_BRACKET
follow(separated_nonempty_list(COMMA,raw_ty_variable)) = RIGHT_BRACKET
follow(separated_nonempty_list(COMMA,name)) = RIGHT_PAREN
follow(separated_nonempty_list(COMMA,general_term)) = RIGHT_PAREN RIGHT_BRACKET
follow(separated_nonempty_list(COMMA,fof_logic_formula)) = RIGHT_BRACKET
follow(role_as_goal) = COMMA
follow(role_as_def) = COMMA
follow(role_as_decl) = COMMA
follow(role_as_axiom) = COMMA
follow(raw_variable) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA COLUMN AT ARROW AND
follow(raw_typed_variable(thf_type)) = RIGHT_BRACKET COMMA
follow(raw_typed_variable(tff_unary_type)) = RIGHT_BRACKET COMMA
follow(raw_ty_variable) = STAR RIGHT_PAREN RIGHT_BRACKET COMMA ARROW
follow(quantified_type(thf_type)) = RIGHT_PAREN COMMA
follow(quantified_type(tff_type)) = RIGHT_PAREN COMMA
follow(plain_term) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AND
follow(parse_ty) = #
follow(parse_term) = #
follow(parse_statement_list) = #
follow(parse_statement) = #
follow(parse_ho_form) = #
follow(parse_fo_form) = #
follow(parse_answer_tuples) = #
follow(name_list) = RIGHT_PAREN
follow(name) = RIGHT_PAREN COMMA
follow(loption(separated_nonempty_list(COMMA,name))) = RIGHT_PAREN
follow(loption(separated_nonempty_list(COMMA,general_term))) = RIGHT_PAREN RIGHT_BRACKET
follow(loption(separated_nonempty_list(COMMA,fof_logic_formula))) = RIGHT_BRACKET
follow(literal) = VLINE RIGHT_PAREN COMMA
follow(list(statement)) = EOI
follow(general_term) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(general_list) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(general_function) = RIGHT_PAREN RIGHT_BRACKET COMMA COLUMN
follow(general_data) = RIGHT_PAREN RIGHT_BRACKET COMMA COLUMN
follow(functor_) = LEFT_PAREN
follow(function_term) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AND
follow(fol_quantifier) = LEFT_BRACKET
follow(fof_unitary_formula) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EOI COMMA AND
follow(fof_unary_formula) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EOI COMMA AND
follow(fof_tuple) = RIGHT_PAREN GENTZEN_ARROW EOI COMMA
follow(fof_sequent) = RIGHT_PAREN EOI COMMA
follow(fof_quantified_formula) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EOI COMMA AND
follow(fof_logic_formula) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EOI COMMA AND
follow(fof_formula) = RIGHT_PAREN EOI COMMA
follow(disjunction) = RIGHT_PAREN COMMA
follow(defined_term) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AND
follow(defined_plain_term) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AND
follow(defined_functor) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AND
follow(defined_constant) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AND
follow(defined_atomic_term) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AND
follow(defined_atom) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AND
follow(conditional_term(fof_formula,term)) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AND
follow(cnf_formula) = RIGHT_PAREN COMMA
follow(binary_connective) = WILDCARD UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LEFT_PAREN LAMBDA ITE_T ITE_F INTEGER HO_FORALL HO_EXISTS FORALL FALSE EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
follow(atomic_word) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA COLUMN AT AND
follow(atomic_system_word) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AND
follow(atomic_formula) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EOI COMMA AND
follow(atomic_defined_word) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY EQUIV EQUAL EOI COMMA AND
follow(arguments) = RIGHT_PAREN
follow(answer_tuples) = EOI
follow(answer_tuple) = VLINE RIGHT_BRACKET
follow(annotations) = RIGHT_PAREN
Built an LR(0) automaton with 418 states.
The grammar is not SLR(1) -- 1 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 512 states.
196 out of 512 states have a default reduction.
146 out of 512 states are represented.
73 out of 159 symbols keep track of their start position.
58 out of 159 symbols keep track of their end position.
147 out of 212 productions exploit shiftreduce optimization.
2 out of 512 states can peek at an error.
1343 functions before inlining, 175 functions after inlining.
