Grammar has 48 nonterminal symbols, among which 1 start symbols.
Grammar has 57 terminal symbols.
Grammar has 122 productions.
nullable(var_term) = false
nullable(var_or_array_term) = false
nullable(var_decl) = false
nullable(update) = false
nullable(unsafe) = false
nullable(type_defs) = true
nullable(type_def_plus) = false
nullable(type_def) = false
nullable(transition_name) = false
nullable(transition) = false
nullable(top_id_term) = false
nullable(term) = false
nullable(system) = false
nullable(symbold_decls) = true
nullable(switchs) = false
nullable(switch) = false
nullable(size_proc) = true
nullable(simple_expr) = false
nullable(require) = true
nullable(proc_name_list_plus) = false
nullable(proc_name) = false
nullable(nondet) = false
nullable(mident) = false
nullable(literal) = false
nullable(lidents_plus_distinct) = false
nullable(lidents_plus) = false
nullable(lidents) = true
nullable(lident_list_plus) = false
nullable(lident_comma_list) = true
nullable(lident) = false
nullable(let_assigns_nondets_updates) = true
nullable(invariant) = false
nullable(init) = false
nullable(function_decl) = false
nullable(expr_or_term_comma_list) = true
nullable(expr) = false
nullable(decl_list) = false
nullable(decl) = false
nullable(constructors) = false
nullable(constnum) = false
nullable(const_proc) = false
nullable(const_decl) = false
nullable(assigns_nondets_updates) = true
nullable(assignment) = false
nullable(assign_nondet_update) = false
nullable(array_term) = false
nullable(array_decl) = false
nullable(arith_term) = false
first(var_term) = MIDENT LIDENT CONSTPROC
first(var_or_array_term) = MIDENT LIDENT CONSTPROC
first(var_decl) = VAR
first(update) = MIDENT
first(unsafe) = UNSAFE
first(type_defs) = TYPE
first(type_def_plus) = TYPE
first(type_def) = TYPE
first(transition_name) = MIDENT LIDENT
first(transition) = TRANSITION
first(top_id_term) = MIDENT LIDENT CONSTPROC
first(term) = REAL MINUS MIDENT LIDENT INT CONSTPROC
first(system) = VAR UNSAFE TYPE TRANSITION SIZEPROC PREDICATE INVARIANT INIT CONST ARRAY
first(symbold_decls) = VAR CONST ARRAY
first(switchs) = BAR
first(switch) = TRUE REAL NOT MINUS MIDENT LIDENT LEFTPAR INT IF FORALL_OTHER FORALL FALSE EXISTS_OTHER EXISTS CONSTPROC
first(size_proc) = SIZEPROC
first(simple_expr) = TRUE REAL MINUS MIDENT LIDENT LEFTPAR INT FALSE CONSTPROC
first(require) = REQUIRE
first(proc_name_list_plus) = LIDENT CONSTPROC
first(proc_name) = LIDENT CONSTPROC
first(nondet) = MIDENT
first(mident) = MIDENT
first(literal) = TRUE REAL MINUS MIDENT LIDENT INT FALSE CONSTPROC
first(lidents_plus_distinct) = LIDENT
first(lidents_plus) = LIDENT
first(lidents) = LIDENT
first(lident_list_plus) = LIDENT
first(lident_comma_list) = LIDENT
first(lident) = LIDENT
first(let_assigns_nondets_updates) = MIDENT LET
first(invariant) = INVARIANT
first(init) = INIT
first(function_decl) = PREDICATE
first(expr_or_term_comma_list) = TRUE REAL NOT MINUS MIDENT LIDENT LEFTPAR INT IF FORALL_OTHER FORALL FALSE EXISTS_OTHER EXISTS CONSTPROC
first(expr) = TRUE REAL NOT MINUS MIDENT LIDENT LEFTPAR INT IF FORALL_OTHER FORALL FALSE EXISTS_OTHER EXISTS CONSTPROC
first(decl_list) = UNSAFE TRANSITION PREDICATE INVARIANT INIT
first(decl) = UNSAFE TRANSITION PREDICATE INVARIANT INIT
first(constructors) = MIDENT
first(constnum) = REAL INT
first(const_proc) = CONSTPROC
first(const_decl) = CONST
first(assigns_nondets_updates) = MIDENT
first(assignment) = MIDENT
first(assign_nondet_update) = MIDENT
first(array_term) = MIDENT
first(array_decl) = ARRAY
first(arith_term) = REAL MINUS MIDENT LIDENT INT CONSTPROC
minimal(var_term) = (* 1 *) MIDENT
minimal(var_or_array_term) = (* 1 *) MIDENT
minimal(var_decl) = (* 4 *) VAR MIDENT COLON LIDENT
minimal(update) = (* 6 *) MIDENT LEFTSQ LIDENT RIGHTSQ AFFECT MIDENT
minimal(unsafe) = (* 4 *) UNSAFE LEFTBR TRUE RIGHTBR
minimal(type_defs) = (* 0 *) 
minimal(type_def_plus) = (* 2 *) TYPE LIDENT
minimal(type_def) = (* 2 *) TYPE LIDENT
minimal(transition_name) = (* 1 *) LIDENT
minimal(transition) = (* 6 *) TRANSITION LIDENT LEFTPAR RIGHTPAR LEFTBR RIGHTBR
minimal(top_id_term) = (* 1 *) MIDENT
minimal(term) = (* 1 *) MIDENT
minimal(system) = (* 5 *) INIT LEFTBR TRUE RIGHTBR EOF
minimal(symbold_decls) = (* 0 *) 
minimal(switchs) = (* 4 *) BAR UNDERSCORE COLON MIDENT
minimal(switch) = (* 3 *) TRUE COLON MIDENT
minimal(size_proc) = (* 0 *) 
minimal(simple_expr) = (* 1 *) TRUE
minimal(require) = (* 0 *) 
minimal(proc_name_list_plus) = (* 1 *) LIDENT
minimal(proc_name) = (* 1 *) LIDENT
minimal(nondet) = (* 3 *) MIDENT AFFECT DOT
minimal(mident) = (* 1 *) MIDENT
minimal(literal) = (* 1 *) TRUE
minimal(lidents_plus_distinct) = (* 1 *) LIDENT
minimal(lidents_plus) = (* 1 *) LIDENT
minimal(lidents) = (* 0 *) 
minimal(lident_list_plus) = (* 1 *) LIDENT
minimal(lident_comma_list) = (* 0 *) 
minimal(lident) = (* 1 *) LIDENT
minimal(let_assigns_nondets_updates) = (* 0 *) 
minimal(invariant) = (* 4 *) INVARIANT LEFTBR TRUE RIGHTBR
minimal(init) = (* 4 *) INIT LEFTBR TRUE RIGHTBR
minimal(function_decl) = (* 7 *) PREDICATE LIDENT LEFTPAR RIGHTPAR LEFTBR TRUE RIGHTBR
minimal(expr_or_term_comma_list) = (* 0 *) 
minimal(expr) = (* 1 *) TRUE
minimal(decl_list) = (* 4 *) INIT LEFTBR TRUE RIGHTBR
minimal(decl) = (* 4 *) INIT LEFTBR TRUE RIGHTBR
minimal(constructors) = (* 1 *) MIDENT
minimal(constnum) = (* 1 *) REAL
minimal(const_proc) = (* 1 *) CONSTPROC
minimal(const_decl) = (* 4 *) CONST MIDENT COLON LIDENT
minimal(assigns_nondets_updates) = (* 0 *) 
minimal(assignment) = (* 3 *) MIDENT AFFECT MIDENT
minimal(assign_nondet_update) = (* 3 *) MIDENT AFFECT MIDENT
minimal(array_term) = (* 4 *) MIDENT LEFTSQ LIDENT RIGHTSQ
minimal(array_decl) = (* 7 *) ARRAY MIDENT LEFTSQ LIDENT RIGHTSQ COLON LIDENT
minimal(arith_term) = (* 1 *) REAL
follow(var_term) = THEN RIGHTPAR RIGHTBR PV PLUS OR NEQ MINUS LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND
follow(var_or_array_term) = PLUS MINUS
follow(var_decl) = VAR UNSAFE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY
follow(update) = RIGHTBR PV
follow(unsafe) = UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF
follow(type_defs) = VAR UNSAFE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY
follow(type_def_plus) = VAR UNSAFE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY
follow(type_def) = VAR UNSAFE TYPE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY
follow(transition_name) = LEFTPAR
follow(transition) = UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF
follow(top_id_term) = THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND
follow(term) = THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND
follow(system) = #
follow(symbold_decls) = UNSAFE TRANSITION PREDICATE INVARIANT INIT
follow(switchs) = RIGHTBR PV
follow(switch) = RIGHTBR PV BAR
follow(size_proc) = VAR UNSAFE TYPE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY
follow(simple_expr) = THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND
follow(require) = LEFTBR
follow(proc_name_list_plus) = RIGHTSQ
follow(proc_name) = THEN RIGHTSQ RIGHTPAR RIGHTBR PV PLUS OR NEQ MINUS LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND
follow(nondet) = RIGHTBR PV
follow(mident) = VAR UNSAFE TYPE TRANSITION TIMES THEN RIGHTPAR RIGHTBR PV PREDICATE PLUS OR NEQ MINUS LT LEFTSQ LEFTPAR LE INVARIANT INIT IN IMP GT GE EQUIV EQ ELSE CONST COMMA COLON BAR ARRAY AND AFFECT
follow(literal) = THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND
follow(lidents_plus_distinct) = DOT
follow(lidents_plus) = RIGHTPAR
follow(lidents) = RIGHTPAR
follow(lident_list_plus) = RIGHTSQ RIGHTPAR
follow(lident_comma_list) = RIGHTPAR
follow(lident) = VAR UNSAFE TYPE TRANSITION THEN RIGHTSQ RIGHTPAR RIGHTBR PV PREDICATE PLUS OR NEQ MINUS LT LIDENT LEFTPAR LE INVARIANT INIT IN IMP GT GE EQUIV EQ ELSE DOT CONST COMMA COLON BAR ARRAY AND
follow(let_assigns_nondets_updates) = RIGHTBR
follow(invariant) = UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF
follow(init) = UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF
follow(function_decl) = UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF
follow(expr_or_term_comma_list) = RIGHTPAR
follow(expr) = THEN RIGHTPAR RIGHTBR OR IMP EQUIV ELSE COMMA COLON AND
follow(decl_list) = EOF
follow(decl) = UNSAFE TRANSITION PREDICATE INVARIANT INIT EOF
follow(constructors) = VAR UNSAFE TYPE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY
follow(constnum) = THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND
follow(const_proc) = THEN RIGHTSQ RIGHTPAR RIGHTBR PV PLUS OR NEQ MINUS LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND
follow(const_decl) = VAR UNSAFE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY
follow(assigns_nondets_updates) = RIGHTBR
follow(assignment) = RIGHTBR PV
follow(assign_nondet_update) = RIGHTBR PV
follow(array_term) = THEN RIGHTPAR RIGHTBR PV PLUS OR NEQ MINUS LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND
follow(array_decl) = VAR UNSAFE TRANSITION PREDICATE INVARIANT INIT CONST ARRAY
follow(arith_term) = THEN RIGHTPAR RIGHTBR PV OR NEQ LT LE IN IMP GT GE EQUIV EQ ELSE COMMA COLON BAR AND
Built an LR(0) automaton with 253 states.
The grammar is not SLR(1) -- 10 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 253 states.
40 shift/reduce conflicts were silently solved.
File "cubicle.1.1.2-parser.mly", line 107, characters 0-9:
Warning: the precedence level assigned to IN is never useful.
87 out of 253 states have a default reduction.
85 out of 253 states are represented.
0 out of 108 symbols keep track of their start position.
0 out of 108 symbols keep track of their end position.
53 out of 123 productions exploit shiftreduce optimization.
0 out of 253 states can peek at an error.
683 functions before inlining, 82 functions after inlining.
