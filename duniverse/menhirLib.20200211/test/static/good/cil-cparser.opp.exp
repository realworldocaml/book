File "cil-cparser.mly", line 269, characters 54-60:
Warning: the token ADDROF is unused.
File "cil-cparser.mly", line 237, characters 36-50:
Warning: the token ATTRIBUTE_USED is unused.
File "cil-cparser.mly", line 238, characters 7-22:
Warning: the token BUILTIN_VA_LIST is unused.
File "cil-cparser.mly", line 269, characters 42-46:
Warning: the token CAST is unused.
File "cil-cparser.mly", line 199, characters 54-59:
Warning: the token INT32 is unused.
%{
open Cabs
module E = Errormsg

let parse_error msg : unit =       (* sm: c++-mode highlight hack: -> ' <- *)
  E.parse_error msg

let print = print_string


let currentLoc () =
  let l, f, c = E.getPosition () in
  { lineno   = l; filename = f; byteno   = c; }

let cabslu = {lineno = -10; filename = "cabs loc unknown"; byteno = -10;}

(*
** Expression building
*)
let smooth_expression lst =
  match lst with
    [] -> NOTHING
  | [expr] -> expr
  | _ -> COMMA (lst)


let currentFunctionName = ref "<outside any function>"

let announceFunctionName ((n, decl, _, _):name) =
  !Lexerhack.add_identifier n;
  (* Start a context that includes the parameter names and the whole body.
   * Will pop when we finish parsing the function body *)
  !Lexerhack.push_context ();
  (* Go through all the parameter names and mark them as identifiers *)
  let rec findProto = function
      PROTO (d, args, _) when isJUSTBASE d ->
        List.iter (fun (_, (an, _, _, _)) -> !Lexerhack.add_identifier an) args

    | PROTO (d, _, _) -> findProto d
    | PARENTYPE (_, d, _) -> findProto d
    | PTR (_, d) -> findProto d
    | ARRAY (d, _, _) -> findProto d
    | _ -> parse_error "Cannot find the prototype in a function definition";
           raise Parsing.Parse_error

  and isJUSTBASE = function
      JUSTBASE -> true
    | PARENTYPE (_, d, _) -> isJUSTBASE d
    | _ -> false
  in
  findProto decl;
  currentFunctionName := n



let applyPointer (ptspecs: attribute list list) (dt: decl_type)
       : decl_type =
  (* Outer specification first *)
  let rec loop = function
      [] -> dt
    | attrs :: rest -> PTR(attrs, loop rest)
  in
  loop ptspecs

let doDeclaration (loc: cabsloc) (specs: spec_elem list) (nl: init_name list) : definition =
  if isTypedef specs then begin
    (* Tell the lexer about the new type names *)
    List.iter (fun ((n, _, _, _), _) -> !Lexerhack.add_type n) nl;
    TYPEDEF ((specs, List.map (fun (n, _) -> n) nl), loc)
  end else
    if nl = [] then
      ONLYTYPEDEF (specs, loc)
    else begin
      (* Tell the lexer about the new variable names *)
      List.iter (fun ((n, _, _, _), _) -> !Lexerhack.add_identifier n) nl;
      DECDEF ((specs, nl), loc)
    end


let doFunctionDef (loc: cabsloc)
                  (lend: cabsloc)
                  (specs: spec_elem list)
                  (n: name)
                  (b: block) : definition =
  let fname = (specs, n) in
  FUNDEF (fname, b, loc, lend)


let doOldParDecl (names: string list)
                 ((pardefs: name_group list), (isva: bool))
    : single_name list * bool =
  let findOneName n =
    (* Search in pardefs for the definition for this parameter *)
    let rec loopGroups = function
        [] -> ([SpecType Tint], (n, JUSTBASE, [], cabslu))
      | (specs, names) :: restgroups ->
          let rec loopNames = function
              [] -> loopGroups restgroups
            | ((n',_, _, _) as sn) :: _ when n' = n -> (specs, sn)
            | _ :: restnames -> loopNames restnames
          in
          loopNames names
    in
    loopGroups pardefs
  in
  let args = List.map findOneName names in
  (args, isva)

let checkConnective (s : string) : unit =
begin
  (* checking this means I could possibly have more connectives, with *)
  (* different meaning *)
  if (s <> "to") then (
    parse_error "transformer connective must be 'to'";
    raise Parsing.Parse_error
  )
  else ()
end

(* takes a not-nul-terminated list, and converts it to a string. *)
let rec intlist_to_string (str: int64 list):string =
  match str with
    [] -> ""  (* add nul-termination *)
  | value::rest ->
      let this_char =
	if (compare value (Int64.of_int 255) > 0)
           || (compare value Int64.zero < 0)
	then begin
	  let msg = Printf.sprintf "cparser:intlist_to_string: character 0x%Lx too big" value in
	  parse_error msg;
	  raise Parsing.Parse_error
	end
	else
	  String.make 1 (Char.chr (Int64.to_int value))
      in
      this_char ^ (intlist_to_string rest)

let fst3 (result, _, _) = result
let snd3 (_, result, _) = result
let trd3 (_, _, result) = result

%}
%start file
%start interpret
%token <Cabs.cabsloc> ALIGNOF
%token <Cabs.cabsloc> AND
%token <Cabs.cabsloc> AND_AND
%token AND_EQ
%token ARROW
%token <Cabs.cabsloc> ASM
%token <Cabs.cabsloc> ATTRIBUTE
%token <Cabs.cabsloc> ATTRIBUTE_USED
%token <Cabs.cabsloc> AT_EXPR
%token AT_NAME
%token <Cabs.cabsloc> AT_SPECIFIER
%token <Cabs.cabsloc> AT_TRANSFORM
%token <Cabs.cabsloc> AT_TRANSFORMEXPR
%token <Cabs.cabsloc> AUTO
%token BLOCKATTRIBUTE
%token <Cabs.cabsloc> BREAK
%token <Cabs.cabsloc> BUILTIN_VA_ARG
%token BUILTIN_VA_LIST
%token <Cabs.cabsloc> CASE
%token <Cabs.cabsloc> CHAR
%token CIRC
%token CIRC_EQ
%token COLON
%token COMMA
%token <Cabs.cabsloc> CONST
%token <Cabs.cabsloc> CONTINUE
%token <int64 list * Cabs.cabsloc> CST_CHAR
%token <string * Cabs.cabsloc> CST_FLOAT
%token <string * Cabs.cabsloc> CST_INT
%token <int64 list * Cabs.cabsloc> CST_STRING
%token <int64 list * Cabs.cabsloc> CST_WCHAR
%token <int64 list * Cabs.cabsloc> CST_WSTRING
%token <Cabs.cabsloc> DECLSPEC
%token <Cabs.cabsloc> DEFAULT
%token <Cabs.cabsloc> DO
%token DOT
%token <Cabs.cabsloc> DOUBLE
%token ELLIPSIS
%token ELSE
%token <Cabs.cabsloc> ENUM
%token EOF
%token EQ
%token EQ_EQ
%token <Cabs.cabsloc> EXCEPT
%token <Cabs.cabsloc> EXCLAM
%token EXCLAM_EQ
%token <Cabs.cabsloc> EXTERN
%token <Cabs.cabsloc> FINALLY
%token <Cabs.cabsloc> FLOAT
%token <Cabs.cabsloc> FOR
%token <Cabs.cabsloc> FUNCTION__
%token <Cabs.cabsloc> GOTO
%token <string * Cabs.cabsloc> IDENT
%token <Cabs.cabsloc> IF
%token INF
%token INF_EQ
%token INF_INF
%token INF_INF_EQ
%token <Cabs.cabsloc> INLINE
%token <Cabs.cabsloc> INT
%token <Cabs.cabsloc> INT32
%token <Cabs.cabsloc> INT64
%token LABEL__
%token <Cabs.cabsloc> LBRACE
%token LBRACKET
%token <Cabs.cabsloc> LONG
%token <Cabs.cabsloc> LPAREN
%token <Cabs.cabsloc> MINUS
%token MINUS_EQ
%token <Cabs.cabsloc> MINUS_MINUS
%token <string * Cabs.cabsloc> MSASM
%token <string * Cabs.cabsloc> MSATTR
%token <string * Cabs.cabsloc> NAMED_TYPE
%token PERCENT
%token PERCENT_EQ
%token PIPE
%token PIPE_EQ
%token PIPE_PIPE
%token <Cabs.cabsloc> PLUS
%token PLUS_EQ
%token <Cabs.cabsloc> PLUS_PLUS
%token <Cabs.cabsloc> PRAGMA
%token PRAGMA_EOL
%token <string * Cabs.cabsloc> PRAGMA_LINE
%token <Cabs.cabsloc> PRETTY_FUNCTION__
%token QUEST
%token <Cabs.cabsloc> RBRACE
%token RBRACKET
%token <Cabs.cabsloc> REGISTER
%token <Cabs.cabsloc> RESTRICT
%token <Cabs.cabsloc> RETURN
%token RPAREN
%token <Cabs.cabsloc> SEMICOLON
%token <Cabs.cabsloc> SHORT
%token <Cabs.cabsloc> SIGNED
%token <Cabs.cabsloc> SIZEOF
%token SLASH
%token SLASH_EQ
%token <Cabs.cabsloc> STAR
%token STAR_EQ
%token <Cabs.cabsloc> STATIC
%token <Cabs.cabsloc> STRUCT
%token SUP
%token SUP_EQ
%token SUP_SUP
%token SUP_SUP_EQ
%token <Cabs.cabsloc> SWITCH
%token <Cabs.cabsloc> THREAD
%token <Cabs.cabsloc> TILDE
%token <Cabs.cabsloc> TRY
%token <Cabs.cabsloc> TYPEDEF
%token <Cabs.cabsloc> TYPEOF
%token <Cabs.cabsloc> UNION
%token <Cabs.cabsloc> UNSIGNED
%token <Cabs.cabsloc> VOID
%token <Cabs.cabsloc> VOLATILE
%token <Cabs.cabsloc> WHILE
%nonassoc IF
%nonassoc ELSE
%left COMMA
%right AND_EQ CIRC_EQ EQ INF_INF_EQ MINUS_EQ PERCENT_EQ PIPE_EQ PLUS_EQ SLASH_EQ STAR_EQ SUP_SUP_EQ
%right COLON QUEST
%left PIPE_PIPE
%left AND_AND
%left PIPE
%left CIRC
%left AND
%left EQ_EQ EXCLAM_EQ
%left INF INF_EQ SUP SUP_EQ
%left INF_INF SUP_SUP
%left MINUS PLUS
%left CONST PERCENT RESTRICT SLASH STAR VOLATILE
%right ADDROF ALIGNOF CAST EXCLAM MINUS_MINUS PLUS_PLUS RPAREN SIZEOF TILDE
%left LBRACKET
%left ARROW DOT LBRACE LPAREN
%right NAMED_TYPE
%left IDENT
%type <Cabs.decl_type> abs_direct_decl
%type <Cabs.decl_type> abs_direct_decl_opt
%type <Cabs.decl_type * Cabs.attribute list> abstract_decl
%type <Cabs.expression list> arguments
%type <Cabs.attribute list> asmattr
%type <Cabs.attribute list> attributes
%type <Cabs.attribute list> attributes_with_asm
%type <Cabs.block * cabsloc * cabsloc> block
%type <Cabs.statement list> block_element_list
%type <Cabs.expression list> bracket_comma_expression
%type <Cabs.expression list * cabsloc> comma_expression
%type <Cabs.constant * cabsloc> constant
%type <Cabs.spec_elem * cabsloc> cvspec
%type <spec_elem list * cabsloc> decl_spec_list
%type <Cabs.definition> declaration
%type <Cabs.name> declarator
%type <string * Cabs.decl_type> direct_decl
%type <Cabs.enum_item list> enum_list
%type <Cabs.enum_item> enumerator
%type <Cabs.expression * cabsloc> expression
%type <Cabs.name * expression option> field_decl
%type <(Cabs.name * expression option) list> field_decl_list
%type <Cabs.definition list> file
%type <Cabs.definition> function_def
%type <cabsloc * spec_elem list * name> function_def_start
%type <Cabs.definition> global
%type <Cabs.definition list> globals
%type <Cabs.init_name> init_declarator
%type <Cabs.init_name list> init_declarator_list
%type <Cabs.initwhat> init_designators
%type <Cabs.initwhat> init_designators_opt
%type <Cabs.init_expression> init_expression
%type <Cabs.initwhat * Cabs.init_expression> initialiser
%type <(Cabs.initwhat * Cabs.init_expression) list> initialiser_list
%type <Cabs.definition list> interpret
%type <string list> local_label_names
%type <string list> local_labels
%type <Cabs.cabsloc> location
%type <string list> old_parameter_list_ne
%type <Cabs.name> old_proto_decl
%type <Cabs.expression> opt_expression
%type <Cabs.single_name> parameter_decl
%type <Cabs.expression list * cabsloc> paren_comma_expression
%type <attribute list list * cabsloc> pointer
%type <attribute list list * cabsloc> pointer_opt
%type <Cabs.statement> statement
%type <string * cabsloc> string_constant
%type <int64 list * cabsloc> string_list
%type <Cabs.field_group list> struct_decl_list
%type <Cabs.spec_elem list * Cabs.decl_type> type_name
%type <typeSpecifier * cabsloc> type_spec
%type <int64 list * cabsloc> wstring_list
%%

interpret:
  _1 = file _2 = EOF
    {              (_1)}

file:
  _1 = globals
    {                 (_1)}

globals:
  
    {                                        ( [] )}
| _1 = global _2 = globals
    {                                        ( _1 :: _2 )}
| _1 = SEMICOLON _2 = globals
    {                                        ( _2 )}

location:
   %prec IDENT
    {                               ( currentLoc () )}

global:
  _1 = declaration
    {                                        ( _1 )}
| _1 = function_def
    {                                        ( _1 )}
| _1 = EXTERN _2 = string_constant _3 = declaration
    {                                        ( LINKAGE (fst _2, snd _2, [ _3 ]) )}
| _1 = EXTERN _2 = string_constant _3 = LBRACE _4 = globals _5 = RBRACE
    {                                        ( LINKAGE (fst _2, snd _2, _4)  )}
| _1 = ASM _2 = LPAREN _3 = string_constant _4 = RPAREN _5 = SEMICOLON
    {                                        ( GLOBASM (fst _3, _1) )}
| _1 = PRAGMA _2 = attr _3 = PRAGMA_EOL
    {                          ( PRAGMA (_2, _1) )}
| _1 = PRAGMA _2 = attr _3 = SEMICOLON _4 = PRAGMA_EOL
    {                                   ( PRAGMA (_2, _1) )}
| _1 = PRAGMA_LINE
    {                                        ( PRAGMA (VARIABLE (fst _1),
                                                  snd _1) )}
| _1 = IDENT _2 = LPAREN _3 = old_parameter_list_ne _4 = RPAREN _5 = old_pardef_list _6 = SEMICOLON
    {                           ( (* Convert pardecl to new style *)
                             let pardecl, isva = doOldParDecl _3 _5 in
                             (* Make the function declarator *)
                             doDeclaration (snd _1) []
                               [((fst _1, PROTO(JUSTBASE, pardecl,isva), [], cabslu),
                                 NO_INIT)]
                            )}
| _1 = IDENT _2 = LPAREN _3 = RPAREN _4 = SEMICOLON
    {                           ( (* Make the function declarator *)
                             doDeclaration (snd _1) []
                               [((fst _1, PROTO(JUSTBASE,[],false), [], cabslu),
                                 NO_INIT)]
                            )}
| _1 = AT_TRANSFORM _2 = LBRACE _3 = global _4 = RBRACE _5 = IDENT _6 = LBRACE _7 = globals _8 = RBRACE
    {                                                                        (
    checkConnective(fst _5);
    TRANSFORMER(_3, _7, _1)
  )}
| _1 = AT_TRANSFORMEXPR _2 = LBRACE _3 = expression _4 = RBRACE _5 = IDENT _6 = LBRACE _7 = expression _8 = RBRACE
    {                                                                                   (
    checkConnective(fst _5);
    EXPRTRANSFORMER(fst _3, fst _7, _1)
  )}
| _1 = location _2 = error _3 = SEMICOLON
    {                           ( PRAGMA (VARIABLE "parse_error", _1) )}

id_or_typename:
  _1 = IDENT
    {             (fst _1)}
| _1 = NAMED_TYPE
    {                  (fst _1)}
| _1 = AT_NAME _2 = LPAREN _3 = IDENT _4 = RPAREN
    {                                        ( "@name(" ^ fst _3 ^ ")" )}

maybecomma:
  
    {                                        ( () )}
| _1 = COMMA
    {                                        ( () )}

primary_expression:
  _1 = IDENT
    {          (VARIABLE (fst _1), snd _1)}
| _1 = constant
    {          (CONSTANT (fst _1), snd _1)}
| _1 = paren_comma_expression
    {          (smooth_expression (fst _1), snd _1)}
| _1 = LPAREN _2 = block _3 = RPAREN
    {          ( GNU_BODY (fst3 _2), _1 )}
| _1 = AT_EXPR _2 = LPAREN _3 = IDENT _4 = RPAREN
    {                         ( EXPR_PATTERN(fst _3), _1 )}

postfix_expression:
  _1 = primary_expression
    {                        ( _1 )}
| _1 = postfix_expression _2 = bracket_comma_expression
    {   (INDEX (fst _1, smooth_expression _2), snd _1)}
| _1 = postfix_expression _2 = LPAREN _3 = arguments _4 = RPAREN
    {   (CALL (fst _1, _3), snd _1)}
| _1 = BUILTIN_VA_ARG _2 = LPAREN _3 = expression _4 = COMMA _5 = type_name _6 = RPAREN
    {                        ( let b, d = _5 in
                          CALL (VARIABLE "__builtin_va_arg",
                                [fst _3; TYPE_SIZEOF (b, d)]), _1 )}
| _1 = postfix_expression _2 = DOT _3 = id_or_typename
    {          (MEMBEROF (fst _1, _3), snd _1)}
| _1 = postfix_expression _2 = ARROW _3 = id_or_typename
    {          (MEMBEROFPTR (fst _1, _3), snd _1)}
| _1 = postfix_expression _2 = PLUS_PLUS
    {          (UNARY (POSINCR, fst _1), snd _1)}
| _1 = postfix_expression _2 = MINUS_MINUS
    {          (UNARY (POSDECR, fst _1), snd _1)}
| _1 = LPAREN _2 = type_name _3 = RPAREN _4 = LBRACE _5 = initialiser_list_opt _6 = RBRACE
    {          ( CAST(_2, COMPOUND_INIT _5), _1 )}

unary_expression:
  _1 = postfix_expression
    {                        ( _1 )}
| _1 = PLUS_PLUS _2 = unary_expression
    {          (UNARY (PREINCR, fst _2), _1)}
| _1 = MINUS_MINUS _2 = unary_expression
    {          (UNARY (PREDECR, fst _2), _1)}
| _1 = SIZEOF _2 = unary_expression
    {          (EXPR_SIZEOF (fst _2), _1)}
| _1 = SIZEOF _2 = LPAREN _3 = type_name _4 = RPAREN
    {          (let b, d = _3 in TYPE_SIZEOF (b, d), _1)}
| _1 = ALIGNOF _2 = unary_expression
    {          (EXPR_ALIGNOF (fst _2), _1)}
| _1 = ALIGNOF _2 = LPAREN _3 = type_name _4 = RPAREN
    {          (let b, d = _3 in TYPE_ALIGNOF (b, d), _1)}
| _1 = PLUS _2 = cast_expression
    {          (UNARY (PLUS, fst _2), _1)}
| _1 = MINUS _2 = cast_expression
    {          (UNARY (MINUS, fst _2), _1)}
| _1 = STAR _2 = cast_expression
    {          (UNARY (MEMOF, fst _2), _1)}
| _1 = AND _2 = cast_expression
    {          (UNARY (ADDROF, fst _2), _1)}
| _1 = EXCLAM _2 = cast_expression
    {          (UNARY (NOT, fst _2), _1)}
| _1 = TILDE _2 = cast_expression
    {          (UNARY (BNOT, fst _2), _1)}
| _1 = AND_AND _2 = IDENT
    {                               ( LABELADDR (fst _2), _1 )}

cast_expression:
  _1 = unary_expression
    {                         ( _1 )}
| _1 = LPAREN _2 = type_name _3 = RPAREN _4 = cast_expression
    {           ( CAST(_2, SINGLE_INIT (fst _4)), _1 )}

multiplicative_expression:
  _1 = cast_expression
    {                         ( _1 )}
| _1 = multiplicative_expression _2 = STAR _3 = cast_expression
    {   (BINARY(MUL, fst _1, fst _3), snd _1)}
| _1 = multiplicative_expression _2 = SLASH _3 = cast_expression
    {   (BINARY(DIV, fst _1, fst _3), snd _1)}
| _1 = multiplicative_expression _2 = PERCENT _3 = cast_expression
    {   (BINARY(MOD, fst _1, fst _3), snd _1)}

additive_expression:
  _1 = multiplicative_expression
    {                        ( _1 )}
| _1 = additive_expression _2 = PLUS _3 = multiplicative_expression
    {   (BINARY(ADD, fst _1, fst _3), snd _1)}
| _1 = additive_expression _2 = MINUS _3 = multiplicative_expression
    {   (BINARY(SUB, fst _1, fst _3), snd _1)}

shift_expression:
  _1 = additive_expression
    {                         ( _1 )}
| _1 = shift_expression _2 = INF_INF _3 = additive_expression
    {   (BINARY(SHL, fst _1, fst _3), snd _1)}
| _1 = shift_expression _2 = SUP_SUP _3 = additive_expression
    {   (BINARY(SHR, fst _1, fst _3), snd _1)}

relational_expression:
  _1 = shift_expression
    {                        ( _1 )}
| _1 = relational_expression _2 = INF _3 = shift_expression
    {   (BINARY(LT, fst _1, fst _3), snd _1)}
| _1 = relational_expression _2 = SUP _3 = shift_expression
    {   (BINARY(GT, fst _1, fst _3), snd _1)}
| _1 = relational_expression _2 = INF_EQ _3 = shift_expression
    {   (BINARY(LE, fst _1, fst _3), snd _1)}
| _1 = relational_expression _2 = SUP_EQ _3 = shift_expression
    {   (BINARY(GE, fst _1, fst _3), snd _1)}

equality_expression:
  _1 = relational_expression
    {                        ( _1 )}
| _1 = equality_expression _2 = EQ_EQ _3 = relational_expression
    {   (BINARY(EQ, fst _1, fst _3), snd _1)}
| _1 = equality_expression _2 = EXCLAM_EQ _3 = relational_expression
    {   (BINARY(NE, fst _1, fst _3), snd _1)}

bitwise_and_expression:
  _1 = equality_expression
    {                       ( _1 )}
| _1 = bitwise_and_expression _2 = AND _3 = equality_expression
    {   (BINARY(BAND, fst _1, fst _3), snd _1)}

bitwise_xor_expression:
  _1 = bitwise_and_expression
    {                       ( _1 )}
| _1 = bitwise_xor_expression _2 = CIRC _3 = bitwise_and_expression
    {   (BINARY(XOR, fst _1, fst _3), snd _1)}

bitwise_or_expression:
  _1 = bitwise_xor_expression
    {                        ( _1 )}
| _1 = bitwise_or_expression _2 = PIPE _3 = bitwise_xor_expression
    {   (BINARY(BOR, fst _1, fst _3), snd _1)}

logical_and_expression:
  _1 = bitwise_or_expression
    {                        ( _1 )}
| _1 = logical_and_expression _2 = AND_AND _3 = bitwise_or_expression
    {   (BINARY(AND, fst _1, fst _3), snd _1)}

logical_or_expression:
  _1 = logical_and_expression
    {                        ( _1 )}
| _1 = logical_or_expression _2 = PIPE_PIPE _3 = logical_and_expression
    {   (BINARY(OR, fst _1, fst _3), snd _1)}

conditional_expression:
  _1 = logical_or_expression
    {                         ( _1 )}
| _1 = logical_or_expression _2 = QUEST _3 = opt_expression _4 = COLON _5 = conditional_expression
    {   (QUESTION (fst _1, _3, fst _5), snd _1)}

assignment_expression:
  _1 = conditional_expression
    {                         ( _1 )}
| _1 = cast_expression _2 = EQ _3 = assignment_expression
    {   (BINARY(ASSIGN, fst _1, fst _3), snd _1)}
| _1 = cast_expression _2 = PLUS_EQ _3 = assignment_expression
    {   (BINARY(ADD_ASSIGN, fst _1, fst _3), snd _1)}
| _1 = cast_expression _2 = MINUS_EQ _3 = assignment_expression
    {   (BINARY(SUB_ASSIGN, fst _1, fst _3), snd _1)}
| _1 = cast_expression _2 = STAR_EQ _3 = assignment_expression
    {   (BINARY(MUL_ASSIGN, fst _1, fst _3), snd _1)}
| _1 = cast_expression _2 = SLASH_EQ _3 = assignment_expression
    {   (BINARY(DIV_ASSIGN, fst _1, fst _3), snd _1)}
| _1 = cast_expression _2 = PERCENT_EQ _3 = assignment_expression
    {   (BINARY(MOD_ASSIGN, fst _1, fst _3), snd _1)}
| _1 = cast_expression _2 = AND_EQ _3 = assignment_expression
    {   (BINARY(BAND_ASSIGN, fst _1, fst _3), snd _1)}
| _1 = cast_expression _2 = PIPE_EQ _3 = assignment_expression
    {   (BINARY(BOR_ASSIGN, fst _1, fst _3), snd _1)}
| _1 = cast_expression _2 = CIRC_EQ _3 = assignment_expression
    {   (BINARY(XOR_ASSIGN, fst _1, fst _3), snd _1)}
| _1 = cast_expression _2 = INF_INF_EQ _3 = assignment_expression
    {   (BINARY(SHL_ASSIGN, fst _1, fst _3), snd _1)}
| _1 = cast_expression _2 = SUP_SUP_EQ _3 = assignment_expression
    {   (BINARY(SHR_ASSIGN, fst _1, fst _3), snd _1)}

expression:
  _1 = assignment_expression
    {                        ( _1 )}

constant:
  _1 = CST_INT
    {               (CONST_INT (fst _1), snd _1)}
| _1 = CST_FLOAT
    {                 (CONST_FLOAT (fst _1), snd _1)}
| _1 = CST_CHAR
    {                (CONST_CHAR (fst _1), snd _1)}
| _1 = CST_WCHAR
    {                 (CONST_WCHAR (fst _1), snd _1)}
| _1 = string_constant
    {                             (CONST_STRING (fst _1), snd _1)}
| _1 = wstring_list
    {                   (CONST_WSTRING (fst _1), snd _1)}

string_constant:
  _1 = string_list
    {                                        (intlist_to_string (fst _1), snd _1 )}

one_string_constant:
  _1 = CST_STRING
    {                                        (intlist_to_string (fst _1) )}

string_list:
  _1 = one_string
    {                                        ( _1 )}
| _1 = string_list _2 = one_string
    {                                        ( (fst _1) @ (fst _2), snd _1 )}

wstring_list:
  _1 = CST_WSTRING
    {                                        ( _1 )}
| _1 = wstring_list _2 = one_string
    {                                        ( (fst _1) @ (fst _2), snd _1 )}
| _1 = wstring_list _2 = CST_WSTRING
    {                                        ( (fst _1) @ (fst _2), snd _1 )}

one_string:
  _1 = CST_STRING
    {                  (_1)}
| _1 = FUNCTION__
    {                                        ((Cabs.explodeStringToInts
					    !currentFunctionName), _1)}
| _1 = PRETTY_FUNCTION__
    {                                        ((Cabs.explodeStringToInts
					    !currentFunctionName), _1)}

init_expression:
  _1 = expression
    {                        ( SINGLE_INIT (fst _1) )}
| _1 = LBRACE _2 = initialiser_list_opt _3 = RBRACE
    {   ( COMPOUND_INIT _2)}

initialiser_list:
  _1 = initialiser
    {                                            ( [_1] )}
| _1 = initialiser _2 = COMMA _3 = initialiser_list_opt
    {                                            ( _1 :: _3 )}

initialiser_list_opt:
  
    {                                            ( [] )}
| _1 = initialiser_list
    {                                            ( _1 )}

initialiser:
  _1 = init_designators _2 = eq_opt _3 = init_expression
    {                                            ( (_1, _3) )}
| _1 = gcc_init_designators _2 = init_expression
    {                                         ( (_1, _2) )}
| _1 = init_expression
    {                                        ( (NEXT_INIT, _1) )}

eq_opt:
  _1 = EQ
    {                             ( () )}
| 
    {                                 ( () )}

init_designators:
  _1 = DOT _2 = id_or_typename _3 = init_designators_opt
    {                                                 ( INFIELD_INIT(_2, _3) )}
| _1 = LBRACKET _2 = expression _3 = RBRACKET _4 = init_designators_opt
    {                                        ( ATINDEX_INIT(fst _2, _4) )}
| _1 = LBRACKET _2 = expression _3 = ELLIPSIS _4 = expression _5 = RBRACKET
    {                                        ( ATINDEXRANGE_INIT(fst _2, fst _4) )}

init_designators_opt:
  
    {                                        ( NEXT_INIT )}
| _1 = init_designators
    {                                        ( _1 )}

gcc_init_designators:
  _1 = id_or_typename _2 = COLON
    {                                        ( INFIELD_INIT(_1, NEXT_INIT) )}

arguments:
  
    {                                    ( [] )}
| _1 = comma_expression
    {                                    ( fst _1 )}

opt_expression:
  
    {          (NOTHING)}
| _1 = comma_expression
    {          (smooth_expression (fst _1))}

comma_expression:
  _1 = expression
    {                                           ([fst _1], snd _1)}
| _1 = expression _2 = COMMA _3 = comma_expression
    {                                                  ( fst _1 :: fst _3, snd _1 )}
| _1 = error _2 = COMMA _3 = comma_expression
    {                                                  ( _3 )}

comma_expression_opt:
  
    {                                    ( NOTHING )}
| _1 = comma_expression
    {                                    ( smooth_expression (fst _1) )}

paren_comma_expression:
  _1 = LPAREN _2 = comma_expression _3 = RPAREN
    {                                                   ( _2 )}
| _1 = LPAREN _2 = error _3 = RPAREN
    {                                                   ( [], _1 )}

bracket_comma_expression:
  _1 = LBRACKET _2 = comma_expression _3 = RBRACKET
    {                                                       ( fst _2 )}
| _1 = LBRACKET _2 = error _3 = RBRACKET
    {                                                       ( [] )}

block:
  _1 = block_begin _2 = local_labels _3 = block_attrs _4 = block_element_list _5 = RBRACE
    {                                         (!Lexerhack.pop_context();
                                          { blabels = _2;
                                            battrs = _3;
                                            bstmts = _4 },
					    _1, _5
                                         )}
| _1 = error _2 = location _3 = RBRACE
    {                                         ( { blabels = [];
                                             battrs  = [];
                                             bstmts  = [] },
					     _2, _3
                                         )}

block_begin:
  _1 = LBRACE
    {                           (!Lexerhack.push_context (); _1)}

block_attrs:
  
    {                                                            ( [] )}
| _1 = BLOCKATTRIBUTE _2 = paren_attr_list_ne
    {                                        ( [("__blockattribute__", _2)] )}

block_element_list:
  
    {                                         ( [] )}
| _1 = declaration _2 = block_element_list
    {                                         ( DEFINITION(_1) :: _2 )}
| _1 = statement _2 = block_element_list
    {                                         ( _1 :: _2 )}
| _1 = IDENT _2 = COLON
    {                                         ( [ LABEL (fst _1, NOP (snd _1),
                                                    snd _1)] )}

local_labels:
  
    {                                                     ( [] )}
| _1 = LABEL__ _2 = local_label_names _3 = SEMICOLON _4 = local_labels
    {                                                     ( _2 @ _4 )}

local_label_names:
  _1 = IDENT
    {                                         ( [ fst _1 ] )}
| _1 = IDENT _2 = COMMA _3 = local_label_names
    {                                         ( fst _1 :: _3 )}

statement:
  _1 = SEMICOLON
    {               (NOP _1 )}
| _1 = comma_expression _2 = SEMICOLON
    {          (COMPUTATION (smooth_expression (fst _1), snd _1))}
| _1 = block
    {                        (BLOCK (fst3 _1, snd3 _1))}
| _1 = IF _2 = paren_comma_expression _3 = statement %prec IF
    {                 (IF (smooth_expression (fst _2), _3, NOP _1, _1))}
| _1 = IF _2 = paren_comma_expression _3 = statement _4 = ELSE _5 = statement
    {                 (IF (smooth_expression (fst _2), _3, _5, _1))}
| _1 = SWITCH _2 = paren_comma_expression _3 = statement
    {                        (SWITCH (smooth_expression (fst _2), _3, _1))}
| _1 = WHILE _2 = paren_comma_expression _3 = statement
    {          (WHILE (smooth_expression (fst _2), _3, _1))}
| _1 = DO _2 = statement _3 = WHILE _4 = paren_comma_expression _5 = SEMICOLON
    {                   (DOWHILE (smooth_expression (fst _4), _2, _1))}
| _1 = FOR _2 = LPAREN _3 = for_clause _4 = opt_expression _5 = SEMICOLON _6 = opt_expression _7 = RPAREN _8 = statement
    {                          (FOR (_3, _4, _6, _8, _1))}
| _1 = IDENT _2 = COLON _3 = statement
    {                   (LABEL (fst _1, _3, snd _1))}
| _1 = CASE _2 = expression _3 = COLON
    {                          (CASE (fst _2, NOP _1, _1))}
| _1 = CASE _2 = expression _3 = ELLIPSIS _4 = expression _5 = COLON
    {                          (CASERANGE (fst _2, fst _4, NOP _1, _1))}
| _1 = DEFAULT _2 = COLON
    {                          (DEFAULT (NOP _1, _1))}
| _1 = RETURN _2 = SEMICOLON
    {                       (RETURN (NOTHING, _1))}
| _1 = RETURN _2 = comma_expression _3 = SEMICOLON
    {                          (RETURN (smooth_expression (fst _2), _1))}
| _1 = BREAK _2 = SEMICOLON
    {                        (BREAK _1)}
| _1 = CONTINUE _2 = SEMICOLON
    {                        (CONTINUE _1)}
| _1 = GOTO _2 = IDENT _3 = SEMICOLON
    {                   (GOTO (fst _2, _1))}
| _1 = GOTO _2 = STAR _3 = comma_expression _4 = SEMICOLON
    {                                 ( COMPGOTO (smooth_expression (fst _3), _1) )}
| _1 = ASM _2 = asmattr _3 = LPAREN _4 = asmtemplate _5 = asmoutputs _6 = RPAREN _7 = SEMICOLON
    {                        ( let (outs,ins,clobs) = _5 in
                          ASM (_2, _4, outs, ins, clobs, _1) )}
| _1 = MSASM
    {                        ( ASM ([], [fst _1], [], [], [], snd _1))}
| _1 = TRY _2 = block _3 = EXCEPT _4 = paren_comma_expression _5 = block
    {                        ( let b, _, _ = _2 in
                          let h, _, _ = _5 in
                          if not !Cprint.msvcMode then
                            parse_error "try/except in GCC code";
                          TRY_EXCEPT (b, COMMA (fst _4), h, _1) )}
| _1 = TRY _2 = block _3 = FINALLY _4 = block
    {                        ( let b, _, _ = _2 in
                          let h, _, _ = _4 in
                          if not !Cprint.msvcMode then
                            parse_error "try/finally in GCC code";
                          TRY_FINALLY (b, h, _1) )}
| _1 = error _2 = location _3 = SEMICOLON
    {                                 ( (NOP _2))}

for_clause:
  _1 = opt_expression _2 = SEMICOLON
    {                                 ( FC_EXP _1 )}
| _1 = declaration
    {                                 ( FC_DECL _1 )}

declaration:
  _1 = decl_spec_list _2 = init_declarator_list _3 = SEMICOLON
    {                                       ( doDeclaration (snd _1) (fst _1) _2 )}
| _1 = decl_spec_list _2 = SEMICOLON
    {                                    ( doDeclaration (snd _1) (fst _1) [] )}

init_declarator_list:
  _1 = init_declarator
    {                                                 ( [_1] )}
| _1 = init_declarator _2 = COMMA _3 = init_declarator_list
    {                                                 ( _1 :: _3 )}

init_declarator:
  _1 = declarator
    {                                        ( (_1, NO_INIT) )}
| _1 = declarator _2 = EQ _3 = init_expression
    {                                        ( (_1, _3) )}

decl_spec_list:
  _1 = TYPEDEF _2 = decl_spec_list_opt
    {                                        ( SpecTypedef :: _2, _1  )}
| _1 = EXTERN _2 = decl_spec_list_opt
    {                                        ( SpecStorage EXTERN :: _2, _1 )}
| _1 = STATIC _2 = decl_spec_list_opt
    {                                        ( SpecStorage STATIC :: _2, _1 )}
| _1 = AUTO _2 = decl_spec_list_opt
    {                                        ( SpecStorage AUTO :: _2, _1 )}
| _1 = REGISTER _2 = decl_spec_list_opt
    {                                        ( SpecStorage REGISTER :: _2, _1)}
| _1 = type_spec _2 = decl_spec_list_opt_no_named
    {                                          ( SpecType (fst _1) :: _2, snd _1 )}
| _1 = INLINE _2 = decl_spec_list_opt
    {                                        ( SpecInline :: _2, _1 )}
| _1 = cvspec _2 = decl_spec_list_opt
    {                                        ( (fst _1) :: _2, snd _1 )}
| _1 = attribute_nocv _2 = decl_spec_list_opt
    {                                        ( SpecAttr (fst _1) :: _2, snd _1 )}
| _1 = AT_SPECIFIER _2 = LPAREN _3 = IDENT _4 = RPAREN
    {                                        ( [ SpecPattern(fst _3) ], _1 )}

decl_spec_list_opt:
   %prec NAMED_TYPE
    {                                        ( [] )}
| _1 = decl_spec_list
    {                                        ( fst _1 )}

decl_spec_list_opt_no_named:
   %prec IDENT
    {                                        ( [] )}
| _1 = decl_spec_list
    {                                        ( fst _1 )}

type_spec:
  _1 = VOID
    {                    ( Tvoid, _1)}
| _1 = CHAR
    {                    ( Tchar, _1 )}
| _1 = SHORT
    {                    ( Tshort, _1 )}
| _1 = INT
    {                    ( Tint, _1 )}
| _1 = LONG
    {                    ( Tlong, _1 )}
| _1 = INT64
    {                    ( Tint64, _1 )}
| _1 = FLOAT
    {                    ( Tfloat, _1 )}
| _1 = DOUBLE
    {                    ( Tdouble, _1 )}
| _1 = SIGNED
    {                    ( Tsigned, _1 )}
| _1 = UNSIGNED
    {                    ( Tunsigned, _1 )}
| _1 = STRUCT _2 = id_or_typename
    {                                                   ( Tstruct (_2, None,    []), _1 )}
| _1 = STRUCT _2 = id_or_typename _3 = LBRACE _4 = struct_decl_list _5 = RBRACE
    {                                                   ( Tstruct (_2, Some _4, []), _1 )}
| _1 = STRUCT _2 = LBRACE _3 = struct_decl_list _4 = RBRACE
    {                                                   ( Tstruct ("", Some _3, []), _1 )}
| _1 = STRUCT _2 = just_attributes _3 = id_or_typename _4 = LBRACE _5 = struct_decl_list _6 = RBRACE
    {                                                   ( Tstruct (_3, Some _5, _2), _1 )}
| _1 = STRUCT _2 = just_attributes _3 = LBRACE _4 = struct_decl_list _5 = RBRACE
    {                                                   ( Tstruct ("", Some _4, _2), _1 )}
| _1 = UNION _2 = id_or_typename
    {                                                   ( Tunion  (_2, None,    []), _1 )}
| _1 = UNION _2 = id_or_typename _3 = LBRACE _4 = struct_decl_list _5 = RBRACE
    {                                                   ( Tunion  (_2, Some _4, []), _1 )}
| _1 = UNION _2 = LBRACE _3 = struct_decl_list _4 = RBRACE
    {                                                   ( Tunion  ("", Some _3, []), _1 )}
| _1 = UNION _2 = just_attributes _3 = id_or_typename _4 = LBRACE _5 = struct_decl_list _6 = RBRACE
    {                                                   ( Tunion  (_3, Some _5, _2), _1 )}
| _1 = UNION _2 = just_attributes _3 = LBRACE _4 = struct_decl_list _5 = RBRACE
    {                                                   ( Tunion  ("", Some _4, _2), _1 )}
| _1 = ENUM _2 = id_or_typename
    {                                                   ( Tenum   (_2, None,    []), _1 )}
| _1 = ENUM _2 = id_or_typename _3 = LBRACE _4 = enum_list _5 = maybecomma _6 = RBRACE
    {                                                   ( Tenum   (_2, Some _4, []), _1 )}
| _1 = ENUM _2 = LBRACE _3 = enum_list _4 = maybecomma _5 = RBRACE
    {                                                   ( Tenum   ("", Some _3, []), _1 )}
| _1 = ENUM _2 = just_attributes _3 = id_or_typename _4 = LBRACE _5 = enum_list _6 = maybecomma _7 = RBRACE
    {                                                   ( Tenum   (_3, Some _5, _2), _1 )}
| _1 = ENUM _2 = just_attributes _3 = LBRACE _4 = enum_list _5 = maybecomma _6 = RBRACE
    {                                                   ( Tenum   ("", Some _4, _2), _1 )}
| _1 = NAMED_TYPE
    {                    ( Tnamed (fst _1), snd _1 )}
| _1 = TYPEOF _2 = LPAREN _3 = expression _4 = RPAREN
    {                                        ( TtypeofE (fst _3), _1 )}
| _1 = TYPEOF _2 = LPAREN _3 = type_name _4 = RPAREN
    {                                        ( let s, d = _3 in
                                          TtypeofT (s, d), _1 )}

struct_decl_list:
  
    {                                         ( [] )}
| _1 = decl_spec_list _2 = SEMICOLON _3 = struct_decl_list
    {                                         ( (fst _1,
                                            [(missingFieldDecl, None)]) :: _3 )}
| _1 = SEMICOLON _2 = struct_decl_list
    {                                         ( _2 )}
| _1 = decl_spec_list _2 = field_decl_list _3 = SEMICOLON _4 = struct_decl_list
    {                                          ( (fst _1, _2)
                                            :: _4 )}
| _1 = error _2 = SEMICOLON _3 = struct_decl_list
    {                                          ( _3 )}

field_decl_list:
  _1 = field_decl
    {                                         ( [_1] )}
| _1 = field_decl _2 = COMMA _3 = field_decl_list
    {                                         ( _1 :: _3 )}

field_decl:
  _1 = declarator
    {                                    ( (_1, None) )}
| _1 = declarator _2 = COLON _3 = expression
    {                                    ( (_1, Some (fst _3)) )}
| _1 = COLON _2 = expression
    {                                    ( (missingFieldDecl, Some (fst _2)) )}

enum_list:
  _1 = enumerator
    {                  ([_1])}
| _1 = enum_list _2 = COMMA _3 = enumerator
    {                                       (_1 @ [_3])}
| _1 = enum_list _2 = COMMA _3 = error
    {                                        ( _1 )}

enumerator:
  _1 = IDENT
    {            ((fst _1, NOTHING, snd _1))}
| _1 = IDENT _2 = EQ _3 = expression
    {                         ((fst _1, fst _3, snd _1))}

declarator:
  _1 = pointer_opt _2 = direct_decl _3 = attributes_with_asm
    {                                         ( let (n, decl) = _2 in
                                           (n, applyPointer (fst _1) decl, _3, snd _1) )}

direct_decl:
  _1 = id_or_typename
    {                                   ( (_1, JUSTBASE) )}
| _1 = LPAREN _2 = attributes _3 = declarator _4 = RPAREN
    {                                   ( let (n,decl,al,loc) = _3 in
                                     (n, PARENTYPE(_2,decl,al)) )}
| _1 = direct_decl _2 = LBRACKET _3 = attributes _4 = comma_expression_opt _5 = RBRACKET
    {                                   ( let (n, decl) = _1 in
                                     (n, ARRAY(decl, _3, _4)) )}
| _1 = direct_decl _2 = LBRACKET _3 = attributes _4 = error _5 = RBRACKET
    {                                   ( let (n, decl) = _1 in
                                     (n, ARRAY(decl, _3, NOTHING)) )}
| _1 = direct_decl _2 = parameter_list_startscope _3 = rest_par_list _4 = RPAREN
    {                                   ( let (n, decl) = _1 in
                                     let (params, isva) = _3 in
                                     !Lexerhack.pop_context ();
                                     (n, PROTO(decl, params, isva))
                                   )}

parameter_list_startscope:
  _1 = LPAREN
    {                                   ( !Lexerhack.push_context () )}

rest_par_list:
  
    {                                   ( ([], false) )}
| _1 = parameter_decl _2 = rest_par_list1
    {                                   ( let (params, isva) = _2 in
                                     (_1 :: params, isva)
                                   )}

rest_par_list1:
  
    {                                        ( ([], false) )}
| _1 = COMMA _2 = ELLIPSIS
    {                                        ( ([], true) )}
| _1 = COMMA _2 = parameter_decl _3 = rest_par_list1
    {                                        ( let (params, isva) = _3 in
                                          (_2 :: params, isva)
                                        )}

parameter_decl:
  _1 = decl_spec_list _2 = declarator
    {                                          ( (fst _1, _2) )}
| _1 = decl_spec_list _2 = abstract_decl
    {                                          ( let d, a = _2 in
                                            (fst _1, ("", d, a, cabslu)) )}
| _1 = decl_spec_list
    {                                          ( (fst _1, ("", JUSTBASE, [], cabslu)) )}
| _1 = LPAREN _2 = parameter_decl _3 = RPAREN
    {                                          ( _2 )}

old_proto_decl:
  _1 = pointer_opt _2 = direct_old_proto_decl
    {                                      ( let (n, decl, a) = _2 in
					  (n, applyPointer (fst _1) decl, a, snd _1) )}

direct_old_proto_decl:
  _1 = direct_decl _2 = LPAREN _3 = old_parameter_list_ne _4 = RPAREN _5 = old_pardef_list
    {                                   ( let par_decl, isva = doOldParDecl _3 _5 in
                                     let n, decl = _1 in
                                     (n, PROTO(decl, par_decl, isva), [])
                                   )}
| _1 = direct_decl _2 = LPAREN _3 = RPAREN
    {                                   ( let n, decl = _1 in
                                     (n, PROTO(decl, [], false), [])
                                   )}

old_parameter_list_ne:
  _1 = IDENT
    {                                               ( [fst _1] )}
| _1 = IDENT _2 = COMMA _3 = old_parameter_list_ne
    {                                               ( let rest = _3 in
                                                 (fst _1 :: rest) )}

old_pardef_list:
  
    {                                          ( ([], false) )}
| _1 = decl_spec_list _2 = old_pardef _3 = SEMICOLON _4 = ELLIPSIS
    {                                          ( ([(fst _1, _2)], true) )}
| _1 = decl_spec_list _2 = old_pardef _3 = SEMICOLON _4 = old_pardef_list
    {                                          ( let rest, isva = _4 in
                                            ((fst _1, _2) :: rest, isva)
                                          )}

old_pardef:
  _1 = declarator
    {                                          ( [_1] )}
| _1 = declarator _2 = COMMA _3 = old_pardef
    {                                          ( _1 :: _3 )}
| _1 = error
    {                                          ( [] )}

pointer:
  _1 = STAR _2 = attributes _3 = pointer_opt
    {                                ( _2 :: fst _3, _1 )}

pointer_opt:
  
    {                                 ( [], currentLoc () )}
| _1 = pointer
    {                                 ( _1 )}

type_name:
  _1 = decl_spec_list _2 = abstract_decl
    {                               ( let d, a = _2 in
                                 if a <> [] then begin
                                   parse_error "attributes in type name";
                                   raise Parsing.Parse_error
                                 end;
                                 (fst _1, d)
                               )}
| _1 = decl_spec_list
    {                               ( (fst _1, JUSTBASE) )}

abstract_decl:
  _1 = pointer_opt _2 = abs_direct_decl _3 = attributes
    {                                          ( applyPointer (fst _1) _2, _3 )}
| _1 = pointer
    {                                          ( applyPointer (fst _1) JUSTBASE, [] )}

abs_direct_decl:
  _1 = LPAREN _2 = attributes _3 = abstract_decl _4 = RPAREN
    {                                   ( let d, a = _3 in
                                     PARENTYPE (_2, d, a)
                                   )}
| _1 = LPAREN _2 = error _3 = RPAREN
    {                                   ( JUSTBASE )}
| _1 = abs_direct_decl_opt _2 = LBRACKET _3 = comma_expression_opt _4 = RBRACKET
    {                                   ( ARRAY(_1, [], _3) )}
| _1 = abs_direct_decl _2 = parameter_list_startscope _3 = rest_par_list _4 = RPAREN
    {                                   ( let (params, isva) = _3 in
                                     !Lexerhack.pop_context ();
                                     PROTO (_1, params, isva)
                                   )}

abs_direct_decl_opt:
  _1 = abs_direct_decl
    {                                    ( _1 )}
| 
    {                                    ( JUSTBASE )}

function_def:
  _1 = function_def_start _2 = block
    {          ( let (loc, specs, decl) = _1 in
            currentFunctionName := "<__FUNCTION__ used outside any functions>";
            !Lexerhack.pop_context (); (* The context pushed by
                                    * announceFunctionName *)
            doFunctionDef loc (trd3 _2) specs decl (fst3 _2)
          )}

function_def_start:
  _1 = decl_spec_list _2 = declarator
    {                            ( announceFunctionName _2;
                              (snd _1, fst _1, _2)
                            )}
| _1 = decl_spec_list _2 = old_proto_decl
    {                            ( announceFunctionName _2;
                              (snd _1, fst _1, _2)
                            )}
| _1 = IDENT _2 = parameter_list_startscope _3 = rest_par_list _4 = RPAREN
    {                           ( let (params, isva) = _3 in
                             let fdec =
                               (fst _1, PROTO(JUSTBASE, params, isva), [], snd _1) in
                             announceFunctionName fdec;
                             (* Default is int type *)
                             let defSpec = [SpecType Tint] in
                             (snd _1, defSpec, fdec)
                           )}
| _1 = IDENT _2 = LPAREN _3 = old_parameter_list_ne _4 = RPAREN _5 = old_pardef_list
    {                           ( (* Convert pardecl to new style *)
                             let pardecl, isva = doOldParDecl _3 _5 in
                             (* Make the function declarator *)
                             let fdec = (fst _1,
                                         PROTO(JUSTBASE, pardecl,isva),
                                         [], snd _1) in
                             announceFunctionName fdec;
                             (* Default is int type *)
                             let defSpec = [SpecType Tint] in
                             (snd _1, defSpec, fdec)
                            )}
| _1 = IDENT _2 = LPAREN _3 = RPAREN
    {                           ( (* Make the function declarator *)
                             let fdec = (fst _1,
                                         PROTO(JUSTBASE, [], false),
                                         [], snd _1) in
                             announceFunctionName fdec;
                             (* Default is int type *)
                             let defSpec = [SpecType Tint] in
                             (snd _1, defSpec, fdec)
                            )}

cvspec:
  _1 = CONST
    {                                        ( SpecCV(CV_CONST), _1 )}
| _1 = VOLATILE
    {                                        ( SpecCV(CV_VOLATILE), _1 )}
| _1 = RESTRICT
    {                                        ( SpecCV(CV_RESTRICT), _1 )}

attributes:
  
    {                   ( [])}
| _1 = attribute _2 = attributes
    {                                 ( fst _1 :: _2 )}

attributes_with_asm:
  
    {                                        ( [] )}
| _1 = attribute _2 = attributes_with_asm
    {                                        ( fst _1 :: _2 )}
| _1 = ASM _2 = LPAREN _3 = string_constant _4 = RPAREN _5 = attributes
    {                                        ( ("__asm__",
					   [CONSTANT(CONST_STRING (fst _3))]) :: _5 )}

attribute_nocv:
  _1 = ATTRIBUTE _2 = LPAREN _3 = paren_attr_list_ne _4 = RPAREN
    {                                        ( ("__attribute__", _3), _1 )}
| _1 = DECLSPEC _2 = paren_attr_list_ne
    {                                        ( ("__declspec", _2), _1 )}
| _1 = MSATTR
    {                                        ( (fst _1, []), snd _1 )}
| _1 = THREAD
    {                                        ( ("__thread",[]), _1 )}

attribute:
  _1 = attribute_nocv
    {                                        ( _1 )}
| _1 = CONST
    {                                        ( ("const", []), _1 )}
| _1 = RESTRICT
    {                                        ( ("restrict",[]), _1 )}
| _1 = VOLATILE
    {                                        ( ("volatile",[]), _1 )}

just_attribute:
  _1 = ATTRIBUTE _2 = LPAREN _3 = paren_attr_list_ne _4 = RPAREN
    {                                        ( ("__attribute__", _3) )}
| _1 = DECLSPEC _2 = paren_attr_list_ne
    {                                        ( ("__declspec", _2) )}

just_attributes:
  _1 = just_attribute
    {                                        ( [_1] )}
| _1 = just_attribute _2 = just_attributes
    {                                        ( _1 :: _2 )}

primary_attr:
  _1 = IDENT
    {             ( VARIABLE (fst _1) )}
| _1 = NAMED_TYPE
    {                  ( VARIABLE (fst _1) )}
| _1 = LPAREN _2 = attr _3 = RPAREN
    {                                        ( _2 )}
| _1 = IDENT _2 = IDENT
    {                                         ( CALL(VARIABLE (fst _1), [VARIABLE (fst _2)]) )}
| _1 = CST_INT
    {                                         ( CONSTANT(CONST_INT (fst _1)) )}
| _1 = string_constant
    {                                         ( CONSTANT(CONST_STRING (fst _1)) )}
| _1 = CONST
    {                                         ( VARIABLE "aconst" )}
| _1 = IDENT _2 = COLON _3 = CST_INT
    {                                         ( VARIABLE (fst _1 ^ ":" ^ fst _3) )}
| _1 = CST_INT _2 = COLON _3 = CST_INT
    {                                         ( VARIABLE (fst _1 ^ ":" ^ fst _3) )}
| _1 = DEFAULT _2 = COLON _3 = CST_INT
    {                                         ( VARIABLE ("default:" ^ fst _3) )}
| _1 = VOLATILE
    {                                         ( VARIABLE ("__noreturn__") )}

postfix_attr:
  _1 = primary_attr
    {                                         ( _1 )}
| _1 = IDENT _2 = LPAREN _3 = RPAREN
    {                                         ( CALL(VARIABLE (fst _1), [VARIABLE ""]) )}
| _1 = IDENT _2 = paren_attr_list_ne
    {                                         ( CALL(VARIABLE (fst _1), _2) )}
| _1 = postfix_attr _2 = ARROW _3 = id_or_typename
    {                                         (MEMBEROFPTR (_1, _3))}
| _1 = postfix_attr _2 = DOT _3 = id_or_typename
    {                                         (MEMBEROF (_1, _3))}

unary_attr:
  _1 = postfix_attr
    {                                         ( _1 )}
| _1 = SIZEOF _2 = unary_expression
    {                                         (EXPR_SIZEOF (fst _2) )}
| _1 = SIZEOF _2 = LPAREN _3 = type_name _4 = RPAREN
    {                           (let b, d = _3 in TYPE_SIZEOF (b, d))}
| _1 = ALIGNOF _2 = unary_expression
    {                                         (EXPR_ALIGNOF (fst _2) )}
| _1 = ALIGNOF _2 = LPAREN _3 = type_name _4 = RPAREN
    {                                         (let b, d = _3 in TYPE_ALIGNOF (b, d))}
| _1 = PLUS _2 = cast_attr
    {                                        (UNARY (PLUS, _2))}
| _1 = MINUS _2 = cast_attr
    {                                        (UNARY (MINUS, _2))}
| _1 = STAR _2 = cast_attr
    {                            (UNARY (MEMOF, _2))}
| _1 = AND _2 = cast_attr
    {                                 (UNARY (ADDROF, _2))}
| _1 = EXCLAM _2 = cast_attr
    {                                 (UNARY (NOT, _2))}
| _1 = TILDE _2 = cast_attr
    {                                        (UNARY (BNOT, _2))}

cast_attr:
  _1 = unary_attr
    {                                         ( _1 )}

multiplicative_attr:
  _1 = cast_attr
    {                                        ( _1 )}
| _1 = multiplicative_attr _2 = STAR _3 = cast_attr
    {                                        (BINARY(MUL ,_1 , _3))}
| _1 = multiplicative_attr _2 = SLASH _3 = cast_attr
    {                                          (BINARY(DIV ,_1 , _3))}
| _1 = multiplicative_attr _2 = PERCENT _3 = cast_attr
    {                                          (BINARY(MOD ,_1 , _3))}

additive_attr:
  _1 = multiplicative_attr
    {                                        ( _1 )}
| _1 = additive_attr _2 = PLUS _3 = multiplicative_attr
    {                                            (BINARY(ADD ,_1 , _3))}
| _1 = additive_attr _2 = MINUS _3 = multiplicative_attr
    {                                            (BINARY(SUB ,_1 , _3))}

shift_attr:
  _1 = additive_attr
    {                                        ( _1 )}
| _1 = shift_attr _2 = INF_INF _3 = additive_attr
    {                                     (BINARY(SHL ,_1 , _3))}
| _1 = shift_attr _2 = SUP_SUP _3 = additive_attr
    {                                     (BINARY(SHR ,_1 , _3))}

relational_attr:
  _1 = shift_attr
    {                                        ( _1 )}
| _1 = relational_attr _2 = INF _3 = shift_attr
    {                                   (BINARY(LT ,_1 , _3))}
| _1 = relational_attr _2 = SUP _3 = shift_attr
    {                                   (BINARY(GT ,_1 , _3))}
| _1 = relational_attr _2 = INF_EQ _3 = shift_attr
    {                                      (BINARY(LE ,_1 , _3))}
| _1 = relational_attr _2 = SUP_EQ _3 = shift_attr
    {                                      (BINARY(GE ,_1 , _3))}

equality_attr:
  _1 = relational_attr
    {                                        ( _1 )}
| _1 = equality_attr _2 = EQ_EQ _3 = relational_attr
    {                                            (BINARY(EQ ,_1 , _3))}
| _1 = equality_attr _2 = EXCLAM_EQ _3 = relational_attr
    {                                            (BINARY(NE ,_1 , _3))}

bitwise_and_attr:
  _1 = equality_attr
    {                                        ( _1 )}
| _1 = bitwise_and_attr _2 = AND _3 = equality_attr
    {                                       (BINARY(BAND ,_1 , _3))}

bitwise_xor_attr:
  _1 = bitwise_and_attr
    {                                           ( _1 )}
| _1 = bitwise_xor_attr _2 = CIRC _3 = bitwise_and_attr
    {                                           (BINARY(XOR ,_1 , _3))}

bitwise_or_attr:
  _1 = bitwise_xor_attr
    {                                          ( _1 )}
| _1 = bitwise_or_attr _2 = PIPE _3 = bitwise_xor_attr
    {                                          (BINARY(BOR ,_1 , _3))}

logical_and_attr:
  _1 = bitwise_or_attr
    {                                                ( _1 )}
| _1 = logical_and_attr _2 = AND_AND _3 = bitwise_or_attr
    {                                             (BINARY(AND ,_1 , _3))}

logical_or_attr:
  _1 = logical_and_attr
    {                                               ( _1 )}
| _1 = logical_or_attr _2 = PIPE_PIPE _3 = logical_and_attr
    {                                               (BINARY(OR ,_1 , _3))}

attr:
  _1 = logical_or_attr
    {                                         ( _1 )}

attr_list_ne:
  _1 = attr
    {                                         ( [_1] )}
| _1 = attr _2 = COMMA _3 = attr_list_ne
    {                                         ( _1 :: _3 )}
| _1 = error _2 = COMMA _3 = attr_list_ne
    {                                         ( _3 )}

paren_attr_list_ne:
  _1 = LPAREN _2 = attr_list_ne _3 = RPAREN
    {                                         ( _2 )}
| _1 = LPAREN _2 = error _3 = RPAREN
    {                                         ( [] )}

asmattr:
  
    {                                        ( [] )}
| _1 = VOLATILE _2 = asmattr
    {                                        ( ("volatile", []) :: _2 )}
| _1 = CONST _2 = asmattr
    {                                        ( ("const", []) :: _2 )}

asmtemplate:
  _1 = one_string_constant
    {                                                 ( [_1] )}
| _1 = one_string_constant _2 = asmtemplate
    {                                                 ( _1 :: _2 )}

asmoutputs:
  
    {                        ( ([], [], []) )}
| _1 = COLON _2 = asmoperands _3 = asminputs
    {                        ( let (ins, clobs) = _3 in
                          (_2, ins, clobs) )}

asmoperands:
  
    {                                        ( [] )}
| _1 = asmoperandsne
    {                                        ( List.rev _1 )}

asmoperandsne:
  _1 = asmoperand
    {                                        ( [_1] )}
| _1 = asmoperandsne _2 = COMMA _3 = asmoperand
    {                                        ( _3 :: _1 )}

asmoperand:
  _1 = string_constant _2 = LPAREN _3 = expression _4 = RPAREN
    {                                                 ( (fst _1, fst _3) )}
| _1 = string_constant _2 = LPAREN _3 = error _4 = RPAREN
    {                                                 ( (fst _1, NOTHING ) )}

asminputs:
  
    {                             ( ([], []) )}
| _1 = COLON _2 = asmoperands _3 = asmclobber
    {                        ( (_2, _3) )}

asmclobber:
  
    {                                        ( [] )}
| _1 = COLON _2 = asmcloberlst_ne
    {                                        ( _2 )}

asmcloberlst_ne:
  _1 = one_string_constant
    {                                                 ( [_1] )}
| _1 = one_string_constant _2 = COMMA _3 = asmcloberlst_ne
    {                                                 ( _1 :: _3 )}

%%







