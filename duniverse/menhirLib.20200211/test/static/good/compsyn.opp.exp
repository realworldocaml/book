File "compsyn.mly", line 281, characters 7-16:
Warning: the token CAPITAL_E is unused.
File "compsyn.mly", line 203, characters 41-44:
Warning: the token EOL is unused.
File "compsyn.mly", line 282, characters 7-15:
Warning: the token LITTLE_E is unused.
%{
open Typedef

let pos_fn = ref "";;
let pos_ln = ref 0;;
let pos_cn = ref 0;;

let delunderscore strg = String.concat "" (Str.split (Str.regexp "['_']+") strg)
;;

let string2base_number strg =
	try
	let pos = String.index strg '\'' in
		let b = String.get strg (pos+1)
		and len = try
			int_of_string (delunderscore (String.sub strg 0 pos))
		with int_of_string -> begin
			Printf.printf "fatal error : base number without width %s at " strg;
			Printf.printf "file : %s " !pos_fn;
			Printf.printf "line : %d " ((!pos_ln) + 1); (*because it start from 0*)
			Printf.printf "char : %d\n" !pos_cn;
			exit 1
		end
		and num = delunderscore(String.sub strg (pos+2) ((String.length strg)-pos-2))
		in begin
			match b with
			'b' -> begin
				let lennum = String.length num
				in begin
					if lennum = len then T_number_base(len,'b',num)
					else if lennum < len then T_number_base(len,'b',(String.concat "" [(String.make (len - lennum) '0');num]))
					else begin
						Printf.printf  "warning : lennum > len %s\n" strg;
						T_number_base(len,'b',(String.sub num (lennum-len) len))
					end
				end
			end
			| 'B' -> begin
				let lennum = String.length num
				in begin
					if lennum = len then T_number_base(len,'b',num)
					else if lennum < len then T_number_base(len,'b',(String.concat "" [(String.make (len - lennum) '0');num]))
					else begin
						Printf.printf  "warning : lennum > len %s\n" strg;
						T_number_base(len,'b',(String.sub num (lennum-len) len))
					end
				end
			end
			| 'h' -> begin
				Printf.printf "NOTE : to convert %s 1\n" strg;
				let newnum = Misc2.hexstring2binstring num
				in
				let lennum = String.length newnum
				in begin
					if lennum = len then T_number_base(len,'b',newnum)
					else if lennum < len then T_number_base(len,'b',(String.concat "" [(String.make (len - lennum) '0');newnum]))
					else begin
						Printf.printf  "warning : lennum > len %s\n" strg;
						T_number_base(len,'b',(String.sub newnum (lennum-len) len))
					end
				end
			end
			| 'H' -> begin
				Printf.printf "NOTE : to convert %s 2\n" strg;
				let newnum = Misc2.hexstring2binstring num
				in
				let lennum = String.length newnum
				in begin
					if lennum = len then T_number_base(len,'b',newnum)
					else if lennum < len then T_number_base(len,'b',(String.concat "" [(String.make (len - lennum) '0');newnum]))
					else begin
						Printf.printf  "warning : lennum > len %s\n" strg;
						T_number_base(len,'b',(String.sub newnum (lennum-len) len))
					end
				end
			end
			| 'd' -> begin
				let newnum = Misc2.decstring2binstring num
				in
				let lennum = String.length newnum
				in begin
					if lennum = len then T_number_base(len,'b',newnum)
					else if lennum < len then T_number_base(len,'b',(String.concat "" [(String.make (len - lennum) '0');newnum]))
					else begin
						Printf.printf  "warning : lennum > len %s\n" strg;
						T_number_base(len,'b',(String.sub newnum (lennum-len) len))
					end
				end
			end
			| 'D' -> begin
				let newnum = Misc2.decstring2binstring num
				in
				let lennum = String.length newnum
				in begin
					if lennum = len then T_number_base(len,'b',newnum)
					else if lennum < len then T_number_base(len,'b',(String.concat "" [(String.make (len - lennum) '0');newnum]))
					else begin
						Printf.printf  "warning : lennum > len %s\n" strg;
						T_number_base(len,'b',(String.sub newnum (lennum-len) len))
					end
				end
			end
			| _ -> begin
				Printf.printf  "fatal error : invalid number %s\n" strg;
				exit 1
			end
		end
	with Not_found -> print_endline "not found";print_endline strg; exit 1
;;

let parse_error str = begin
	Printf.printf "fatal error : %s at " str;
	Printf.printf "file : %s " !pos_fn;
	Printf.printf "line : %d " ((!pos_ln) + 1); (*because it start from 0*)
	Printf.printf "char : %d\n" !pos_cn;
	exit 1
end
;;
let get_pos (pos : Lexing.position ) = begin
	pos_fn := pos.Lexing.pos_fname;
	pos_ln := pos.Lexing.pos_lnum;
	pos_cn := pos.Lexing.pos_cnum-pos.Lexing.pos_bol
end
;;
let get_endpos pos2 = begin
	match pos2 with
	(_,pos) -> get_pos pos
end
;;
%}
%start source_text
%token <Lexing.position*Lexing.position> ADD
%token <Lexing.position*Lexing.position> AND3
%token <Lexing.position*Lexing.position> AT
%token <string> BASE_NUMBER
%token <Lexing.position*Lexing.position> BIT_AND
%token <Lexing.position*Lexing.position> BIT_EQU
%token <Lexing.position*Lexing.position> BIT_NEG
%token <Lexing.position*Lexing.position> BIT_OR
%token <Lexing.position*Lexing.position> BIT_XOR
%token CAPITAL_E
%token <Lexing.position*Lexing.position> CASE_EQU
%token <Lexing.position*Lexing.position> CASE_INE
%token <Lexing.position*Lexing.position> COLON
%token <Lexing.position*Lexing.position> COMMA
%token <Lexing.position*Lexing.position> DIV
%token <Lexing.position*Lexing.position> DOLLOR
%token DOLLOR_HOLD
%token DOLLOR_PERIOD
%token DOLLOR_RECOVERY
%token DOLLOR_SETUP
%token DOLLOR_SETUPHOLD
%token DOLLOR_SKEW
%token <string> DOLLOR_SYSTEM_IDENTIFIER
%token DOLLOR_WIDTH
%token <Lexing.position*Lexing.position> DOT
%token <Lexing.position*Lexing.position> EOF
%token <Lexing.position*Lexing.position> EOL
%token <string> FLOAT_NUMBER
%token <string> GATETYPE
%token <Lexing.position*Lexing.position> GE
%token <Lexing.position*Lexing.position> GT
%token <string> IDENTIFIER
%token <Lexing.position*Lexing.position> JING
%token <Lexing.position*Lexing.position> KEY_ALWAYS
%token <Lexing.position*Lexing.position> KEY_ASSIGN
%token <Lexing.position*Lexing.position> KEY_BEGIN
%token <Lexing.position*Lexing.position> KEY_CASE
%token <Lexing.position*Lexing.position> KEY_CASEX
%token <Lexing.position*Lexing.position> KEY_CASEZ
%token <Lexing.position*Lexing.position> KEY_DEFAULT
%token <Lexing.position*Lexing.position> KEY_DEFPARAM
%token <Lexing.position*Lexing.position> KEY_DISABLE
%token <Lexing.position*Lexing.position> KEY_EDGE
%token <Lexing.position*Lexing.position> KEY_ELSE
%token <Lexing.position*Lexing.position> KEY_END
%token <Lexing.position*Lexing.position> KEY_ENDCASE
%token <Lexing.position*Lexing.position> KEY_ENDFUNCTION
%token <Lexing.position*Lexing.position> KEY_ENDMODULE
%token <Lexing.position*Lexing.position> KEY_ENDSPECIFY
%token <Lexing.position*Lexing.position> KEY_ENDTASK
%token <Lexing.position*Lexing.position> KEY_EVENT
%token <Lexing.position*Lexing.position> KEY_FOR
%token <Lexing.position*Lexing.position> KEY_FORCE
%token <Lexing.position*Lexing.position> KEY_FOREVER
%token <Lexing.position*Lexing.position> KEY_FORK
%token <Lexing.position*Lexing.position> KEY_FUNCTION
%token <Lexing.position*Lexing.position> KEY_IF
%token <Lexing.position*Lexing.position> KEY_INITIAL
%token <Lexing.position*Lexing.position> KEY_INOUT
%token <Lexing.position*Lexing.position> KEY_INPUT
%token <Lexing.position*Lexing.position> KEY_INTEGER
%token <Lexing.position*Lexing.position> KEY_JOIN
%token <Lexing.position*Lexing.position> KEY_LARGE
%token <Lexing.position*Lexing.position> KEY_MEDIUM
%token <Lexing.position*Lexing.position> KEY_MODULE
%token <Lexing.position*Lexing.position> KEY_NEGEDGE
%token <Lexing.position*Lexing.position> KEY_OR
%token <Lexing.position*Lexing.position> KEY_OUTPUT
%token <Lexing.position*Lexing.position> KEY_PARAMETER
%token <Lexing.position*Lexing.position> KEY_POSEDGE
%token <Lexing.position*Lexing.position> KEY_REAL
%token <Lexing.position*Lexing.position> KEY_REG
%token <Lexing.position*Lexing.position> KEY_RELEASE
%token <Lexing.position*Lexing.position> KEY_REPEAT
%token <Lexing.position*Lexing.position> KEY_SCALARED
%token <Lexing.position*Lexing.position> KEY_SMALL
%token <Lexing.position*Lexing.position> KEY_SPECIFY
%token <Lexing.position*Lexing.position> KEY_SPECPARAM
%token <Lexing.position*Lexing.position> KEY_TASK
%token <Lexing.position*Lexing.position> KEY_TIME
%token <Lexing.position*Lexing.position> KEY_VECTORED
%token <Lexing.position*Lexing.position> KEY_WAIT
%token <Lexing.position*Lexing.position> KEY_WHILE
%token <Lexing.position*Lexing.position> LBRACE
%token <Lexing.position*Lexing.position> LBRACKET
%token <Lexing.position*Lexing.position> LE
%token <Lexing.position*Lexing.position> LEADTO
%token <Lexing.position*Lexing.position> LEFT_SHIFT
%token LITTLE_E
%token <Lexing.position*Lexing.position> LOGIC_AND
%token <Lexing.position*Lexing.position> LOGIC_EQU
%token <Lexing.position*Lexing.position> LOGIC_INE
%token <Lexing.position*Lexing.position> LOGIC_NEG
%token <Lexing.position*Lexing.position> LOGIC_OR
%token <Lexing.position*Lexing.position> LPAREN
%token <Lexing.position*Lexing.position> LT
%token <Lexing.position*Lexing.position> MOD
%token <Lexing.position*Lexing.position> MUL
%token <string> NETTYPE
%token <Lexing.position*Lexing.position> PATHTO
%token <Lexing.position*Lexing.position> PATHTOSTAR
%token <Lexing.position*Lexing.position> QUESTION_MARK
%token <Lexing.position*Lexing.position> QUESTION_MARK_COLON
%token <Lexing.position*Lexing.position> RBRACE
%token <Lexing.position*Lexing.position> RBRACKET
%token <Lexing.position*Lexing.position> RED_NAND
%token <Lexing.position*Lexing.position> RED_NOR
%token <Lexing.position*Lexing.position> RIGHT_SHIFT
%token <Lexing.position*Lexing.position> RPAREN
%token <Lexing.position*Lexing.position> SEMICOLON
%token <Lexing.position*Lexing.position> SINGLEASSIGN
%token <string> STRENGTH0
%token <string> STRENGTH1
%token <string> STRING
%token <Lexing.position*Lexing.position> SUB
%token <string> UNSIGNED_NUMBER
%right QUESTION_MARK
%left LOGIC_OR
%left LOGIC_AND
%left BIT_OR
%left BIT_EQU BIT_XOR
%left BIT_AND
%left CASE_EQU CASE_INE LOGIC_EQU LOGIC_INE
%left GE GT LE LT
%left LEFT_SHIFT RIGHT_SHIFT
%left ADD SUB
%left DIV MOD MUL
%left BIT_NEG LOGIC_NEG RED_NAND RED_NOR
%left UADD UAND UEQU UOR USUB UXOR
%type <Typedef.module_def list> source_text
%%

source_text:
  _1 = description_list _2 = EOF
    {   (
				get_endpos _2;
				_1
			)}

description_list:
  _1 = description
    {              ( _1::[] )}
| _1 = description _2 = source_text
    {                             (  _1::_2 )}

description:
  _1 = module_def
    {             (
					_1
				)}

module_def:
  _1 = KEY_MODULE _2 = IDENTIFIER _3 = list_of_ports_opt _4 = SEMICOLON _5 = module_item_optlist _6 = KEY_ENDMODULE
    {   (
				(*print_endline $2;*)
				get_endpos _6;
				T_module_def(_2,_3,_5)
			)}

list_of_ports_opt:
  
    {   ([])}
| _1 = list_of_ports
    {                  (_1)}

list_of_ports:
  _1 = LPAREN _2 = port _3 = comma_port_optlist _4 = RPAREN
    {   (
				get_endpos _4;
				_2::_3
			)}

comma_port_optlist:
  
    {   ([])}
| _1 = comma_port _2 = comma_port_optlist
    {                                   (_1::_2)}

comma_port:
  _1 = COMMA _2 = port
    {   (
				_2
			)}

port:
  _1 = port_expression_opt
    {                       (_1)}

port_expression_opt:
  
    {      ([])}
| _1 = port_expression
    {                     (_1)}

port_expression:
  _1 = port_reference
    {                   ([_1])}
| _1 = LBRACE _2 = port_reference _3 = comma_port_reference_optlist _4 = RBRACE
    {  (
			get_endpos _4;
			_2::_3
		)}

comma_port_reference_optlist:
  
    {      ([])}
| _1 = comma_port_reference _2 = comma_port_reference_optlist
    {                                                     (_1::_2)}

comma_port_reference:
  _1 = COMMA _2 = port_reference
    {                        (_2)}

port_reference:
  _1 = IDENTIFIER
    {               (_1)}

module_item_optlist:
  
    {     ([])}
| _1 = module_item _2 = module_item_optlist
    {                                    (_1::_2)}

module_item:
  _1 = parameter_declaration
    {                          (_1)}
| _1 = input_declaration
    {                        (_1)}
| _1 = output_declaration
    {                         (_1)}
| _1 = inout_declaration
    {                        (_1)}
| _1 = net_declaration
    {                      (_1)}
| _1 = reg_declaration
    {                     (_1)}
| _1 = time_declaration
    {                      (T_time_declaration(_1))}
| _1 = integer_declaration
    {                         (T_integer_declaration(_1))}
| _1 = real_declaration
    {                      (_1)}
| _1 = event_declaration
    {                       (_1)}
| _1 = gate_declaration
    {                      (_1)}
| _1 = module_instantiation
    {                          (_1)}
| _1 = parameter_override
    {                        (_1)}
| _1 = continuous_assign
    {                       (T_continuous_assign(_1))}
| _1 = specify_block
    {                   (_1)}
| _1 = initial_statement
    {                       (T_initial_statement(_1))}
| _1 = always_statement
    {                      (T_always_statement(_1))}
| _1 = task
    {          (_1)}
| _1 = function_avoid_amb
    {                        (_1)}

function_avoid_amb:
  _1 = KEY_FUNCTION _2 = range_or_type_opt _3 = IDENTIFIER _4 = SEMICOLON _5 = tf_declaration_list _6 = statement _7 = KEY_ENDFUNCTION
    {   (
				get_endpos _7;
				T_function_avoid_amb(_2,_3,_5,_6)
			)}

tf_declaration_list:
  _1 = tf_declaration
    {                  ([_1])}
| _1 = tf_declaration _2 = tf_declaration_list
    {                                       (_1::_2)}

range_or_type_opt:
  
    {    (T_range_or_type_NOSPEC)}
| _1 = range_or_type
    {                  (_1)}

range_or_type:
  _1 = range
    {       (T_range_or_type_range(_1))}
| _1 = KEY_INTEGER
    {                 (T_range_or_type_INTEGER)}
| _1 = KEY_REAL
    {              (T_range_or_type_REAL)}

task:
  _1 = KEY_TASK _2 = IDENTIFIER _3 = SEMICOLON _4 = tf_declaration_optlist _5 = statement_or_null _6 = KEY_ENDTASK
    {  (
			get_endpos _6;
			T_task(_2,_4,_5)
		)}

tf_declaration_optlist:
  
    {   ([])}
| _1 = tf_declaration _2 = tf_declaration_optlist
    {                                         (_1::_2)}

tf_declaration:
  _1 = parameter_declaration
    {                       (_1)}
| _1 = input_declaration
    {                     (_1)}
| _1 = output_declaration
    {                      (_1)}
| _1 = inout_declaration
    {                     (_1)}
| _1 = reg_declaration
    {                   (_1)}
| _1 = time_declaration
    {                    (T_time_declaration(_1))}
| _1 = integer_declaration
    {                       (T_integer_declaration(_1))}
| _1 = real_declaration
    {                    (_1)}
| _1 = event_declaration
    {                     (_1)}

initial_statement:
  _1 = KEY_INITIAL _2 = statement
    {                          (_2)}

specify_block:
  _1 = KEY_SPECIFY _2 = specify_item_optlist _3 = KEY_ENDSPECIFY
    {  (
			get_endpos _3;
			T_specify_block(_2)
		)}

specify_item_optlist:
  
    {   ([])}
| _1 = specify_item _2 = specify_item_optlist
    {                                     (_1::_2)}

specify_item:
  _1 = specparam_declaration
    {                       (0)}
| _1 = path_declaration
    {                     (0)}
| _1 = level_sensitive_path_declaration
    {                                    (0)}
| _1 = edge_sensitive_path_declaration
    {                                   (0)}
| _1 = system_timing_check
    {                       (0)}
| _1 = sdpd
    {        (0)}

sdpd:
  _1 = KEY_IF _2 = LPAREN _3 = expression _4 = RPAREN _5 = path_description _6 = SINGLEASSIGN _7 = path_delay_value _8 = SEMICOLON
    {  (
			get_endpos _8;
			0
		)}

system_timing_check:
  _1 = DOLLOR_SETUP _2 = LPAREN _3 = timing_check_event _4 = COMMA _5 = timing_check_event _6 = COMMA _7 = timing_check_limit _8 = comma_notify_register_opt _9 = RPAREN _10 = SEMICOLON
    { (
		get_endpos _10;
		0
	)}
| _1 = DOLLOR_HOLD _2 = LPAREN _3 = timing_check_event _4 = COMMA _5 = timing_check_event _6 = COMMA _7 = timing_check_limit _8 = comma_notify_register_opt _9 = RPAREN _10 = SEMICOLON
    { (
		get_endpos _10;
		0
	)}
| _1 = DOLLOR_PERIOD _2 = LPAREN _3 = controlled_timing_check_event _4 = COMMA _5 = timing_check_limit _6 = comma_notify_register_opt _7 = RPAREN _8 = SEMICOLON
    { (
		get_endpos _8;
		0
	)}
| _1 = DOLLOR_WIDTH _2 = LPAREN _3 = controlled_timing_check_event _4 = COMMA _5 = timing_check_limit _6 = comma_constant_expression_comma_notify_register_opt _7 = RPAREN _8 = SEMICOLON
    { (
		get_endpos _8;
		0
	)}
| _1 = DOLLOR_SKEW _2 = LPAREN _3 = timing_check_event _4 = COMMA _5 = timing_check_event _6 = COMMA _7 = timing_check_limit _8 = comma_notify_register_opt _9 = RPAREN _10 = SEMICOLON
    { (
		get_endpos _10;
		0
	)}
| _1 = DOLLOR_RECOVERY _2 = LPAREN _3 = controlled_timing_check_event _4 = COMMA _5 = timing_check_event _6 = COMMA _7 = timing_check_limit _8 = comma_notify_register_opt _9 = RPAREN _10 = SEMICOLON
    { (
		get_endpos _10;
		0
	)}
| _1 = DOLLOR_SETUPHOLD _2 = LPAREN _3 = timing_check_event _4 = COMMA _5 = timing_check_event _6 = COMMA _7 = timing_check_limit _8 = COMMA _9 = timing_check_limit _10 = comma_notify_register_opt _11 = RPAREN _12 = SEMICOLON
    { (
		get_endpos _12;
		0
	)}

comma_constant_expression_comma_notify_register_opt:
  
    {   (0)}
| _1 = comma_constant_expression_comma_notify_register
    {                                                   (0)}

comma_constant_expression_comma_notify_register:
  _1 = COMMA _2 = constant_expression _3 = COMMA _4 = notify_register
    {                                                  (0)}

notify_register:
  _1 = identifier
    {             (0)}

controlled_timing_check_event:
  _1 = timing_check_event_control _2 = specify_terminal_descriptor _3 = and3_timing_check_condition_opt
    {                                                                                         (0)}

and3_timing_check_condition_opt:
  
    {   (0)}
| _1 = and3_timing_check_condition
    {                                (0)}

and3_timing_check_condition:
  _1 = AND3 _2 = timing_check_condition
    {                              (0)}

timing_check_condition:
  _1 = expression
    {             (0)}

comma_notify_register_opt:
  
    {   (0)}
| _1 = comma_notify_register
    {                         (0)}

comma_notify_register:
  _1 = COMMA _2 = notify_register
    {                        (0)}

timing_check_limit:
  _1 = expression
    {             (0)}

timing_check_event:
  _1 = timing_check_event_control_opt _2 = specify_terminal_descriptor _3 = and3_timing_check_condition_opt
    {                                                                                              (0)}

timing_check_event_control_opt:
  
    {   (0)}
| _1 = timing_check_event_control
    {                              (0)}

timing_check_event_control:
  _1 = KEY_POSEDGE
    { (
		get_endpos _1;
		0
	)}
| _1 = KEY_NEGEDGE
    { (
		get_endpos _1;
		0
	)}
| _1 = edge_control_specifier
    {                          (0)}

edge_control_specifier:
  _1 = KEY_EDGE _2 = LBRACKET _3 = edge_descriptor _4 = comma_edge_descriptor_optlist _5 = RBRACKET
    { (
		get_endpos _5;
		0
	)}

edge_descriptor:
  
    {  (print_string "no supported edge_descriptor";0)}

comma_edge_descriptor_optlist:
  
    {   (0)}
| _1 = comma_edge_descriptor _2 = comma_edge_descriptor_optlist
    {                                                       (0)}

comma_edge_descriptor:
  _1 = COMMA _2 = edge_descriptor
    {                        (0)}

edge_sensitive_path_declaration:
  _1 = KEY_IF_LPAREN_expression_RPAREN_opt _2 = LPAREN _3 = edge_identifier_opt _4 = specify_terminal_descriptor _5 = PATHTO _6 = LPAREN _7 = specify_terminal_descriptor _8 = polarity_operator _9 = QUESTION_MARK_COLON _10 = data_source_expression _11 = RPAREN _12 = RPAREN _13 = SINGLEASSIGN _14 = path_delay_value _15 = SEMICOLON
    { (
		get_endpos _15;
		0
	)}
| _1 = KEY_IF_LPAREN_expression_RPAREN_opt _2 = LPAREN _3 = edge_identifier_opt _4 = specify_terminal_descriptor _5 = PATHTOSTAR _6 = LPAREN _7 = list_of_path_input_outputs _8 = polarity_operator _9 = QUESTION_MARK_COLON _10 = data_source_expression _11 = RPAREN _12 = RPAREN _13 = SINGLEASSIGN _14 = path_delay_value _15 = SEMICOLON
    { (
		get_endpos _15;
		0
	)}

list_of_path_input_outputs:
  _1 = specify_terminal_descriptor _2 = comma_specify_terminal_descriptor_optlist
    {                                                                       (0)}

comma_specify_terminal_descriptor_optlist:
  
    {   (0)}
| _1 = comma_specify_terminal_descriptor _2 = comma_specify_terminal_descriptor_optlist
    {                                                                               (0)}

comma_specify_terminal_descriptor:
  _1 = COMMA _2 = specify_terminal_descriptor
    {                                   (0)}

data_source_expression:
  _1 = expression
    {             (0)}

edge_identifier_opt:
  
    {  (0)}
| _1 = edge_identifier
    {                    (0)}

edge_identifier:
  _1 = KEY_POSEDGE
    { (
		get_endpos _1;
		0
	)}
| _1 = KEY_NEGEDGE
    { (
		get_endpos _1;
		0
	)}

polarity_operator:
  _1 = ADD
    { (
		get_endpos _1;
		0
	)}
| _1 = SUB
    { (
		get_endpos _1;
		0
	)}

KEY_IF_LPAREN_expression_RPAREN_opt:
  
    {   (0)}
| _1 = KEY_IF _2 = LPAREN _3 = expression _4 = RPAREN
    { (
		get_endpos _4;
		0
	)}

level_sensitive_path_declaration:
  _1 = KEY_IF _2 = LPAREN _3 = conditional_port_expression _4 = RPAREN _5 = LPAREN _6 = specify_terminal_descriptor _7 = polarity_operator_opt _8 = PATHTO _9 = specify_terminal_descriptor _10 = RPAREN _11 = SINGLEASSIGN _12 = path_delay_value _13 = SEMICOLON
    { (
		get_endpos _13;
		0
	)}
| _1 = KEY_IF _2 = LPAREN _3 = conditional_port_expression _4 = RPAREN _5 = LPAREN _6 = list_of_path_input_outputs _7 = polarity_operator_opt _8 = PATHTOSTAR _9 = list_of_path_input_outputs _10 = RPAREN _11 = SINGLEASSIGN _12 = path_delay_value _13 = SEMICOLON
    { (
		get_endpos _13;
		0
	)}

specify_terminal_descriptor:
  _1 = IDENTIFIER
    {            (0)}
| _1 = IDENTIFIER _2 = LBRACKET _3 = expression _4 = RBRACKET
    { (
		get_endpos _4;
		0
	)}
| _1 = IDENTIFIER _2 = LBRACKET _3 = expression _4 = COLON _5 = expression _6 = RBRACKET
    { (
		get_endpos _6;
		0
	)}

polarity_operator_opt:
  
    {  (0)}
| _1 = polarity_operator
    {                     (0)}

conditional_port_expression:
  _1 = expression
    {             (0)}

path_declaration:
  _1 = path_description _2 = SINGLEASSIGN _3 = path_delay_value _4 = SEMICOLON
    { (
		get_endpos _4;
		0
	)}

path_description:
  _1 = LPAREN _2 = specify_terminal_descriptor _3 = PATHTO _4 = specify_terminal_descriptor _5 = RPAREN
    { (
		get_endpos _5;
		0
	)}
| _1 = LPAREN _2 = list_of_path_input_outputs _3 = PATHTOSTAR _4 = list_of_path_input_outputs _5 = RPAREN
    { (
		get_endpos _5;
		0
	)}

path_delay_value:
  _1 = path_delay_expression
    {                         (0)}
| _1 = LPAREN _2 = path_delay_expression _3 = COMMA _4 = path_delay_expression _5 = RPAREN
    { (
		get_endpos _5;
		0
	)}
| _1 = LPAREN _2 = path_delay_expression _3 = COMMA _4 = path_delay_expression _5 = COMMA _6 = path_delay_expression _7 = RPAREN
    { (
		get_endpos _7;
		0
	)}
| _1 = LPAREN _2 = path_delay_expression _3 = COMMA _4 = path_delay_expression _5 = COMMA _6 = path_delay_expression _7 = COMMA _8 = path_delay_expression _9 = COMMA _10 = path_delay_expression _11 = COMMA _12 = path_delay_expression _13 = RPAREN
    { (
		get_endpos _13;
		0
	)}

path_delay_expression:
  _1 = mintypmax_expression
    {                      (0)}

specparam_declaration:
  _1 = KEY_SPECPARAM _2 = list_of_param_assignments _3 = SEMICOLON
    { (
		get_endpos _3;
		0
	)}

parameter_override:
  _1 = KEY_DEFPARAM _2 = list_of_param_assignments _3 = SEMICOLON
    { (
		get_endpos _3;
		T_parameter_override(_2)
	)}

gate_declaration:
  _1 = GATETYPE _2 = drive_strength_opt _3 = delay_opt _4 = gate_instance _5 = comma_gate_instance_optlist _6 = SEMICOLON
    { (
		get_endpos _6;
		T_gate_declaration(_1,_2,_3,(_4::_5))
	)}

comma_gate_instance_optlist:
  
    {    ([])}
| _1 = comma_gate_instance _2 = comma_gate_instance_optlist
    {                                                    (_1::_2)}

comma_gate_instance:
  _1 = COMMA _2 = gate_instance
    {                       (_2)}

gate_instance:
  _1 = name_of_gate_instance_opt _2 = LPAREN _3 = terminal _4 = comma_terminal_optlist _5 = RPAREN
    {  (
			get_endpos _5;
			T_gate_instance(_1,(_3::_4))
		)}

name_of_gate_instance_opt:
  
    {    ("")}
| _1 = IDENTIFIER
    {              (_1)}

comma_terminal_optlist:
  
    {    ([])}
| _1 = comma_terminal _2 = comma_terminal_optlist
    {                                         (_1::_2)}

comma_terminal:
  _1 = COMMA _2 = terminal
    {                  (_2)}

terminal:
  _1 = expression
    {                      (_1)}

drive_strength_opt:
  
    {   (T_drive_strength_NOSPEC)}
| _1 = drive_strength
    {                  (_1)}

integer_declaration:
  _1 = KEY_INTEGER _2 = list_of_register_variables _3 = SEMICOLON
    {  (
			get_endpos _3;
			_2
		)}

time_declaration:
  _1 = KEY_TIME _2 = list_of_register_variables _3 = SEMICOLON
    {  (
			get_endpos _3;
			_2
		)}

always_statement:
  _1 = KEY_ALWAYS _2 = statement
    {                        (_2)}

statement:
  _1 = blocking_assignment _2 = SEMICOLON
    {  (
			get_endpos _2;
			T_blocking_assignment(_1)
		)}
| _1 = non_blocking_assignment _2 = SEMICOLON
    {  (
			get_endpos _2;
			T_non_blocking_assignment(_1)
		)}
| _1 = KEY_IF _2 = LPAREN _3 = expression _4 = RPAREN _5 = statement_or_null
    {  (
			get_endpos _4;
			T_if_statement(_3,_5)
		)}
| _1 = KEY_IF _2 = LPAREN _3 = expression _4 = RPAREN _5 = statement_or_null _6 = KEY_ELSE _7 = statement_or_null
    {  (
			get_endpos _6;
			T_if_else_statement(_3,_5,_7)
		)}
| _1 = KEY_CASE _2 = LPAREN _3 = expression _4 = RPAREN _5 = case_item_list _6 = KEY_ENDCASE
    {  (
			get_endpos _6;
			T_case_statement(_3,_5)
		)}
| _1 = KEY_CASEZ _2 = LPAREN _3 = expression _4 = RPAREN _5 = case_item_list _6 = KEY_ENDCASE
    {  (
			get_endpos _6;
			T_casez_statement(_3,_5)
		)}
| _1 = KEY_CASEX _2 = LPAREN _3 = expression _4 = RPAREN _5 = case_item_list _6 = KEY_ENDCASE
    {  (
			get_endpos _6;
			T_casex_statement(_3,_5)
		)}
| _1 = KEY_FOREVER _2 = statement
    {  (
			get_endpos _1;
			T_forever_statement(_2)
		)}
| _1 = KEY_REPEAT _2 = LPAREN _3 = expression _4 = RPAREN _5 = statement
    {  (
			get_endpos _4;
			T_repeat_statement(_3,_5)
		)}
| _1 = KEY_WHILE _2 = LPAREN _3 = expression _4 = RPAREN _5 = statement
    {  (
			get_endpos _4;
			T_while_statement(_3,_5)
		)}
| _1 = KEY_FOR _2 = LPAREN _3 = assignment _4 = SEMICOLON _5 = expression _6 = SEMICOLON _7 = assignment _8 = RPAREN _9 = statement
    {  (
			get_endpos _8;
			T_for_statement(_3,_5,_7,_9)
		)}
| _1 = delay_control _2 = statement_or_null
    {                                     (T_delay_statement(_1,_2))}
| _1 = event_control _2 = statement_or_null
    {                                     (T_event_statement(_1,_2))}
| _1 = KEY_WAIT _2 = LPAREN _3 = expression _4 = RPAREN _5 = statement_or_null
    {  (
			get_endpos _4;
			T_wait_statement(_3,_5)
		)}
| _1 = LEADTO _2 = name_of_event _3 = SEMICOLON
    {  (
			get_endpos _3;
			T_leadto_event(_2)
		)}
| _1 = KEY_BEGIN _2 = statement_optlist _3 = KEY_END
    {  (
			get_endpos _3;
			T_seq_block("",[],_2)
		)}
| _1 = KEY_BEGIN _2 = COLON _3 = IDENTIFIER _4 = block_declaration_optlist _5 = statement_optlist _6 = KEY_END
    {  (
			get_endpos _6;
			T_seq_block(_3,_4,_5)
		)}
| _1 = KEY_FORK _2 = statement_optlist _3 = KEY_JOIN
    {  (
			get_endpos _3;
			T_par_block("",[],_2)
		)}
| _1 = KEY_FORK _2 = COLON _3 = IDENTIFIER _4 = block_declaration_optlist _5 = statement_optlist _6 = KEY_JOIN
    {  (
			get_endpos _6;
			T_par_block(_3,_4,_5)
		)}
| _1 = IDENTIFIER _2 = SEMICOLON
    {  (
			get_endpos _2;
			T_task_enable(_1,[])
		)}
| _1 = IDENTIFIER _2 = LPAREN _3 = expression _4 = comma_expression_optlist _5 = RPAREN _6 = SEMICOLON
    {  (
			get_endpos _6;
			T_task_enable(_1,(_3::_4))
		)}
| _1 = name_of_system_task _2 = SEMICOLON
    {  (
			get_endpos _2;
			T_system_task_enable(_1,[])
		)}
| _1 = name_of_system_task _2 = LPAREN _3 = expression _4 = comma_expression_optlist _5 = RPAREN _6 = SEMICOLON
    {  (
			get_endpos _6;
			T_system_task_enable(_1,(_3::_4))
		)}
| _1 = KEY_DISABLE _2 = IDENTIFIER _3 = SEMICOLON
    {  (
			get_endpos _3;
			T_disable_statement(_2)
		)}
| _1 = KEY_FORCE _2 = assignment _3 = SEMICOLON
    {  (
			get_endpos _3;
			T_force_statement(_2)
		)}
| _1 = KEY_RELEASE _2 = lvalue _3 = SEMICOLON
    {  (
			get_endpos _3;
			T_release_statement(_2)
		)}

statement_optlist:
  
    {    ([])}
| _1 = statement _2 = statement_optlist
    {                               (_1::_2)}

block_declaration_optlist:
  
    {    ([])}
| _1 = block_declaration _2 = block_declaration_optlist
    {                                                  (_1::_2)}

block_declaration:
  _1 = parameter_declaration
    {                       (_1)}
| _1 = reg_declaration
    {                   (_1)}
| _1 = integer_declaration
    {                       (T_integer_declaration(_1))}
| _1 = real_declaration
    {                    (_1)}
| _1 = time_declaration
    {                    (T_time_declaration(_1))}
| _1 = event_declaration
    {                     (_1)}

event_declaration:
  _1 = KEY_EVENT _2 = name_of_event _3 = comma_name_of_event_optlist _4 = SEMICOLON
    {  (
			get_endpos _4;
			T_event_declaration(_2::_3)
		)}

comma_name_of_event_optlist:
  
    {    ([])}
| _1 = comma_name_of_event _2 = comma_name_of_event_optlist
    {                                                   (_1::_2)}

comma_name_of_event:
  _1 = COMMA _2 = name_of_event
    {                       (_2)}

name_of_event:
  _1 = IDENTIFIER
    {             (_1)}

real_declaration:
  _1 = KEY_REAL _2 = list_of_variables _3 = SEMICOLON
    {  (
			get_endpos _3;
			T_real_declaration(_2)
		)}

parameter_declaration:
  _1 = KEY_PARAMETER _2 = list_of_param_assignments _3 = SEMICOLON
    {  (
			get_endpos _3;
			T_parameter_declaration(_2)
		)}

list_of_param_assignments:
  _1 = param_assignment _2 = comma_param_assignment_optlist
    {                                                  (_1::_2)}

comma_param_assignment_optlist:
  
    {   ([])}
| _1 = comma_param_assignment _2 = comma_param_assignment_optlist
    {                                                          (_1::_2)}

comma_param_assignment:
  _1 = COMMA _2 = param_assignment
    {                         (_2)}

param_assignment:
  _1 = identifier _2 = SINGLEASSIGN _3 = constant_expression
    {  (
			get_endpos _2;
			T_param_assignment(_1,_3)
		)}

name_of_system_task:
  _1 = DOLLOR_SYSTEM_IDENTIFIER
    {                          (_1)}

event_control:
  _1 = AT _2 = identifier
    {  (
			get_endpos _1;
			T_event_control_id(_2)
		)}
| _1 = AT _2 = LPAREN _3 = event_expression_list _4 = RPAREN
    {  (
			get_endpos _4;
			T_event_control_evexp(_3)
		)}

event_expression_list:
  _1 = event_expression _2 = or_event_expression_optlist
    {                                                (_1::_2)}
| _1 = event_expression _2 = comma_event_expression_optlist
    {                                                     (_1::_2)}

or_event_expression_optlist:
  
    {   ([])}
| _1 = KEY_OR _2 = event_expression _3 = or_event_expression_optlist
    {                                                        (_2::_3)}

comma_event_expression_optlist:
  
    {   ([])}
| _1 = COMMA _2 = event_expression _3 = comma_event_expression_optlist
    {                                                         (_2::_3)}

event_expression:
  _1 = expression
    {              (T_event_expression(_1))}
| _1 = KEY_POSEDGE _2 = SCALAR_EVENT_EXPRESSION
    {                                         (T_event_expression_posedge(_2))}
| _1 = KEY_NEGEDGE _2 = SCALAR_EVENT_EXPRESSION
    {                                         (T_event_expression_negedge(_2))}

SCALAR_EVENT_EXPRESSION:
  _1 = expression
    {              (_1)}

delay_control:
  _1 = JING _2 = expression
    {                   (T_delay_control(_2))}

case_item_list:
  _1 = case_item
    {             ([_1])}
| _1 = case_item _2 = case_item_list
    {                              (_1::_2)}

case_item:
  _1 = expression _2 = comma_expression_optlist _3 = COLON _4 = statement_or_null
    {                                                               (T_case_item_normal(_1::_2,_4))}
| _1 = KEY_DEFAULT _2 = COLON _3 = statement_or_null
    {                                         (T_case_item_default(_3))}
| _1 = KEY_DEFAULT _2 = statement_or_null
    {                                   (T_case_item_default(_2))}

blocking_assignment:
  _1 = lvalue _2 = SINGLEASSIGN _3 = expression
    {                                  (T_blocking_assignment_direct(_1,_3))}
| _1 = lvalue _2 = SINGLEASSIGN _3 = delay_control _4 = expression
    {                                                   (T_blocking_assignment_delay(_1,_4,_3))}
| _1 = lvalue _2 = SINGLEASSIGN _3 = event_control _4 = expression
    {                                                  (T_blocking_assignment_event(_1,_4,_3))}

non_blocking_assignment:
  _1 = lvalue _2 = LE _3 = expression
    {                        (T_non_blocking_assignment_direct(_1,_3))}
| _1 = lvalue _2 = LE _3 = delay_control _4 = expression
    {                                        (T_non_blocking_assignment_delay(_1,_4,_3))}
| _1 = lvalue _2 = LE _3 = event_control _4 = expression
    {                                         (T_non_blocking_assignment_event(_1,_4,_3))}

statement_or_null:
  _1 = statement
    {           (_1)}
| _1 = SEMICOLON
    {  (
			get_endpos _1;
			T_statement_NOSPEC
		)}

reg_declaration:
  _1 = KEY_REG _2 = range_opt _3 = list_of_register_variables _4 = SEMICOLON
    {  (
			get_endpos _4;
			T_reg_declaration(_2,_3)
		)}

list_of_register_variables:
  _1 = register_variable _2 = comma_register_variable_optlist
    {                                                    (_1::_2)}

comma_register_variable_optlist:
  
    {   ([])}
| _1 = comma_register_variable _2 = comma_register_variable_optlist
    {                                                            (_1::_2)}

comma_register_variable:
  _1 = COMMA _2 = register_variable
    {                           (_2)}

register_variable:
  _1 = IDENTIFIER
    {            (T_register_variables_ID(_1))}
| _1 = IDENTIFIER _2 = LBRACKET _3 = constant_expression _4 = COLON _5 = constant_expression _6 = RBRACKET
    {  (
			get_endpos _6;
			T_register_variables_IDrange(_1,_3,_5)
		)}

module_instantiation:
  _1 = IDENTIFIER _2 = drive_strength_opt _3 = parameter_value_assignment_opt _4 = module_instance _5 = comma_module_instance_optlist _6 = SEMICOLON
    {  (
			get_endpos _6;
			T_module_instantiation(_1,_2,_3,_4::_5)
		)}

comma_module_instance_optlist:
  
    {   ([])}
| _1 = comma_module_instance _2 = comma_module_instance_optlist
    {                                                         (_1::_2)}

comma_module_instance:
  _1 = COMMA _2 = module_instance
    {                          (_2)}

module_instance:
  _1 = IDENTIFIER _2 = LPAREN _3 = list_of_module_connections _4 = RPAREN
    {  (
			get_endpos _4;
			T_module_instance(_1,_3)
		)}

list_of_module_connections:
  _1 = module_port_connection _2 = comma_module_port_connection_optlist
    {                                                             (T_list_of_module_connections_unnamed(_1::_2))}
| _1 = named_port_connection _2 = comma_named_port_connection_optlist
    {                                                                 (T_list_of_module_connections_named(_1::_2))}

comma_named_port_connection_optlist:
  
    {    ([])}
| _1 = comma_named_port_connection _2 = comma_named_port_connection_optlist
    {                                                                    (_1::_2)}

comma_named_port_connection:
  _1 = COMMA _2 = named_port_connection
    {                               (_2)}

named_port_connection:
  _1 = DOT _2 = IDENTIFIER _3 = LPAREN _4 = RPAREN
    {  (
			get_endpos _4;
			T_named_port_connection(_2,T_expression_NOSPEC(0))
		)}
| _1 = DOT _2 = IDENTIFIER _3 = LPAREN _4 = expression _5 = RPAREN
    {  (
			get_endpos _5;
			T_named_port_connection(_2,_4)
		)}

comma_module_port_connection_optlist:
  
    {    ([])}
| _1 = comma_module_port_connection _2 = comma_module_port_connection_optlist
    {                                                                      (_1::_2)}

comma_module_port_connection:
  _1 = COMMA _2 = module_port_connection
    {                                 (_2)}

module_port_connection:
  
    {                   (T_expression_NOSPEC(0))}
| _1 = expression
    {              (_1)}

parameter_value_assignment_opt:
  
    {                        ([])}
| _1 = parameter_value_assignment
    {                               (_1)}

parameter_value_assignment:
  _1 = JING _2 = LPAREN _3 = expression _4 = comma_expression_optlist _5 = RPAREN
    {  (
			get_endpos _5;
			_3::_4
		)}

continuous_assign:
  _1 = KEY_ASSIGN _2 = delay_opt _3 = list_of_assignments _4 = SEMICOLON
    {   (
			get_endpos _4;
			T_continuous_assign_assign(T_drive_strength_NOSPEC,_2,_3)
		)}
| _1 = KEY_ASSIGN _2 = drive_strength _3 = delay_opt _4 = list_of_assignments _5 = SEMICOLON
    {  (
			get_endpos _5;
			T_continuous_assign_assign(_2,_3,_4)
		)}
| _1 = NETTYPE _2 = expandrange_opt _3 = delay_opt _4 = list_of_assignments _5 = SEMICOLON
    {  (
			get_endpos _5;
			T_continuous_assign_net(_1,T_drive_strength_NOSPEC,_2,_3,_4)
		)}
| _1 = NETTYPE _2 = drive_strength _3 = expandrange_opt _4 = delay_opt _5 = list_of_assignments _6 = SEMICOLON
    {  (
			get_endpos _6;
			T_continuous_assign_net(_1,_2,_3,_4,_5)
		)}

list_of_assignments:
  _1 = assignment _2 = comma_assignment_optlist
    {                                       (_1::_2)}

comma_assignment_optlist:
  
    {   ([])}
| _1 = comma_assignment _2 = comma_assignment_optlist
    {                                              (_1::_2)}

comma_assignment:
  _1 = COMMA _2 = assignment
    {                   (_2)}

assignment:
  _1 = lvalue _2 = SINGLEASSIGN _3 = expression
    {                                 (T_assignment(_1,_3))}

lvalue:
  _1 = identifier
    {              (T_lvalue_id(_1))}
| _1 = identifier _2 = LBRACKET _3 = expression _4 = RBRACKET
    {  (
			get_endpos _4;
			T_lvalue_arrbit(_1,_3)
		)}
| _1 = identifier _2 = LBRACKET _3 = constant_expression _4 = COLON _5 = constant_expression _6 = RBRACKET
    {  (
			get_endpos _6;
			T_lvalue_arrrange(_1,_3,_5)
		)}
| _1 = concatenation
    {                  (T_lvalue_concat(_1))}

expression:
  _1 = primary
    {           (T_primary(_1))}
| _1 = ADD _2 = primary %prec UADD
    {                            (T_add1(_2))}
| _1 = SUB _2 = primary %prec USUB
    {                           (T_sub1(_2))}
| _1 = LOGIC_NEG _2 = primary
    {                       (T_logicneg(_2))}
| _1 = BIT_NEG _2 = primary
    {                     (T_bitneg(_2))}
| _1 = BIT_AND _2 = primary %prec UAND
    {                                (T_reduce_and(_2))}
| _1 = RED_NAND _2 = primary
    {                      (T_reduce_nand(_2))}
| _1 = BIT_OR _2 = primary %prec UOR
    {                              (T_reduce_or(_2))}
| _1 = RED_NOR _2 = primary
    {                     (T_reduce_nor(_2))}
| _1 = BIT_XOR _2 = primary %prec UXOR
    {                                (T_reduce_xor(_2))}
| _1 = BIT_EQU _2 = primary %prec UEQU
    {                               (T_reduce_xnor(_2))}
| _1 = expression _2 = ADD _3 = expression
    {                              (T_add2(_1,_3))}
| _1 = expression _2 = SUB _3 = expression
    {                              (T_sub2(_1,_3))}
| _1 = expression _2 = MUL _3 = expression
    {                              (T_mul2(_1,_3))}
| _1 = expression _2 = DIV _3 = expression
    {                              (T_div(_1,_3))}
| _1 = expression _2 = MOD _3 = expression
    {                              (T_mod(_1,_3))}
| _1 = expression _2 = LOGIC_EQU _3 = expression
    {                                    (T_logic_equ(_1,_3))}
| _1 = expression _2 = LOGIC_INE _3 = expression
    {                                    (T_logic_ine(_1,_3))}
| _1 = expression _2 = CASE_EQU _3 = expression
    {                                   (T_case_equ(_1,_3))}
| _1 = expression _2 = CASE_INE _3 = expression
    {                                   (T_case_ine(_1,_3))}
| _1 = expression _2 = LOGIC_AND _3 = expression
    {                                    (T_logic_and2(_1,_3))}
| _1 = expression _2 = LOGIC_OR _3 = expression
    {                                   (T_logic_or2(_1,_3))}
| _1 = expression _2 = LT _3 = expression
    {                             (T_lt(_1,_3))}
| _1 = expression _2 = LE _3 = expression
    {                             (T_le(_1,_3))}
| _1 = expression _2 = GT _3 = expression
    {                             (T_gt(_1,_3))}
| _1 = expression _2 = GE _3 = expression
    {                             (T_ge(_1,_3))}
| _1 = expression _2 = BIT_AND _3 = expression
    {                                  (T_bit_and2(_1,_3))}
| _1 = expression _2 = BIT_OR _3 = expression
    {                                 (T_bit_or2(_1,_3))}
| _1 = expression _2 = BIT_XOR _3 = expression
    {                                  (T_bit_xor2(_1,_3))}
| _1 = expression _2 = BIT_EQU _3 = expression
    {                                  (T_bit_equ(_1,_3))}
| _1 = expression _2 = LEFT_SHIFT _3 = expression
    {                                     (T_leftshift(_1,_3))}
| _1 = expression _2 = RIGHT_SHIFT _3 = expression
    {                                      (T_rightshift(_1,_3))}
| _1 = expression _2 = QUESTION_MARK _3 = expression _4 = COLON _5 = expression
    {                                                          (T_selection(_1,_3,_5))}
| _1 = STRING
    {            (T_string(_1))}

primary:
  _1 = number
    {          (T_primary_num(_1))}
| _1 = identifier
    {               (T_primary_id(_1))}
| _1 = identifier _2 = LBRACKET _3 = expression _4 = RBRACKET
    {  (
			get_endpos _4;
			T_primary_arrbit(_1,_3)
		)}
| _1 = identifier _2 = LBRACKET _3 = constant_expression _4 = COLON _5 = constant_expression _6 = RBRACKET
    {  (
			get_endpos _6;
			T_primary_arrrange(_1,_3,_5)
		)}
| _1 = concatenation
    {                          (T_primary_concat(_1))}
| _1 = multiple_concatenation
    {                           (_1)}
| _1 = identifier _2 = LPAREN _3 = expression _4 = comma_expression_optlist _5 = RPAREN
    {  (
			get_endpos _5;
			T_primary_funcall(_1,_3::_4)
		)}
| _1 = name_of_system_function _2 = LPAREN _3 = expression _4 = comma_expression_optlist _5 = RPAREN
    {  (
			get_endpos _5;
			T_primary_sysfuncall(_1,_3::_4)
		)}
| _1 = name_of_system_function
    {                                (T_primary_sysfuncall(_1,[]))}
| _1 = LPAREN _2 = mintypmax_expression _3 = RPAREN
    {  (
			get_endpos _3;
			T_primary_minmaxexp(_2)
		)}

multiple_concatenation:
  _1 = LBRACE _2 = expression _3 = LBRACE _4 = expression _5 = comma_expression_optlist _6 = RBRACE _7 = RBRACE
    {  (
			get_endpos _7;
			T_primary_multiconcat(_2,_4::_5)
		)}

concatenation:
  _1 = LBRACE _2 = expression _3 = comma_expression_optlist _4 = RBRACE
    {  (
			get_endpos _4;
			_2::_3
		)}

comma_expression_optlist:
  
    {    ([])}
| _1 = comma_expression _2 = comma_expression_optlist
    {                                               (_1::_2)}

mintypmax_expression:
  _1 = expression
    {            (T_mintypmax_expression_1(_1))}
| _1 = expression _2 = COLON _3 = expression _4 = COLON _5 = expression
    {                                                  (T_mintypmax_expression_3(_1,_3,_5))}

comma_expression:
  _1 = COMMA _2 = expression
    {                    (_2)}

number:
  _1 = UNSIGNED_NUMBER
    {                    (T_number_unsign(int_of_string (delunderscore _1)))}
| _1 = BASE_NUMBER
    {                (string2base_number _1)}
| _1 = UNSIGNED_NUMBER _2 = DOT _3 = UNSIGNED_NUMBER
    {                                           (T_number_float(float_of_string( String.concat "" [delunderscore _1;".";delunderscore _3])))}
| _1 = FLOAT_NUMBER
    {                (T_number_float(float_of_string (delunderscore _1)))}

identifier:
  _1 = IDENTIFIER _2 = dot_IDENTIFIER_optlist
    {                                    (_1::_2)}

dot_IDENTIFIER_optlist:
  
    {    ([])}
| _1 = dot_IDENTIFIER _2 = dot_IDENTIFIER_optlist
    {                                         (_1::_2)}

dot_IDENTIFIER:
  _1 = DOT _2 = IDENTIFIER
    {                  (_2)}

drive_strength:
  _1 = LPAREN _2 = STRENGTH0 _3 = COMMA _4 = STRENGTH1 _5 = RPAREN
    {  (
			get_endpos _5;
			T_drive_strength(_2,_4)
		)}
| _1 = LPAREN _2 = STRENGTH1 _3 = COMMA _4 = STRENGTH0 _5 = RPAREN
    {  (
			get_endpos _5;
			T_drive_strength(_2,_4)
		)}

input_declaration:
  _1 = KEY_INPUT _2 = range_opt _3 = list_of_variables _4 = SEMICOLON
    {  (
			get_endpos _4;
			T_input_declaration(_2,_3)
		)}

output_declaration:
  _1 = KEY_OUTPUT _2 = range_opt _3 = list_of_variables _4 = SEMICOLON
    {  (
			get_endpos _4;
			T_output_declaration(_2,_3)
		)}

inout_declaration:
  _1 = KEY_INOUT _2 = range_opt _3 = list_of_variables _4 = SEMICOLON
    {  (
			get_endpos _4;
			T_inout_declaration(_2,_3)
		)}

net_declaration:
  _1 = NETTYPE _2 = expandrange_opt _3 = delay_opt _4 = list_of_variables _5 = SEMICOLON
    {  (
			get_endpos _5;
			T_net_declaration(_1,T_charge_strength_NOSPEC,_2,_3,_4)
		)}
| _1 = NETTYPE _2 = charge_strength _3 = expandrange_opt _4 = delay_opt _5 = list_of_variables _6 = SEMICOLON
    {  (
			get_endpos _6;
			T_net_declaration(_1,_2,_3,_4,_5)
		)}

delay_opt:
  
    {   (T_delay_NOSPEC)}
| _1 = delay
    {          (_1)}

delay:
  _1 = JING _2 = number
    {              (T_delay_number(_2))}
| _1 = JING _2 = identifier
    {                    (T_delay_id(_2))}
| _1 = JING _2 = LPAREN _3 = mintypmax_expression _4 = RPAREN
    {   (
			get_endpos _4;
			T_delay_minmax1(_3)
		)}
| _1 = JING _2 = LPAREN _3 = mintypmax_expression _4 = COMMA _5 = mintypmax_expression _6 = COMMA _7 = mintypmax_expression _8 = RPAREN
    {   (
			get_endpos _8;
			T_delay_minmax3(_3,_5,_7)
		)}

expandrange_opt:
  
    {   (T_expandrange_NOSPEC)}
| _1 = expandrange
    {                  (_1)}

expandrange:
  _1 = range
    {        (T_expandrange_range(_1))}
| _1 = KEY_SCALARED _2 = range
    {                       (T_expandrange_scalared(_2))}
| _1 = KEY_VECTORED _2 = range
    {                       (T_expandrange_vectored(_2))}

charge_strength:
  _1 = LPAREN _2 = KEY_SMALL _3 = RPAREN
    {  (
			get_endpos _3;
			T_charge_strength_SMALL
		)}
| _1 = LPAREN _2 = KEY_MEDIUM _3 = RPAREN
    {  (
			get_endpos _3;
			T_charge_strength_MEDIUM
		)}
| _1 = LPAREN _2 = KEY_LARGE _3 = RPAREN
    {  (
			get_endpos _3;
			T_charge_strength_LARGE
		)}

range_opt:
  
    {    (T_range_NOSPEC)}
| _1 = range
    {         (_1)}

range:
  _1 = LBRACKET _2 = constant_expression _3 = COLON _4 = constant_expression _5 = RBRACKET
    {  (
			get_endpos _5;
			T_range(_2,_4)
		)}

constant_expression:
  _1 = expression
    {             (_1)}

list_of_variables:
  _1 = IDENTIFIER _2 = comma_IDENTIFIER_optlist
    {                                      (_1::_2)}

comma_IDENTIFIER_optlist:
  
    {    ([])}
| _1 = comma_IDENTIFIER _2 = comma_IDENTIFIER_optlist
    {                                              (_1::_2)}

comma_IDENTIFIER:
  _1 = COMMA _2 = IDENTIFIER
    {                    (_2)}

name_of_system_function:
  _1 = DOLLOR _2 = IDENTIFIER
    {                    ((String.concat "" ("$"::[_2]))::[])}

%%


