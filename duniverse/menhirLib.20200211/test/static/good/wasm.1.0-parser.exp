File "wasm.1.0-parser.mly", line 158, characters 39-58:
Warning: the token ASSERT_SOFT_INVALID is unused.
Grammar has 75 nonterminal symbols, among which 3 start symbols.
Grammar has 76 terminal symbols.
Grammar has 194 productions.
nullable(var_list) = true
nullable(var) = false
nullable(value_type_list) = true
nullable(type_use) = false
nullable(type_def) = false
nullable(type_) = false
nullable(table_sig) = false
nullable(table_fields) = false
nullable(table) = false
nullable(string_list) = true
nullable(start) = false
nullable(script_var_opt) = true
nullable(script_module) = false
nullable(script1) = false
nullable(script) = false
nullable(plain_instr) = false
nullable(offset_opt) = true
nullable(offset) = false
nullable(name) = false
nullable(module_var_opt) = true
nullable(module_fields1) = false
nullable(module_fields) = true
nullable(module_) = false
nullable(module1) = false
nullable(meta) = false
nullable(memory_sig) = false
nullable(memory_fields) = false
nullable(memory) = false
nullable(literal) = false
nullable(limits) = false
nullable(labeling_opt) = true
nullable(labeling_end_opt) = true
nullable(instr_list) = true
nullable(instr) = false
nullable(inline_module1) = false
nullable(inline_module) = true
nullable(inline_import) = false
nullable(inline_export) = false
nullable(import_desc) = false
nullable(import) = false
nullable(if_block) = false
nullable(if_) = false
nullable(global_type) = false
nullable(global_fields) = false
nullable(global) = false
nullable(func_type) = false
nullable(func_sig) = true
nullable(func_result_body) = true
nullable(func_fields_import_result) = true
nullable(func_fields_import) = true
nullable(func_fields_body) = true
nullable(func_fields) = true
nullable(func_body) = true
nullable(func) = false
nullable(expr_list) = true
nullable(expr1) = false
nullable(expr) = false
nullable(export_desc) = false
nullable(export) = false
nullable(elem_type) = false
nullable(elem) = false
nullable(data) = false
nullable(const_list) = true
nullable(const_expr) = true
nullable(const) = false
nullable(cmd_list) = true
nullable(cmd) = false
nullable(block_sig) = false
nullable(block_instr) = false
nullable(block) = true
nullable(bind_var_opt) = true
nullable(bind_var) = false
nullable(assertion) = false
nullable(align_opt) = true
nullable(action) = false
first(var_list) = VAR NAT
first(var) = VAR NAT
first(value_type_list) = VALUE_TYPE
first(type_use) = LPAR
first(type_def) = LPAR
first(type_) = LPAR
first(table_sig) = NAT
first(table_fields) = NAT LPAR ANYFUNC
first(table) = LPAR
first(string_list) = STRING
first(start) = LPAR
first(script_var_opt) = VAR
first(script_module) = LPAR
first(script1) = LPAR
first(script) = LPAR EOF
first(plain_instr) = UNREACHABLE UNARY TEST TEE_LOCAL STORE SET_LOCAL SET_GLOBAL SELECT RETURN NOP LOAD GROW_MEMORY GET_LOCAL GET_GLOBAL DROP CURRENT_MEMORY CONVERT CONST COMPARE CALL_INDIRECT CALL BR_TABLE BR_IF BR BINARY
first(offset_opt) = OFFSET_EQ_NAT
first(offset) = LPAR
first(name) = STRING
first(module_var_opt) = VAR
first(module_fields1) = LPAR
first(module_fields) = LPAR
first(module_) = LPAR
first(module1) = LPAR EOF
first(meta) = LPAR
first(memory_sig) = NAT
first(memory_fields) = NAT LPAR
first(memory) = LPAR
first(literal) = NAT INT FLOAT
first(limits) = NAT
first(labeling_opt) = VAR
first(labeling_end_opt) = VAR
first(instr_list) = UNREACHABLE UNARY TEST TEE_LOCAL STORE SET_LOCAL SET_GLOBAL SELECT RETURN NOP LPAR LOOP LOAD IF GROW_MEMORY GET_LOCAL GET_GLOBAL DROP CURRENT_MEMORY CONVERT CONST COMPARE CALL_INDIRECT CALL BR_TABLE BR_IF BR BLOCK BINARY
first(instr) = UNREACHABLE UNARY TEST TEE_LOCAL STORE SET_LOCAL SET_GLOBAL SELECT RETURN NOP LPAR LOOP LOAD IF GROW_MEMORY GET_LOCAL GET_GLOBAL DROP CURRENT_MEMORY CONVERT CONST COMPARE CALL_INDIRECT CALL BR_TABLE BR_IF BR BLOCK BINARY
first(inline_module1) = LPAR
first(inline_module) = LPAR
first(inline_import) = LPAR
first(inline_export) = LPAR
first(import_desc) = LPAR
first(import) = LPAR
first(if_block) = LPAR
first(if_) = LPAR
first(global_type) = VALUE_TYPE LPAR
first(global_fields) = VALUE_TYPE LPAR
first(global) = LPAR
first(func_type) = LPAR
first(func_sig) = LPAR
first(func_result_body) = UNREACHABLE UNARY TEST TEE_LOCAL STORE SET_LOCAL SET_GLOBAL SELECT RETURN NOP LPAR LOOP LOAD IF GROW_MEMORY GET_LOCAL GET_GLOBAL DROP CURRENT_MEMORY CONVERT CONST COMPARE CALL_INDIRECT CALL BR_TABLE BR_IF BR BLOCK BINARY
first(func_fields_import_result) = LPAR
first(func_fields_import) = LPAR
first(func_fields_body) = UNREACHABLE UNARY TEST TEE_LOCAL STORE SET_LOCAL SET_GLOBAL SELECT RETURN NOP LPAR LOOP LOAD IF GROW_MEMORY GET_LOCAL GET_GLOBAL DROP CURRENT_MEMORY CONVERT CONST COMPARE CALL_INDIRECT CALL BR_TABLE BR_IF BR BLOCK BINARY
first(func_fields) = UNREACHABLE UNARY TEST TEE_LOCAL STORE SET_LOCAL SET_GLOBAL SELECT RETURN NOP LPAR LOOP LOAD IF GROW_MEMORY GET_LOCAL GET_GLOBAL DROP CURRENT_MEMORY CONVERT CONST COMPARE CALL_INDIRECT CALL BR_TABLE BR_IF BR BLOCK BINARY
first(func_body) = UNREACHABLE UNARY TEST TEE_LOCAL STORE SET_LOCAL SET_GLOBAL SELECT RETURN NOP LPAR LOOP LOAD IF GROW_MEMORY GET_LOCAL GET_GLOBAL DROP CURRENT_MEMORY CONVERT CONST COMPARE CALL_INDIRECT CALL BR_TABLE BR_IF BR BLOCK BINARY
first(func) = LPAR
first(expr_list) = LPAR
first(expr1) = UNREACHABLE UNARY TEST TEE_LOCAL STORE SET_LOCAL SET_GLOBAL SELECT RETURN NOP LOOP LOAD IF GROW_MEMORY GET_LOCAL GET_GLOBAL DROP CURRENT_MEMORY CONVERT CONST COMPARE CALL_INDIRECT CALL BR_TABLE BR_IF BR BLOCK BINARY
first(expr) = LPAR
first(export_desc) = LPAR
first(export) = LPAR
first(elem_type) = ANYFUNC
first(elem) = LPAR
first(data) = LPAR
first(const_list) = LPAR
first(const_expr) = UNREACHABLE UNARY TEST TEE_LOCAL STORE SET_LOCAL SET_GLOBAL SELECT RETURN NOP LPAR LOOP LOAD IF GROW_MEMORY GET_LOCAL GET_GLOBAL DROP CURRENT_MEMORY CONVERT CONST COMPARE CALL_INDIRECT CALL BR_TABLE BR_IF BR BLOCK BINARY
first(const) = LPAR
first(cmd_list) = LPAR
first(cmd) = LPAR
first(block_sig) = LPAR
first(block_instr) = LOOP IF BLOCK
first(block) = UNREACHABLE UNARY TEST TEE_LOCAL STORE SET_LOCAL SET_GLOBAL SELECT RETURN NOP LPAR LOOP LOAD IF GROW_MEMORY GET_LOCAL GET_GLOBAL DROP CURRENT_MEMORY CONVERT CONST COMPARE CALL_INDIRECT CALL BR_TABLE BR_IF BR BLOCK BINARY
first(bind_var_opt) = VAR
first(bind_var) = VAR
first(assertion) = LPAR
first(align_opt) = ALIGN_EQ_NAT
first(action) = LPAR
minimal(var_list) = (* 0 *) 
minimal(var) = (* 1 *) NAT
minimal(value_type_list) = (* 0 *) 
minimal(type_use) = (* 4 *) LPAR TYPE NAT RPAR
minimal(type_def) = (* 6 *) LPAR TYPE LPAR FUNC RPAR RPAR
minimal(type_) = (* 3 *) LPAR FUNC RPAR
minimal(table_sig) = (* 2 *) NAT ANYFUNC
minimal(table_fields) = (* 2 *) NAT ANYFUNC
minimal(table) = (* 5 *) LPAR TABLE NAT ANYFUNC RPAR
minimal(string_list) = (* 0 *) 
minimal(start) = (* 4 *) LPAR START NAT RPAR
minimal(script_var_opt) = (* 0 *) 
minimal(script_module) = (* 3 *) LPAR MODULE RPAR
minimal(script1) = (* 3 *) LPAR MODULE RPAR
minimal(script) = (* 1 *) EOF
minimal(plain_instr) = (* 1 *) UNREACHABLE
minimal(offset_opt) = (* 0 *) 
minimal(offset) = (* 3 *) LPAR OFFSET RPAR
minimal(name) = (* 1 *) STRING
minimal(module_var_opt) = (* 0 *) 
minimal(module_fields1) = (* 3 *) LPAR FUNC RPAR
minimal(module_fields) = (* 0 *) 
minimal(module_) = (* 3 *) LPAR MODULE RPAR
minimal(module1) = (* 1 *) EOF
minimal(meta) = (* 3 *) LPAR SCRIPT RPAR
minimal(memory_sig) = (* 1 *) NAT
minimal(memory_fields) = (* 1 *) NAT
minimal(memory) = (* 4 *) LPAR MEMORY NAT RPAR
minimal(literal) = (* 1 *) NAT
minimal(limits) = (* 1 *) NAT
minimal(labeling_opt) = (* 0 *) 
minimal(labeling_end_opt) = (* 0 *) 
minimal(instr_list) = (* 0 *) 
minimal(instr) = (* 1 *) UNREACHABLE
minimal(inline_module1) = (* 3 *) LPAR FUNC RPAR
minimal(inline_module) = (* 0 *) 
minimal(inline_import) = (* 5 *) LPAR IMPORT STRING STRING RPAR
minimal(inline_export) = (* 4 *) LPAR EXPORT STRING RPAR
minimal(import_desc) = (* 3 *) LPAR FUNC RPAR
minimal(import) = (* 8 *) LPAR IMPORT STRING STRING LPAR FUNC RPAR RPAR
minimal(if_block) = (* 3 *) LPAR THEN RPAR
minimal(if_) = (* 3 *) LPAR THEN RPAR
minimal(global_type) = (* 1 *) VALUE_TYPE
minimal(global_fields) = (* 1 *) VALUE_TYPE
minimal(global) = (* 4 *) LPAR GLOBAL VALUE_TYPE RPAR
minimal(func_type) = (* 3 *) LPAR FUNC RPAR
minimal(func_sig) = (* 0 *) 
minimal(func_result_body) = (* 0 *) 
minimal(func_fields_import_result) = (* 0 *) 
minimal(func_fields_import) = (* 0 *) 
minimal(func_fields_body) = (* 0 *) 
minimal(func_fields) = (* 0 *) 
minimal(func_body) = (* 0 *) 
minimal(func) = (* 3 *) LPAR FUNC RPAR
minimal(expr_list) = (* 0 *) 
minimal(expr1) = (* 1 *) UNREACHABLE
minimal(expr) = (* 3 *) LPAR UNREACHABLE RPAR
minimal(export_desc) = (* 4 *) LPAR FUNC NAT RPAR
minimal(export) = (* 8 *) LPAR EXPORT STRING LPAR FUNC NAT RPAR RPAR
minimal(elem_type) = (* 1 *) ANYFUNC
minimal(elem) = (* 6 *) LPAR ELEM LPAR OFFSET RPAR RPAR
minimal(data) = (* 6 *) LPAR DATA LPAR OFFSET RPAR RPAR
minimal(const_list) = (* 0 *) 
minimal(const_expr) = (* 0 *) 
minimal(const) = (* 4 *) LPAR CONST NAT RPAR
minimal(cmd_list) = (* 0 *) 
minimal(cmd) = (* 3 *) LPAR MODULE RPAR
minimal(block_sig) = (* 4 *) LPAR RESULT VALUE_TYPE RPAR
minimal(block_instr) = (* 2 *) BLOCK END
minimal(block) = (* 0 *) 
minimal(bind_var_opt) = (* 0 *) 
minimal(bind_var) = (* 1 *) VAR
minimal(assertion) = (* 7 *) LPAR ASSERT_MALFORMED LPAR MODULE RPAR STRING RPAR
minimal(align_opt) = (* 0 *) 
minimal(action) = (* 4 *) LPAR INVOKE STRING RPAR
follow(var_list) = UNREACHABLE UNARY TEST TEE_LOCAL STORE SET_LOCAL SET_GLOBAL SELECT RPAR RETURN NOP LPAR LOOP LOAD IF GROW_MEMORY GET_LOCAL GET_GLOBAL END ELSE DROP CURRENT_MEMORY CONVERT CONST COMPARE CALL_INDIRECT CALL BR_TABLE BR_IF BR BLOCK BINARY
follow(var) = VAR UNREACHABLE UNARY TEST TEE_LOCAL STORE SET_LOCAL SET_GLOBAL SELECT RPAR RETURN NOP NAT LPAR LOOP LOAD IF GROW_MEMORY GET_LOCAL GET_GLOBAL END ELSE DROP CURRENT_MEMORY CONVERT CONST COMPARE CALL_INDIRECT CALL BR_TABLE BR_IF BR BLOCK BINARY
follow(value_type_list) = RPAR
follow(type_use) = UNREACHABLE UNARY TEST TEE_LOCAL STORE SET_LOCAL SET_GLOBAL SELECT RPAR RETURN NOP LPAR LOOP LOAD IF GROW_MEMORY GET_LOCAL GET_GLOBAL DROP CURRENT_MEMORY CONVERT CONST COMPARE CALL_INDIRECT CALL BR_TABLE BR_IF BR BLOCK BINARY
follow(type_def) = RPAR LPAR EOF
follow(type_) = RPAR
follow(table_sig) = RPAR
follow(table_fields) = RPAR
follow(table) = RPAR LPAR EOF
follow(string_list) = STRING RPAR
follow(start) = RPAR LPAR EOF
follow(script_var_opt) = STRING RPAR LPAR
follow(script_module) = STRING RPAR LPAR EOF #
follow(script1) = #
follow(script) = #
follow(plain_instr) = UNREACHABLE UNARY TEST TEE_LOCAL STORE SET_LOCAL SET_GLOBAL SELECT RPAR RETURN NOP LPAR LOOP LOAD IF GROW_MEMORY GET_LOCAL GET_GLOBAL END ELSE DROP CURRENT_MEMORY CONVERT CONST COMPARE CALL_INDIRECT CALL BR_TABLE BR_IF BR BLOCK BINARY
follow(offset_opt) = UNREACHABLE UNARY TEST TEE_LOCAL STORE SET_LOCAL SET_GLOBAL SELECT RPAR RETURN NOP LPAR LOOP LOAD IF GROW_MEMORY GET_LOCAL GET_GLOBAL END ELSE DROP CURRENT_MEMORY CONVERT CONST COMPARE CALL_INDIRECT CALL BR_TABLE BR_IF BR BLOCK BINARY ALIGN_EQ_NAT
follow(offset) = VAR STRING RPAR NAT
follow(name) = VAR STRING RPAR LPAR
follow(module_var_opt) = STRING RPAR QUOTE LPAR BIN
follow(module_fields1) = RPAR EOF
follow(module_fields) = RPAR EOF
follow(module_) = STRING RPAR LPAR EOF #
follow(module1) = #
follow(meta) = RPAR LPAR EOF #
follow(memory_sig) = RPAR
follow(memory_fields) = RPAR
follow(memory) = RPAR LPAR EOF
follow(literal) = UNREACHABLE UNARY TEST TEE_LOCAL STORE SET_LOCAL SET_GLOBAL SELECT RPAR RETURN NOP LPAR LOOP LOAD IF GROW_MEMORY GET_LOCAL GET_GLOBAL END ELSE DROP CURRENT_MEMORY CONVERT CONST COMPARE CALL_INDIRECT CALL BR_TABLE BR_IF BR BLOCK BINARY
follow(limits) = RPAR ANYFUNC
follow(labeling_opt) = UNREACHABLE UNARY TEST TEE_LOCAL STORE SET_LOCAL SET_GLOBAL SELECT RPAR RETURN NOP LPAR LOOP LOAD IF GROW_MEMORY GET_LOCAL GET_GLOBAL END ELSE DROP CURRENT_MEMORY CONVERT CONST COMPARE CALL_INDIRECT CALL BR_TABLE BR_IF BR BLOCK BINARY
follow(labeling_end_opt) = UNREACHABLE UNARY TEST TEE_LOCAL STORE SET_LOCAL SET_GLOBAL SELECT RPAR RETURN NOP LPAR LOOP LOAD IF GROW_MEMORY GET_LOCAL GET_GLOBAL END ELSE DROP CURRENT_MEMORY CONVERT CONST COMPARE CALL_INDIRECT CALL BR_TABLE BR_IF BR BLOCK BINARY
follow(instr_list) = RPAR END ELSE
follow(instr) = UNREACHABLE UNARY TEST TEE_LOCAL STORE SET_LOCAL SET_GLOBAL SELECT RPAR RETURN NOP LPAR LOOP LOAD IF GROW_MEMORY GET_LOCAL GET_GLOBAL END ELSE DROP CURRENT_MEMORY CONVERT CONST COMPARE CALL_INDIRECT CALL BR_TABLE BR_IF BR BLOCK BINARY
follow(inline_module1) = EOF
follow(inline_module) = EOF
follow(inline_import) = VALUE_TYPE RPAR NAT LPAR
follow(inline_export) = VALUE_TYPE UNREACHABLE UNARY TEST TEE_LOCAL STORE SET_LOCAL SET_GLOBAL SELECT RPAR RETURN NOP NAT LPAR LOOP LOAD IF GROW_MEMORY GET_LOCAL GET_GLOBAL DROP CURRENT_MEMORY CONVERT CONST COMPARE CALL_INDIRECT CALL BR_TABLE BR_IF BR BLOCK BINARY ANYFUNC
follow(import_desc) = RPAR
follow(import) = RPAR LPAR EOF
follow(if_block) = RPAR
follow(if_) = RPAR
follow(global_type) = UNREACHABLE UNARY TEST TEE_LOCAL STORE SET_LOCAL SET_GLOBAL SELECT RPAR RETURN NOP LPAR LOOP LOAD IF GROW_MEMORY GET_LOCAL GET_GLOBAL DROP CURRENT_MEMORY CONVERT CONST COMPARE CALL_INDIRECT CALL BR_TABLE BR_IF BR BLOCK BINARY
follow(global_fields) = RPAR
follow(global) = RPAR LPAR EOF
follow(func_type) = RPAR
follow(func_sig) = RPAR
follow(func_result_body) = RPAR
follow(func_fields_import_result) = RPAR
follow(func_fields_import) = RPAR
follow(func_fields_body) = RPAR
follow(func_fields) = RPAR
follow(func_body) = RPAR
follow(func) = RPAR LPAR EOF
follow(expr_list) = RPAR
follow(expr1) = RPAR
follow(expr) = VAR UNREACHABLE UNARY TEST TEE_LOCAL STRING STORE SET_LOCAL SET_GLOBAL SELECT RPAR RETURN NOP NAT LPAR LOOP LOAD IF GROW_MEMORY GET_LOCAL GET_GLOBAL END ELSE DROP CURRENT_MEMORY CONVERT CONST COMPARE CALL_INDIRECT CALL BR_TABLE BR_IF BR BLOCK BINARY
follow(export_desc) = RPAR
follow(export) = RPAR LPAR EOF
follow(elem_type) = RPAR LPAR
follow(elem) = RPAR LPAR EOF
follow(data) = RPAR LPAR EOF
follow(const_list) = RPAR
follow(const_expr) = RPAR
follow(const) = RPAR LPAR
follow(cmd_list) = RPAR EOF
follow(cmd) = RPAR LPAR EOF #
follow(block_sig) = UNREACHABLE UNARY TEST TEE_LOCAL STORE SET_LOCAL SET_GLOBAL SELECT RPAR RETURN NOP LPAR LOOP LOAD IF GROW_MEMORY GET_LOCAL GET_GLOBAL END ELSE DROP CURRENT_MEMORY CONVERT CONST COMPARE CALL_INDIRECT CALL BR_TABLE BR_IF BR BLOCK BINARY
follow(block_instr) = UNREACHABLE UNARY TEST TEE_LOCAL STORE SET_LOCAL SET_GLOBAL SELECT RPAR RETURN NOP LPAR LOOP LOAD IF GROW_MEMORY GET_LOCAL GET_GLOBAL END ELSE DROP CURRENT_MEMORY CONVERT CONST COMPARE CALL_INDIRECT CALL BR_TABLE BR_IF BR BLOCK BINARY
follow(block) = RPAR END ELSE
follow(bind_var_opt) = VALUE_TYPE UNREACHABLE UNARY TEST TEE_LOCAL STORE SET_LOCAL SET_GLOBAL SELECT RPAR RETURN NOP NAT LPAR LOOP LOAD IF GROW_MEMORY GET_LOCAL GET_GLOBAL DROP CURRENT_MEMORY CONVERT CONST COMPARE CALL_INDIRECT CALL BR_TABLE BR_IF BR BLOCK BINARY ANYFUNC
follow(bind_var) = VALUE_TYPE UNREACHABLE UNARY TEST TEE_LOCAL STORE SET_LOCAL SET_GLOBAL SELECT RPAR RETURN NOP NAT LPAR LOOP LOAD IF GROW_MEMORY GET_LOCAL GET_GLOBAL END ELSE DROP CURRENT_MEMORY CONVERT CONST COMPARE CALL_INDIRECT CALL BR_TABLE BR_IF BR BLOCK BINARY ANYFUNC
follow(assertion) = RPAR LPAR EOF #
follow(align_opt) = UNREACHABLE UNARY TEST TEE_LOCAL STORE SET_LOCAL SET_GLOBAL SELECT RPAR RETURN NOP LPAR LOOP LOAD IF GROW_MEMORY GET_LOCAL GET_GLOBAL END ELSE DROP CURRENT_MEMORY CONVERT CONST COMPARE CALL_INDIRECT CALL BR_TABLE BR_IF BR BLOCK BINARY
follow(action) = STRING RPAR LPAR EOF #
Built an LR(0) automaton with 458 states.
The grammar is SLR(1).
The construction mode is pager.
Built an LR(1) automaton with 533 states.
File "wasm.1.0-parser.mly", line 180, characters 0-9:
Warning: the precedence level assigned to LOW is never useful.
File "wasm.1.0-parser.mly", line 181, characters 0-9:
Warning: the precedence level assigned to VAR is never useful.
File "wasm.1.0-parser.mly", line 276, characters 22-25:
Warning: this %prec declaration is never useful.
File "wasm.1.0-parser.mly", line 265, characters 22-25:
Warning: this %prec declaration is never useful.
209 out of 533 states have a default reduction.
200 out of 533 states are represented.
0 out of 156 symbols keep track of their start position.
0 out of 156 symbols keep track of their end position.
116 out of 197 productions exploit shiftreduce optimization.
0 out of 533 states can peek at an error.
1346 functions before inlining, 203 functions after inlining.
