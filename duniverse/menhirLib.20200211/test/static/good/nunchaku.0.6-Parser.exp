Grammar has 52 nonterminal symbols, among which 4 start symbols.
Grammar has 59 terminal symbols.
Grammar has 117 productions.
nullable(wf_attribute) = true
nullable(var_or_wildcard) = false
nullable(var) = false
nullable(typed_var) = false
nullable(typed_ty_var) = false
nullable(type_def) = false
nullable(term) = false
nullable(statement) = false
nullable(spec_defs) = false
nullable(separated_nonempty_list(VERTICAL_BAR,constructor)) = false
nullable(separated_nonempty_list(VERTICAL_BAR,case(term))) = false
nullable(separated_nonempty_list(SEMI_COLON,term)) = false
nullable(separated_nonempty_list(SEMI_COLON,nonempty_list(decl_attribute_element))) = false
nullable(separated_nonempty_list(AND,type_def)) = false
nullable(separated_nonempty_list(AND,rec_def)) = false
nullable(separated_nonempty_list(AND,pred_def)) = false
nullable(separated_nonempty_list(AND,defined_symbol)) = false
nullable(rec_defs) = false
nullable(rec_def) = false
nullable(raw_var) = false
nullable(pred_def) = false
nullable(parse_ty) = false
nullable(parse_term) = false
nullable(parse_statement_list) = false
nullable(parse_statement) = false
nullable(or_term) = false
nullable(option(VERTICAL_BAR)) = true
nullable(nonempty_list(typed_var)) = false
nullable(nonempty_list(typed_ty_var)) = false
nullable(nonempty_list(decl_attribute_element)) = false
nullable(nonempty_list(atomic_term)) = false
nullable(mutual_types) = false
nullable(mutual_preds) = false
nullable(meta_var) = false
nullable(list(var_or_wildcard)) = true
nullable(list(statement)) = true
nullable(list(raw_var)) = true
nullable(list(atomic_term)) = true
nullable(eq_term) = false
nullable(defined_symbol) = false
nullable(decl_attributes) = true
nullable(decl_attribute_element) = false
nullable(copy_wrt) = true
nullable(constructors) = false
nullable(constructor) = false
nullable(const) = false
nullable(cases(term)) = false
nullable(case(term)) = false
nullable(atomic_term) = false
nullable(at_var) = false
nullable(apply_term) = false
nullable(and_term) = false
first(wf_attribute) = LEFT_BRACKET
first(var_or_wildcard) = WILDCARD UPPER_WORD LOWER_WORD
first(var) = WILDCARD UPPER_WORD LOWER_WORD
first(typed_var) = UPPER_WORD LOWER_WORD LEFT_PAREN
first(typed_ty_var) = UPPER_WORD LOWER_WORD LEFT_PAREN
first(type_def) = UPPER_WORD LOWER_WORD
first(term) = error WILDCARD UPPER_WORD TYPE PROP PI META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_NOT LOGIC_FORALL LOGIC_FALSE LOGIC_EXISTS LET LEFT_PAREN IF FUN AT
first(statement) = error VAL SPEC REC PRED INCLUDE GOAL DATA COPY COPRED CODATA AXIOM
first(spec_defs) = UPPER_WORD LOWER_WORD
first(separated_nonempty_list(VERTICAL_BAR,constructor)) = UPPER_WORD LOWER_WORD
first(separated_nonempty_list(VERTICAL_BAR,case(term))) = UPPER_WORD LOWER_WORD
first(separated_nonempty_list(SEMI_COLON,term)) = error WILDCARD UPPER_WORD TYPE PROP PI META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_NOT LOGIC_FORALL LOGIC_FALSE LOGIC_EXISTS LET LEFT_PAREN IF FUN AT
first(separated_nonempty_list(SEMI_COLON,nonempty_list(decl_attribute_element))) = UPPER_WORD LOWER_WORD INTEGER
first(separated_nonempty_list(AND,type_def)) = UPPER_WORD LOWER_WORD
first(separated_nonempty_list(AND,rec_def)) = UPPER_WORD LOWER_WORD
first(separated_nonempty_list(AND,pred_def)) = UPPER_WORD LOWER_WORD
first(separated_nonempty_list(AND,defined_symbol)) = UPPER_WORD LOWER_WORD
first(rec_defs) = UPPER_WORD LOWER_WORD
first(rec_def) = UPPER_WORD LOWER_WORD
first(raw_var) = UPPER_WORD LOWER_WORD
first(pred_def) = UPPER_WORD LOWER_WORD
first(parse_ty) = error WILDCARD UPPER_WORD TYPE PROP PI META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_NOT LOGIC_FORALL LOGIC_FALSE LOGIC_EXISTS LET LEFT_PAREN IF FUN AT
first(parse_term) = error WILDCARD UPPER_WORD TYPE PROP PI META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_NOT LOGIC_FORALL LOGIC_FALSE LOGIC_EXISTS LET LEFT_PAREN IF FUN AT
first(parse_statement_list) = error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM
first(parse_statement) = error VAL SPEC REC PRED INCLUDE GOAL DATA COPY COPRED CODATA AXIOM
first(or_term) = WILDCARD UPPER_WORD TYPE PROP META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_NOT LOGIC_FALSE LEFT_PAREN AT
first(option(VERTICAL_BAR)) = VERTICAL_BAR
first(nonempty_list(typed_var)) = UPPER_WORD LOWER_WORD LEFT_PAREN
first(nonempty_list(typed_ty_var)) = UPPER_WORD LOWER_WORD LEFT_PAREN
first(nonempty_list(decl_attribute_element)) = UPPER_WORD LOWER_WORD INTEGER
first(nonempty_list(atomic_term)) = WILDCARD UPPER_WORD TYPE PROP META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN AT
first(mutual_types) = UPPER_WORD LOWER_WORD
first(mutual_preds) = UPPER_WORD LOWER_WORD
first(meta_var) = META_VAR
first(list(var_or_wildcard)) = WILDCARD UPPER_WORD LOWER_WORD
first(list(statement)) = error VAL SPEC REC PRED INCLUDE GOAL DATA COPY COPRED CODATA AXIOM
first(list(raw_var)) = UPPER_WORD LOWER_WORD
first(list(atomic_term)) = WILDCARD UPPER_WORD TYPE PROP META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN AT
first(eq_term) = WILDCARD UPPER_WORD TYPE PROP META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_NOT LOGIC_FALSE LEFT_PAREN AT
first(defined_symbol) = UPPER_WORD LOWER_WORD
first(decl_attributes) = LEFT_BRACKET
first(decl_attribute_element) = UPPER_WORD LOWER_WORD INTEGER
first(copy_wrt) = SUBSET QUOTIENT PARTIAL_QUOTIENT
first(constructors) = VERTICAL_BAR UPPER_WORD LOWER_WORD
first(constructor) = UPPER_WORD LOWER_WORD
first(const) = TYPE PROP LOGIC_TRUE LOGIC_FALSE
first(cases(term)) = VERTICAL_BAR UPPER_WORD LOWER_WORD
first(case(term)) = UPPER_WORD LOWER_WORD
first(atomic_term) = WILDCARD UPPER_WORD TYPE PROP META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_FALSE LEFT_PAREN AT
first(at_var) = AT
first(apply_term) = WILDCARD UPPER_WORD TYPE PROP META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_NOT LOGIC_FALSE LEFT_PAREN AT
first(and_term) = WILDCARD UPPER_WORD TYPE PROP META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_NOT LOGIC_FALSE LEFT_PAREN AT
minimal(wf_attribute) = (* 0 *) 
minimal(var_or_wildcard) = (* 1 *) WILDCARD
minimal(var) = (* 1 *) WILDCARD
minimal(typed_var) = (* 1 *) LOWER_WORD
minimal(typed_ty_var) = (* 1 *) LOWER_WORD
minimal(type_def) = (* 3 *) LOWER_WORD EQDEF LOWER_WORD
minimal(term) = (* 1 *) WILDCARD
minimal(statement) = (* 1 *) error
minimal(spec_defs) = (* 5 *) LOWER_WORD COLON WILDCARD EQDEF WILDCARD
minimal(separated_nonempty_list(VERTICAL_BAR,constructor)) = (* 1 *) LOWER_WORD
minimal(separated_nonempty_list(VERTICAL_BAR,case(term))) = (* 3 *) LOWER_WORD ARROW WILDCARD
minimal(separated_nonempty_list(SEMI_COLON,term)) = (* 1 *) WILDCARD
minimal(separated_nonempty_list(SEMI_COLON,nonempty_list(decl_attribute_element))) = (* 1 *) UPPER_WORD
minimal(separated_nonempty_list(AND,type_def)) = (* 3 *) LOWER_WORD EQDEF LOWER_WORD
minimal(separated_nonempty_list(AND,rec_def)) = (* 5 *) LOWER_WORD COLON WILDCARD EQDEF WILDCARD
minimal(separated_nonempty_list(AND,pred_def)) = (* 5 *) LOWER_WORD COLON WILDCARD EQDEF WILDCARD
minimal(separated_nonempty_list(AND,defined_symbol)) = (* 3 *) LOWER_WORD COLON WILDCARD
minimal(rec_defs) = (* 5 *) LOWER_WORD COLON WILDCARD EQDEF WILDCARD
minimal(rec_def) = (* 5 *) LOWER_WORD COLON WILDCARD EQDEF WILDCARD
minimal(raw_var) = (* 1 *) LOWER_WORD
minimal(pred_def) = (* 5 *) LOWER_WORD COLON WILDCARD EQDEF WILDCARD
minimal(parse_ty) = (* 2 *) WILDCARD EOI
minimal(parse_term) = (* 2 *) WILDCARD EOI
minimal(parse_statement_list) = (* 1 *) EOI
minimal(parse_statement) = (* 2 *) error EOI
minimal(or_term) = (* 1 *) WILDCARD
minimal(option(VERTICAL_BAR)) = (* 0 *) 
minimal(nonempty_list(typed_var)) = (* 1 *) LOWER_WORD
minimal(nonempty_list(typed_ty_var)) = (* 1 *) LOWER_WORD
minimal(nonempty_list(decl_attribute_element)) = (* 1 *) UPPER_WORD
minimal(nonempty_list(atomic_term)) = (* 1 *) WILDCARD
minimal(mutual_types) = (* 3 *) LOWER_WORD EQDEF LOWER_WORD
minimal(mutual_preds) = (* 5 *) LOWER_WORD COLON WILDCARD EQDEF WILDCARD
minimal(meta_var) = (* 2 *) META_VAR LOWER_WORD
minimal(list(var_or_wildcard)) = (* 0 *) 
minimal(list(statement)) = (* 0 *) 
minimal(list(raw_var)) = (* 0 *) 
minimal(list(atomic_term)) = (* 0 *) 
minimal(eq_term) = (* 1 *) WILDCARD
minimal(defined_symbol) = (* 3 *) LOWER_WORD COLON WILDCARD
minimal(decl_attributes) = (* 0 *) 
minimal(decl_attribute_element) = (* 1 *) UPPER_WORD
minimal(copy_wrt) = (* 0 *) 
minimal(constructors) = (* 1 *) LOWER_WORD
minimal(constructor) = (* 1 *) LOWER_WORD
minimal(const) = (* 1 *) TYPE
minimal(cases(term)) = (* 3 *) LOWER_WORD ARROW WILDCARD
minimal(case(term)) = (* 3 *) LOWER_WORD ARROW WILDCARD
minimal(atomic_term) = (* 1 *) WILDCARD
minimal(at_var) = (* 2 *) AT LOWER_WORD
minimal(apply_term) = (* 1 *) WILDCARD
minimal(and_term) = (* 1 *) WILDCARD
follow(wf_attribute) = UPPER_WORD LOWER_WORD
follow(var_or_wildcard) = WILDCARD UPPER_WORD LOWER_WORD ARROW
follow(var) = WITH WILDCARD VERTICAL_BAR UPPER_WORD TYPE THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PROP PARTIAL_QUOTIENT META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET IN EQDEF EOI END ELSE DOT AT ASSERTING ARROW AND ABSTRACT
follow(typed_var) = UPPER_WORD LOWER_WORD LEFT_PAREN DOT
follow(typed_ty_var) = UPPER_WORD LOWER_WORD LEFT_PAREN DOT
follow(type_def) = DOT AND
follow(term) = WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT
follow(statement) = error VAL SPEC REC PRED INCLUDE GOAL EOI DATA COPY COPRED CODATA AXIOM
follow(spec_defs) = DOT
follow(separated_nonempty_list(VERTICAL_BAR,constructor)) = DOT AND
follow(separated_nonempty_list(VERTICAL_BAR,case(term))) = END
follow(separated_nonempty_list(SEMI_COLON,term)) = DOT AND
follow(separated_nonempty_list(SEMI_COLON,nonempty_list(decl_attribute_element))) = RIGHT_BRACKET
follow(separated_nonempty_list(AND,type_def)) = DOT
follow(separated_nonempty_list(AND,rec_def)) = DOT
follow(separated_nonempty_list(AND,pred_def)) = DOT
follow(separated_nonempty_list(AND,defined_symbol)) = EQDEF
follow(rec_defs) = DOT
follow(rec_def) = DOT AND
follow(raw_var) = WITH WILDCARD VERTICAL_BAR UPPER_WORD TYPE THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PROP PARTIAL_QUOTIENT META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET IN EQDEF EOI END ELSE DOT CONCRETE COLON AT ASSERTING ARROW AND ABSTRACT
follow(pred_def) = DOT AND
follow(parse_ty) = #
follow(parse_term) = #
follow(parse_statement_list) = #
follow(parse_statement) = #
follow(or_term) = WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT
follow(option(VERTICAL_BAR)) = UPPER_WORD LOWER_WORD
follow(nonempty_list(typed_var)) = DOT
follow(nonempty_list(typed_ty_var)) = DOT
follow(nonempty_list(decl_attribute_element)) = SEMI_COLON RIGHT_BRACKET
follow(nonempty_list(atomic_term)) = WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQ LOGIC_AND LEFT_BRACKET IN EQDEF EOI END ELSE DOT ASSERTING ARROW AND ABSTRACT
follow(mutual_types) = DOT
follow(mutual_preds) = DOT
follow(meta_var) = WITH WILDCARD VERTICAL_BAR UPPER_WORD TYPE THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PROP PARTIAL_QUOTIENT META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET IN EQDEF EOI END ELSE DOT AT ASSERTING ARROW AND ABSTRACT
follow(list(var_or_wildcard)) = ARROW
follow(list(statement)) = EOI
follow(list(raw_var)) = EQDEF
follow(list(atomic_term)) = VERTICAL_BAR DOT AND
follow(eq_term) = WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LOGIC_OR LOGIC_IMPLY LOGIC_AND LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT
follow(defined_symbol) = EQDEF AND
follow(decl_attributes) = DOT
follow(decl_attribute_element) = UPPER_WORD SEMI_COLON RIGHT_BRACKET LOWER_WORD INTEGER
follow(copy_wrt) = ABSTRACT
follow(constructors) = DOT AND
follow(constructor) = VERTICAL_BAR DOT AND
follow(const) = WITH WILDCARD VERTICAL_BAR UPPER_WORD TYPE THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PROP PARTIAL_QUOTIENT META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET IN EQDEF EOI END ELSE DOT AT ASSERTING ARROW AND ABSTRACT
follow(cases(term)) = END
follow(case(term)) = VERTICAL_BAR END
follow(atomic_term) = WITH WILDCARD VERTICAL_BAR UPPER_WORD TYPE THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PROP PARTIAL_QUOTIENT META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET IN EQDEF EOI END ELSE DOT AT ASSERTING ARROW AND ABSTRACT
follow(at_var) = WITH WILDCARD VERTICAL_BAR UPPER_WORD TYPE THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PROP PARTIAL_QUOTIENT META_VAR MATCH LOWER_WORD LOGIC_TRUE LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_FALSE LOGIC_EQ LOGIC_AND LEFT_PAREN LEFT_BRACKET IN EQDEF EOI END ELSE DOT AT ASSERTING ARROW AND ABSTRACT
follow(apply_term) = WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LOGIC_OR LOGIC_NEQ LOGIC_IMPLY LOGIC_EQ LOGIC_AND LEFT_BRACKET IN EQDEF EOI END ELSE DOT ASSERTING ARROW AND ABSTRACT
follow(and_term) = WITH VERTICAL_BAR THEN SUBSET SEMI_COLON RIGHT_PAREN QUOTIENT PARTIAL_QUOTIENT LOGIC_OR LOGIC_IMPLY LEFT_BRACKET IN EQDEF EOI END ELSE DOT AND ABSTRACT
Built an LR(0) automaton with 242 states.
The grammar is SLR(1).
The construction mode is pager.
Built an LR(1) automaton with 289 states.
108 out of 289 states have a default reduction.
105 out of 289 states are represented.
39 out of 117 symbols keep track of their start position.
23 out of 117 symbols keep track of their end position.
62 out of 121 productions exploit shiftreduce optimization.
2 out of 289 states can peek at an error.
The generated parser cannot raise Error.
760 functions before inlining, 109 functions after inlining.
