File "parser_java.mly", line 186, characters 10-17:
Warning: the token BOOLEAN is unused.
File "parser_java.mly", line 186, characters 24-28:
Warning: the token BYTE is unused.
File "parser_java.mly", line 186, characters 40-44:
Warning: the token CHAR is unused.
File "parser_java.mly", line 186, characters 51-56:
Warning: the token CONST is unused.
File "parser_java.mly", line 187, characters 12-18:
Warning: the token DOUBLE is unused.
File "parser_java.mly", line 187, characters 46-51:
Warning: the token FLOAT is unused.
File "parser_java.mly", line 187, characters 56-60:
Warning: the token GOTO is unused.
File "parser_java.mly", line 188, characters 33-36:
Warning: the token INT is unused.
File "parser_java.mly", line 188, characters 47-51:
Warning: the token LONG is unused.
File "parser_java.mly", line 190, characters 1-6:
Warning: the token SHORT is unused.
File "parser_java.mly", line 110, characters 25-33:
Warning: the token TComment is unused.
File "parser_java.mly", line 110, characters 34-49:
Warning: the token TCommentNewline is unused.
File "parser_java.mly", line 110, characters 50-63:
Warning: the token TCommentSpace is unused.
File "parser_java.mly", line 201, characters 25-33:
Warning: the token TUnknown is unused.
Grammar has 196 nonterminal symbols, among which 1 start symbols.
Grammar has 102 terminal symbols.
Grammar has 434 productions.
nullable(while_statement_no_short_if) = false
nullable(while_statement) = false
nullable(variable_modifiers_opt) = true
nullable(variable_modifiers) = false
nullable(variable_modifier) = false
nullable(variable_initializers) = false
nullable(variable_initializer) = false
nullable(variable_declarators) = false
nullable(variable_declarator_id_bis) = false
nullable(variable_declarator_id) = false
nullable(variable_declarator) = false
nullable(unary_expression_not_plus_minus) = false
nullable(unary_expression) = false
nullable(type_parameters_opt) = true
nullable(type_parameters_bis) = false
nullable(type_parameters) = false
nullable(type_parameter) = false
nullable(type_java) = false
nullable(type_declarations_opt) = true
nullable(type_declarations) = false
nullable(type_declaration) = false
nullable(type_arguments) = false
nullable(type_argument) = false
nullable(try_statement) = false
nullable(throws_opt) = true
nullable(throws) = false
nullable(throw_statement) = false
nullable(synchronized_statement) = false
nullable(switch_statement) = false
nullable(switch_labels) = false
nullable(switch_label) = false
nullable(switch_block_statement_groups) = false
nullable(switch_block_statement_group) = false
nullable(switch_block) = false
nullable(super_opt) = true
nullable(super) = false
nullable(static_opt) = true
nullable(static_initializer) = false
nullable(statement_without_trailing_substatement) = false
nullable(statement_no_short_if) = false
nullable(statement_expression_list) = false
nullable(statement_expression) = false
nullable(statement) = false
nullable(shift_expression) = false
nullable(return_statement) = false
nullable(relational_expression) = false
nullable(reference_type) = false
nullable(ref_type_list) = false
nullable(ref_type_and_list) = false
nullable(qualified_ident_list) = false
nullable(primitive_type) = false
nullable(primary_no_new_array) = false
nullable(primary) = false
nullable(pre_increment_expression) = false
nullable(pre_decrement_expression) = false
nullable(postfix_expression) = false
nullable(post_increment_expression) = false
nullable(post_decrement_expression) = false
nullable(package_declaration_opt) = true
nullable(package_declaration) = false
nullable(name) = false
nullable(multiplicative_expression) = false
nullable(modifiers_opt) = true
nullable(modifiers) = false
nullable(modifier) = false
nullable(method_invocation) = false
nullable(method_header) = false
nullable(method_declarator_rest) = false
nullable(method_declarator) = false
nullable(method_declarations_opt) = true
nullable(method_declarations) = false
nullable(method_declaration) = false
nullable(method_body) = false
nullable(local_variable_declaration_statement) = false
nullable(local_variable_declaration) = false
nullable(literal) = false
nullable(left_hand_side) = false
nullable(labeled_statement_no_short_if) = false
nullable(labeled_statement) = false
nullable(interfaces_opt) = true
nullable(interfaces) = false
nullable(interface_method_declator_rest) = false
nullable(interface_member_declarations_opt) = true
nullable(interface_member_declarations) = false
nullable(interface_member_declaration) = false
nullable(interface_generic_method_decl) = false
nullable(interface_declaration) = false
nullable(interface_body) = false
nullable(instance_initializer) = false
nullable(inclusive_or_expression) = false
nullable(import_declarations_opt) = true
nullable(import_declarations) = false
nullable(import_declaration) = false
nullable(if_then_statement) = false
nullable(if_then_else_statement_no_short_if) = false
nullable(if_then_else_statement) = false
nullable(identifier_opt) = true
nullable(identifier_) = false
nullable(identifier) = false
nullable(goal) = false
nullable(generic_method_or_constructor_rest) = false
nullable(generic_method_or_constructor_decl) = false
nullable(formal_parameters) = false
nullable(formal_parameter_list_opt) = true
nullable(formal_parameter_list) = false
nullable(formal_parameter) = false
nullable(for_var_control_rest) = false
nullable(for_var_control) = false
nullable(for_update_opt) = true
nullable(for_update) = false
nullable(for_statement_no_short_if) = false
nullable(for_statement) = false
nullable(for_init_opt) = true
nullable(for_init) = false
nullable(for_control) = false
nullable(finally) = false
nullable(field_declaration) = false
nullable(field_access) = false
nullable(extends_interfaces_opt) = true
nullable(extends_interfaces) = false
nullable(expression_statement) = false
nullable(expression_opt) = true
nullable(expression) = false
nullable(expr1) = false
nullable(explicit_constructor_invocation) = false
nullable(exclusive_or_expression) = false
nullable(equality_expression) = false
nullable(enum_declaration) = false
nullable(enum_constants) = false
nullable(enum_constant) = false
nullable(enum_body_declarations_opt) = true
nullable(enum_body_declarations) = false
nullable(enum_body) = false
nullable(empty_statement) = false
nullable(element_values) = false
nullable(element_value_pairs) = false
nullable(element_value_pair) = false
nullable(element_value_array_initializer) = false
nullable(element_value) = false
nullable(do_statement) = false
nullable(dims_opt) = true
nullable(dims) = false
nullable(dim_exprs) = false
nullable(dim_expr) = false
nullable(continue_statement) = false
nullable(constructor_declarator) = false
nullable(constructor_declaration) = false
nullable(constructor_body) = false
nullable(constant_expression) = false
nullable(constant_declaration) = false
nullable(conditional_or_expression) = false
nullable(conditional_expression) = false
nullable(conditional_and_expression) = false
nullable(compilation_unit) = true
nullable(comma_opt) = true
nullable(class_or_interface_type) = false
nullable(class_member_declaration) = false
nullable(class_literal) = false
nullable(class_instance_creation_expression) = false
nullable(class_declaration) = false
nullable(class_body_opt) = true
nullable(class_body_declarations_opt) = true
nullable(class_body_declarations) = false
nullable(class_body_declaration) = false
nullable(class_body) = false
nullable(catches_opt) = true
nullable(catches) = false
nullable(catch_clause) = false
nullable(cast_expression) = false
nullable(break_statement) = false
nullable(bound) = false
nullable(block_statements_opt) = true
nullable(block_statements) = false
nullable(block_statement) = false
nullable(block) = false
nullable(assignment_operator) = false
nullable(assignment_expression) = false
nullable(assignment) = false
nullable(array_type) = false
nullable(array_initializer) = false
nullable(array_creation_expression) = false
nullable(array_access) = false
nullable(argument_list_opt) = true
nullable(argument_list) = false
nullable(annotation_type_element_rest) = false
nullable(annotation_type_element_declarations_opt) = true
nullable(annotation_type_element_declarations) = false
nullable(annotation_type_element_declaration) = false
nullable(annotation_type_declaration) = false
nullable(annotation_type_body) = false
nullable(annotation_method_or_constant_rest) = false
nullable(annotation_element) = true
nullable(annotation) = false
nullable(and_expression) = false
nullable(additive_expression) = false
nullable(abstract_method_declaration) = false
first(while_statement_no_short_if) = WHILE
first(while_statement) = WHILE
first(variable_modifiers_opt) = FINAL AT
first(variable_modifiers) = FINAL AT
first(variable_modifier) = FINAL AT
first(variable_initializers) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NOT NEW MINUS LP LITERAL LC INCR IDENTIFIER DECR COMPL
first(variable_initializer) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NOT NEW MINUS LP LITERAL LC INCR IDENTIFIER DECR COMPL
first(variable_declarators) = IDENTIFIER
first(variable_declarator_id_bis) = IDENTIFIER DOTS
first(variable_declarator_id) = IDENTIFIER
first(variable_declarator) = IDENTIFIER
first(unary_expression_not_plus_minus) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NOT NEW LP LITERAL IDENTIFIER COMPL
first(unary_expression) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NOT NEW MINUS LP LITERAL INCR IDENTIFIER DECR COMPL
first(type_parameters_opt) = LT
first(type_parameters_bis) = IDENTIFIER
first(type_parameters) = LT
first(type_parameter) = IDENTIFIER
first(type_java) = PRIMITIVE_TYPE IDENTIFIER
first(type_declarations_opt) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL ENUM CLASS AT ABSTRACT
first(type_declarations) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL ENUM CLASS AT ABSTRACT
first(type_declaration) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL ENUM CLASS AT ABSTRACT
first(type_arguments) = PRIMITIVE_TYPE IDENTIFIER COND
first(type_argument) = PRIMITIVE_TYPE IDENTIFIER COND
first(try_statement) = TRY
first(throws_opt) = THROWS
first(throws) = THROWS
first(throw_statement) = THROW
first(synchronized_statement) = SYNCHRONIZED
first(switch_statement) = SWITCH
first(switch_labels) = DEFAULT CASE
first(switch_label) = DEFAULT CASE
first(switch_block_statement_groups) = DEFAULT CASE
first(switch_block_statement_group) = DEFAULT CASE
first(switch_block) = LC
first(super_opt) = EXTENDS
first(super) = EXTENDS
first(static_opt) = STATIC
first(static_initializer) = STATIC
first(statement_without_trailing_substatement) = VOID TString TRY TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER SM RETURN PRIMITIVE_TYPE NEW LP LITERAL LC INCR IDENTIFIER DO DECR CONTINUE BREAK ASSERT
first(statement_no_short_if) = WHILE VOID TString TRY TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER SM RETURN PRIMITIVE_TYPE NEW LP LITERAL LC INCR IF IDENTIFIER FOR DO DECR CONTINUE BREAK ASSERT
first(statement_expression_list) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NEW LP LITERAL INCR IDENTIFIER DECR
first(statement_expression) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NEW LP LITERAL INCR IDENTIFIER DECR
first(statement) = WHILE VOID TString TRY TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER SM RETURN PRIMITIVE_TYPE NEW LP LITERAL LC INCR IF IDENTIFIER FOR DO DECR CONTINUE BREAK ASSERT
first(shift_expression) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NOT NEW MINUS LP LITERAL INCR IDENTIFIER DECR COMPL
first(return_statement) = RETURN
first(relational_expression) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NOT NEW MINUS LP LITERAL INCR IDENTIFIER DECR COMPL
first(reference_type) = PRIMITIVE_TYPE IDENTIFIER
first(ref_type_list) = PRIMITIVE_TYPE IDENTIFIER
first(ref_type_and_list) = PRIMITIVE_TYPE IDENTIFIER
first(qualified_ident_list) = IDENTIFIER
first(primitive_type) = PRIMITIVE_TYPE
first(primary_no_new_array) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NEW LP LITERAL IDENTIFIER
first(primary) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NEW LP LITERAL IDENTIFIER
first(pre_increment_expression) = INCR
first(pre_decrement_expression) = DECR
first(postfix_expression) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NEW LP LITERAL IDENTIFIER
first(post_increment_expression) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NEW LP LITERAL IDENTIFIER
first(post_decrement_expression) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NEW LP LITERAL IDENTIFIER
first(package_declaration_opt) = PACKAGE
first(package_declaration) = PACKAGE
first(name) = IDENTIFIER
first(multiplicative_expression) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NOT NEW MINUS LP LITERAL INCR IDENTIFIER DECR COMPL
first(modifiers_opt) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE NATIVE FINAL AT ABSTRACT
first(modifiers) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE NATIVE FINAL AT ABSTRACT
first(modifier) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE NATIVE FINAL AT ABSTRACT
first(method_invocation) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NEW LP LITERAL IDENTIFIER
first(method_header) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL AT ABSTRACT
first(method_declarator_rest) = LP
first(method_declarator) = IDENTIFIER
first(method_declarations_opt) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL AT ABSTRACT
first(method_declarations) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL AT ABSTRACT
first(method_declaration) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL AT ABSTRACT
first(method_body) = SM LC
first(local_variable_declaration_statement) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL AT ABSTRACT
first(local_variable_declaration) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL AT ABSTRACT
first(literal) = TString TInt TFloat TChar LITERAL
first(left_hand_side) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NEW LP LITERAL IDENTIFIER
first(labeled_statement_no_short_if) = IDENTIFIER
first(labeled_statement) = IDENTIFIER
first(interfaces_opt) = IMPLEMENTS
first(interfaces) = IMPLEMENTS
first(interface_method_declator_rest) = LP
first(interface_member_declarations_opt) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
first(interface_member_declarations) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
first(interface_member_declaration) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
first(interface_generic_method_decl) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE NATIVE LT FINAL AT ABSTRACT
first(interface_declaration) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL AT ABSTRACT
first(interface_body) = LC
first(instance_initializer) = LC
first(inclusive_or_expression) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NOT NEW MINUS LP LITERAL INCR IDENTIFIER DECR COMPL
first(import_declarations_opt) = IMPORT
first(import_declarations) = IMPORT
first(import_declaration) = IMPORT
first(if_then_statement) = IF
first(if_then_else_statement_no_short_if) = IF
first(if_then_else_statement) = IF
first(identifier_opt) = IDENTIFIER
first(identifier_) = IDENTIFIER
first(identifier) = IDENTIFIER
first(goal) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE PACKAGE NATIVE INTERFACE IMPORT FINAL EOF ENUM CLASS AT ABSTRACT
first(generic_method_or_constructor_rest) = VOID PRIMITIVE_TYPE IDENTIFIER
first(generic_method_or_constructor_decl) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE NATIVE LT FINAL AT ABSTRACT
first(formal_parameters) = LP
first(formal_parameter_list_opt) = PRIMITIVE_TYPE IDENTIFIER FINAL AT
first(formal_parameter_list) = PRIMITIVE_TYPE IDENTIFIER FINAL AT
first(formal_parameter) = PRIMITIVE_TYPE IDENTIFIER FINAL AT
first(for_var_control_rest) = COLON
first(for_var_control) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL AT ABSTRACT
first(for_update_opt) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NEW LP LITERAL INCR IDENTIFIER DECR
first(for_update) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NEW LP LITERAL INCR IDENTIFIER DECR
first(for_statement_no_short_if) = FOR
first(for_statement) = FOR
first(for_init_opt) = VOLATILE VOID TString TRANSIENT TInt THIS TFloat TChar SYNCHRONIZED SUPER STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL INCR IDENTIFIER FINAL DECR AT ABSTRACT
first(for_init) = VOLATILE VOID TString TRANSIENT TInt THIS TFloat TChar SYNCHRONIZED SUPER STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL INCR IDENTIFIER FINAL DECR AT ABSTRACT
first(for_control) = VOLATILE VOID TString TRANSIENT TInt THIS TFloat TChar SYNCHRONIZED SUPER STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL INCR IDENTIFIER FINAL DECR AT ABSTRACT
first(finally) = FINALLY
first(field_declaration) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL AT ABSTRACT
first(field_access) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NEW LP LITERAL IDENTIFIER
first(extends_interfaces_opt) = EXTENDS
first(extends_interfaces) = EXTENDS
first(expression_statement) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NEW LP LITERAL INCR IDENTIFIER DECR
first(expression_opt) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NOT NEW MINUS LP LITERAL INCR IDENTIFIER DECR COMPL
first(expression) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NOT NEW MINUS LP LITERAL INCR IDENTIFIER DECR COMPL
first(expr1) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NEW LP LITERAL IDENTIFIER
first(explicit_constructor_invocation) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NEW LP LITERAL IDENTIFIER
first(exclusive_or_expression) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NOT NEW MINUS LP LITERAL INCR IDENTIFIER DECR COMPL
first(equality_expression) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NOT NEW MINUS LP LITERAL INCR IDENTIFIER DECR COMPL
first(enum_declaration) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE NATIVE FINAL ENUM AT ABSTRACT
first(enum_constants) = IDENTIFIER
first(enum_constant) = IDENTIFIER
first(enum_body_declarations_opt) = SM
first(enum_body_declarations) = SM
first(enum_body) = LC
first(empty_statement) = SM
first(element_values) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NEW LP LITERAL LC IDENTIFIER AT
first(element_value_pairs) = IDENTIFIER
first(element_value_pair) = IDENTIFIER
first(element_value_array_initializer) = LC
first(element_value) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NEW LP LITERAL LC IDENTIFIER AT
first(do_statement) = DO
first(dims_opt) = LB_RB
first(dims) = LB_RB
first(dim_exprs) = LB
first(dim_expr) = LB
first(continue_statement) = CONTINUE
first(constructor_declarator) = IDENTIFIER
first(constructor_declaration) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE NATIVE IDENTIFIER FINAL AT ABSTRACT
first(constructor_body) = LC
first(constant_expression) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NOT NEW MINUS LP LITERAL INCR IDENTIFIER DECR COMPL
first(constant_declaration) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL AT ABSTRACT
first(conditional_or_expression) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NOT NEW MINUS LP LITERAL INCR IDENTIFIER DECR COMPL
first(conditional_expression) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NOT NEW MINUS LP LITERAL INCR IDENTIFIER DECR COMPL
first(conditional_and_expression) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NOT NEW MINUS LP LITERAL INCR IDENTIFIER DECR COMPL
first(compilation_unit) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE PACKAGE NATIVE INTERFACE IMPORT FINAL ENUM CLASS AT ABSTRACT
first(comma_opt) = CM
first(class_or_interface_type) = IDENTIFIER
first(class_member_declaration) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
first(class_literal) = VOID PRIMITIVE_TYPE IDENTIFIER
first(class_instance_creation_expression) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NEW LP LITERAL IDENTIFIER
first(class_declaration) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE NATIVE FINAL CLASS AT ABSTRACT
first(class_body_opt) = LC
first(class_body_declarations_opt) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
first(class_body_declarations) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
first(class_body_declaration) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
first(class_body) = LC
first(catches_opt) = CATCH
first(catches) = CATCH
first(catch_clause) = CATCH
first(cast_expression) = LP
first(break_statement) = BREAK
first(bound) = PRIMITIVE_TYPE IDENTIFIER
first(block_statements_opt) = WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
first(block_statements) = WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
first(block_statement) = WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
first(block) = LC
first(assignment_operator) = OPERATOR_EQ EQ
first(assignment_expression) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NOT NEW MINUS LP LITERAL INCR IDENTIFIER DECR COMPL
first(assignment) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NEW LP LITERAL IDENTIFIER
first(array_type) = PRIMITIVE_TYPE IDENTIFIER
first(array_initializer) = LC
first(array_creation_expression) = NEW
first(array_access) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NEW LP LITERAL IDENTIFIER
first(argument_list_opt) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NOT NEW MINUS LP LITERAL INCR IDENTIFIER DECR COMPL
first(argument_list) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NOT NEW MINUS LP LITERAL INCR IDENTIFIER DECR COMPL
first(annotation_type_element_rest) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
first(annotation_type_element_declarations_opt) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
first(annotation_type_element_declarations) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
first(annotation_type_element_declaration) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
first(annotation_type_declaration) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE NATIVE FINAL AT ABSTRACT
first(annotation_type_body) = LC
first(annotation_method_or_constant_rest) = LP
first(annotation_element) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE NEW LP LITERAL LC IDENTIFIER AT
first(annotation) = AT
first(and_expression) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NOT NEW MINUS LP LITERAL INCR IDENTIFIER DECR COMPL
first(additive_expression) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NOT NEW MINUS LP LITERAL INCR IDENTIFIER DECR COMPL
first(abstract_method_declaration) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL AT ABSTRACT
minimal(while_statement_no_short_if) = (* 5 *) WHILE LP LITERAL RP SM
minimal(while_statement) = (* 5 *) WHILE LP LITERAL RP SM
minimal(variable_modifiers_opt) = (* 0 *) 
minimal(variable_modifiers) = (* 1 *) FINAL
minimal(variable_modifier) = (* 1 *) FINAL
minimal(variable_initializers) = (* 1 *) LITERAL
minimal(variable_initializer) = (* 1 *) LITERAL
minimal(variable_declarators) = (* 1 *) IDENTIFIER
minimal(variable_declarator_id_bis) = (* 1 *) IDENTIFIER
minimal(variable_declarator_id) = (* 1 *) IDENTIFIER
minimal(variable_declarator) = (* 1 *) IDENTIFIER
minimal(unary_expression_not_plus_minus) = (* 1 *) LITERAL
minimal(unary_expression) = (* 1 *) LITERAL
minimal(type_parameters_opt) = (* 0 *) 
minimal(type_parameters_bis) = (* 1 *) IDENTIFIER
minimal(type_parameters) = (* 3 *) LT IDENTIFIER GT
minimal(type_parameter) = (* 1 *) IDENTIFIER
minimal(type_java) = (* 1 *) PRIMITIVE_TYPE
minimal(type_declarations_opt) = (* 0 *) 
minimal(type_declarations) = (* 1 *) SM
minimal(type_declaration) = (* 1 *) SM
minimal(type_arguments) = (* 1 *) COND
minimal(type_argument) = (* 1 *) COND
minimal(try_statement) = (* 6 *) TRY LC RC FINALLY LC RC
minimal(throws_opt) = (* 0 *) 
minimal(throws) = (* 2 *) THROWS IDENTIFIER
minimal(throw_statement) = (* 3 *) THROW LITERAL SM
minimal(synchronized_statement) = (* 6 *) SYNCHRONIZED LP LITERAL RP LC RC
minimal(switch_statement) = (* 6 *) SWITCH LP LITERAL RP LC RC
minimal(switch_labels) = (* 2 *) DEFAULT COLON
minimal(switch_label) = (* 2 *) DEFAULT COLON
minimal(switch_block_statement_groups) = (* 3 *) DEFAULT COLON SM
minimal(switch_block_statement_group) = (* 3 *) DEFAULT COLON SM
minimal(switch_block) = (* 2 *) LC RC
minimal(super_opt) = (* 0 *) 
minimal(super) = (* 2 *) EXTENDS PRIMITIVE_TYPE
minimal(static_opt) = (* 0 *) 
minimal(static_initializer) = (* 3 *) STATIC LC RC
minimal(statement_without_trailing_substatement) = (* 1 *) SM
minimal(statement_no_short_if) = (* 1 *) SM
minimal(statement_expression_list) = (* 2 *) INCR LITERAL
minimal(statement_expression) = (* 2 *) INCR LITERAL
minimal(statement) = (* 1 *) SM
minimal(shift_expression) = (* 1 *) LITERAL
minimal(return_statement) = (* 2 *) RETURN SM
minimal(relational_expression) = (* 1 *) LITERAL
minimal(reference_type) = (* 1 *) IDENTIFIER
minimal(ref_type_list) = (* 1 *) IDENTIFIER
minimal(ref_type_and_list) = (* 1 *) IDENTIFIER
minimal(qualified_ident_list) = (* 1 *) IDENTIFIER
minimal(primitive_type) = (* 1 *) PRIMITIVE_TYPE
minimal(primary_no_new_array) = (* 1 *) LITERAL
minimal(primary) = (* 1 *) LITERAL
minimal(pre_increment_expression) = (* 2 *) INCR LITERAL
minimal(pre_decrement_expression) = (* 2 *) DECR LITERAL
minimal(postfix_expression) = (* 1 *) LITERAL
minimal(post_increment_expression) = (* 2 *) LITERAL INCR
minimal(post_decrement_expression) = (* 2 *) LITERAL DECR
minimal(package_declaration_opt) = (* 0 *) 
minimal(package_declaration) = (* 3 *) PACKAGE IDENTIFIER SM
minimal(name) = (* 1 *) IDENTIFIER
minimal(multiplicative_expression) = (* 1 *) LITERAL
minimal(modifiers_opt) = (* 0 *) 
minimal(modifiers) = (* 1 *) PUBLIC
minimal(modifier) = (* 1 *) PUBLIC
minimal(method_invocation) = (* 3 *) IDENTIFIER LP RP
minimal(method_header) = (* 4 *) PRIMITIVE_TYPE IDENTIFIER LP RP
minimal(method_declarator_rest) = (* 3 *) LP RP SM
minimal(method_declarator) = (* 3 *) IDENTIFIER LP RP
minimal(method_declarations_opt) = (* 0 *) 
minimal(method_declarations) = (* 5 *) PRIMITIVE_TYPE IDENTIFIER LP RP SM
minimal(method_declaration) = (* 5 *) PRIMITIVE_TYPE IDENTIFIER LP RP SM
minimal(method_body) = (* 1 *) SM
minimal(local_variable_declaration_statement) = (* 3 *) PRIMITIVE_TYPE IDENTIFIER SM
minimal(local_variable_declaration) = (* 2 *) PRIMITIVE_TYPE IDENTIFIER
minimal(literal) = (* 1 *) LITERAL
minimal(left_hand_side) = (* 1 *) IDENTIFIER
minimal(labeled_statement_no_short_if) = (* 3 *) IDENTIFIER COLON SM
minimal(labeled_statement) = (* 3 *) IDENTIFIER COLON SM
minimal(interfaces_opt) = (* 0 *) 
minimal(interfaces) = (* 2 *) IMPLEMENTS IDENTIFIER
minimal(interface_method_declator_rest) = (* 3 *) LP RP SM
minimal(interface_member_declarations_opt) = (* 0 *) 
minimal(interface_member_declarations) = (* 1 *) SM
minimal(interface_member_declaration) = (* 1 *) SM
minimal(interface_generic_method_decl) = (* 8 *) LT IDENTIFIER GT PRIMITIVE_TYPE IDENTIFIER LP RP SM
minimal(interface_declaration) = (* 4 *) INTERFACE IDENTIFIER LC RC
minimal(interface_body) = (* 2 *) LC RC
minimal(instance_initializer) = (* 2 *) LC RC
minimal(inclusive_or_expression) = (* 1 *) LITERAL
minimal(import_declarations_opt) = (* 0 *) 
minimal(import_declarations) = (* 3 *) IMPORT IDENTIFIER SM
minimal(import_declaration) = (* 3 *) IMPORT IDENTIFIER SM
minimal(if_then_statement) = (* 5 *) IF LP LITERAL RP SM
minimal(if_then_else_statement_no_short_if) = (* 7 *) IF LP LITERAL RP SM ELSE SM
minimal(if_then_else_statement) = (* 7 *) IF LP LITERAL RP SM ELSE SM
minimal(identifier_opt) = (* 0 *) 
minimal(identifier_) = (* 1 *) IDENTIFIER
minimal(identifier) = (* 1 *) IDENTIFIER
minimal(goal) = (* 1 *) EOF
minimal(generic_method_or_constructor_rest) = (* 5 *) PRIMITIVE_TYPE IDENTIFIER LP RP SM
minimal(generic_method_or_constructor_decl) = (* 8 *) LT IDENTIFIER GT PRIMITIVE_TYPE IDENTIFIER LP RP SM
minimal(formal_parameters) = (* 2 *) LP RP
minimal(formal_parameter_list_opt) = (* 0 *) 
minimal(formal_parameter_list) = (* 2 *) PRIMITIVE_TYPE IDENTIFIER
minimal(formal_parameter) = (* 2 *) PRIMITIVE_TYPE IDENTIFIER
minimal(for_var_control_rest) = (* 2 *) COLON LITERAL
minimal(for_var_control) = (* 4 *) PRIMITIVE_TYPE IDENTIFIER COLON LITERAL
minimal(for_update_opt) = (* 0 *) 
minimal(for_update) = (* 2 *) INCR LITERAL
minimal(for_statement_no_short_if) = (* 6 *) FOR LP SM SM RP SM
minimal(for_statement) = (* 6 *) FOR LP SM SM RP SM
minimal(for_init_opt) = (* 0 *) 
minimal(for_init) = (* 2 *) INCR LITERAL
minimal(for_control) = (* 2 *) SM SM
minimal(finally) = (* 3 *) FINALLY LC RC
minimal(field_declaration) = (* 3 *) PRIMITIVE_TYPE IDENTIFIER SM
minimal(field_access) = (* 3 *) SUPER DOT IDENTIFIER
minimal(extends_interfaces_opt) = (* 0 *) 
minimal(extends_interfaces) = (* 2 *) EXTENDS IDENTIFIER
minimal(expression_statement) = (* 3 *) INCR LITERAL SM
minimal(expression_opt) = (* 0 *) 
minimal(expression) = (* 1 *) LITERAL
minimal(expr1) = (* 1 *) LITERAL
minimal(explicit_constructor_invocation) = (* 4 *) THIS LP RP SM
minimal(exclusive_or_expression) = (* 1 *) LITERAL
minimal(equality_expression) = (* 1 *) LITERAL
minimal(enum_declaration) = (* 4 *) ENUM IDENTIFIER LC RC
minimal(enum_constants) = (* 1 *) IDENTIFIER
minimal(enum_constant) = (* 1 *) IDENTIFIER
minimal(enum_body_declarations_opt) = (* 0 *) 
minimal(enum_body_declarations) = (* 1 *) SM
minimal(enum_body) = (* 2 *) LC RC
minimal(empty_statement) = (* 1 *) SM
minimal(element_values) = (* 1 *) LITERAL
minimal(element_value_pairs) = (* 3 *) IDENTIFIER EQ LITERAL
minimal(element_value_pair) = (* 3 *) IDENTIFIER EQ LITERAL
minimal(element_value_array_initializer) = (* 2 *) LC RC
minimal(element_value) = (* 1 *) LITERAL
minimal(do_statement) = (* 7 *) DO SM WHILE LP LITERAL RP SM
minimal(dims_opt) = (* 0 *) 
minimal(dims) = (* 1 *) LB_RB
minimal(dim_exprs) = (* 3 *) LB LITERAL RB
minimal(dim_expr) = (* 3 *) LB LITERAL RB
minimal(continue_statement) = (* 2 *) CONTINUE SM
minimal(constructor_declarator) = (* 3 *) IDENTIFIER LP RP
minimal(constructor_declaration) = (* 5 *) IDENTIFIER LP RP LC RC
minimal(constructor_body) = (* 2 *) LC RC
minimal(constant_expression) = (* 1 *) LITERAL
minimal(constant_declaration) = (* 3 *) PRIMITIVE_TYPE IDENTIFIER SM
minimal(conditional_or_expression) = (* 1 *) LITERAL
minimal(conditional_expression) = (* 1 *) LITERAL
minimal(conditional_and_expression) = (* 1 *) LITERAL
minimal(compilation_unit) = (* 0 *) 
minimal(comma_opt) = (* 0 *) 
minimal(class_or_interface_type) = (* 1 *) IDENTIFIER
minimal(class_member_declaration) = (* 1 *) SM
minimal(class_literal) = (* 3 *) PRIMITIVE_TYPE DOT CLASS
minimal(class_instance_creation_expression) = (* 4 *) NEW IDENTIFIER LP RP
minimal(class_declaration) = (* 4 *) CLASS IDENTIFIER LC RC
minimal(class_body_opt) = (* 0 *) 
minimal(class_body_declarations_opt) = (* 0 *) 
minimal(class_body_declarations) = (* 1 *) SM
minimal(class_body_declaration) = (* 1 *) SM
minimal(class_body) = (* 2 *) LC RC
minimal(catches_opt) = (* 0 *) 
minimal(catches) = (* 6 *) CATCH LP PRIMITIVE_TYPE IDENTIFIER RP SM
minimal(catch_clause) = (* 6 *) CATCH LP PRIMITIVE_TYPE IDENTIFIER RP SM
minimal(cast_expression) = (* 4 *) LP PRIMITIVE_TYPE RP LITERAL
minimal(break_statement) = (* 2 *) BREAK SM
minimal(bound) = (* 1 *) IDENTIFIER
minimal(block_statements_opt) = (* 0 *) 
minimal(block_statements) = (* 1 *) SM
minimal(block_statement) = (* 1 *) SM
minimal(block) = (* 2 *) LC RC
minimal(assignment_operator) = (* 1 *) EQ
minimal(assignment_expression) = (* 1 *) LITERAL
minimal(assignment) = (* 3 *) IDENTIFIER EQ LITERAL
minimal(array_type) = (* 2 *) PRIMITIVE_TYPE LB_RB
minimal(array_initializer) = (* 2 *) LC RC
minimal(array_creation_expression) = (* 5 *) NEW PRIMITIVE_TYPE LB_RB LC RC
minimal(array_access) = (* 4 *) IDENTIFIER LB LITERAL RB
minimal(argument_list_opt) = (* 0 *) 
minimal(argument_list) = (* 1 *) LITERAL
minimal(annotation_type_element_rest) = (* 4 *) CLASS IDENTIFIER LC RC
minimal(annotation_type_element_declarations_opt) = (* 0 *) 
minimal(annotation_type_element_declarations) = (* 4 *) CLASS IDENTIFIER LC RC
minimal(annotation_type_element_declaration) = (* 4 *) CLASS IDENTIFIER LC RC
minimal(annotation_type_declaration) = (* 5 *) AT INTERFACE IDENTIFIER LC RC
minimal(annotation_type_body) = (* 2 *) LC RC
minimal(annotation_method_or_constant_rest) = (* 2 *) LP RP
minimal(annotation_element) = (* 0 *) 
minimal(annotation) = (* 2 *) AT IDENTIFIER
minimal(and_expression) = (* 1 *) LITERAL
minimal(additive_expression) = (* 1 *) LITERAL
minimal(abstract_method_declaration) = (* 5 *) PRIMITIVE_TYPE IDENTIFIER LP RP SM
follow(while_statement_no_short_if) = ELSE
follow(while_statement) = WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(variable_modifiers_opt) = PRIMITIVE_TYPE IDENTIFIER
follow(variable_modifiers) = PRIMITIVE_TYPE IDENTIFIER FINAL AT
follow(variable_modifier) = PRIMITIVE_TYPE IDENTIFIER FINAL AT
follow(variable_initializers) = RC CM
follow(variable_initializer) = SM RC CM
follow(variable_declarators) = SM CM
follow(variable_declarator_id_bis) = RP CM
follow(variable_declarator_id) = SM RP LB_RB EQ COLON CM
follow(variable_declarator) = SM CM
follow(unary_expression_not_plus_minus) = XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND
follow(unary_expression) = XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND
follow(type_parameters_opt) = LC IMPLEMENTS EXTENDS
follow(type_parameters_bis) = GT CM
follow(type_parameters) = VOID PRIMITIVE_TYPE LC IMPLEMENTS IDENTIFIER EXTENDS
follow(type_parameter) = GT CM
follow(type_java) = LC IMPLEMENTS IDENTIFIER DOTS
follow(type_declarations_opt) = EOF
follow(type_declarations) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM CLASS AT ABSTRACT
follow(type_declaration) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM CLASS AT ABSTRACT
follow(type_arguments) = GT CM
follow(type_argument) = GT CM
follow(try_statement) = WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(throws_opt) = SM LC
follow(throws) = SM LC
follow(throw_statement) = WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(synchronized_statement) = WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(switch_statement) = WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(switch_labels) = WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(switch_label) = WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(switch_block_statement_groups) = RC DEFAULT CASE
follow(switch_block_statement_group) = RC DEFAULT CASE
follow(switch_block) = WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(super_opt) = LC IMPLEMENTS
follow(super) = LC IMPLEMENTS
follow(static_opt) = IDENTIFIER
follow(static_initializer) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
follow(statement_without_trailing_substatement) = WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(statement_no_short_if) = ELSE
follow(statement_expression_list) = SM RP CM
follow(statement_expression) = SM RP CM
follow(statement) = WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(shift_expression) = XOR URS SRS SM RP RC RB OR_OR OR NOT_EQ LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND
follow(return_statement) = WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(relational_expression) = XOR SM RP RC RB OR_OR OR NOT_EQ LT LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND
follow(reference_type) = XOR SM RP RC RB OR_OR OR NOT_EQ LT LE LC INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND
follow(ref_type_list) = LC CM
follow(ref_type_and_list) = GT CM AND
follow(qualified_ident_list) = SM LC CM
follow(primitive_type) = RP LC LB_RB LB IMPLEMENTS IDENTIFIER DOTS DOT
follow(primary_no_new_array) = XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
follow(primary) = XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
follow(pre_increment_expression) = XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND
follow(pre_decrement_expression) = XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND
follow(postfix_expression) = XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DIV DECR COND COLON CM AND_AND AND
follow(post_increment_expression) = XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DIV DECR COND COLON CM AND_AND AND
follow(post_decrement_expression) = XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DIV DECR COND COLON CM AND_AND AND
follow(package_declaration_opt) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM CLASS AT ABSTRACT
follow(package_declaration) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM CLASS AT ABSTRACT
follow(name) = XOR VOLATILE VOID URS TRANSIENT TIMES SYNCHRONIZED STRICTFP STATIC SRS SM RP RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PLUS OR_OR OR OPERATOR_EQ NOT_EQ NATIVE MOD MINUS LT LS LP LE LC LB_RB LB INTERFACE INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE FINAL EQ_EQ EQ ENUM DOTS DOT DIV DECR COND COLON CM CLASS AT AND_AND AND ABSTRACT
follow(multiplicative_expression) = XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND
follow(modifiers_opt) = VOID PRIMITIVE_TYPE LT INTERFACE IDENTIFIER ENUM CLASS
follow(modifiers) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
follow(modifier) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
follow(method_invocation) = XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
follow(method_header) = SM LC
follow(method_declarator_rest) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
follow(method_declarator) = THROWS SM LC LB_RB
follow(method_declarations_opt) = RC
follow(method_declarations) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE IDENTIFIER FINAL AT ABSTRACT
follow(method_declaration) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
follow(method_body) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
follow(local_variable_declaration_statement) = WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(local_variable_declaration) = SM
follow(literal) = XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
follow(left_hand_side) = OPERATOR_EQ EQ
follow(labeled_statement_no_short_if) = ELSE
follow(labeled_statement) = WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(interfaces_opt) = LC
follow(interfaces) = LC
follow(interface_method_declator_rest) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
follow(interface_member_declarations_opt) = RC
follow(interface_member_declarations) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
follow(interface_member_declaration) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
follow(interface_generic_method_decl) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
follow(interface_declaration) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT
follow(interface_body) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT
follow(instance_initializer) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
follow(inclusive_or_expression) = SM RP RC RB OR_OR OR COND COLON CM AND_AND
follow(import_declarations_opt) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE FINAL EOF ENUM CLASS AT ABSTRACT
follow(import_declarations) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM CLASS AT ABSTRACT
follow(import_declaration) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC SM PUBLIC PROTECTED PRIVATE NATIVE INTERFACE IMPORT FINAL EOF ENUM CLASS AT ABSTRACT
follow(if_then_statement) = WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(if_then_else_statement_no_short_if) = ELSE
follow(if_then_else_statement) = WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(identifier_opt) = SM
follow(identifier_) = XOR VOLATILE VOID URS TRANSIENT TIMES SYNCHRONIZED STRICTFP STATIC SRS SM RP RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PLUS OR_OR OR OPERATOR_EQ NOT_EQ NATIVE MOD MINUS LT LS LP LE LC LB_RB LB INTERFACE INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE FINAL EQ_EQ EQ ENUM DOTS DOT DIV DECR COND COLON CM CLASS AT AND_AND AND ABSTRACT
follow(identifier) = XOR VOLATILE VOID URS TRANSIENT TIMES SYNCHRONIZED STRICTFP STATIC SRS SM RP RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PLUS OR_OR OR OPERATOR_EQ NOT_EQ NATIVE MOD MINUS LT2 LT LS LP LE LC LB_RB LB INTERFACE INSTANCEOF INCR IMPLEMENTS IDENTIFIER GT GE FINAL EXTENDS EQ_EQ EQ ENUM DOTS DOT DIV DECR COND COLON CM CLASS AT AND_AND AND ABSTRACT
follow(goal) = #
follow(generic_method_or_constructor_rest) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
follow(generic_method_or_constructor_decl) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
follow(formal_parameters) = THROWS SM LC
follow(formal_parameter_list_opt) = RP
follow(formal_parameter_list) = RP CM
follow(formal_parameter) = RP CM
follow(for_var_control_rest) = RP
follow(for_var_control) = RP
follow(for_update_opt) = RP
follow(for_update) = RP
follow(for_statement_no_short_if) = ELSE
follow(for_statement) = WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(for_init_opt) = SM
follow(for_init) = SM
follow(for_control) = RP
follow(finally) = WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(field_declaration) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
follow(field_access) = XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ DOT DIV DECR COND COLON CM AND_AND AND
follow(extends_interfaces_opt) = LC
follow(extends_interfaces) = LC CM
follow(expression_statement) = WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(expression_opt) = SM
follow(expression) = SM RP RC RB COLON CM
follow(expr1) = SM RP RC CM
follow(explicit_constructor_invocation) = WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DECR CONTINUE CLASS BREAK AT ASSERT ABSTRACT
follow(exclusive_or_expression) = XOR SM RP RC RB OR_OR OR COND COLON CM AND_AND
follow(equality_expression) = XOR SM RP RC RB OR_OR OR NOT_EQ EQ_EQ COND COLON CM AND_AND AND
follow(enum_declaration) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT
follow(enum_constants) = SM RC CM
follow(enum_constant) = SM RC CM
follow(enum_body_declarations_opt) = RC
follow(enum_body_declarations) = RC
follow(enum_body) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT
follow(empty_statement) = WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINALLY FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT
follow(element_values) = RC CM
follow(element_value_pairs) = RP CM
follow(element_value_pair) = RP CM
follow(element_value_array_initializer) = SM RP RC CM
follow(element_value) = SM RP RC CM
follow(do_statement) = WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(dims_opt) = XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
follow(dims) = XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LC LB_RB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
follow(dim_exprs) = XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB_RB LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
follow(dim_expr) = XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB_RB LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
follow(continue_statement) = WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(constructor_declarator) = THROWS LC
follow(constructor_declaration) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
follow(constructor_body) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
follow(constant_expression) = COLON
follow(constant_declaration) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
follow(conditional_or_expression) = SM RP RC RB OR_OR COND COLON CM
follow(conditional_expression) = SM RP RC RB COLON CM
follow(conditional_and_expression) = SM RP RC RB OR_OR COND COLON CM AND_AND
follow(compilation_unit) = EOF
follow(comma_opt) = RC
follow(class_or_interface_type) = XOR SM RP RC RB OR_OR OR NOT_EQ LT LE LC LB_RB INSTANCEOF IMPLEMENTS IDENTIFIER GT GE EQ_EQ DOTS COND COLON CM AND_AND AND
follow(class_member_declaration) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
follow(class_literal) = XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
follow(class_instance_creation_expression) = XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
follow(class_declaration) = WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LT LP LITERAL LC INTERFACE INCR IF IDENTIFIER FOR FINAL EOF ENUM DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(class_body_opt) = XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
follow(class_body_declarations_opt) = RC
follow(class_body_declarations) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
follow(class_body_declaration) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
follow(class_body) = XOR WHILE VOLATILE VOID URS TString TRY TRANSIENT TInt TIMES THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SRS SM RP RETURN RC RB PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE PLUS OR_OR OR NOT_EQ NEW NATIVE MOD MINUS LT LS LP LITERAL LE LC LB INTERFACE INSTANCEOF INCR IF IDENTIFIER GT GE FOR FINAL EQ_EQ EOF ENUM DOT DO DIV DEFAULT DECR CONTINUE COND COLON CM CLASS CASE BREAK AT ASSERT AND_AND AND ABSTRACT
follow(catches_opt) = FINALLY
follow(catches) = WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINALLY FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT
follow(catch_clause) = WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINALLY FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT
follow(cast_expression) = XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF GT GE EQ_EQ DIV COND COLON CM AND_AND AND
follow(break_statement) = WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL ELSE DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(bound) = GT CM
follow(block_statements_opt) = RC
follow(block_statements) = WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(block_statement) = WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LP LITERAL LC INCR IF IDENTIFIER FOR FINAL DO DEFAULT DECR CONTINUE CLASS CASE BREAK AT ASSERT ABSTRACT
follow(block) = WHILE VOLATILE VOID TString TRY TRANSIENT TInt THROW THIS TFloat TChar SYNCHRONIZED SWITCH SUPER STRICTFP STATIC SM RETURN RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NEW NATIVE LT LP LITERAL LC INTERFACE INCR IF IDENTIFIER FOR FINALLY FINAL ENUM ELSE DO DEFAULT DECR CONTINUE CLASS CATCH CASE BREAK AT ASSERT ABSTRACT
follow(assignment_operator) = VOID TString TInt THIS TFloat TChar SUPER PRIMITIVE_TYPE PLUS NOT NEW MINUS LP LITERAL INCR IDENTIFIER DECR COMPL
follow(assignment_expression) = SM RP RC RB COLON CM
follow(assignment) = SM RP RC RB COLON CM
follow(array_type) = XOR SM RP RC RB OR_OR OR NOT_EQ LT LE LC LB_RB INSTANCEOF IMPLEMENTS IDENTIFIER GT GE EQ_EQ DOTS DOT COND COLON CM AND_AND AND
follow(array_initializer) = XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
follow(array_creation_expression) = XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MOD MINUS LT LS LE INSTANCEOF INCR GT GE EQ_EQ DOT DIV DECR COND COLON CM AND_AND AND
follow(array_access) = XOR URS TIMES SRS SM RP RC RB PLUS OR_OR OR OPERATOR_EQ NOT_EQ MOD MINUS LT LS LE LB INSTANCEOF INCR GT GE EQ_EQ EQ DOT DIV DECR COND COLON CM AND_AND AND
follow(argument_list_opt) = RP
follow(argument_list) = RP CM
follow(annotation_type_element_rest) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
follow(annotation_type_element_declarations_opt) = RC
follow(annotation_type_element_declarations) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
follow(annotation_type_element_declaration) = VOLATILE TRANSIENT SYNCHRONIZED STRICTFP STATIC RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
follow(annotation_type_declaration) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT
follow(annotation_type_body) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT LC INTERFACE IDENTIFIER FINAL EOF ENUM CLASS AT ABSTRACT
follow(annotation_method_or_constant_rest) = SM
follow(annotation_element) = RP
follow(annotation) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RP RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CM CLASS AT ABSTRACT
follow(and_expression) = XOR SM RP RC RB OR_OR OR COND COLON CM AND_AND AND
follow(additive_expression) = XOR URS SRS SM RP RC RB PLUS OR_OR OR NOT_EQ MINUS LT LS LE INSTANCEOF GT GE EQ_EQ COND COLON CM AND_AND AND
follow(abstract_method_declaration) = VOLATILE VOID TRANSIENT SYNCHRONIZED STRICTFP STATIC SM RC PUBLIC PROTECTED PRIVATE PRIMITIVE_TYPE NATIVE LT INTERFACE IDENTIFIER FINAL ENUM CLASS AT ABSTRACT
Built an LR(0) automaton with 757 states.
The grammar is not SLR(1) -- 22 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 757 states.
322 out of 757 states have a default reduction.
244 out of 757 states are represented.
0 out of 301 symbols keep track of their start position.
0 out of 301 symbols keep track of their end position.
275 out of 435 productions exploit shiftreduce optimization.
0 out of 757 states can peek at an error.
2151 functions before inlining, 302 functions after inlining.
