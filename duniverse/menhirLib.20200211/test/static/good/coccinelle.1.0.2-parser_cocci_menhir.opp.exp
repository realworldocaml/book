%{

(* Not clear how to allow function declarations to specify a return type
and how to allow both to be specified as static, because they are in
different rules.  The rules seem to have to be combined, which would allow
functions to be declared as local variables *)

(* Not clear how to let a function have a parameter of type void.  At the
moment, void is allowed to be the type of a variable, which is wrong, and a
parameter needs both a type and an identifier *)
module Ast0 = Ast0_cocci
module Ast = Ast_cocci
module P = Parse_aux

(* ---------------------------------------------------------------------- *)
(* support for argument lists *)

type 'a argorellipsis =
  | Nothing
  | Arg of 'a
  | Ellipsis of Data.clt
  | VAEllipsis of Data.clt
  | Separator of Data.clt

let string_of_arg = function
  | Nothing -> "Nothing"
  | Arg _ -> "Arg"
  | Ellipsis _ -> "Ellipsis"
  | VAEllipsis _ -> "VAEllipsis"
  | Separator _ -> "Comma"

let is_nothing = function
  | Nothing -> true
  | _ -> false

let is_separator = function
  | Separator _ -> true
  | _ -> false

let is_vaellipsis = function
  | VAEllipsis _ -> true
  | _ -> false

let rec adjacent_ellipsis = function
  | [] -> false
  | [_] -> false
  | (Ellipsis _) :: (Ellipsis _) :: _ -> true
  | x::xs -> adjacent_ellipsis xs

let build_arg = function
  | Arg arg -> arg
  | Ellipsis e -> Ast0.wrap (Ast0.Pdots(P.clt2mcode "..." e))
  | Separator comma -> Ast0.wrap (Ast0.PComma (P.clt2mcode "," comma))
  | VAEllipsis _ -> assert false
  | Nothing -> assert false

let string_of_arglist l =
  "[" ^ (String.concat ";" (List.map string_of_arg l)) ^ "]"

let cleanup_arglist l =
  if l=[] then ([], None)
  else begin
    let (args, vararg) = match l with
      | (VAEllipsis vaellipsis)::(Separator comma)::rem ->
        let c = P.clt2mcode "," comma in
        let e = P.clt2mcode "......" vaellipsis in
        (rem, Some (c, e))
      | _ -> (l, None) in
    let just_args = List.filter (fun x -> not (is_separator x)) args in
    if List.exists is_vaellipsis just_args then failwith "...... can occur only as last argument"
    else if adjacent_ellipsis just_args then failwith "Argument list contains adjacent ellipsis"
    else
      let pure_args = List.filter (fun x -> not (is_nothing x)) args in
      (List.map build_arg (List.rev pure_args), vararg)
  end

(* ---------------------------------------------------------------------- *)
(* support for TMeta *)

let print_meta (r,n) = r^"."^n

let meta_metatable = Hashtbl.create(101)

let coerce_tmeta newty name builder matcher =
  try
    let x = Hashtbl.find meta_metatable name in
    if not (matcher x)
    then
      failwith
	(Printf.sprintf "Metavariable %s is used as %s"
	   (print_meta name) newty)
  with Not_found ->
    (if !Flag_parsing_cocci.show_SP
    then
      Common.pr2
	(Printf.sprintf
	   "Metavariable %s is assumed to be %s metavariable"
	   (print_meta name) newty));
    Hashtbl.add meta_metatable name builder

let tmeta_to_type (name,pure,clt) =
  (coerce_tmeta "a type" name (TMetaType(name,pure,clt))
     (function TMetaType(_,_,_) -> true | _ -> false));
  Ast0.wrap(Ast0.MetaType(P.clt2mcode name clt,pure))

let tmeta_to_field (name,pure,clt) =
  (coerce_tmeta "a field" name (TMetaField(name,pure,clt))
     (function TMetaField(_,_,_) -> true | _ -> false));
  P.meta_field (name,pure,clt)

let tmeta_to_exp (name,pure,clt) =
  (coerce_tmeta "an expression" name
     (TMetaExp(name,Ast0.NoConstraint,pure,None,clt))
     (function TMetaExp(_,_,_,_,_) -> true | _ -> false));
  Ast0.wrap
    (Ast0.MetaExpr(P.clt2mcode name clt,Ast0.NoConstraint,None,Ast.ANY,pure))

let tmeta_to_param (name,pure,clt) =
  (coerce_tmeta "a parameter" name (TMetaParam(name,pure,clt))
     (function TMetaParam(_,_,_) -> true | _ -> false));
  Ast0.wrap(Ast0.MetaParam(P.clt2mcode name clt,pure))

let tmeta_to_assignOp (name,pure,clt) =
  (coerce_tmeta "an assignment operator" name
     (TMetaAssignOp(name,Ast0.AssignOpNoConstraint,pure,clt))
     (function TMetaAssignOp(_,_,_,_) -> true | _ -> false));
  Ast0.wrap
    (Ast0.MetaAssign(P.clt2mcode name clt,Ast0.AssignOpNoConstraint, pure))

let tmeta_to_binaryOp (name,pure,clt) =
  (coerce_tmeta "a binary operator" name
     (TMetaBinaryOp(name,Ast0.BinaryOpNoConstraint,pure,clt))
     (function TMetaBinaryOp(_,_,_,_) -> true | _ -> false));
  Ast0.wrap
    (Ast0.MetaBinary(P.clt2mcode name clt,Ast0.BinaryOpNoConstraint, pure),clt)

let tmeta_to_statement (name,pure,clt) =
  (coerce_tmeta "a statement" name (TMetaType(name,pure,clt))
     (function TMetaType(_,_,_) -> true | _ -> false));
  P.meta_stm (name,pure,clt)

let tmeta_to_seed_id (name,pure,clt) =
  (coerce_tmeta "an identifier" name
     (TMetaId(name,Ast.IdNoConstraint,Ast.NoVal,pure,clt))
     (function TMetaId(_,_,_,_,_) -> true | _ -> false));
  Ast.SeedId name

let tmeta_to_ident (name,pure,clt) =
  (coerce_tmeta "an identifier" name
     (TMetaId(name,Ast.IdNoConstraint,Ast.NoVal,pure,clt))
     (function TMetaId(_,_,_,_,_) -> true | _ -> false));
  Ast0.wrap(Ast0.MetaId(P.clt2mcode name clt,Ast.IdNoConstraint,Ast.NoVal,pure))

and  arithOp = function
    Ast.Plus -> "+"
  | Ast.Minus -> "-"
  | Ast.Mul -> "*"
  | Ast.Div -> "/"
  | Ast.Min -> "<?"
  | Ast.Max -> ">?"
  | Ast.Mod -> "%"
  | Ast.DecLeft -> "<<"
  | Ast.DecRight -> ">>"
  | Ast.And -> "&"
  | Ast.Or -> "|"
  | Ast.Xor -> "^"

and  logicalOp = function
    Ast.Inf -> "<"
  | Ast.Sup -> ">"
  | Ast.InfEq -> "<="
  | Ast.SupEq -> ">="
  | Ast.Eq -> "=="
  | Ast.NotEq -> "!="
  | Ast.AndLog -> "&&"
  | Ast.OrLog -> "||"

let mkarithop (op, clt) =
  let op' = P.clt2mcode op clt in
  Ast0.wrap (Ast0.Arith op')

let mklogop (op,clt) =
  let op' = P.clt2mcode op clt in
  Ast0.wrap (Ast0.Logical op')

%}
%start include_main
%start iso_main
%start iso_meta_main
%start iso_rule_name
%start meta_main
%start minus_exp_main
%start minus_id_main
%start minus_main
%start minus_ty_main
%start never_used
%start plus_exp_main
%start plus_id_main
%start plus_main
%start plus_ty_main
%start rule_name
%start script_meta_main
%start script_meta_virt_nofresh_main
%token EOF
%token TAnalysis
%token <Data.clt> TAnd
%token <Data.clt> TAndLog
%token <Data.clt> TAny
%token TArob
%token TArobArob
%token TAssignment
%token TAttribute
%token <Data.clt> TBang
%token TBang0
%token TBinary
%token <Data.clt> TBreak
%token <Data.clt> TCBrace
%token <Data.clt> TCCro
%token <Data.clt> TCEllipsis
%token <Data.clt> TCPar
%token <string * Data.clt> TCPar0
%token <Data.clt> TCase
%token <string * Data.clt> TChar
%token <Data.clt> TComma
%token TConstant
%token TContext
%token <Data.clt> TContinue
%token TCppConcatOp
%token <Data.clt> TDec
%token <string * string (*n*) * string (*p*) * Data.clt> TDecimalCst
%token TDeclaration
%token TDeclarer
%token <string * Data.clt> TDeclarerId
%token <Data.clt> TDefault
%token <Data.clt * token> TDefine
%token <Data.clt * token * int * int> TDefineParam
%token TDepends
%token <Ast_cocci.added_string * Data.clt> TDirective
%token TDisable
%token <Ast_cocci.arithOp * Data.clt> TDmOp
%token <Data.clt> TDo
%token <Data.clt> TDot
%token <Data.clt> TDotDot
%token <Data.clt> TEllipsis
%token <Data.clt> TElse
%token <Data.clt> TEq
%token <Data.clt> TEqEq
%token TError
%token TEver
%token TExists
%token TExpression
%token TExtends
%token TField
%token TFinalize
%token <string * Data.clt> TFloat
%token <Data.clt> TFor
%token TForall
%token TFormat
%token TFresh
%token <Data.clt> TFunDecl
%token TFunction
%token TGenerated
%token TGlobal
%token <Data.clt> TGoto
%token TIdExpression
%token <string * Data.clt> TIdent
%token TIdentifier
%token <Data.clt> TIf
%token <Data.clt> TInc
%token <string * Data.clt> TIncludeL
%token <string * Data.clt> TIncludeNL
%token TInitialiser
%token TInitialize
%token <string * Data.clt> TInt
%token TInvalid
%token TIso
%token TIsoArgExpression
%token TIsoDeclaration
%token TIsoExpression
%token TIsoStatement
%token TIsoTestExpression
%token TIsoToTestExpression
%token TIsoTopLevel
%token TIsoType
%token TIterator
%token <string * Data.clt> TIteratorId
%token <Data.clt> TLineEnd
%token TLocal
%token <Ast_cocci.logicalOp * Data.clt> TLogOp
%token TMPtVirg
%token <Parse_aux.info> TMeta
%token <Parse_aux.assignOpinfo> TMetaAssignOp
%token <Parse_aux.binaryOpinfo> TMetaBinaryOp
%token <Parse_aux.typed_expinfo> TMetaConst
%token <Parse_aux.info> TMetaDecl
%token <Parse_aux.idinfo> TMetaDeclarer
%token <Parse_aux.expinfo> TMetaErr
%token <Parse_aux.typed_expinfo> TMetaExp
%token <Parse_aux.list_info> TMetaExpList
%token <Parse_aux.info> TMetaField
%token <Parse_aux.list_info> TMetaFieldList
%token <Parse_aux.idinfo> TMetaFunc
%token <Parse_aux.typed_expinfo> TMetaGlobalIdExp
%token <Parse_aux.midinfo> TMetaId
%token <Parse_aux.typed_expinfo> TMetaIdExp
%token <Parse_aux.info> TMetaInit
%token <Parse_aux.list_info> TMetaInitList
%token <Parse_aux.idinfo> TMetaIterator
%token <Parse_aux.idinfo> TMetaLocalFunc
%token <Parse_aux.typed_expinfo> TMetaLocalIdExp
%token <Parse_aux.info> TMetaParam
%token <Parse_aux.list_info> TMetaParamList
%token <Parse_aux.pos_info> TMetaPos
%token <Parse_aux.info> TMetaStm
%token <Parse_aux.info> TMetaStmList
%token <Parse_aux.info> TMetaType
%token TMetavariable
%token <string * Data.clt> TMid0
%token <Data.clt> TMinus
%token <string * Data.clt> TMinusFile
%token <Data.clt> TMul
%token TName
%token TNever
%token <Data.clt> TNotEq
%token TNothing
%token <Data.clt> TOBrace
%token <Data.clt> TOCro
%token <Data.clt> TOEllipsis
%token <Data.clt> TOInit
%token <Data.clt> TOPar
%token <string * Data.clt> TOPar0
%token TOn
%token <Ast_cocci.arithOp * Data.clt> TOpAssign
%token TOperator
%token <Data.clt> TOr
%token <Data.clt> TOrLog
%token <Data.clt> TPArob
%token <Data.clt> TPCEllipsis
%token <Data.clt> TPOEllipsis
%token TParameter
%token <string> TPathIsoFile
%token <Data.clt> TPlus
%token TPlus0
%token <string * Data.clt> TPlusFile
%token TPosAny
%token TPosition
%token <Data.clt> TPragma
%token <Data.clt> TPtVirg
%token <Data.clt> TPtrOp
%token TPure
%token <Data.clt> TReturn
%token TRightIso
%token <string> TRuleName
%token TScript
%token <string> TScriptData
%token <Ast_cocci.arithOp * Data.clt> TShLOp
%token <Ast_cocci.arithOp * Data.clt> TShROp
%token <Data.clt> TSizeof
%token TStatement
%token <Data.clt> TStrict
%token <string * Data.clt> TString
%token <Data.clt> TSub
%token <Data.clt> TSwitch
%token <string * Data.clt> TSymId
%token TSymbol
%token <Data.clt> TTilde
%token <Data.clt> TTildeEq
%token <Data.clt> TTildeExclEq
%token TType
%token <string * Data.clt> TTypeId
%token TTypedef
%token <Data.clt * token> TUndef
%token TUnderscore
%token TUsing
%token <Data.clt> TVAEllipsis
%token TVirtual
%token <Data.clt> TWhen
%token <Data.clt> TWhenFalse
%token <Data.clt> TWhenTrue
%token <Data.clt> TWhile
%token <string> TWhitespace
%token <Data.clt> TWhy
%token TWhy0
%token TWords
%token <Data.clt> TXor
%token <string * Data.clt> Tattr
%token <Data.clt> Tauto
%token <Data.clt> Tchar
%token <Data.clt> Tconst
%token <Data.clt> Tdecimal
%token <Data.clt> Tdouble
%token <Data.clt> Tenum
%token <Data.clt> Texec
%token <Data.clt> Textern
%token <Data.clt> Tfloat
%token <Data.clt> Tinline
%token <Data.clt> Tint
%token Tlist
%token <Data.clt> Tlong
%token <Data.clt> Tptrdiff_t
%token <Data.clt> Tregister
%token <Data.clt> Tshort
%token <Data.clt> Tsigned
%token <Data.clt> Tsize_t
%token <Data.clt> Tssize_t
%token <Data.clt> Tstatic
%token <Data.clt> Tstruct
%token <Data.clt> Ttypedef
%token <Data.clt> Tunion
%token <Data.clt> Tunsigned
%token <Data.clt> Tvoid
%token <Data.clt> Tvolatile
%nonassoc TIf
%nonassoc TElse
%left TOrLog
%left TAndLog
%left TOr
%left TXor
%left TAnd
%left TEqEq TNotEq
%left TLogOp
%left TShLOp TShROp
%left TMetaBinaryOp TMinus TPlus
%left TDmOp TMul
%type <Data.incl_iso list> include_main
%type <Ast0_cocci.anything list list> iso_main
%type <(Ast_cocci.metavar,Ast_cocci.metavar) Common.either list> iso_meta_main
%type <Ast_cocci.rulename> iso_rule_name
%type <(Ast_cocci.metavar,Ast_cocci.metavar) Common.either list> meta_main
%type <Ast0_cocci.rule> minus_exp_main
%type <Ast0_cocci.rule> minus_id_main
%type <Ast0_cocci.rule> minus_main
%type <Ast0_cocci.rule> minus_ty_main
%type <unit> never_used
%type <Ast0_cocci.rule> plus_exp_main
%type <Ast0_cocci.rule> plus_id_main
%type <Ast0_cocci.rule> plus_main
%type <Ast0_cocci.rule> plus_ty_main
%type <Ast_cocci.rulename> rule_name
%type <(string option (*string*) * string option (*ast*)) * (Ast_cocci.meta_name * Ast_cocci.metavar) option> script_meta_main
%type <(string option (*string*) * string option (*ast*)) * (Ast_cocci.meta_name * Ast_cocci.metavar) option> script_meta_virt_nofresh_main
%%

option_TLocal_:
  
    {    ( None )}
| x = TLocal
    {    ( Some x )}

option_TPosAny_:
  
    {    ( None )}
| x = TPosAny
    {    ( Some x )}

option_eexpr_:
  
    {    ( None )}
| x = eexpr
    {    ( Some x )}

option_expr_:
  
    {    ( None )}
| x = expr
    {    ( Some x )}

option_not_ceq_or_sub_:
  
    {    ( None )}
| x = not_ceq_or_sub
    {    ( Some x )}

option_re_only_:
  
    {    ( None )}
| x = re_only
    {    ( Some x )}

option_re_or_not_eqe_or_sub_:
  
    {    ( None )}
| x = re_or_not_eqe_or_sub
    {    ( Some x )}

option_re_or_not_eqid_:
  
    {    ( None )}
| x = re_or_not_eqid
    {    ( Some x )}

loption_choose_iso_:
  
    {    ( [] )}
| x = choose_iso
    {    ( x )}

loption_disable_:
  
    {    ( [] )}
| x = disable
    {    ( x )}

loption_filespec_:
  
    {    ( [] )}
| x = filespec
    {    ( x )}

loption_minus_start_:
  
    {    ( [] )}
| x = minus_start
    {    ( x )}

loption_not_pos_:
  
    {    ( [] )}
| x = not_pos
    {    ( x )}

loption_plus_start_:
  
    {    ( [] )}
| x = plus_start
    {    ( x )}

list_TMul_:
  
    {    ( [] )}
| x = TMul xs = list_TMul_
    {    ( x :: xs )}

list_array_dec_:
  
    {    ( [] )}
| x = array_dec xs = list_array_dec_
    {    ( x :: xs )}

list_case_line_:
  
    {    ( [] )}
| x = case_line xs = list_case_line_
    {    ( x :: xs )}

list_decl_var_:
  
    {    ( [] )}
| x = decl_var xs = list_decl_var_
    {    ( x :: xs )}

list_designator_:
  
    {    ( [] )}
| x = designator xs = list_designator_
    {    ( x :: xs )}

list_incl_:
  
    {    ( [] )}
| x = incl xs = list_incl_
    {    ( x :: xs )}

list_iso_ctype__:
  
    {    ( [] )}
| x = iso_ctype_ xs = list_iso_ctype__
    {    ( x :: xs )}

list_iso_decl_var__:
  
    {    ( [] )}
| x = iso_decl_var_ xs = list_iso_decl_var__
    {    ( x :: xs )}

list_iso_eexpr__:
  
    {    ( [] )}
| x = iso_eexpr_ xs = list_iso_eexpr__
    {    ( x :: xs )}

list_iso_iso_statement__:
  
    {    ( [] )}
| x = iso_iso_statement_ xs = list_iso_iso_statement__
    {    ( x :: xs )}

list_iso_nest_start__:
  
    {    ( [] )}
| x = iso_nest_start_ xs = list_iso_nest_start__
    {    ( x :: xs )}

list_mul_:
  
    {    ( [] )}
| x = mul xs = list_mul_
    {    ( x :: xs )}

list_mzl_ctype__:
  
    {    ( [] )}
| x = mzl_ctype_ xs = list_mzl_ctype__
    {    ( x :: xs )}

list_mzl_disj_ident__:
  
    {    ( [] )}
| x = mzl_disj_ident_ xs = list_mzl_disj_ident__
    {    ( x :: xs )}

list_mzl_eexpr__:
  
    {    ( [] )}
| x = mzl_eexpr_ xs = list_mzl_eexpr__
    {    ( x :: xs )}

list_mzl_fun_after_dots_or__:
  
    {    ( [] )}
| x = mzl_fun_after_dots_or_ xs = list_mzl_fun_after_dots_or__
    {    ( x :: xs )}

list_mzl_fun_start__:
  
    {    ( [] )}
| x = mzl_fun_start_ xs = list_mzl_fun_start__
    {    ( x :: xs )}

list_mzl_mctype__:
  
    {    ( [] )}
| x = mzl_mctype_ xs = list_mzl_mctype__
    {    ( x :: xs )}

list_mzl_rule_elem_statement__:
  
    {    ( [] )}
| x = mzl_rule_elem_statement_ xs = list_mzl_rule_elem_statement__
    {    ( x :: xs )}

list_mzl_statement__:
  
    {    ( [] )}
| x = mzl_statement_ xs = list_mzl_statement__
    {    ( x :: xs )}

list_mzl_struct_decl_one__:
  
    {    ( [] )}
| x = mzl_struct_decl_one_ xs = list_mzl_struct_decl_one__
    {    ( x :: xs )}

list_pair_edots_when_TEllipsis_eexpr__dexpr__:
  
    {    ( [] )}
| x = edots_when_TEllipsis_eexpr_ y = dexpr xs = list_pair_edots_when_TEllipsis_eexpr__dexpr__
    {let x =     ( (x, y) ) in
    ( x :: xs )}

list_whenppdecs_:
  
    {    ( [] )}
| x = whenppdecs xs = list_whenppdecs_
    {    ( x :: xs )}

nonempty_list_TMul_:
  x = TMul
    {    ( [ x ] )}
| x = TMul xs = nonempty_list_TMul_
    {    ( x :: xs )}

nonempty_list_ident_:
  x = ident
    {    ( [ x ] )}
| x = ident xs = nonempty_list_ident_
    {    ( x :: xs )}

separated_nonempty_list_TComma_TString_:
  x = TString
    {    ( [ x ] )}
| x = TString _2 = TComma xs = separated_nonempty_list_TComma_TString_
    {    ( x :: xs )}

separated_nonempty_list_TComma_any_strict_:
  x = any_strict
    {    ( [ x ] )}
| x = any_strict _2 = TComma xs = separated_nonempty_list_TComma_any_strict_
    {    ( x :: xs )}

separated_nonempty_list_TComma_assignment_operator_:
  x = assignment_operator
    {    ( [ x ] )}
| x = assignment_operator _2 = TComma xs = separated_nonempty_list_TComma_assignment_operator_
    {    ( x :: xs )}

separated_nonempty_list_TComma_binary_operator_:
  x = binary_operator
    {    ( [ x ] )}
| x = binary_operator _2 = TComma xs = separated_nonempty_list_TComma_binary_operator_
    {    ( x :: xs )}

separated_nonempty_list_TComma_ctype_:
  x = ctype
    {    ( [ x ] )}
| x = ctype _2 = TComma xs = separated_nonempty_list_TComma_ctype_
    {    ( x :: xs )}

separated_nonempty_list_TComma_d_ident_:
  x = d_ident
    {    ( [ x ] )}
| x = d_ident _2 = TComma xs = separated_nonempty_list_TComma_d_ident_
    {    ( x :: xs )}

separated_nonempty_list_TComma_ident_or_const_:
  x = ident_or_const
    {    ( [ x ] )}
| x = ident_or_const _2 = TComma xs = separated_nonempty_list_TComma_ident_or_const_
    {    ( x :: xs )}

separated_nonempty_list_TComma_meta_ident_:
  x = meta_ident
    {    ( [ x ] )}
| x = meta_ident _2 = TComma xs = separated_nonempty_list_TComma_meta_ident_
    {    ( x :: xs )}

separated_nonempty_list_TComma_pure_ident_:
  x = pure_ident
    {    ( [ x ] )}
| x = pure_ident _2 = TComma xs = separated_nonempty_list_TComma_pure_ident_
    {    ( x :: xs )}

separated_nonempty_list_TComma_pure_ident_or_meta_ident_:
  x = pure_ident_or_meta_ident
    {    ( [ x ] )}
| x = pure_ident_or_meta_ident _2 = TComma xs = separated_nonempty_list_TComma_pure_ident_or_meta_ident_
    {    ( x :: xs )}

separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_assignop_constraint_:
  x = pure_ident_or_meta_ident_with_assignop_constraint
    {    ( [ x ] )}
| x = pure_ident_or_meta_ident_with_assignop_constraint _2 = TComma xs = separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_assignop_constraint_
    {    ( x :: xs )}

separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_binop_constraint_:
  x = pure_ident_or_meta_ident_with_binop_constraint
    {    ( [ x ] )}
| x = pure_ident_or_meta_ident_with_binop_constraint _2 = TComma xs = separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_binop_constraint_
    {    ( x :: xs )}

separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_econstraint_not_ceq_or_sub__:
  x = pure_ident_or_meta_ident_with_econstraint_not_ceq_or_sub_
    {    ( [ x ] )}
| x = pure_ident_or_meta_ident_with_econstraint_not_ceq_or_sub_ _2 = TComma xs = separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_econstraint_not_ceq_or_sub__
    {    ( x :: xs )}

separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_econstraint_re_or_not_eqe_or_sub__:
  x = pure_ident_or_meta_ident_with_econstraint_re_or_not_eqe_or_sub_
    {    ( [ x ] )}
| x = pure_ident_or_meta_ident_with_econstraint_re_or_not_eqe_or_sub_ _2 = TComma xs = separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_econstraint_re_or_not_eqe_or_sub__
    {    ( x :: xs )}

separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_idconstraint_re_only__:
  x = pure_ident_or_meta_ident_with_idconstraint_re_only_
    {    ( [ x ] )}
| x = pure_ident_or_meta_ident_with_idconstraint_re_only_ _2 = TComma xs = separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_idconstraint_re_only__
    {    ( x :: xs )}

separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_idconstraint_re_or_not_eqid__:
  x = pure_ident_or_meta_ident_with_idconstraint_re_or_not_eqid_
    {    ( [ x ] )}
| x = pure_ident_or_meta_ident_with_idconstraint_re_or_not_eqid_ _2 = TComma xs = separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_idconstraint_re_or_not_eqid__
    {    ( x :: xs )}

separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_idconstraint_virt_re_or_not_eqid__:
  x = pure_ident_or_meta_ident_with_idconstraint_virt_re_or_not_eqid_
    {    ( [ x ] )}
| x = pure_ident_or_meta_ident_with_idconstraint_virt_re_or_not_eqid_ _2 = TComma xs = separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_idconstraint_virt_re_or_not_eqid__
    {    ( x :: xs )}

separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_seed_:
  x = pure_ident_or_meta_ident_with_seed
    {    ( [ x ] )}
| x = pure_ident_or_meta_ident_with_seed _2 = TComma xs = separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_seed_
    {    ( x :: xs )}

separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_x_eq_not_pos__:
  x = pure_ident_or_meta_ident_with_x_eq_not_pos_
    {    ( [ x ] )}
| x = pure_ident_or_meta_ident_with_x_eq_not_pos_ _2 = TComma xs = separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_x_eq_not_pos__
    {    ( x :: xs )}

separated_nonempty_list_TComma_typedef_ident_:
  x = typedef_ident
    {    ( [ x ] )}
| x = typedef_ident _2 = TComma xs = separated_nonempty_list_TComma_typedef_ident_
    {    ( x :: xs )}

separated_nonempty_list_TCppConcatOp_seed_elem_:
  x = seed_elem
    {    ( [ x ] )}
| x = seed_elem _2 = TCppConcatOp xs = separated_nonempty_list_TCppConcatOp_seed_elem_
    {    ( x :: xs )}

minus_main:
  _1 = minus_body _2 = EOF
    {                           ( _1 )}
| m = minus_body _2 = TArobArob
    {                                                           ( m )}
| m = minus_body _2 = TArob
    {                     ( m )}

plus_main:
  _1 = plus_body _2 = EOF
    {                         ( _1 )}
| p = plus_body _2 = TArobArob
    {                                                        ( p )}
| p = plus_body _2 = TArob
    {                    ( p )}

minus_exp_main:
  _1 = minus_exp_body _2 = EOF
    {                                   ( _1 )}
| m = minus_exp_body _2 = TArobArob
    {                                                                       ( m )}
| m = minus_exp_body _2 = TArob
    {                         ( m )}

minus_ty_main:
  _1 = minus_ty_body _2 = EOF
    {                                 ( _1 )}
| m = minus_ty_body _2 = TArobArob
    {                                                                    ( m )}
| m = minus_ty_body _2 = TArob
    {                        ( m )}

minus_id_main:
  _1 = minus_id_body _2 = EOF
    {                                 ( _1 )}
| m = minus_id_body _2 = TArobArob
    {                                                                    ( m )}
| m = minus_id_body _2 = TArob
    {                        ( m )}

plus_exp_main:
  _1 = plus_exp_body _2 = EOF
    {                                 ( _1 )}
| p = plus_exp_body _2 = TArobArob
    {                                                                    ( p )}
| p = plus_exp_body _2 = TArob
    {                        ( p )}

plus_ty_main:
  _1 = plus_ty_body _2 = EOF
    {                               ( _1 )}
| p = plus_ty_body _2 = TArobArob
    {                                                                 ( p )}
| p = plus_ty_body _2 = TArob
    {                       ( p )}

plus_id_main:
  _1 = plus_id_body _2 = EOF
    {                               ( _1 )}
| p = plus_id_body _2 = TArobArob
    {                                                                 ( p )}
| p = plus_id_body _2 = TArob
    {                       ( p )}

meta_main:
  m = metadec
    {                       ( m (!Ast0.rule_name) )}

iso_meta_main:
  m = metadec
    {                         ( m "" )}

pure:
  _1 = TPure
    {                 ( Ast0.Pure )}
| _1 = TContext
    {                 ( Ast0.Context )}
| _1 = TPure _2 = TContext
    {                 ( Ast0.PureContext )}
| _1 = TContext _2 = TPure
    {                 ( Ast0.PureContext )}
| 
    {                 ( Ast0.Impure )}

iso_rule_name:
  nm = pure_ident _2 = TArob
    {                      ( P.make_iso_rule_name_result (P.id2name nm) )}

rule_name:
  _2 = extends d = depends i = loption_choose_iso_ a = loption_disable_ e = exists ee = is_expression _8 = TArob
    {let nm =     ( None ) in
      ( P.make_cocci_rule_name_result nm d i a e ee )}
| x = pure_ident _2 = extends d = depends i = loption_choose_iso_ a = loption_disable_ e = exists ee = is_expression _8 = TArob
    {let nm =     ( Some x ) in
      ( P.make_cocci_rule_name_result nm d i a e ee )}
| _1 = TGenerated _2 = extends d = depends i = loption_choose_iso_ a = loption_disable_ e = exists ee = is_expression _8 = TArob
    {      ( P.make_generated_rule_name_result None d i a e ee )}
| _1 = TScript _2 = TDotDot lang = pure_ident d = depends _6 = TArob
    {let nm =     ( None ) in
      ( P.make_script_rule_name_result lang nm d )}
| _1 = TScript _2 = TDotDot lang = pure_ident x = pure_ident d = depends _6 = TArob
    {let nm =     ( Some x ) in
      ( P.make_script_rule_name_result lang nm d )}
| _1 = TInitialize _2 = TDotDot lang = pure_ident d = depends _5 = TArob
    {      ( P.make_initial_script_rule_name_result lang d )}
| _1 = TFinalize _2 = TDotDot lang = pure_ident d = depends _5 = TArob
    {      ( P.make_final_script_rule_name_result lang d )}

extends:
  
    {                                                  ( () )}
| _1 = TExtends parent = TRuleName
    {    ( !Data.install_bindings (parent) )}

depends:
  
    {                           ( Ast0.NoDep )}
| _1 = TDepends _2 = TOn parents = dep
    {                           ( parents )}

dep:
  _1 = TRuleName
    {                   ( Ast0.Dep _1 )}
| _1 = TBang _2 = TRuleName
    {                   ( Ast0.AntiDep (Ast0.Dep _2) )}
| _1 = TBang _2 = TOPar _3 = dep _4 = TCPar
    {                   ( Ast0.AntiDep _3 )}
| _1 = TEver _2 = TRuleName
    {                   ( Ast0.EverDep _2 )}
| _1 = TNever _2 = TRuleName
    {                   ( Ast0.NeverDep _2 )}
| _1 = dep _2 = TAndLog _3 = dep
    {                   ( Ast0.AndDep(_1, _3) )}
| _1 = dep _2 = TOrLog _3 = dep
    {                   ( Ast0.OrDep (_1, _3) )}
| _1 = TOPar _2 = dep _3 = TCPar
    {                   ( _2 )}

choose_iso:
  _1 = TUsing _2 = separated_nonempty_list_TComma_TString_
    {                                                 ( List.map P.id2name _2 )}

disable:
  _1 = TDisable _2 = separated_nonempty_list_TComma_pure_ident_
    {                                                      ( List.map P.id2name _2 )}

exists:
  _1 = TExists
    {          ( Ast.Exists )}
| _1 = TForall
    {          ( Ast.Forall )}
| 
    {          ( Ast.Undetermined )}

is_expression:
  
    {              ( Ast.AnyP )}
| _1 = TExpression
    {              ( Ast.ExpP )}
| _1 = TIdentifier
    {              ( Ast.IdP )}
| _1 = TType
    {              ( Ast.TyP )}

include_main:
  _1 = list_incl_ _2 = TArob
    {                       ( _1 )}
| _1 = list_incl_ _2 = TArobArob
    {                       ( _1 )}

incl:
  _1 = TIncludeL
    {                      ( let (x,_) = _1 in Data.Include(x) )}
| _1 = TUsing _2 = TString
    {                      ( Data.Iso(Common.Left(P.id2name _2)) )}
| _1 = TUsing _2 = TPathIsoFile
    {                      ( Data.Iso(Common.Right _2) )}
| _1 = TVirtual l = separated_nonempty_list_TComma_pure_ident_
    {let ids =                                          ( l ) in
    ( let names = List.map P.id2name ids in
      Iteration.parsed_virtual_rules :=
	Common.union_set names !Iteration.parsed_virtual_rules;
      (* ensure that the names of virtual and real rules don't overlap *)
      List.iter
      (function name -> Hashtbl.add Data.all_metadecls name [])
      names;
      Data.Virt(names) )}

metadec:
  ar = arity ispure = pure _1 = TMetavariable l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let ids =                                          ( l ) in
let kindfn =     ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaMetaDecl(arity,name)) in
      !Data.add_meta_meta name pure; tok) ) in
    ( P.create_metadec ar ispure kindfn ids )}
| ar = arity ispure = pure _1 = TParameter l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let ids =                                          ( l ) in
let kindfn =     ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaParamDecl(arity,name)) in
      !Data.add_param_meta name pure; tok) ) in
    ( P.create_metadec ar ispure kindfn ids )}
| ar = arity ispure = pure _1 = TParameter _2 = Tlist l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let ids =                                          ( l ) in
let kindfn =     ( (fun arity name pure check_meta ->
      let len = Ast.AnyLen in
      let tok = check_meta(Ast.MetaParamListDecl(arity,name,len)) in
      !Data.add_paramlist_meta name len pure; tok) ) in
    ( P.create_metadec ar ispure kindfn ids )}
| ar = arity ispure = pure _1 = TExpression _2 = Tlist l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let ids =                                          ( l ) in
let kindfn =     ( (fun arity name pure check_meta ->
      let len = Ast.AnyLen in
      let tok = check_meta(Ast.MetaExpListDecl(arity,name,len)) in
      !Data.add_explist_meta name len pure; tok) ) in
    ( P.create_metadec ar ispure kindfn ids )}
| ar = arity ispure = pure _1 = TType l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let ids =                                          ( l ) in
let kindfn =     ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaTypeDecl(arity,name)) in
      !Data.add_type_meta name pure; tok) ) in
    ( P.create_metadec ar ispure kindfn ids )}
| ar = arity ispure = pure _1 = TInitialiser l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let ids =                                          ( l ) in
let kindfn =     ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaInitDecl(arity,name)) in
      !Data.add_init_meta name pure; tok) ) in
    ( P.create_metadec ar ispure kindfn ids )}
| ar = arity ispure = pure _1 = TInitialiser _2 = Tlist l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let ids =                                          ( l ) in
let kindfn =     ( (fun arity name pure check_meta ->
      let len = Ast.AnyLen in
      let tok = check_meta(Ast.MetaInitListDecl(arity,name,len)) in
      !Data.add_initlist_meta name len pure; tok) ) in
    ( P.create_metadec ar ispure kindfn ids )}
| ar = arity ispure = pure _1 = TStatement l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let ids =                                          ( l ) in
let kindfn =     ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaStmDecl(arity,name)) in
      !Data.add_stm_meta name pure; tok) ) in
    ( P.create_metadec ar ispure kindfn ids )}
| ar = arity ispure = pure _1 = TDeclaration l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let ids =                                          ( l ) in
let kindfn =     ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaDeclDecl(arity,name)) in
      !Data.add_decl_meta name pure; tok) ) in
    ( P.create_metadec ar ispure kindfn ids )}
| ar = arity ispure = pure _1 = TField l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let ids =                                          ( l ) in
let kindfn =     ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaFieldDecl(arity,name)) in
      !Data.add_field_meta name pure; tok) ) in
    ( P.create_metadec ar ispure kindfn ids )}
| ar = arity ispure = pure _1 = TField _2 = Tlist l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let ids =                                          ( l ) in
let kindfn =     ( (fun arity name pure check_meta ->
      let len = Ast.AnyLen in
      let tok = check_meta(Ast.MetaFieldListDecl(arity,name,len)) in
      !Data.add_field_list_meta name len pure; tok) ) in
    ( P.create_metadec ar ispure kindfn ids )}
| ar = arity ispure = pure _1 = TStatement _2 = Tlist l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let ids =                                          ( l ) in
let kindfn =     ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaStmListDecl(arity,name)) in
      !Data.add_stmlist_meta name pure; tok) ) in
    ( P.create_metadec ar ispure kindfn ids )}
| ar = arity ispure = pure _1 = TTypedef l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let ids =                                          ( l ) in
let kindfn =     ( (fun arity (_,name) pure check_meta ->
      if arity = Ast.NONE && pure = Ast0.Impure
      then (!Data.add_type_name name; [])
      else raise (Semantic_cocci.Semantic "bad typedef")) ) in
    ( P.create_metadec ar ispure kindfn ids )}
| ar = arity ispure = pure _1 = TAttribute l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let ids =                                          ( l ) in
let kindfn =     ( (fun arity (_,name) pure check_meta ->
      if arity = Ast.NONE && pure = Ast0.Impure
      then (!Data.add_attribute name; [])
      else raise (Semantic_cocci.Semantic "bad attribute")) ) in
    ( P.create_metadec ar ispure kindfn ids )}
| ar = arity ispure = pure _1 = TDeclarer _2 = TName l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let ids =                                          ( l ) in
let kindfn =     ( (fun arity (_,name) pure check_meta ->
      if arity = Ast.NONE && pure = Ast0.Impure
      then (!Data.add_declarer_name name; [])
      else raise (Semantic_cocci.Semantic "bad declarer")) ) in
    ( P.create_metadec ar ispure kindfn ids )}
| ar = arity ispure = pure _1 = TIterator _2 = TName l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let ids =                                          ( l ) in
let kindfn =     ( (fun arity (_,name) pure check_meta ->
      if arity = Ast.NONE && pure = Ast0.Impure
      then (!Data.add_iterator_name name; [])
      else raise (Semantic_cocci.Semantic "bad iterator")) ) in
    ( P.create_metadec ar ispure kindfn ids )}
| _1 = TFresh _2 = TIdentifier l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_seed_ _3 = TMPtVirg
    {let ids =                                          ( l ) in
let kindfn =     ( (fun name check_meta seed ->
      let tok = check_meta(Ast.MetaFreshIdDecl(name,seed)) in
      !Data.add_fresh_id_meta name seed; tok) ) in
    ( P.create_fresh_metadec kindfn ids )}
| ar = arity ispure = pure _1 = TIdentifier l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_idconstraint_virt_re_or_not_eqid__ _5 = TMPtVirg
    {let ids =                                          ( l ) in
let kindfn =     (
     let idfn arity name pure check_meta constraints =
       let tok = check_meta(Ast.MetaIdDecl(arity,name)) in
       !Data.add_id_meta name constraints pure; tok in
     let virtfn arity name pure check_meta virtual_env =
       try
	 let vl = List.assoc name virtual_env in
	 !Data.add_virt_id_meta_found name vl; []
       with Not_found ->
	 Iteration.parsed_virtual_identifiers :=
	   Common.union_set [name]
	     !Iteration.parsed_virtual_identifiers;
	 let name = ("virtual",name) in
	 let tok = check_meta(Ast.MetaIdDecl(arity,name)) in
	 !Data.add_virt_id_meta_not_found name pure; tok in
     (idfn,virtfn) ) in
    ( let (normal,virt) = Common.partition_either (fun x -> x) ids in
    let (idfn,virtfn) = kindfn in
    function cr ->
      (P.create_metadec_with_constraints ar ispure idfn normal cr) @
      (P.create_metadec_virt ar ispure virtfn virt cr) )}
| ar = arity ispure = pure _1 = TFunction l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_idconstraint_re_or_not_eqid__ _5 = TMPtVirg
    {let ids =                                          ( l ) in
let kindfn =     ( (fun arity name pure check_meta constraints ->
      let tok = check_meta(Ast.MetaFuncDecl(arity,name)) in
      !Data.add_func_meta name constraints pure; tok) ) in
    ( P.create_metadec_with_constraints ar ispure kindfn ids )}
| ar = arity ispure = pure _1 = TLocal _2 = TFunction l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_idconstraint_re_or_not_eqid__ _5 = TMPtVirg
    {let ids =                                          ( l ) in
let kindfn =     ( (fun arity name pure check_meta constraints ->
      let tok = check_meta(Ast.MetaLocalFuncDecl(arity,name)) in
      !Data.add_local_func_meta name constraints pure;
      tok) ) in
    ( P.create_metadec_with_constraints ar ispure kindfn ids )}
| ar = arity ispure = pure _1 = TDeclarer l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_idconstraint_re_or_not_eqid__ _5 = TMPtVirg
    {let ids =                                          ( l ) in
let kindfn =     ( (fun arity name pure check_meta constraints ->
      let tok = check_meta(Ast.MetaDeclarerDecl(arity,name)) in
      !Data.add_declarer_meta name constraints pure; tok) ) in
    ( P.create_metadec_with_constraints ar ispure kindfn ids )}
| ar = arity ispure = pure _1 = TIterator l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_idconstraint_re_or_not_eqid__ _5 = TMPtVirg
    {let ids =                                          ( l ) in
let kindfn =     ( (fun arity name pure check_meta constraints ->
      let tok = check_meta(Ast.MetaIteratorDecl(arity,name)) in
      !Data.add_iterator_meta name constraints pure; tok) ) in
    ( P.create_metadec_with_constraints ar ispure kindfn ids )}
| ar = arity ispure = pure _1 = TError l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_econstraint_re_or_not_eqe_or_sub__ _5 = TMPtVirg
    {let ids =                                          ( l ) in
let kindfn =     ( (fun arity name pure check_meta constraints ->
      let tok = check_meta(Ast.MetaErrDecl(arity,name)) in
      !Data.add_err_meta name constraints pure; tok) ) in
    ( P.create_metadec_with_constraints ar ispure kindfn ids )}
| ar = arity ispure = pure l = option_TLocal_ _2 = TIdExpression l_inlined1 = separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_econstraint_re_or_not_eqe_or_sub__ _5 = TMPtVirg
    {let ids =
  let l = l_inlined1 in
                                           ( l )
in
let kindfn =
  let ty =     ( None ) in
      ( (fun arity name pure check_meta constraints ->
      match l with
	None ->
	  !Data.add_idexp_meta ty name constraints pure;
	  check_meta(Ast.MetaIdExpDecl(arity,name,ty))
      | Some _ ->
	  !Data.add_local_idexp_meta ty name constraints pure;
	  check_meta(Ast.MetaLocalIdExpDecl(arity,name,ty))) )
in
    ( P.create_metadec_with_constraints ar ispure kindfn ids )}
| ar = arity ispure = pure l = option_TLocal_ _2 = TIdExpression x = meta_exp_type l_inlined1 = separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_econstraint_re_or_not_eqe_or_sub__ _5 = TMPtVirg
    {let ids =
  let l = l_inlined1 in
                                           ( l )
in
let kindfn =
  let ty =     ( Some x ) in
      ( (fun arity name pure check_meta constraints ->
      match l with
	None ->
	  !Data.add_idexp_meta ty name constraints pure;
	  check_meta(Ast.MetaIdExpDecl(arity,name,ty))
      | Some _ ->
	  !Data.add_local_idexp_meta ty name constraints pure;
	  check_meta(Ast.MetaLocalIdExpDecl(arity,name,ty))) )
in
    ( P.create_metadec_with_constraints ar ispure kindfn ids )}
| ar = arity ispure = pure l = option_TLocal_ _2 = TIdExpression m = nonempty_list_TMul_ l_inlined1 = separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_econstraint_re_or_not_eqe_or_sub__ _5 = TMPtVirg
    {let ids =
  let l = l_inlined1 in
                                           ( l )
in
let kindfn =     ( (fun arity name pure check_meta constraints ->
      let ty = Some [P.ty_pointerify Type_cocci.Unknown m] in
      match l with
	None ->
	  !Data.add_idexp_meta ty name constraints pure;
	  check_meta(Ast.MetaIdExpDecl(arity,name,ty))
      | Some _ ->
	  !Data.add_local_idexp_meta ty name constraints pure;
	  check_meta(Ast.MetaLocalIdExpDecl(arity,name,ty))) ) in
    ( P.create_metadec_with_constraints ar ispure kindfn ids )}
| ar = arity ispure = pure _1 = TGlobal _2 = TIdExpression l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_econstraint_re_or_not_eqe_or_sub__ _5 = TMPtVirg
    {let ids =                                          ( l ) in
let kindfn =
  let ty =     ( None ) in
      ( (fun arity name pure check_meta constraints ->
      !Data.add_global_idexp_meta ty name constraints pure;
      check_meta(Ast.MetaGlobalIdExpDecl(arity,name,ty))) )
in
    ( P.create_metadec_with_constraints ar ispure kindfn ids )}
| ar = arity ispure = pure _1 = TGlobal _2 = TIdExpression x = meta_exp_type l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_econstraint_re_or_not_eqe_or_sub__ _5 = TMPtVirg
    {let ids =                                          ( l ) in
let kindfn =
  let ty =     ( Some x ) in
      ( (fun arity name pure check_meta constraints ->
      !Data.add_global_idexp_meta ty name constraints pure;
      check_meta(Ast.MetaGlobalIdExpDecl(arity,name,ty))) )
in
    ( P.create_metadec_with_constraints ar ispure kindfn ids )}
| ar = arity ispure = pure _1 = TGlobal _2 = TIdExpression m = nonempty_list_TMul_ l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_econstraint_re_or_not_eqe_or_sub__ _5 = TMPtVirg
    {let ids =                                          ( l ) in
let kindfn =     ( (fun arity name pure check_meta constraints ->
      let ty = Some [P.ty_pointerify Type_cocci.Unknown m] in
      !Data.add_global_idexp_meta ty name constraints pure;
      check_meta(Ast.MetaGlobalIdExpDecl(arity,name,ty))) ) in
    ( P.create_metadec_with_constraints ar ispure kindfn ids )}
| ar = arity ispure = pure _1 = TExpression ty = expression_type l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_econstraint_re_or_not_eqe_or_sub__ _5 = TMPtVirg
    {let ids =                                          ( l ) in
let kindfn =     ( (fun arity name pure check_meta constraints ->
      let ty = Some [ty] in
      let tok = check_meta(Ast.MetaExpDecl(arity,name,ty)) in
      !Data.add_exp_meta ty name constraints pure; tok) ) in
    ( P.create_metadec_with_constraints ar ispure kindfn ids )}
| ar = arity ispure = pure _1 = TConstant l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_econstraint_re_or_not_eqe_or_sub__ _5 = TMPtVirg
    {let ids =                                          ( l ) in
let kindfn =
  let ty =     ( None ) in
      ( (fun arity name pure check_meta constraints ->
      let tok = check_meta(Ast.MetaConstDecl(arity,name,ty)) in
      !Data.add_const_meta ty name constraints pure; tok) )
in
    ( P.create_metadec_with_constraints ar ispure kindfn ids )}
| ar = arity ispure = pure _1 = TConstant x = meta_exp_type l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_econstraint_re_or_not_eqe_or_sub__ _5 = TMPtVirg
    {let ids =                                          ( l ) in
let kindfn =
  let ty =     ( Some x ) in
      ( (fun arity name pure check_meta constraints ->
      let tok = check_meta(Ast.MetaConstDecl(arity,name,ty)) in
      !Data.add_const_meta ty name constraints pure; tok) )
in
    ( P.create_metadec_with_constraints ar ispure kindfn ids )}
| ar = arity ispure = pure _1 = TExpression l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_econstraint_not_ceq_or_sub__ _5 = TMPtVirg
    {let ids =                                          ( l ) in
let kindfn =     ( (fun arity name pure check_meta constraints ->
      let tok = check_meta(Ast.MetaExpDecl(arity,name,None)) in
      !Data.add_exp_meta None name constraints pure; tok) ) in
    ( P.create_metadec_with_constraints ar ispure kindfn ids )}
| ar = arity ispure = pure vl = meta_exp_type l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_econstraint_not_ceq_or_sub__ _5 = TMPtVirg
    {let ids =                                          ( l ) in
let kindfn =     ( (fun arity name pure check_meta constraints ->
      let ty = Some vl in
      (match constraints with
	Ast0.NotExpCstrt constraints ->
	  List.iter
	    (function c ->
	      match Ast0.unwrap c with
		Ast0.Constant(_) ->
		  if not
		      (List.exists
			 (function
			     Type_cocci.BaseType(Type_cocci.IntType) -> true
			   | Type_cocci.BaseType(Type_cocci.ShortType) -> true
			   | Type_cocci.BaseType(Type_cocci.LongType) -> true
			   | _ -> false)
			 vl)
		  then
		    failwith "metavariable with int constraint must be an int"
	      | _ -> ())
	    constraints
      |	_ -> ());
      let tok = check_meta(Ast.MetaExpDecl(arity,name,ty)) in
      !Data.add_exp_meta ty name constraints pure; tok)
    ) in
    ( P.create_metadec_with_constraints ar ispure kindfn ids )}
| ar = arity _2 = TPosition a = option_TPosAny_ l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_x_eq_not_pos__ _5 = TMPtVirg
    {let ids =                                          ( l ) in
    ( (if !Data.in_generating
      then failwith "position variables not allowed in a generated rule file");
      let kindfn arity name pure check_meta constraints =
      let tok = check_meta(Ast.MetaPosDecl(arity,name)) in
      let any = match a with None -> Ast.PER | Some _ -> Ast.ALL in
      !Data.add_pos_meta name constraints any; tok in
    P.create_metadec_with_constraints ar false kindfn ids )}
| ar = arity ispure = pure _3 = TParameter _4 = Tlist _5 = TOCro len = list_len _7 = TCCro l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_ _9 = TMPtVirg
    {let ids =                                          ( l ) in
    ( P.create_len_metadec ar ispure
	(fun lenname arity name pure check_meta ->
	  let tok = check_meta(Ast.MetaParamListDecl(arity,name,lenname)) in
	  !Data.add_paramlist_meta name lenname pure; tok)
	len ids )}
| ar = arity ispure = pure _3 = TExpression _4 = Tlist _5 = TOCro len = list_len _7 = TCCro l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_ _9 = TMPtVirg
    {let ids =                                          ( l ) in
    ( P.create_len_metadec ar ispure
	(fun lenname arity name pure check_meta ->
	  let tok = check_meta(Ast.MetaExpListDecl(arity,name,lenname)) in
	  !Data.add_explist_meta name lenname pure; tok)
	len ids )}
| ar = arity ispure = pure _3 = TField _4 = Tlist _5 = TOCro len = list_len _7 = TCCro l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_ _9 = TMPtVirg
    {let ids =                                          ( l ) in
    ( P.create_len_metadec ar ispure
	(fun lenname arity name pure check_meta ->
	  let tok = check_meta(Ast.MetaFieldListDecl(arity,name,lenname)) in
	  !Data.add_field_list_meta name lenname pure; tok)
	len ids )}
| ar = arity ispure = pure _3 = TInitialiser _4 = Tlist _5 = TOCro len = list_len _7 = TCCro l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_ _9 = TMPtVirg
    {let ids =                                          ( l ) in
    ( P.create_len_metadec ar ispure
	(fun lenname arity name pure check_meta ->
	  let tok = check_meta(Ast.MetaInitListDecl(arity,name,lenname)) in
	  !Data.add_initlist_meta name lenname pure; tok)
	len ids )}
| _1 = TSymbol l = separated_nonempty_list_TComma_pure_ident_ _3 = TMPtVirg
    {let ids =                                          ( l ) in
    ( (fun _ ->
        let add_sym = fun (nm,_) -> !Data.add_symbol_meta nm in
          List.iter add_sym ids; [])
    )}
| ar = arity _2 = TFormat l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_idconstraint_re_only__ _4 = TMPtVirg
    {let ids =                                          ( l ) in
    ( P.create_metadec_with_constraints ar Ast0.Impure
	(fun arity name pure check_meta constraints ->
	  let tok = check_meta(Ast.MetaFmtDecl(arity,name)) in
	  !Data.add_fmt_meta name constraints; tok)
    ids )}
| ar = arity _2 = TFormat _3 = Tlist l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let ids =                                          ( l ) in
    ( P.create_metadec ar Ast0.Impure
	(fun arity name pure check_meta ->
	  let len = Ast.AnyLen in
	  let tok = check_meta(Ast.MetaFragListDecl(arity,name,len)) in
	  !Data.add_fmtlist_meta name len; tok)
	ids )}
| ar = arity _2 = TFormat _3 = Tlist _4 = TOCro len = list_len _6 = TCCro l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_ _8 = TMPtVirg
    {let ids =                                          ( l ) in
    ( P.create_len_metadec ar Ast0.Impure
	(fun lenname arity name pure check_meta ->
	  let tok = check_meta(Ast.MetaFragListDecl(arity,name,lenname)) in
	  !Data.add_fmtlist_meta name lenname; tok)
	len ids )}
| ar = arity _2 = TBinary _3 = TOperator l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_binop_constraint_ _5 = TMPtVirg
    {let ids =                                          ( l ) in
    ( P.create_metadec_with_constraints ar Ast0.Impure
	(fun arity name pure check_meta constraints ->
	  let tok = check_meta(Ast.MetaBinaryOperatorDecl(arity,name)) in
	  !Data.add_binaryOp_meta name constraints pure; tok)
        ids )}
| ar = arity _2 = TAssignment _3 = TOperator l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_with_assignop_constraint_ _5 = TMPtVirg
    {let ids =                                          ( l ) in
    ( P.create_metadec_with_constraints ar Ast0.Impure
	(fun arity name pure check_meta constraints ->
	  let tok = check_meta(Ast.MetaAssignmentOperatorDecl(arity,name)) in
	  !Data.add_assignOp_meta name constraints pure; tok)
        ids )}

pure_ident_or_meta_ident_with_binop_constraint:
  i = pure_ident_or_meta_ident c = binaryopconstraint
    {                                                    ( (i,c) )}

binaryopconstraint:
  
    {  ( Ast0.BinaryOpNoConstraint )}
| _1 = TEq _2 = TOBrace l = separated_nonempty_list_TComma_binary_operator_ _4 = TCBrace
    {let ops =                                          ( l ) in
  ( Ast0.BinaryOpInSet ops )}
| _1 = TEq op = binary_operator
    {  ( Ast0.BinaryOpInSet [op] )}

pure_ident_or_meta_ident_with_assignop_constraint:
  i = pure_ident_or_meta_ident c = assignopconstraint
    {                                                    ( (i,c) )}

assignopconstraint:
  
    {  ( Ast0.AssignOpNoConstraint )}
| _1 = TEq _2 = TOBrace l = separated_nonempty_list_TComma_assignment_operator_ _4 = TCBrace
    {let ops =                                          ( l ) in
  ( Ast0.AssignOpInSet ops )}
| _1 = TEq op = assignment_operator
    {  ( Ast0.AssignOpInSet [op] )}

binary_operator:
  _1 = TShLOp
    {         ( mkarithop _1 )}
| _1 = TMul
    {       ( mkarithop (Ast.Mul,_1) )}
| _1 = TEqEq
    {        ( mklogop (Ast.Eq,_1) )}
| _1 = TNotEq
    {         ( mklogop (Ast.NotEq,_1) )}
| _1 = TSub
    {       ( mklogop (Ast.InfEq,_1) )}
| _1 = TPlus
    {        ( mkarithop (Ast.Plus,_1) )}
| _1 = TMinus
    {         ( mkarithop (Ast.Minus,_1) )}
| _1 = TDmOp
    {        ( mkarithop _1 )}
| _1 = TShROp
    {         ( mkarithop _1 )}
| _1 = TAnd
    {       ( mkarithop (Ast.And,_1) )}
| _1 = TOr
    {      ( mkarithop (Ast.Or,_1) )}
| _1 = TXor
    {       ( mkarithop (Ast.Xor,_1) )}
| _1 = TLogOp
    {         ( mklogop _1 )}
| _1 = TAndLog
    {          ( mklogop (Ast.AndLog,_1) )}
| _1 = TOrLog
    {         ( mklogop (Ast.OrLog,_1) )}

assignment_operator:
  _1 = TEq
    {  ( let clt = _1 in
  let op' = P.clt2mcode "=" clt in
  Ast0.wrap (Ast0.SimpleAssign op') )}
| _1 = TOpAssign
    {  ( let (op,clt) = _1 in
  let op' = P.clt2mcode op clt in
  Ast0.wrap (Ast0.OpAssign op') )}

list_len:
  _1 = pure_ident_or_meta_ident
    {                           ( Common.Left _1 )}
| _1 = TInt
    {       ( let (x,clt) = _1 in Common.Right (int_of_string x) )}
| _1 = TVirtual _2 = TDot _3 = pure_ident
    {    ( let nm = ("virtual",P.id2name _3) in
    Iteration.parsed_virtual_identifiers :=
      Common.union_set [snd nm]
        !Iteration.parsed_virtual_identifiers;
    try
    Common.Right (int_of_string
		    (List.assoc (snd nm) !Flag.defined_virtual_env))
    with Not_found | Failure "int_of_string" ->
      begin
	Common.Left (Some "virtual",P.id2name _3)
      end
    )}

expression_type:
  m = nonempty_list_TMul_
    {                        ( P.ty_pointerify Type_cocci.Unknown m )}
| _1 = Tenum m = list_TMul_
    {    ( P.ty_pointerify (Type_cocci.EnumName Type_cocci.NoName) m )}
| _1 = Tstruct m = list_TMul_
    {    ( P.ty_pointerify
	(Type_cocci.StructUnionName (Type_cocci.Struct,Type_cocci.NoName)) m )}
| _1 = Tunion m = list_TMul_
    {    ( P.ty_pointerify
	(Type_cocci.StructUnionName (Type_cocci.Union,Type_cocci.NoName)) m )}

meta_exp_type:
  t = typedef_ctype
    {    ( [Ast0_cocci.ast0_type_to_type true t] )}
| t = typedef_ctype _2 = TOCro _3 = TCCro
    {    ( [Type_cocci.Array (Ast0_cocci.ast0_type_to_type true t)] )}
| _1 = TOBrace l = separated_nonempty_list_TComma_ctype_ _3 = TCBrace m = list_TMul_
    {let t =                                          ( l ) in
    ( List.map
	(function x -> P.ty_pointerify (Ast0_cocci.ast0_type_to_type true x) m)
	t )}

arity:
  _1 = TBang0
    {              ( Ast.UNIQUE )}
| _1 = TWhy0
    {              ( Ast.OPT )}
| _1 = TPlus0
    {              ( Ast.MULTI )}
| 
    {                   ( Ast.NONE )}

signable_types:
  ty = Tchar
    {    ( Ast0.wrap(Ast0.BaseType(Ast.CharType,[P.clt2mcode "char" ty])) )}
| ty = Tshort
    {    ( Ast0.wrap(Ast0.BaseType(Ast.ShortType,[P.clt2mcode "short" ty])) )}
| ty1 = Tshort ty2 = Tint
    {    ( Ast0.wrap
	(Ast0.BaseType
	   (Ast.ShortIntType,[P.clt2mcode "short" ty1;P.clt2mcode "int" ty2])) )}
| ty = Tint
    {    ( Ast0.wrap(Ast0.BaseType(Ast.IntType,[P.clt2mcode "int" ty])) )}
| p = TMetaType
    {    ( let (nm,pure,clt) = p in
      Ast0.wrap(Ast0.MetaType(P.clt2mcode nm clt,pure)) )}
| r = TRuleName _2 = TDot p = TIdent
    {    ( let nm = (r,P.id2name p) in
    (* this is only possible when we are in a metavar decl.  Otherwise,
       it will be represented already as a MetaType *)
    let _ = P.check_meta(Ast.MetaTypeDecl(Ast.NONE,nm)) in
    Ast0.wrap(Ast0.MetaType(P.clt2mcode nm (P.id2clt p),
			    Ast0.Impure (*will be ignored*))) )}
| ty1 = Tlong
    {    ( Ast0.wrap(Ast0.BaseType(Ast.LongType,[P.clt2mcode "long" ty1])) )}
| ty1 = Tlong ty2 = Tint
    {    ( Ast0.wrap
	(Ast0.BaseType
	   (Ast.LongIntType,[P.clt2mcode "long" ty1;P.clt2mcode "int" ty2])) )}
| ty1 = Tlong ty2 = Tlong
    {    ( Ast0.wrap
	(Ast0.BaseType
	   (Ast.LongLongType,
	    [P.clt2mcode "long" ty1;P.clt2mcode "long" ty2])) )}
| ty1 = Tlong ty2 = Tlong ty3 = Tint
    {    ( Ast0.wrap
	(Ast0.BaseType
	   (Ast.LongLongIntType,
	    [P.clt2mcode "long" ty1;P.clt2mcode "long" ty2;
	      P.clt2mcode "int" ty3])) )}

non_signable_types:
  ty = Tvoid
    {    ( Ast0.wrap(Ast0.BaseType(Ast.VoidType,[P.clt2mcode "void" ty])) )}
| ty1 = Tlong ty2 = Tdouble
    {    ( Ast0.wrap
	(Ast0.BaseType
	   (Ast.LongDoubleType,
	    [P.clt2mcode "long" ty1;P.clt2mcode "double" ty2])) )}
| ty = Tdouble
    {    ( Ast0.wrap(Ast0.BaseType(Ast.DoubleType,[P.clt2mcode "double" ty])) )}
| ty = Tfloat
    {    ( Ast0.wrap(Ast0.BaseType(Ast.FloatType,[P.clt2mcode "float" ty])) )}
| ty = Tsize_t
    {    ( Ast0.wrap(Ast0.BaseType(Ast.SizeType,[P.clt2mcode "size_t" ty])) )}
| ty = Tssize_t
    {    ( Ast0.wrap(Ast0.BaseType(Ast.SSizeType,[P.clt2mcode "ssize_t" ty])) )}
| ty = Tptrdiff_t
    {    ( Ast0.wrap(Ast0.BaseType(Ast.PtrDiffType,[P.clt2mcode "ptrdiff_t" ty])) )}
| s = Tenum i = ident
    {    ( Ast0.wrap(Ast0.EnumName(P.clt2mcode "enum" s, Some i)) )}
| s = Tenum l = TOBrace ids = enum_decl_list r = TCBrace
    {let i =     ( None ) in
    ( (if i = None && !Data.in_iso
    then failwith "enums must be named in the iso file");
      Ast0.wrap(Ast0.EnumDef(Ast0.wrap(Ast0.EnumName(P.clt2mcode "enum" s, i)),
			     P.clt2mcode "{" l, ids, P.clt2mcode "}" r)) )}
| s = Tenum x = ident l = TOBrace ids = enum_decl_list r = TCBrace
    {let i =     ( Some x ) in
    ( (if i = None && !Data.in_iso
    then failwith "enums must be named in the iso file");
      Ast0.wrap(Ast0.EnumDef(Ast0.wrap(Ast0.EnumName(P.clt2mcode "enum" s, i)),
			     P.clt2mcode "{" l, ids, P.clt2mcode "}" r)) )}
| s = struct_or_union i = type_ident
    {    ( Ast0.wrap(Ast0.StructUnionName(s, Some i)) )}
| s = struct_or_union l = TOBrace d = struct_decl_list r = TCBrace
    {let i =     ( None ) in
    ( (if i = None && !Data.in_iso
    then failwith "structures must be named in the iso file");
      Ast0.wrap(Ast0.StructUnionDef(Ast0.wrap(Ast0.StructUnionName(s, i)),
				    P.clt2mcode "{" l,
				    d, P.clt2mcode "}" r)) )}
| s = struct_or_union x = type_ident l = TOBrace d = struct_decl_list r = TCBrace
    {let i =     ( Some x ) in
    ( (if i = None && !Data.in_iso
    then failwith "structures must be named in the iso file");
      Ast0.wrap(Ast0.StructUnionDef(Ast0.wrap(Ast0.StructUnionName(s, i)),
				    P.clt2mcode "{" l,
				    d, P.clt2mcode "}" r)) )}
| s = TMetaType l = TOBrace d = struct_decl_list r = TCBrace
    {    ( let (nm,pure,clt) = s in
    let ty = Ast0.wrap(Ast0.MetaType(P.clt2mcode nm clt,pure)) in
    Ast0.wrap(Ast0.StructUnionDef(ty,P.clt2mcode "{" l,d,P.clt2mcode "}" r)) )}
| p = TTypeId
    {    ( Ast0.wrap(Ast0.TypeName(P.id2mcode p)) )}
| _1 = Tdecimal _2 = TOPar _3 = enum_val _4 = TComma _5 = enum_val _6 = TCPar
    {    ( Ast0.wrap(Ast0.Decimal(P.clt2mcode "decimal" _1,
			     P.clt2mcode "(" _2,_3,
			     Some (P.clt2mcode "," _4), Some _5,
			     P.clt2mcode ")" _6)) )}
| _1 = Tdecimal _2 = TOPar _3 = enum_val _4 = TCPar
    {    ( Ast0.wrap(Ast0.Decimal(P.clt2mcode "decimal" _1,
			     P.clt2mcode "(" _2,_3,None,None,
			     P.clt2mcode ")" _4)) )}

all_basic_types:
  r = Tsigned ty = signable_types
    {    ( Ast0.wrap(Ast0.Signed(P.clt2mcode Ast.Signed r,Some ty)) )}
| r = Tunsigned ty = signable_types
    {    ( Ast0.wrap(Ast0.Signed(P.clt2mcode Ast.Unsigned r,Some ty)) )}
| ty = signable_types
    {                    ( ty )}
| ty = non_signable_types
    {                        ( ty )}

top_ctype:
  _1 = ctype
    {        ( Ast0.wrap(Ast0.OTHER(Ast0.wrap(Ast0.Ty(_1)))) )}

ctype:
  ty = all_basic_types m = list_mul_
    {let cv =     ( None ) in
    ( List.fold_left
	(function prev ->
	  function (star,cv) ->
	    P.make_cv cv (P.pointerify prev [star]))
	(P.make_cv cv ty) m )}
| x = const_vol ty = all_basic_types m = list_mul_
    {let cv =     ( Some x ) in
    ( List.fold_left
	(function prev ->
	  function (star,cv) ->
	    P.make_cv cv (P.pointerify prev [star]))
	(P.make_cv cv ty) m )}
| r = Tsigned
    {    ( Ast0.wrap(Ast0.Signed(P.clt2mcode Ast.Signed r,None)) )}
| r = Tunsigned
    {    ( Ast0.wrap(Ast0.Signed(P.clt2mcode Ast.Unsigned r,None)) )}
| lp = TOPar0 t = midzero_list_ctype_ctype_ rp = TCPar0
    {    ( let (mids,code) = t in
      Ast0.wrap
	(Ast0.DisjType(P.id2mcode lp,code,mids, P.id2mcode rp)) )}

mul:
  a = TMul
    {let b =     ( None ) in
                                 ( (a,b) )}
| a = TMul x = const_vol
    {let b =     ( Some x ) in
                                 ( (a,b) )}

mctype:
  _1 = TMeta
    {        ( tmeta_to_type _1 )}
| _1 = ctype
    {        (_1)}

typedef_ctype:
  ty = all_basic_types m = list_TMul_
    {let cv =     ( None ) in
    ( P.pointerify (P.make_cv cv ty) m )}
| x = const_vol ty = all_basic_types m = list_TMul_
    {let cv =     ( Some x ) in
    ( P.pointerify (P.make_cv cv ty) m )}
| lp = TOPar0 t = midzero_list_mctype_mctype_ rp = TCPar0
    {    ( let (mids,code) = t in
      Ast0.wrap
	(Ast0.DisjType(P.id2mcode lp,code,mids, P.id2mcode rp)) )}
| _1 = TMeta
    {        ( tmeta_to_type _1 )}

struct_or_union:
  s = Tstruct
    {                 ( P.clt2mcode Ast.Struct s )}
| u = Tunion
    {                 ( P.clt2mcode Ast.Union u )}

struct_decl:
  _1 = TNothing
    {                      ( [] )}
| _1 = struct_decl_one
    {                      ( [_1] )}

struct_decl_one:
  _1 = TMetaField
    {                 ( P.meta_field _1 )}
| _1 = TMetaFieldList
    {                     ( P.meta_field_list _1 )}
| _1 = TMeta
    {            ( tmeta_to_field _1 )}
| lp = TOPar0 t = midzero_list_struct_decl_one_struct_decl_one_ rp = TCPar0
    { ( let (mids,code) = t in
	Ast0.wrap
	  (Ast0.DisjDecl(P.id2mcode lp,code,mids, P.id2mcode rp)) )}
| t = ctype d = d_ident pv = TPtVirg
    {  ( let (id,fn) = d in
	 Ast0.wrap(Ast0.UnInit(None,fn t,id,P.clt2mcode ";" pv)) )}
| t = ctype lp1 = TOPar st = TMul d = d_ident rp1 = TCPar lp2 = TOPar p = decl_list_name_opt_decl_ rp2 = TCPar pv = TPtVirg
    {        ( let (id,fn) = d in
        let t =
	  Ast0.wrap
	    (Ast0.FunctionPointer
	       (t,P.clt2mcode "(" lp1,P.clt2mcode "*" st,P.clt2mcode ")" rp1,
		P.clt2mcode "(" lp2,p,P.clt2mcode ")" rp2)) in
        Ast0.wrap(Ast0.UnInit(None,fn t,id,P.clt2mcode ";" pv)) )}
| i = pure_ident_or_symbol d = d_ident pv = TPtVirg
    {let cv =     ( None ) in
  ( let (id,fn) = d in
	 let idtype = P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
	 Ast0.wrap(Ast0.UnInit(None,fn idtype,id,P.clt2mcode ";" pv)) )}
| x = const_vol i = pure_ident_or_symbol d = d_ident pv = TPtVirg
    {let cv =     ( Some x ) in
  ( let (id,fn) = d in
	 let idtype = P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
	 Ast0.wrap(Ast0.UnInit(None,fn idtype,id,P.clt2mcode ";" pv)) )}

struct_decl_list:
  _1 = struct_decl_list_start
    {                          ( Ast0.wrap(Ast0.DOTS(_1)) )}

struct_decl_list_start:
  _1 = struct_decl
    {                                     ( _1 )}
| _1 = struct_decl _2 = struct_decl_list_start
    {                                     ( _1@_2 )}
| d = edots_when_TEllipsis_struct_decl_one_ r = continue_struct_decl_list
    {    ( (P.mkddots_one "..." d)::r )}

continue_struct_decl_list:
  
    {                                     ( [] )}
| _1 = struct_decl _2 = struct_decl_list_start
    {                                     ( _1@_2 )}
| _1 = struct_decl
    {                                     ( _1 )}

enum_decl_one:
  _1 = disj_ident
    {                    ( Ast0.wrap(Ast0.Ident(_1)) )}
| _1 = disj_ident _2 = TEq _3 = enum_val
    { ( let id = Ast0.wrap(Ast0.Ident(_1)) in
        let (op,clt) = ("=",_2) in
        let op' = P.clt2mcode op clt in
        let op'' = Ast0.wrap (Ast0.SimpleAssign op') in
	Ast0.wrap
	  (Ast0.Assignment
	     (id, op'', Ast0.set_arg_exp _3, false)) )}

enum_val:
  _1 = ident
    {            ( Ast0.wrap(Ast0.Ident(_1)) )}
| _1 = TInt
    {     ( let (x,clt) = _1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Int x) clt)) )}
| _1 = TMeta
    {         ( tmeta_to_exp _1 )}
| _1 = TMetaConst
    {     ( let (nm,constraints,pure,ty,clt) = _1 in
     Ast0.wrap
       (Ast0.MetaExpr(P.clt2mcode nm clt,constraints,ty,Ast.CONST,pure)) )}
| _1 = TMetaExp
    {     ( let (nm,constraints,pure,ty,clt) = _1 in
     Ast0.wrap
       (Ast0.MetaExpr(P.clt2mcode nm clt,constraints,ty,Ast.ANY,pure)) )}
| _1 = TMetaIdExp
    {     ( let (nm,constraints,pure,ty,clt) = _1 in
     Ast0.wrap
       (Ast0.MetaExpr(P.clt2mcode nm clt,constraints,ty,Ast.ID,pure)) )}

enum_decl_list:
  _1 = nonempty_list_start_enum_decl_one_edots_when_TEllipsis_enum_decl_one__
    {     ( Ast0.wrap(Ast0.DOTS(_1 P.mkedots (fun c -> Ast0.EComma c))) )}

minus_body:
  f = loption_filespec_ b = loption_minus_start_
    {    ( match f@b(*@ew*) with
      [] -> raise (Semantic_cocci.Semantic "minus slice can't be empty")
    | code -> code )}

plus_body:
  f = loption_filespec_ b = loption_plus_start_
    {    ( f@b(*@ew*) )}

minus_exp_body:
  f = loption_filespec_ b = top_eexpr
    {    ( match f@[b](*@ew*) with
      [] -> raise (Semantic_cocci.Semantic "minus slice can't be empty")
    | code -> code )}

plus_exp_body:
  f = loption_filespec_ b = top_eexpr
    {    ( f@[b](*@ew*) )}

minus_ty_body:
  f = loption_filespec_ b = top_ctype
    {    ( match f@[b](*@ew*) with
      [] -> raise (Semantic_cocci.Semantic "minus slice can't be empty")
    | code -> code )}

plus_ty_body:
  f = loption_filespec_ b = top_ctype
    {    ( f@[b](*@ew*) )}

minus_id_body:
  f = loption_filespec_ b = top_ident
    {    ( match f@[b](*@ew*) with
      [] -> raise (Semantic_cocci.Semantic "minus slice can't be empty")
    | code -> code )}

plus_id_body:
  f = loption_filespec_ b = top_ident
    {    ( f@[b](*@ew*) )}

filespec:
  _1 = TMinusFile _2 = TPlusFile
    {    ( [Ast0.wrap
	  (Ast0.FILEINFO(P.id2mcode _1,
			 P.id2mcode _2))] )}

includes:
  _1 = TIncludeL
    {    ( Ast0.wrap
	(Ast0.Include(P.clt2mcode "#include"
			(P.drop_pos (P.drop_aft (P.id2clt _1))),
		      let (arity,ln,lln,llne,offset,col,strbef,straft,pos,_) =
			P.id2clt _1 in
		      let clt = (* default to one space whitespace *)
			(arity,ln,lln,llne,offset,0,strbef,straft,pos," ") in
		      P.clt2mcode
			(Ast.Local (Parse_aux.str2inc (P.id2name _1)))
			(P.drop_bef clt))) )}
| _1 = TIncludeNL
    {    ( Ast0.wrap
	(Ast0.Include(P.clt2mcode "#include"
			(P.drop_pos (P.drop_aft (P.id2clt _1))),
		      let (arity,ln,lln,llne,offset,col,strbef,straft,pos,_) =
			P.id2clt _1 in
		      let clt = (* default to one space whitespace *)
			(arity,ln,lln,llne,offset,0,strbef,straft,pos," ") in
		      P.clt2mcode
			(Ast.NonLocal (Parse_aux.str2inc (P.id2name _1)))
			(P.drop_bef clt))) )}
| _1 = TUndef _2 = TLineEnd
    {    ( let (clt,ident) = _1 in
      let aft = P.get_aft clt in (* move stuff after the define to the ident *)
      Ast0.wrap
      (Ast0.Undef
	 (P.clt2mcode "#undef" (P.drop_aft clt),
	  (match ident with
	    TMetaId((nm,constraints,seed,pure,clt)) ->
	      let clt = P.set_aft aft clt in
	      Ast0.wrap(Ast0.MetaId(P.clt2mcode nm clt,constraints,seed,pure))
	  | TIdent((nm,clt)) ->
	      let clt = P.set_aft aft clt in
	      Ast0.wrap(Ast0.Id(P.clt2mcode nm clt))
	  | TSymId(nm,clt) ->
	      let clt = P.set_aft aft clt in
	      Ast0.wrap(Ast0.Id(P.clt2mcode nm clt))
	  | _ ->
	      raise
		(Semantic_cocci.Semantic
		   "unexpected name for a #define")))) )}
| d = defineop _2 = TLineEnd
    {    ( d (Ast0.wrap(Ast0.DOTS([]))) )}
| d = defineop t = ctype _3 = TLineEnd
    {    ( let ty = Ast0.wrap(Ast0.TopExp(Ast0.wrap(Ast0.TypeExp(t)))) in
      d (Ast0.wrap(Ast0.DOTS([ty]))) )}
| _1 = defineop b = toplevel_seq_start_toplevel_after_dots_ _3 = TLineEnd
    {    ( let body =
	match b with
	  [e] ->
	    (match Ast0.unwrap e with
	      Ast0.Exp(e1) ->
		[Ast0.rewrap e (Ast0.TopExp(Ast0.set_arg_exp (e1)))]
	    | _ -> b)
	| _ -> b in
      _1 (Ast0.wrap(Ast0.DOTS(body))) )}
| _1 = TPragma _2 = ident_or_kwd _3 = pragmabody _4 = TLineEnd
    {    ( Ast0.wrap(Ast0.Pragma(P.clt2mcode "#pragma" _1, _2, _3)) )}

pragmabody:
  _1 = TOPar _2 = eexpr_list_option _3 = TCPar
    {    ( Ast0.wrap(Ast0.PragmaTuple(P.clt2mcode "(" _1,_2,P.clt2mcode ")" _3)) )}
| l = nonempty_list_ident_
    {    ( Ast0.wrap(Ast0.PragmaIdList(Ast0.wrap (Ast0.DOTS l))) )}
| _1 = TEllipsis
    {            ( Ast0.wrap(Ast0.PragmaDots(P.clt2mcode "..." _1)) )}

defineop:
  _1 = TDefine
    {    ( let (clt,ident) = _1 in
      let aft = P.get_aft clt in (* move stuff after the define to the ident *)
      function body ->
	Ast0.wrap
	  (Ast0.Define
	     (P.clt2mcode "#define" (P.drop_aft clt),
	      (match ident with
		TMetaId((nm,constraints,seed,pure,clt)) ->
		  let clt = P.set_aft aft clt in
		  Ast0.wrap
		    (Ast0.MetaId(P.clt2mcode nm clt,constraints,seed,pure))
	      | TIdent((nm,clt)) ->
		  let clt = P.set_aft aft clt in
		  Ast0.wrap(Ast0.Id(P.clt2mcode nm clt))
	      | TSymId(nm,clt) ->
		  let clt = P.set_aft aft clt in
		  Ast0.wrap(Ast0.Id(P.clt2mcode nm clt))
	      | _ ->
		  raise
		    (Semantic_cocci.Semantic
		       "unexpected name for a #define")),
	      Ast0.wrap Ast0.NoParams,
	      body)) )}
| _1 = TDefineParam _2 = define_param_list_option _3 = TCPar
    {    ( let (clt,ident,parenoff,parencol) = _1 in
      let aft = P.get_aft clt in (* move stuff after the define to the ( *)
      (* clt is the start of the #define itself *)
      let (arity,line,lline,llineend,offset,col,strbef,straft,pos,ws) = clt in
      let lp =
	P.clt2mcode "("
	  (arity,line,lline,llineend,parenoff,parencol,[],[],[],"") in
      function body ->
	Ast0.wrap
	  (Ast0.Define
	     (P.clt2mcode "#define" (P.drop_aft clt),
	      (match ident with
		TMetaId((nm,constraints,seed,pure,clt)) ->
		  Ast0.wrap
		    (Ast0.MetaId(P.clt2mcode nm clt,constraints,seed,pure))
	      | TIdent((nm,clt)) ->
		  Ast0.wrap(Ast0.Id(P.clt2mcode nm clt))
	      | TSymId(nm,clt) ->
		  Ast0.wrap(Ast0.Id(P.clt2mcode nm clt))
	      | _ ->
		  raise
		    (Semantic_cocci.Semantic
		       "unexpected name for a #define")),
	      (let clt = P.set_aft aft _3 in
	      Ast0.wrap (Ast0.DParams (lp,_2,P.clt2mcode ")" clt))),body)) )}

dparam:
  _1 = mident
    {               ( Ast0.wrap(Ast0.DParam _1) )}

define_param_list_option:
  _1 = empty_list_start_dparam_TEllipsis_
    {      ( Ast0.wrap
	  (Ast0.DOTS
	     (_1
		(fun _ d -> Ast0.wrap(Ast0.DPdots(P.clt2mcode "," d)))
		(fun c -> Ast0.DPComma c))) )}

arg_list_decl_:
  
    {let arglist =
  let xs =     ( [] ) in
      ( xs )
in
     ( let (args,vararg) = cleanup_arglist arglist in
       ((Ast0.wrap (Ast0.DOTS args)), vararg) )}
| xs = reverse_separated_nonempty_llist_TComma_argorellipsis_one_arg_decl___
    {let arglist =
  let xs =     ( xs ) in
      ( xs )
in
     ( let (args,vararg) = cleanup_arglist arglist in
       ((Ast0.wrap (Ast0.DOTS args)), vararg) )}

arg_list_name_opt_decl_:
  
    {let arglist =
  let xs =     ( [] ) in
      ( xs )
in
     ( let (args,vararg) = cleanup_arglist arglist in
       ((Ast0.wrap (Ast0.DOTS args)), vararg) )}
| xs = reverse_separated_nonempty_llist_TComma_argorellipsis_one_arg_name_opt_decl___
    {let arglist =
  let xs =     ( xs ) in
      ( xs )
in
     ( let (args,vararg) = cleanup_arglist arglist in
       ((Ast0.wrap (Ast0.DOTS args)), vararg) )}

argorellipsis_one_arg_decl__:
  arg = one_arg_decl_
    {          ( Arg arg )}
| x = TVAEllipsis
    {                ( VAEllipsis (x) )}
| y = TEllipsis
    {              ( Ellipsis (y) )}

argorellipsis_one_arg_name_opt_decl__:
  arg = one_arg_name_opt_decl_
    {          ( Arg arg )}
| x = TVAEllipsis
    {                ( VAEllipsis (x) )}
| y = TEllipsis
    {              ( Ellipsis (y) )}

one_arg_decl_:
  arg = decl
    {           ( arg )}
| metaparamlist = TMetaParamList
    {    ( let (nm,lenname,pure,clt) = metaparamlist in
      let nm = P.clt2mcode nm clt in
      let lenname =
	match lenname with
	  Ast.AnyLen -> Ast0.AnyListLen
	| Ast.MetaLen nm -> Ast0.MetaListLen(P.clt2mcode nm clt)
	| Ast.CstLen n -> Ast0.CstListLen n in
      Ast0.wrap(Ast0.MetaParamList(nm,lenname,pure)) )}

one_arg_name_opt_decl_:
  arg = name_opt_decl
    {           ( arg )}
| metaparamlist = TMetaParamList
    {    ( let (nm,lenname,pure,clt) = metaparamlist in
      let nm = P.clt2mcode nm clt in
      let lenname =
	match lenname with
	  Ast.AnyLen -> Ast0.AnyListLen
	| Ast.MetaLen nm -> Ast0.MetaListLen(P.clt2mcode nm clt)
	| Ast.CstLen n -> Ast0.CstListLen n in
      Ast0.wrap(Ast0.MetaParamList(nm,lenname,pure)) )}

reverse_separated_nonempty_llist_TComma_argorellipsis_one_arg_decl___:
  x = argorellipsis_one_arg_decl__
    {    ( [ x ] )}
| xs = reverse_separated_nonempty_llist_TComma_argorellipsis_one_arg_decl___ s = TComma x = argorellipsis_one_arg_decl__
    {    ( x :: (Separator s) :: xs )}
| xs = reverse_separated_nonempty_llist_TComma_argorellipsis_one_arg_decl___ s = TComma _3 = TNothing x = argorellipsis_one_arg_decl__
    {    ( x :: Nothing :: (Separator s) :: xs )}

reverse_separated_nonempty_llist_TComma_argorellipsis_one_arg_name_opt_decl___:
  x = argorellipsis_one_arg_name_opt_decl__
    {    ( [ x ] )}
| xs = reverse_separated_nonempty_llist_TComma_argorellipsis_one_arg_name_opt_decl___ s = TComma x = argorellipsis_one_arg_name_opt_decl__
    {    ( x :: (Separator s) :: xs )}
| xs = reverse_separated_nonempty_llist_TComma_argorellipsis_one_arg_name_opt_decl___ s = TComma _3 = TNothing x = argorellipsis_one_arg_name_opt_decl__
    {    ( x :: Nothing :: (Separator s) :: xs )}

funproto:
  t = ctype id = fn_ident lp = TOPar arglist = arg_list_name_opt_decl_ rp = TCPar pt = TPtVirg
    {let i =     ( None ) in
let s =     ( None ) in
      ( let s = match s with None -> [] | Some s -> [Ast0.FStorage s] in
        let i =
	  match i with
	    None -> []
	  | Some i -> [Ast0.FInline (P.clt2mcode "inline" i)] in
	let t = [Ast0.FType t] in
        let (args,vararg) = arglist in
	Ast0.wrap
	  (Ast0.FunProto
	     (s @ i @ t, id,
	      P.clt2mcode "(" lp, args, vararg, P.clt2mcode ")" rp,
	      P.clt2mcode ";" pt)) )}
| x = Tinline t = ctype id = fn_ident lp = TOPar arglist = arg_list_name_opt_decl_ rp = TCPar pt = TPtVirg
    {let i =     ( Some x ) in
let s =     ( None ) in
      ( let s = match s with None -> [] | Some s -> [Ast0.FStorage s] in
        let i =
	  match i with
	    None -> []
	  | Some i -> [Ast0.FInline (P.clt2mcode "inline" i)] in
	let t = [Ast0.FType t] in
        let (args,vararg) = arglist in
	Ast0.wrap
	  (Ast0.FunProto
	     (s @ i @ t, id,
	      P.clt2mcode "(" lp, args, vararg, P.clt2mcode ")" rp,
	      P.clt2mcode ";" pt)) )}
| x = storage t = ctype id = fn_ident lp = TOPar arglist = arg_list_name_opt_decl_ rp = TCPar pt = TPtVirg
    {let i =     ( None ) in
let s =     ( Some x ) in
      ( let s = match s with None -> [] | Some s -> [Ast0.FStorage s] in
        let i =
	  match i with
	    None -> []
	  | Some i -> [Ast0.FInline (P.clt2mcode "inline" i)] in
	let t = [Ast0.FType t] in
        let (args,vararg) = arglist in
	Ast0.wrap
	  (Ast0.FunProto
	     (s @ i @ t, id,
	      P.clt2mcode "(" lp, args, vararg, P.clt2mcode ")" rp,
	      P.clt2mcode ";" pt)) )}
| x = storage x_inlined1 = Tinline t = ctype id = fn_ident lp = TOPar arglist = arg_list_name_opt_decl_ rp = TCPar pt = TPtVirg
    {let i =
  let x = x_inlined1 in
      ( Some x )
in
let s =     ( Some x ) in
      ( let s = match s with None -> [] | Some s -> [Ast0.FStorage s] in
        let i =
	  match i with
	    None -> []
	  | Some i -> [Ast0.FInline (P.clt2mcode "inline" i)] in
	let t = [Ast0.FType t] in
        let (args,vararg) = arglist in
	Ast0.wrap
	  (Ast0.FunProto
	     (s @ i @ t, id,
	      P.clt2mcode "(" lp, args, vararg, P.clt2mcode ")" rp,
	      P.clt2mcode ";" pt)) )}
| i = Tinline s = storage t = ctype id = fn_ident lp = TOPar arglist = arg_list_name_opt_decl_ rp = TCPar pt = TPtVirg
    {      ( let s = [Ast0.FStorage s] in
        let i = [Ast0.FInline (P.clt2mcode "inline" i)] in
	let t = [Ast0.FType t] in
        let (args,vararg) = arglist in
	Ast0.wrap
	  (Ast0.FunProto
	     (s @ i @ t, id,
	      P.clt2mcode "(" lp, args, vararg, P.clt2mcode ")" rp,
	      P.clt2mcode ";" pt)) )}

fundecl:
  f = fninfo _2 = TFunDecl i = fn_ident lp = TOPar arglist = arg_list_decl_ rp = TCPar lb = TOBrace b = fun_start rb = TCBrace
    {      ( let (args,vararg) = arglist in
        Ast0.wrap(Ast0.FunDecl((Ast0.default_info(),Ast0.context_befaft()),
			       f, i,
			       P.clt2mcode "(" (lp), args, vararg,
			       P.clt2mcode ")" rp,
			       P.clt2mcode "{" lb, b,
			       P.clt2mcode "}" rb,
			       (Ast0.default_info(),Ast0.context_befaft()))) )}

fninfo:
  
    {                ( [] )}
| _1 = storage _2 = fninfo
    {      ( try
	let _ =
	  List.find (function Ast0.FStorage(_) -> true | _ -> false) _2 in
	raise (Semantic_cocci.Semantic "duplicate storage")
      with Not_found -> (Ast0.FStorage(_1))::_2 )}
| t = ctype r = fninfo_nt
    {                        ( (Ast0.FType(t))::r )}
| _1 = Tinline _2 = fninfo
    {      ( try
	let _ = List.find (function Ast0.FInline(_) -> true | _ -> false) _2 in
	raise (Semantic_cocci.Semantic "duplicate inline")
      with Not_found -> (Ast0.FInline(P.clt2mcode "inline" _1))::_2 )}
| _1 = Tattr _2 = fninfo
    {      ( try
	let _ = List.find (function Ast0.FAttr(_) -> true | _ -> false) _2 in
	raise (Semantic_cocci.Semantic "multiple attributes")
      with Not_found -> (Ast0.FAttr(P.id2mcode _1))::_2 )}

fninfo_nt:
  
    {                ( [] )}
| _1 = storage _2 = fninfo_nt
    {      ( try
	let _ =
	  List.find (function Ast0.FStorage(_) -> true | _ -> false) _2 in
	raise (Semantic_cocci.Semantic "duplicate storage")
      with Not_found -> (Ast0.FStorage(_1))::_2 )}
| _1 = Tinline _2 = fninfo_nt
    {      ( try
	let _ = List.find (function Ast0.FInline(_) -> true | _ -> false) _2 in
	raise (Semantic_cocci.Semantic "duplicate inline")
      with Not_found -> (Ast0.FInline(P.clt2mcode "inline" _1))::_2 )}
| _1 = Tattr _2 = fninfo_nt
    {      ( try
	let _ = List.find (function Ast0.FAttr(_) -> true | _ -> false) _2 in
	raise (Semantic_cocci.Semantic "duplicate init")
      with Not_found -> (Ast0.FAttr(P.id2mcode _1))::_2 )}

storage:
  s = Tstatic
    {                        ( P.clt2mcode Ast.Static s )}
| s = Tauto
    {                        ( P.clt2mcode Ast.Auto s )}
| s = Tregister
    {                        ( P.clt2mcode Ast.Register s )}
| s = Textern
    {                        ( P.clt2mcode Ast.Extern s )}

decl:
  t = ctype i = disj_ident a = list_array_dec_
    { ( let t = P.arrayify t a in Ast0.wrap(Ast0.Param(t, Some i)) )}
| t = ctype
    {              ( (*verify in FunDecl*) Ast0.wrap(Ast0.Param(t, None)) )}
| t = ctype lp = TOPar s = TMul i = disj_ident rp = TCPar lp1 = TOPar d = decl_list_name_opt_decl_ rp1 = TCPar
    {        ( let fnptr =
	  Ast0.wrap
	    (Ast0.FunctionPointer
	       (t,P.clt2mcode "(" lp,P.clt2mcode "*" s,P.clt2mcode ")" rp,
		P.clt2mcode "(" lp1,d,P.clt2mcode ")" rp1)) in
	Ast0.wrap(Ast0.Param(fnptr, Some i)) )}
| _1 = TMetaParam
    { ( let (nm,pure,clt) = _1 in
	Ast0.wrap(Ast0.MetaParam(P.clt2mcode nm clt,pure)) )}
| _1 = TMeta
    {            ( tmeta_to_param _1 )}

name_opt_decl:
  _1 = decl
    {            ( _1 )}
| t = ctype lp = TOPar s = TMul rp = TCPar lp1 = TOPar d = decl_list_name_opt_decl_ rp1 = TCPar
    {        ( let fnptr =
	  Ast0.wrap
	    (Ast0.FunctionPointer
	       (t,P.clt2mcode "(" lp,P.clt2mcode "*" s,P.clt2mcode ")" rp,
		P.clt2mcode "(" lp1,d,P.clt2mcode ")" rp1)) in
	Ast0.wrap(Ast0.Param(fnptr, None)) )}

const_vol:
  _1 = Tconst
    {                   ( P.clt2mcode Ast.Const _1 )}
| _1 = Tvolatile
    {                   ( P.clt2mcode Ast.Volatile _1 )}

statement:
  _1 = includes
    {           ( _1 )}
| _1 = TMeta
    {        ( tmeta_to_statement _1)}
| _1 = TMetaStm
    {    ( P.meta_stm _1 )}
| _1 = option_expr_ _2 = TPtVirg
    {    ( P.exp_stm _1 _2 )}
| _1 = TIf _2 = TOPar _3 = eexpr _4 = TCPar _5 = single_statement %prec TIf
    {    ( P.ifthen _1 _2 _3 _4 _5 )}
| _1 = TIf _2 = TOPar _3 = eexpr _4 = TCPar _5 = single_statement _6 = TElse _7 = single_statement
    {    ( P.ifthenelse _1 _2 _3 _4 _5 _6 _7 )}
| _1 = TFor _2 = TOPar _3 = option_eexpr_ _4 = TPtVirg _5 = option_eexpr_ _6 = TPtVirg _7 = option_eexpr_ _8 = TCPar _9 = single_statement
    {    ( P.forloop _1 _2 _3 _4 _5 _6 _7 _8 _9 )}
| _1 = TFor _2 = TOPar _3 = one_decl_var _4 = option_eexpr_ _5 = TPtVirg _6 = option_eexpr_ _7 = TCPar _8 = single_statement
    {    ( P.forloop2 _1 _2 _3 _4 _5 _6 _7 _8 )}
| _1 = TWhile _2 = TOPar _3 = eexpr _4 = TCPar _5 = single_statement
    {    ( P.whileloop _1 _2 _3 _4 _5 )}
| _1 = TDo _2 = single_statement _3 = TWhile _4 = TOPar _5 = eexpr _6 = TCPar _7 = TPtVirg
    {    ( P.doloop _1 _2 _3 _4 _5 _6 _7 )}
| _1 = iter_ident _2 = TOPar _3 = eexpr_list_option _4 = TCPar _5 = single_statement
    {    ( P.iterator _1 _2 _3 _4 _5 )}
| _1 = TSwitch _2 = TOPar _3 = eexpr _4 = TCPar _5 = TOBrace _6 = list_decl_var_ _7 = list_case_line_ _8 = TCBrace
    {    ( P.switch _1 _2 _3 _4 _5 (List.concat _6) _7 _8 )}
| _1 = TReturn _2 = eexpr _3 = TPtVirg
    {                        ( P.ret_exp _1 _2 _3 )}
| _1 = TReturn _2 = TPtVirg
    {                  ( P.ret _1 _2 )}
| _1 = TBreak _2 = TPtVirg
    {                 ( P.break _1 _2 )}
| _1 = TContinue _2 = TPtVirg
    {                    ( P.cont _1 _2 )}
| _1 = mident _2 = TDotDot
    {                 ( P.label _1 _2 )}
| _1 = TGoto _2 = disj_ident _3 = TPtVirg
    {                           ( P.goto _1 _2 _3 )}
| _1 = TOBrace _2 = fun_start _3 = TCBrace
    {    ( P.seq _1 _2 _3 )}
| _1 = Texec _2 = TIdent _3 = exec_list _4 = TPtVirg
    {    ( Ast0.wrap(
      Ast0.Exec(P.clt2mcode "EXEC" _1,P.clt2mcode (fst _2) (snd _2),
		Ast0.wrap(Ast0.DOTS _3),P.clt2mcode ";" _4)) )}

stm_dots:
  _1 = TEllipsis w = list_whenppdecs_
    {    ( Ast0.wrap(Ast0.Dots(P.clt2mcode "..." _1, List.concat w)) )}
| _1 = TOEllipsis w = list_whenppdecs_ b = nest_start c = TCEllipsis
    {    ( Ast0.wrap(Ast0.Nest(P.clt2mcode "<..." _1, b,
			  P.clt2mcode "...>" c, List.concat w, false)) )}
| _1 = TPOEllipsis w = list_whenppdecs_ b = nest_start c = TPCEllipsis
    {    ( Ast0.wrap(Ast0.Nest(P.clt2mcode "<+..." _1, b,
			  P.clt2mcode "...+>" c, List.concat w, true)) )}

whenppdecs:
  w = whens_when_start_rule_elem_statement_any_strict_
    {    ( w )}

rule_elem_statement:
  _1 = one_decl_var
    {    ( Ast0.wrap(Ast0.Decl((Ast0.default_info(),Ast0.context_befaft()),_1)) )}
| _1 = option_expr_ _2 = TPtVirg
    {                       ( P.exp_stm _1 _2 )}
| _1 = TReturn _2 = eexpr _3 = TPtVirg
    {                        ( P.ret_exp _1 _2 _3 )}
| _1 = TReturn _2 = TPtVirg
    {                  ( P.ret _1 _2 )}
| _1 = TBreak _2 = TPtVirg
    {                 ( P.break _1 _2 )}
| _1 = TContinue _2 = TPtVirg
    {                    ( P.cont _1 _2 )}
| _1 = TOPar0 _2 = midzero_list_rule_elem_statement_rule_elem_statement_ _3 = TCPar0
    {    ( let (mids,code) = _2 in
    Ast0.wrap
      (Ast0.Disj(P.id2mcode _1,
		 List.map (function x -> Ast0.wrap(Ast0.DOTS([x]))) code,
		 mids, P.id2mcode _3)) )}

single_statement:
  _1 = statement
    {                                      ( _1 )}
| _1 = TOPar0 _2 = midzero_list_statement_statement_ _3 = TCPar0
    {      ( let (mids,code) = _2 in
        Ast0.wrap
	  (Ast0.Disj(P.id2mcode _1,
		     List.map (function x -> Ast0.wrap(Ast0.DOTS([x]))) code,
		     mids, P.id2mcode _3)) )}

iso_statement:
  _1 = statement
    {                                      ( _1 )}
| _1 = decl_var
    {      ( match _1 with
	[decl] ->
	  Ast0.wrap
	    (Ast0.Decl((Ast0.default_info(),Ast0.context_befaft()),decl))
      |	_ -> failwith "exactly one decl allowed in statement iso" )}

case_line:
  _1 = TDefault _2 = TDotDot _3 = fun_start
    {      ( Ast0.wrap
	  (Ast0.Default(P.clt2mcode "default" _1,P.clt2mcode ":" _2,_3)) )}
| _1 = TCase _2 = eexpr _3 = TDotDot _4 = fun_start
    {      ( Ast0.wrap(Ast0.Case(P.clt2mcode "case" _1,_2,P.clt2mcode ":" _3,_4)) )}

decl_var:
  t = ctype pv = TPtVirg
    {      ( [Ast0.wrap(Ast0.TyDecl(t,P.clt2mcode ";" pv))] )}
| _1 = TMetaDecl
    {              ( [P.meta_decl _1] )}
| t = ctype l = separated_nonempty_list_TComma_d_ident_ pv = TPtVirg
    {let d =                                          ( l ) in
let s =     ( None ) in
      ( List.map
	  (function (id,fn) ->
	    Ast0.wrap(Ast0.UnInit(s,fn t,id,P.clt2mcode ";" pv)))
	  d )}
| x = storage t = ctype l = separated_nonempty_list_TComma_d_ident_ pv = TPtVirg
    {let d =                                          ( l ) in
let s =     ( Some x ) in
      ( List.map
	  (function (id,fn) ->
	    Ast0.wrap(Ast0.UnInit(s,fn t,id,P.clt2mcode ";" pv)))
	  d )}
| f = funproto
    {               ( [f] )}
| t = ctype d = d_ident q = TEq e = initialize pv = TPtVirg
    {let s =     ( None ) in
      (let (id,fn) = d in
      [Ast0.wrap(Ast0.Init(s,fn t,id,P.clt2mcode "=" q,e,P.clt2mcode ";" pv))])}
| x = storage t = ctype d = d_ident q = TEq e = initialize pv = TPtVirg
    {let s =     ( Some x ) in
      (let (id,fn) = d in
      [Ast0.wrap(Ast0.Init(s,fn t,id,P.clt2mcode "=" q,e,P.clt2mcode ";" pv))])}
| i = pure_ident_or_symbol l = separated_nonempty_list_TComma_d_ident_ pv = TPtVirg
    {let d =                                          ( l ) in
let cv =     ( None ) in
let s =     ( None ) in
      ( List.map
	  (function (id,fn) ->
	    let idtype =
	      P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
	    Ast0.wrap(Ast0.UnInit(s,fn idtype,id,P.clt2mcode ";" pv)))
	  d )}
| x = const_vol i = pure_ident_or_symbol l = separated_nonempty_list_TComma_d_ident_ pv = TPtVirg
    {let d =                                          ( l ) in
let cv =     ( Some x ) in
let s =     ( None ) in
      ( List.map
	  (function (id,fn) ->
	    let idtype =
	      P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
	    Ast0.wrap(Ast0.UnInit(s,fn idtype,id,P.clt2mcode ";" pv)))
	  d )}
| x = storage i = pure_ident_or_symbol l = separated_nonempty_list_TComma_d_ident_ pv = TPtVirg
    {let d =                                          ( l ) in
let cv =     ( None ) in
let s =     ( Some x ) in
      ( List.map
	  (function (id,fn) ->
	    let idtype =
	      P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
	    Ast0.wrap(Ast0.UnInit(s,fn idtype,id,P.clt2mcode ";" pv)))
	  d )}
| x = storage x_inlined1 = const_vol i = pure_ident_or_symbol l = separated_nonempty_list_TComma_d_ident_ pv = TPtVirg
    {let d =                                          ( l ) in
let cv =
  let x = x_inlined1 in
      ( Some x )
in
let s =     ( Some x ) in
      ( List.map
	  (function (id,fn) ->
	    let idtype =
	      P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
	    Ast0.wrap(Ast0.UnInit(s,fn idtype,id,P.clt2mcode ";" pv)))
	  d )}
| i = pure_ident_or_symbol d = d_ident q = TEq e = initialize pv = TPtVirg
    {let cv =     ( None ) in
let s =     ( None ) in
      ( let (id,fn) = d in
      !Data.add_type_name (P.id2name i);
      let idtype = P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
      [Ast0.wrap(Ast0.Init(s,fn idtype,id,P.clt2mcode "=" q,e,
			   P.clt2mcode ";" pv))] )}
| x = const_vol i = pure_ident_or_symbol d = d_ident q = TEq e = initialize pv = TPtVirg
    {let cv =     ( Some x ) in
let s =     ( None ) in
      ( let (id,fn) = d in
      !Data.add_type_name (P.id2name i);
      let idtype = P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
      [Ast0.wrap(Ast0.Init(s,fn idtype,id,P.clt2mcode "=" q,e,
			   P.clt2mcode ";" pv))] )}
| x = storage i = pure_ident_or_symbol d = d_ident q = TEq e = initialize pv = TPtVirg
    {let cv =     ( None ) in
let s =     ( Some x ) in
      ( let (id,fn) = d in
      !Data.add_type_name (P.id2name i);
      let idtype = P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
      [Ast0.wrap(Ast0.Init(s,fn idtype,id,P.clt2mcode "=" q,e,
			   P.clt2mcode ";" pv))] )}
| x = storage x_inlined1 = const_vol i = pure_ident_or_symbol d = d_ident q = TEq e = initialize pv = TPtVirg
    {let cv =
  let x = x_inlined1 in
      ( Some x )
in
let s =     ( Some x ) in
      ( let (id,fn) = d in
      !Data.add_type_name (P.id2name i);
      let idtype = P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
      [Ast0.wrap(Ast0.Init(s,fn idtype,id,P.clt2mcode "=" q,e,
			   P.clt2mcode ";" pv))] )}
| t = ctype lp1 = TOPar st = TMul d = d_ident rp1 = TCPar lp2 = TOPar p = decl_list_name_opt_decl_ rp2 = TCPar pv = TPtVirg
    {let s =     ( None ) in
      ( let (id,fn) = d in
        let t =
	  Ast0.wrap
	    (Ast0.FunctionPointer
	       (t,P.clt2mcode "(" lp1,P.clt2mcode "*" st,P.clt2mcode ")" rp1,
		P.clt2mcode "(" lp2,p,P.clt2mcode ")" rp2)) in
        [Ast0.wrap(Ast0.UnInit(s,fn t,id,P.clt2mcode ";" pv))] )}
| x = storage t = ctype lp1 = TOPar st = TMul d = d_ident rp1 = TCPar lp2 = TOPar p = decl_list_name_opt_decl_ rp2 = TCPar pv = TPtVirg
    {let s =     ( Some x ) in
      ( let (id,fn) = d in
        let t =
	  Ast0.wrap
	    (Ast0.FunctionPointer
	       (t,P.clt2mcode "(" lp1,P.clt2mcode "*" st,P.clt2mcode ")" rp1,
		P.clt2mcode "(" lp2,p,P.clt2mcode ")" rp2)) in
        [Ast0.wrap(Ast0.UnInit(s,fn t,id,P.clt2mcode ";" pv))] )}
| d = decl_ident o = TOPar e = eexpr_list_option c = TCPar p = TPtVirg
    {let s =     ( None ) in
      ( [Ast0.wrap(Ast0.MacroDecl(s,d,P.clt2mcode "(" o,e,
				  P.clt2mcode ")" c,P.clt2mcode ";" p))] )}
| x = storage d = decl_ident o = TOPar e = eexpr_list_option c = TCPar p = TPtVirg
    {let s =     ( Some x ) in
      ( [Ast0.wrap(Ast0.MacroDecl(s,d,P.clt2mcode "(" o,e,
				  P.clt2mcode ")" c,P.clt2mcode ";" p))] )}
| d = decl_ident o = TOPar e = eexpr_list_option c = TCPar q = TEq i = initialize p = TPtVirg
    {let s =     ( None ) in
      ( [Ast0.wrap
	    (Ast0.MacroDeclInit
	       (s,d,P.clt2mcode "(" o,e,
		P.clt2mcode ")" c,P.clt2mcode "=" q,i,
		P.clt2mcode ";" p))] )}
| x = storage d = decl_ident o = TOPar e = eexpr_list_option c = TCPar q = TEq i = initialize p = TPtVirg
    {let s =     ( Some x ) in
      ( [Ast0.wrap
	    (Ast0.MacroDeclInit
	       (s,d,P.clt2mcode "(" o,e,
		P.clt2mcode ")" c,P.clt2mcode "=" q,i,
		P.clt2mcode ";" p))] )}
| t = ctype lp1 = TOPar st = TMul d = d_ident rp1 = TCPar lp2 = TOPar p = decl_list_name_opt_decl_ rp2 = TCPar q = TEq e = initialize pv = TPtVirg
    {let s =     ( None ) in
      ( let (id,fn) = d in
        let t =
	  Ast0.wrap
	    (Ast0.FunctionPointer
	       (t,P.clt2mcode "(" lp1,P.clt2mcode "*" st,P.clt2mcode ")" rp1,
		P.clt2mcode "(" lp2,p,P.clt2mcode ")" rp2)) in
      [Ast0.wrap(Ast0.Init(s,fn t,id,P.clt2mcode "=" q,e,P.clt2mcode ";" pv))])}
| x = storage t = ctype lp1 = TOPar st = TMul d = d_ident rp1 = TCPar lp2 = TOPar p = decl_list_name_opt_decl_ rp2 = TCPar q = TEq e = initialize pv = TPtVirg
    {let s =     ( Some x ) in
      ( let (id,fn) = d in
        let t =
	  Ast0.wrap
	    (Ast0.FunctionPointer
	       (t,P.clt2mcode "(" lp1,P.clt2mcode "*" st,P.clt2mcode ")" rp1,
		P.clt2mcode "(" lp2,p,P.clt2mcode ")" rp2)) in
      [Ast0.wrap(Ast0.Init(s,fn t,id,P.clt2mcode "=" q,e,P.clt2mcode ";" pv))])}
| s = Ttypedef t = typedef_ctype l = separated_nonempty_list_TComma_typedef_ident_ pv = TPtVirg
    {let id =                                          ( l ) in
      ( let s = P.clt2mcode "typedef" s in
        List.map
	  (function id ->
	    Ast0.wrap(Ast0.Typedef(s,t,id,P.clt2mcode ";" pv)))
	  id )}

one_decl_var:
  t = ctype pv = TPtVirg
    {      ( Ast0.wrap(Ast0.TyDecl(t,P.clt2mcode ";" pv)) )}
| _1 = TMetaDecl
    {              ( P.meta_decl _1 )}
| t = ctype d = d_ident pv = TPtVirg
    {let s =     ( None ) in
      ( let (id,fn) = d in
        Ast0.wrap(Ast0.UnInit(s,fn t,id,P.clt2mcode ";" pv)) )}
| x = storage t = ctype d = d_ident pv = TPtVirg
    {let s =     ( Some x ) in
      ( let (id,fn) = d in
        Ast0.wrap(Ast0.UnInit(s,fn t,id,P.clt2mcode ";" pv)) )}
| f = funproto
    {               ( f )}
| t = ctype d = d_ident q = TEq e = initialize pv = TPtVirg
    {let s =     ( None ) in
      ( let (id,fn) = d in
      Ast0.wrap(Ast0.Init(s,fn t,id,P.clt2mcode "=" q,e,P.clt2mcode ";" pv)) )}
| x = storage t = ctype d = d_ident q = TEq e = initialize pv = TPtVirg
    {let s =     ( Some x ) in
      ( let (id,fn) = d in
      Ast0.wrap(Ast0.Init(s,fn t,id,P.clt2mcode "=" q,e,P.clt2mcode ";" pv)) )}
| i = pure_ident_or_symbol d = d_ident pv = TPtVirg
    {let cv =     ( None ) in
let s =     ( None ) in
      ( let (id,fn) = d in
        let idtype = P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
	Ast0.wrap(Ast0.UnInit(s,fn idtype,id,P.clt2mcode ";" pv)) )}
| x = const_vol i = pure_ident_or_symbol d = d_ident pv = TPtVirg
    {let cv =     ( Some x ) in
let s =     ( None ) in
      ( let (id,fn) = d in
        let idtype = P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
	Ast0.wrap(Ast0.UnInit(s,fn idtype,id,P.clt2mcode ";" pv)) )}
| x = storage i = pure_ident_or_symbol d = d_ident pv = TPtVirg
    {let cv =     ( None ) in
let s =     ( Some x ) in
      ( let (id,fn) = d in
        let idtype = P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
	Ast0.wrap(Ast0.UnInit(s,fn idtype,id,P.clt2mcode ";" pv)) )}
| x = storage x_inlined1 = const_vol i = pure_ident_or_symbol d = d_ident pv = TPtVirg
    {let cv =
  let x = x_inlined1 in
      ( Some x )
in
let s =     ( Some x ) in
      ( let (id,fn) = d in
        let idtype = P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
	Ast0.wrap(Ast0.UnInit(s,fn idtype,id,P.clt2mcode ";" pv)) )}
| i = pure_ident_or_symbol d = d_ident q = TEq e = initialize pv = TPtVirg
    {let cv =     ( None ) in
let s =     ( None ) in
      ( let (id,fn) = d in
      !Data.add_type_name (P.id2name i);
      let idtype = P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
      Ast0.wrap(Ast0.Init(s,fn idtype,id,P.clt2mcode "=" q,e,
			   P.clt2mcode ";" pv)) )}
| x = const_vol i = pure_ident_or_symbol d = d_ident q = TEq e = initialize pv = TPtVirg
    {let cv =     ( Some x ) in
let s =     ( None ) in
      ( let (id,fn) = d in
      !Data.add_type_name (P.id2name i);
      let idtype = P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
      Ast0.wrap(Ast0.Init(s,fn idtype,id,P.clt2mcode "=" q,e,
			   P.clt2mcode ";" pv)) )}
| x = storage i = pure_ident_or_symbol d = d_ident q = TEq e = initialize pv = TPtVirg
    {let cv =     ( None ) in
let s =     ( Some x ) in
      ( let (id,fn) = d in
      !Data.add_type_name (P.id2name i);
      let idtype = P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
      Ast0.wrap(Ast0.Init(s,fn idtype,id,P.clt2mcode "=" q,e,
			   P.clt2mcode ";" pv)) )}
| x = storage x_inlined1 = const_vol i = pure_ident_or_symbol d = d_ident q = TEq e = initialize pv = TPtVirg
    {let cv =
  let x = x_inlined1 in
      ( Some x )
in
let s =     ( Some x ) in
      ( let (id,fn) = d in
      !Data.add_type_name (P.id2name i);
      let idtype = P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
      Ast0.wrap(Ast0.Init(s,fn idtype,id,P.clt2mcode "=" q,e,
			   P.clt2mcode ";" pv)) )}
| t = ctype lp1 = TOPar st = TMul d = d_ident rp1 = TCPar lp2 = TOPar p = decl_list_name_opt_decl_ rp2 = TCPar pv = TPtVirg
    {let s =     ( None ) in
      ( let (id,fn) = d in
        let t =
	  Ast0.wrap
	    (Ast0.FunctionPointer
	       (t,P.clt2mcode "(" lp1,P.clt2mcode "*" st,P.clt2mcode ")" rp1,
		P.clt2mcode "(" lp2,p,P.clt2mcode ")" rp2)) in
        Ast0.wrap(Ast0.UnInit(s,fn t,id,P.clt2mcode ";" pv)) )}
| x = storage t = ctype lp1 = TOPar st = TMul d = d_ident rp1 = TCPar lp2 = TOPar p = decl_list_name_opt_decl_ rp2 = TCPar pv = TPtVirg
    {let s =     ( Some x ) in
      ( let (id,fn) = d in
        let t =
	  Ast0.wrap
	    (Ast0.FunctionPointer
	       (t,P.clt2mcode "(" lp1,P.clt2mcode "*" st,P.clt2mcode ")" rp1,
		P.clt2mcode "(" lp2,p,P.clt2mcode ")" rp2)) in
        Ast0.wrap(Ast0.UnInit(s,fn t,id,P.clt2mcode ";" pv)) )}
| d = decl_ident o = TOPar e = eexpr_list_option c = TCPar p = TPtVirg
    {let s =     ( None ) in
      ( Ast0.wrap(Ast0.MacroDecl(s,d,P.clt2mcode "(" o,e,
				  P.clt2mcode ")" c,P.clt2mcode ";" p)) )}
| x = storage d = decl_ident o = TOPar e = eexpr_list_option c = TCPar p = TPtVirg
    {let s =     ( Some x ) in
      ( Ast0.wrap(Ast0.MacroDecl(s,d,P.clt2mcode "(" o,e,
				  P.clt2mcode ")" c,P.clt2mcode ";" p)) )}
| d = decl_ident o = TOPar e = eexpr_list_option c = TCPar q = TEq i = initialize p = TPtVirg
    {let s =     ( None ) in
      ( Ast0.wrap
            (Ast0.MacroDeclInit
               (s,d,P.clt2mcode "(" o,e,
                P.clt2mcode ")" c,P.clt2mcode "=" q,i,
                P.clt2mcode ";" p)) )}
| x = storage d = decl_ident o = TOPar e = eexpr_list_option c = TCPar q = TEq i = initialize p = TPtVirg
    {let s =     ( Some x ) in
      ( Ast0.wrap
            (Ast0.MacroDeclInit
               (s,d,P.clt2mcode "(" o,e,
                P.clt2mcode ")" c,P.clt2mcode "=" q,i,
                P.clt2mcode ";" p)) )}
| t = ctype lp1 = TOPar st = TMul d = d_ident rp1 = TCPar lp2 = TOPar p = decl_list_name_opt_decl_ rp2 = TCPar q = TEq e = initialize pv = TPtVirg
    {let s =     ( None ) in
      ( let (id,fn) = d in
        let t =
	  Ast0.wrap
	    (Ast0.FunctionPointer
	       (t,P.clt2mcode "(" lp1,P.clt2mcode "*" st,P.clt2mcode ")" rp1,
		P.clt2mcode "(" lp2,p,P.clt2mcode ")" rp2)) in
      Ast0.wrap(Ast0.Init(s,fn t,id,P.clt2mcode "=" q,e,P.clt2mcode ";" pv)))}
| x = storage t = ctype lp1 = TOPar st = TMul d = d_ident rp1 = TCPar lp2 = TOPar p = decl_list_name_opt_decl_ rp2 = TCPar q = TEq e = initialize pv = TPtVirg
    {let s =     ( Some x ) in
      ( let (id,fn) = d in
        let t =
	  Ast0.wrap
	    (Ast0.FunctionPointer
	       (t,P.clt2mcode "(" lp1,P.clt2mcode "*" st,P.clt2mcode ")" rp1,
		P.clt2mcode "(" lp2,p,P.clt2mcode ")" rp2)) in
      Ast0.wrap(Ast0.Init(s,fn t,id,P.clt2mcode "=" q,e,P.clt2mcode ";" pv)))}

d_ident:
  _1 = disj_ident _2 = list_array_dec_
    {      ( (_1, function t -> P.arrayify t _2) )}

array_dec:
  l = TOCro i = option_eexpr_ r = TCCro
    {                                           ( (l,i,r) )}

initialize:
  _1 = eexpr
    {      ( Ast0.wrap(Ast0.InitExpr(_1)) )}
| _1 = TOBrace _2 = initialize_list _3 = TCBrace
    {    ( if P.struct_initializer _2
    then
      let il = P.drop_dot_commas _2 in
      Ast0.wrap(Ast0.InitList(P.clt2mcode "{" _1,il,P.clt2mcode "}" _3,false))
    else
      Ast0.wrap(Ast0.InitList(P.clt2mcode "{" _1,_2,P.clt2mcode "}" _3,true)) )}
| _1 = TMetaInit
    {      (let (nm,pure,clt) = _1 in
      Ast0.wrap(Ast0.MetaInit(P.clt2mcode nm clt,pure)) )}

initialize2:
  _1 = arith_expr_eexpr_invalid_
    {                            ( Ast0.wrap(Ast0.InitExpr(_1)) )}
| _1 = nest_expressions_only
    {                            ( Ast0.wrap(Ast0.InitExpr(_1)) )}
| _1 = TOBrace _2 = initialize_list _3 = TCBrace
    {    ( if P.struct_initializer _2
    then
      let il = P.drop_dot_commas _2 in
      Ast0.wrap(Ast0.InitList(P.clt2mcode "{" _1,il,P.clt2mcode "}" _3,false))
    else
      Ast0.wrap(Ast0.InitList(P.clt2mcode "{" _1,_2,P.clt2mcode "}" _3,true)) )}
| _1 = list_designator_ _2 = TEq _3 = initialize2
    {    ( Ast0.wrap(Ast0.InitGccExt(_1,P.clt2mcode "=" _2,_3)) )}
| _1 = mident _2 = TDotDot _3 = initialize2
    {    ( Ast0.wrap(Ast0.InitGccName(_1,P.clt2mcode ":" _2,_3)) )}
| _1 = TMetaInit
    {      (let (nm,pure,clt) = _1 in
      Ast0.wrap(Ast0.MetaInit(P.clt2mcode nm clt,pure)) )}
| _1 = TMetaInitList
    {      (let (nm,lenname,pure,clt) = _1 in
      let nm = P.clt2mcode nm clt in
      let lenname =
	match lenname with
	  Ast.AnyLen -> Ast0.AnyListLen
	| Ast.MetaLen nm -> Ast0.MetaListLen(P.clt2mcode nm clt)
	| Ast.CstLen n -> Ast0.CstListLen n in
      Ast0.wrap(Ast0.MetaInitList(nm,lenname,pure)) )}

designator:
  _1 = TDot _2 = disj_ident
    {     ( Ast0.DesignatorField (P.clt2mcode "." _1,_2) )}
| _1 = TOCro _2 = eexpr _3 = TCCro
    {     ( Ast0.DesignatorIndex (P.clt2mcode "[" _1,_2,P.clt2mcode "]" _3) )}
| _1 = TOCro _2 = eexpr _3 = TEllipsis _4 = eexpr _5 = TCCro
    {     ( Ast0.DesignatorRange (P.clt2mcode "[" _1,_2,P.clt2mcode "..." _3,
			     _4,P.clt2mcode "]" _5) )}

initialize_list:
  _1 = empty_list_start_initialize2_edots_when_TEllipsis_initialize__
    {     ( Ast0.wrap(Ast0.DOTS(_1 P.mkidots (fun c -> Ast0.IComma c))) )}

decl_statement:
  _1 = TMetaStmList
    {      ( let (nm,pure,clt) = _1 in
      [Ast0.wrap(Ast0.MetaStmt(P.clt2mcode nm clt,pure))] )}
| _1 = decl_var
    {      ( List.map
	  (function x ->
	    Ast0.wrap
	      (Ast0.Decl((Ast0.default_info(),Ast0.context_befaft()),x)))
	  _1 )}
| _1 = statement
    {              ( [_1] )}
| _1 = TOPar0 t = midzero_list_fun_start_fun_start_ _3 = TCPar0
    {      ( let (mids,code) = t in
	if List.for_all
	    (function x ->
	      match Ast0.unwrap x with Ast0.DOTS([]) -> true | _ -> false)
	    code
      then []
      else
	  [Ast0.wrap(Ast0.Disj(P.id2mcode _1, code, mids,
			       P.id2mcode _3))] )}

decl_statement_expr:
  _1 = TMetaStmList
    {      ( let (nm,pure,clt) = _1 in
      [Ast0.wrap(Ast0.MetaStmt(P.clt2mcode nm clt,pure))] )}
| _1 = decl_var
    {      ( List.map
	  (function x ->
	    Ast0.wrap
	      (Ast0.Decl((Ast0.default_info(),Ast0.context_befaft()),x)))
	  _1 )}
| _1 = statement
    {              ( [_1] )}
| _1 = TOPar0 t = midzero_list_fun_after_stm_fun_after_dots_or_ _3 = TCPar0
    {      ( let (mids,code) = t in
	if List.for_all (function [] -> true | _ -> false) code
      then []
      else
	  let dot_code =
	    List.map (function x -> Ast0.wrap(Ast0.DOTS x)) code in
	  [Ast0.wrap(Ast0.Disj(P.id2mcode _1, dot_code, mids,
			       P.id2mcode _3))] )}

expr:
  _1 = pre_basic_expr_expr_invalid_
    {                                    ( _1 )}

eexpr:
  _1 = pre_basic_expr_eexpr_dot_expressions_
    {                                             ( _1 )}

eargexpr:
  _1 = basic_expr_eexpr_dot_expressions_
    {                                            ( _1 )}

dexpr:
  _1 = pre_basic_expr_eexpr_nest_expressions_
    {                                              ( _1 )}

dargexpr:
  _1 = basic_expr_eexpr_nest_expressions_
    {                                             ( _1 )}

top_eexpr:
  _1 = eexpr
    {        ( Ast0.wrap(Ast0.OTHER(Ast0.wrap(Ast0.Exp(_1)))) )}

invalid:
  _1 = TInvalid
    {           ( raise (Semantic_cocci.Semantic "not matchable") )}

dot_expressions:
  _1 = TEllipsis
    {            ( Ast0.wrap(Ast0.Edots(P.clt2mcode "..." _1,None)) )}
| _1 = nest_expressions
    {                   ( _1 )}

nest_expressions:
  _1 = TOEllipsis e = expr_dots_TEllipsis_ c = TCEllipsis
    {    ( Ast0.wrap(Ast0.NestExpr(P.clt2mcode "<..." _1,
			      Ast0.wrap(Ast0.DOTS(e (P.mkedots "..."))),
			      P.clt2mcode "...>" c, None, false)) )}
| _1 = TPOEllipsis e = expr_dots_TEllipsis_ c = TPCEllipsis
    {    ( Ast0.wrap(Ast0.NestExpr(P.clt2mcode "<+..." _1,
			      Ast0.wrap(Ast0.DOTS(e (P.mkedots "..."))),
			      P.clt2mcode "...+>" c, None, true)) )}
| _1 = TMeta
    {        ( tmeta_to_exp _1 )}

nest_expressions_only:
  _1 = TOEllipsis e = expr_dots_TEllipsis_ c = TCEllipsis
    {    ( Ast0.wrap(Ast0.NestExpr(P.clt2mcode "<..." _1,
			      Ast0.wrap(Ast0.DOTS(e (P.mkedots "..."))),
			      P.clt2mcode "...>" c, None, false)) )}
| _1 = TPOEllipsis e = expr_dots_TEllipsis_ c = TPCEllipsis
    {    ( Ast0.wrap(Ast0.NestExpr(P.clt2mcode "<+..." _1,
			      Ast0.wrap(Ast0.DOTS(e (P.mkedots "..."))),
			      P.clt2mcode "...+>" c, None, true)) )}

pre_basic_expr_eexpr_dot_expressions_:
  _1 = basic_expr_eexpr_dot_expressions_
    {                                                          ( _1 )}
| _1 = pre_basic_expr_eexpr_dot_expressions_ _2 = TComma _3 = basic_expr_eexpr_dot_expressions_
    {     ( Ast0.wrap(Ast0.Sequence(_1,P.clt2mcode "," _2,_3)) )}

pre_basic_expr_eexpr_nest_expressions_:
  _1 = basic_expr_eexpr_nest_expressions_
    {                                                          ( _1 )}
| _1 = pre_basic_expr_eexpr_nest_expressions_ _2 = TComma _3 = basic_expr_eexpr_nest_expressions_
    {     ( Ast0.wrap(Ast0.Sequence(_1,P.clt2mcode "," _2,_3)) )}

pre_basic_expr_expr_invalid_:
  _1 = basic_expr_expr_invalid_
    {                                                          ( _1 )}
| _1 = pre_basic_expr_expr_invalid_ _2 = TComma _3 = basic_expr_expr_invalid_
    {     ( Ast0.wrap(Ast0.Sequence(_1,P.clt2mcode "," _2,_3)) )}

basic_expr_eexpr_dot_expressions_:
  _1 = assign_expr_eexpr_dot_expressions_
    {                                                           ( _1 )}

basic_expr_eexpr_nest_expressions_:
  _1 = assign_expr_eexpr_nest_expressions_
    {                                                           ( _1 )}

basic_expr_expr_invalid_:
  _1 = assign_expr_expr_invalid_
    {                                                           ( _1 )}

assign_expr_eexpr_dot_expressions_:
  _1 = cond_expr_eexpr_dot_expressions_
    {                                           ( _1 )}
| _1 = unary_expr_eexpr_dot_expressions_ _2 = TOpAssign _3 = assign_expr_bis
    {      ( let (op,clt) = _2 in
      let op' = P.clt2mcode op clt in
      let op'' = Ast0.wrap (Ast0.OpAssign op') in
      Ast0.wrap(Ast0.Assignment(_1, op'', Ast0.set_arg_exp _3,false)) )}
| _1 = unary_expr_eexpr_dot_expressions_ _2 = TEq _3 = assign_expr_bis
    {      ( let (op,clt) = ("=",_2) in
      let op' = P.clt2mcode op clt in
      let op'' = Ast0.wrap (Ast0.SimpleAssign op') in
      Ast0.wrap
	  (Ast0.Assignment
	     (_1, op'', Ast0.set_arg_exp _3,false)) )}
| _1 = unary_expr_eexpr_dot_expressions_ _2 = TMetaAssignOp _3 = assign_expr_bis
    {      ( let (mv, cstrt, pure, clt) = _2 in
      let op' = P.clt2mcode mv clt in
      let op'' = Ast0.wrap (Ast0.MetaAssign (op', cstrt, pure)) in
      Ast0.wrap
	  (Ast0.Assignment
	     (_1, op'', Ast0.set_arg_exp _3,false)) )}

assign_expr_eexpr_nest_expressions_:
  _1 = cond_expr_eexpr_nest_expressions_
    {                                           ( _1 )}
| _1 = unary_expr_eexpr_nest_expressions_ _2 = TOpAssign _3 = assign_expr_bis
    {      ( let (op,clt) = _2 in
      let op' = P.clt2mcode op clt in
      let op'' = Ast0.wrap (Ast0.OpAssign op') in
      Ast0.wrap(Ast0.Assignment(_1, op'', Ast0.set_arg_exp _3,false)) )}
| _1 = unary_expr_eexpr_nest_expressions_ _2 = TEq _3 = assign_expr_bis
    {      ( let (op,clt) = ("=",_2) in
      let op' = P.clt2mcode op clt in
      let op'' = Ast0.wrap (Ast0.SimpleAssign op') in
      Ast0.wrap
	  (Ast0.Assignment
	     (_1, op'', Ast0.set_arg_exp _3,false)) )}
| _1 = unary_expr_eexpr_nest_expressions_ _2 = TMetaAssignOp _3 = assign_expr_bis
    {      ( let (mv, cstrt, pure, clt) = _2 in
      let op' = P.clt2mcode mv clt in
      let op'' = Ast0.wrap (Ast0.MetaAssign (op', cstrt, pure)) in
      Ast0.wrap
	  (Ast0.Assignment
	     (_1, op'', Ast0.set_arg_exp _3,false)) )}

assign_expr_expr_invalid_:
  _1 = cond_expr_expr_invalid_
    {                                           ( _1 )}
| _1 = unary_expr_expr_invalid_ _2 = TOpAssign _3 = assign_expr_bis
    {      ( let (op,clt) = _2 in
      let op' = P.clt2mcode op clt in
      let op'' = Ast0.wrap (Ast0.OpAssign op') in
      Ast0.wrap(Ast0.Assignment(_1, op'', Ast0.set_arg_exp _3,false)) )}
| _1 = unary_expr_expr_invalid_ _2 = TEq _3 = assign_expr_bis
    {      ( let (op,clt) = ("=",_2) in
      let op' = P.clt2mcode op clt in
      let op'' = Ast0.wrap (Ast0.SimpleAssign op') in
      Ast0.wrap
	  (Ast0.Assignment
	     (_1, op'', Ast0.set_arg_exp _3,false)) )}
| _1 = unary_expr_expr_invalid_ _2 = TMetaAssignOp _3 = assign_expr_bis
    {      ( let (mv, cstrt, pure, clt) = _2 in
      let op' = P.clt2mcode mv clt in
      let op'' = Ast0.wrap (Ast0.MetaAssign (op', cstrt, pure)) in
      Ast0.wrap
	  (Ast0.Assignment
	     (_1, op'', Ast0.set_arg_exp _3,false)) )}

assign_expr_bis:
  _1 = cond_expr_eexpr_dot_expressions_
    {                                                            ( _1 )}
| _1 = unary_expr_eexpr_dot_expressions_ _2 = TOpAssign _3 = assign_expr_bis
    {      ( let (op,clt) = _2 in
      let op' = P.clt2mcode op clt in
      let op'' = Ast0.wrap (Ast0.OpAssign op') in
      Ast0.wrap(Ast0.Assignment(_1, op'', Ast0.set_arg_exp _3,false)) )}
| _1 = unary_expr_eexpr_dot_expressions_ _2 = TEq _3 = assign_expr_bis
    {      ( let (op,clt) = ("=",_2) in
      let op' = P.clt2mcode op clt in
      let op'' = Ast0.wrap (Ast0.SimpleAssign op') in
      Ast0.wrap
	  (Ast0.Assignment
	     (_1, op'', Ast0.set_arg_exp _3,false)) )}

cond_expr_eexpr_dot_expressions_:
  _1 = arith_expr_eexpr_dot_expressions_
    {                                             ( _1 )}
| l = arith_expr_eexpr_dot_expressions_ w = TWhy t = option_eexpr_ dd = TDotDot r = eargexpr
    {      ( Ast0.wrap(Ast0.CondExpr (l, P.clt2mcode "?" w, t,
				 P.clt2mcode ":" dd, r)) )}

cond_expr_eexpr_nest_expressions_:
  _1 = arith_expr_eexpr_nest_expressions_
    {                                             ( _1 )}
| l = arith_expr_eexpr_nest_expressions_ w = TWhy t = option_eexpr_ dd = TDotDot r = eargexpr
    {      ( Ast0.wrap(Ast0.CondExpr (l, P.clt2mcode "?" w, t,
				 P.clt2mcode ":" dd, r)) )}

cond_expr_expr_invalid_:
  _1 = arith_expr_expr_invalid_
    {                                             ( _1 )}
| l = arith_expr_expr_invalid_ w = TWhy t = option_eexpr_ dd = TDotDot r = eargexpr
    {      ( Ast0.wrap(Ast0.CondExpr (l, P.clt2mcode "?" w, t,
				 P.clt2mcode ":" dd, r)) )}

arith_expr_eexpr_dot_expressions_:
  _1 = cast_expr_eexpr_dot_expressions_
    {                                            ( _1 )}
| _1 = arith_expr_eexpr_dot_expressions_ _2 = TMul _3 = arith_expr_bis
    {    ( P.arith_op Ast.Mul _1 _2 _3 )}
| _1 = arith_expr_eexpr_dot_expressions_ _2 = TDmOp _3 = arith_expr_bis
    {      ( let (op,clt) = _2 in P.arith_op op _1 clt _3 )}
| _1 = arith_expr_eexpr_dot_expressions_ _2 = TPlus _3 = arith_expr_bis
    {      ( P.arith_op Ast.Plus _1 _2 _3 )}
| _1 = arith_expr_eexpr_dot_expressions_ _2 = TMinus _3 = arith_expr_bis
    {      ( P.arith_op Ast.Minus _1 _2 _3 )}
| _1 = arith_expr_eexpr_dot_expressions_ _2 = TShLOp _3 = arith_expr_bis
    {      ( let (op,clt) = _2 in P.arith_op op _1 clt _3 )}
| _1 = arith_expr_eexpr_dot_expressions_ _2 = TShROp _3 = arith_expr_bis
    {      ( let (op,clt) = _2 in P.arith_op op _1 clt _3 )}
| _1 = arith_expr_eexpr_dot_expressions_ _2 = TLogOp _3 = arith_expr_bis
    {      ( let (op,clt) = _2 in P.logic_op op _1 clt _3 )}
| _1 = arith_expr_eexpr_dot_expressions_ _2 = TEqEq _3 = arith_expr_bis
    {      ( P.logic_op Ast.Eq _1 _2 _3 )}
| _1 = arith_expr_eexpr_dot_expressions_ _2 = TNotEq _3 = arith_expr_bis
    {      ( P.logic_op Ast.NotEq _1 _2 _3 )}
| _1 = arith_expr_eexpr_dot_expressions_ _2 = TAnd _3 = arith_expr_bis
    {      ( P.arith_op Ast.And _1 _2 _3 )}
| _1 = arith_expr_eexpr_dot_expressions_ _2 = TOr _3 = arith_expr_bis
    {      ( P.arith_op Ast.Or _1 _2 _3 )}
| _1 = arith_expr_eexpr_dot_expressions_ _2 = TXor _3 = arith_expr_bis
    {      ( P.arith_op Ast.Xor _1 _2 _3 )}
| _1 = arith_expr_eexpr_dot_expressions_ _2 = TAndLog _3 = arith_expr_bis
    {      ( P.logic_op Ast.AndLog _1 _2 _3 )}
| _1 = arith_expr_eexpr_dot_expressions_ _2 = TOrLog _3 = arith_expr_bis
    {      ( P.logic_op Ast.OrLog _1 _2 _3 )}
| _1 = arith_expr_eexpr_dot_expressions_ _2 = TMetaBinaryOp _3 = arith_expr_bis
    {      ( let (mv, cstrt, pure, clt) = _2 in
      let op' = P.clt2mcode mv clt in
      let op = Ast0.wrap (Ast0.MetaBinary (op', cstrt, pure)) in
      Ast0.wrap (Ast0.Binary(_1, op, _3)) )}

arith_expr_eexpr_invalid_:
  _1 = cast_expr_eexpr_invalid_
    {                                            ( _1 )}
| _1 = arith_expr_eexpr_invalid_ _2 = TMul _3 = arith_expr_bis
    {    ( P.arith_op Ast.Mul _1 _2 _3 )}
| _1 = arith_expr_eexpr_invalid_ _2 = TDmOp _3 = arith_expr_bis
    {      ( let (op,clt) = _2 in P.arith_op op _1 clt _3 )}
| _1 = arith_expr_eexpr_invalid_ _2 = TPlus _3 = arith_expr_bis
    {      ( P.arith_op Ast.Plus _1 _2 _3 )}
| _1 = arith_expr_eexpr_invalid_ _2 = TMinus _3 = arith_expr_bis
    {      ( P.arith_op Ast.Minus _1 _2 _3 )}
| _1 = arith_expr_eexpr_invalid_ _2 = TShLOp _3 = arith_expr_bis
    {      ( let (op,clt) = _2 in P.arith_op op _1 clt _3 )}
| _1 = arith_expr_eexpr_invalid_ _2 = TShROp _3 = arith_expr_bis
    {      ( let (op,clt) = _2 in P.arith_op op _1 clt _3 )}
| _1 = arith_expr_eexpr_invalid_ _2 = TLogOp _3 = arith_expr_bis
    {      ( let (op,clt) = _2 in P.logic_op op _1 clt _3 )}
| _1 = arith_expr_eexpr_invalid_ _2 = TEqEq _3 = arith_expr_bis
    {      ( P.logic_op Ast.Eq _1 _2 _3 )}
| _1 = arith_expr_eexpr_invalid_ _2 = TNotEq _3 = arith_expr_bis
    {      ( P.logic_op Ast.NotEq _1 _2 _3 )}
| _1 = arith_expr_eexpr_invalid_ _2 = TAnd _3 = arith_expr_bis
    {      ( P.arith_op Ast.And _1 _2 _3 )}
| _1 = arith_expr_eexpr_invalid_ _2 = TOr _3 = arith_expr_bis
    {      ( P.arith_op Ast.Or _1 _2 _3 )}
| _1 = arith_expr_eexpr_invalid_ _2 = TXor _3 = arith_expr_bis
    {      ( P.arith_op Ast.Xor _1 _2 _3 )}
| _1 = arith_expr_eexpr_invalid_ _2 = TAndLog _3 = arith_expr_bis
    {      ( P.logic_op Ast.AndLog _1 _2 _3 )}
| _1 = arith_expr_eexpr_invalid_ _2 = TOrLog _3 = arith_expr_bis
    {      ( P.logic_op Ast.OrLog _1 _2 _3 )}
| _1 = arith_expr_eexpr_invalid_ _2 = TMetaBinaryOp _3 = arith_expr_bis
    {      ( let (mv, cstrt, pure, clt) = _2 in
      let op' = P.clt2mcode mv clt in
      let op = Ast0.wrap (Ast0.MetaBinary (op', cstrt, pure)) in
      Ast0.wrap (Ast0.Binary(_1, op, _3)) )}

arith_expr_eexpr_nest_expressions_:
  _1 = cast_expr_eexpr_nest_expressions_
    {                                            ( _1 )}
| _1 = arith_expr_eexpr_nest_expressions_ _2 = TMul _3 = arith_expr_bis
    {    ( P.arith_op Ast.Mul _1 _2 _3 )}
| _1 = arith_expr_eexpr_nest_expressions_ _2 = TDmOp _3 = arith_expr_bis
    {      ( let (op,clt) = _2 in P.arith_op op _1 clt _3 )}
| _1 = arith_expr_eexpr_nest_expressions_ _2 = TPlus _3 = arith_expr_bis
    {      ( P.arith_op Ast.Plus _1 _2 _3 )}
| _1 = arith_expr_eexpr_nest_expressions_ _2 = TMinus _3 = arith_expr_bis
    {      ( P.arith_op Ast.Minus _1 _2 _3 )}
| _1 = arith_expr_eexpr_nest_expressions_ _2 = TShLOp _3 = arith_expr_bis
    {      ( let (op,clt) = _2 in P.arith_op op _1 clt _3 )}
| _1 = arith_expr_eexpr_nest_expressions_ _2 = TShROp _3 = arith_expr_bis
    {      ( let (op,clt) = _2 in P.arith_op op _1 clt _3 )}
| _1 = arith_expr_eexpr_nest_expressions_ _2 = TLogOp _3 = arith_expr_bis
    {      ( let (op,clt) = _2 in P.logic_op op _1 clt _3 )}
| _1 = arith_expr_eexpr_nest_expressions_ _2 = TEqEq _3 = arith_expr_bis
    {      ( P.logic_op Ast.Eq _1 _2 _3 )}
| _1 = arith_expr_eexpr_nest_expressions_ _2 = TNotEq _3 = arith_expr_bis
    {      ( P.logic_op Ast.NotEq _1 _2 _3 )}
| _1 = arith_expr_eexpr_nest_expressions_ _2 = TAnd _3 = arith_expr_bis
    {      ( P.arith_op Ast.And _1 _2 _3 )}
| _1 = arith_expr_eexpr_nest_expressions_ _2 = TOr _3 = arith_expr_bis
    {      ( P.arith_op Ast.Or _1 _2 _3 )}
| _1 = arith_expr_eexpr_nest_expressions_ _2 = TXor _3 = arith_expr_bis
    {      ( P.arith_op Ast.Xor _1 _2 _3 )}
| _1 = arith_expr_eexpr_nest_expressions_ _2 = TAndLog _3 = arith_expr_bis
    {      ( P.logic_op Ast.AndLog _1 _2 _3 )}
| _1 = arith_expr_eexpr_nest_expressions_ _2 = TOrLog _3 = arith_expr_bis
    {      ( P.logic_op Ast.OrLog _1 _2 _3 )}
| _1 = arith_expr_eexpr_nest_expressions_ _2 = TMetaBinaryOp _3 = arith_expr_bis
    {      ( let (mv, cstrt, pure, clt) = _2 in
      let op' = P.clt2mcode mv clt in
      let op = Ast0.wrap (Ast0.MetaBinary (op', cstrt, pure)) in
      Ast0.wrap (Ast0.Binary(_1, op, _3)) )}

arith_expr_expr_invalid_:
  _1 = cast_expr_expr_invalid_
    {                                            ( _1 )}
| _1 = arith_expr_expr_invalid_ _2 = TMul _3 = arith_expr_bis
    {    ( P.arith_op Ast.Mul _1 _2 _3 )}
| _1 = arith_expr_expr_invalid_ _2 = TDmOp _3 = arith_expr_bis
    {      ( let (op,clt) = _2 in P.arith_op op _1 clt _3 )}
| _1 = arith_expr_expr_invalid_ _2 = TPlus _3 = arith_expr_bis
    {      ( P.arith_op Ast.Plus _1 _2 _3 )}
| _1 = arith_expr_expr_invalid_ _2 = TMinus _3 = arith_expr_bis
    {      ( P.arith_op Ast.Minus _1 _2 _3 )}
| _1 = arith_expr_expr_invalid_ _2 = TShLOp _3 = arith_expr_bis
    {      ( let (op,clt) = _2 in P.arith_op op _1 clt _3 )}
| _1 = arith_expr_expr_invalid_ _2 = TShROp _3 = arith_expr_bis
    {      ( let (op,clt) = _2 in P.arith_op op _1 clt _3 )}
| _1 = arith_expr_expr_invalid_ _2 = TLogOp _3 = arith_expr_bis
    {      ( let (op,clt) = _2 in P.logic_op op _1 clt _3 )}
| _1 = arith_expr_expr_invalid_ _2 = TEqEq _3 = arith_expr_bis
    {      ( P.logic_op Ast.Eq _1 _2 _3 )}
| _1 = arith_expr_expr_invalid_ _2 = TNotEq _3 = arith_expr_bis
    {      ( P.logic_op Ast.NotEq _1 _2 _3 )}
| _1 = arith_expr_expr_invalid_ _2 = TAnd _3 = arith_expr_bis
    {      ( P.arith_op Ast.And _1 _2 _3 )}
| _1 = arith_expr_expr_invalid_ _2 = TOr _3 = arith_expr_bis
    {      ( P.arith_op Ast.Or _1 _2 _3 )}
| _1 = arith_expr_expr_invalid_ _2 = TXor _3 = arith_expr_bis
    {      ( P.arith_op Ast.Xor _1 _2 _3 )}
| _1 = arith_expr_expr_invalid_ _2 = TAndLog _3 = arith_expr_bis
    {      ( P.logic_op Ast.AndLog _1 _2 _3 )}
| _1 = arith_expr_expr_invalid_ _2 = TOrLog _3 = arith_expr_bis
    {      ( P.logic_op Ast.OrLog _1 _2 _3 )}
| _1 = arith_expr_expr_invalid_ _2 = TMetaBinaryOp _3 = arith_expr_bis
    {      ( let (mv, cstrt, pure, clt) = _2 in
      let op' = P.clt2mcode mv clt in
      let op = Ast0.wrap (Ast0.MetaBinary (op', cstrt, pure)) in
      Ast0.wrap (Ast0.Binary(_1, op, _3)) )}

arith_expr_bis:
  _1 = cast_expr_eexpr_dot_expressions_
    {                                                             ( _1 )}
| _1 = arith_expr_bis _2 = TMul _3 = arith_expr_bis
    {      ( P.arith_op Ast.Mul _1 _2 _3 )}
| _1 = arith_expr_bis _2 = TDmOp _3 = arith_expr_bis
    {      ( let (op,clt) = _2 in P.arith_op op _1 clt _3 )}
| _1 = arith_expr_bis _2 = TPlus _3 = arith_expr_bis
    {      ( P.arith_op Ast.Plus _1 _2 _3 )}
| _1 = arith_expr_bis _2 = TMinus _3 = arith_expr_bis
    {      ( P.arith_op Ast.Minus _1 _2 _3 )}
| _1 = arith_expr_bis _2 = TShLOp _3 = arith_expr_bis
    {      ( let (op,clt) = _2 in P.arith_op op _1 clt _3 )}
| _1 = arith_expr_bis _2 = TShROp _3 = arith_expr_bis
    {      ( let (op,clt) = _2 in P.arith_op op _1 clt _3 )}
| _1 = arith_expr_bis _2 = TLogOp _3 = arith_expr_bis
    {      ( let (op,clt) = _2 in P.logic_op op _1 clt _3 )}
| _1 = arith_expr_bis _2 = TEqEq _3 = arith_expr_bis
    {      ( P.logic_op Ast.Eq _1 _2 _3 )}
| _1 = arith_expr_bis _2 = TNotEq _3 = arith_expr_bis
    {      ( P.logic_op Ast.NotEq _1 _2 _3 )}
| _1 = arith_expr_bis _2 = TAnd _3 = arith_expr_bis
    {      ( P.arith_op Ast.And _1 _2 _3 )}
| _1 = arith_expr_bis _2 = TOr _3 = arith_expr_bis
    {      ( P.arith_op Ast.Or _1 _2 _3 )}
| _1 = arith_expr_bis _2 = TXor _3 = arith_expr_bis
    {      ( P.arith_op Ast.Xor _1 _2 _3 )}
| _1 = arith_expr_bis _2 = TAndLog _3 = arith_expr_bis
    {      ( P.logic_op Ast.AndLog _1 _2 _3 )}

cast_expr_eexpr_dot_expressions_:
  _1 = unary_expr_eexpr_dot_expressions_
    {                                          ( _1 )}
| lp = TOPar t = ctype rp = TCPar e = cast_expr_eexpr_dot_expressions_
    {      ( Ast0.wrap(Ast0.Cast (P.clt2mcode "(" lp, t,
			     P.clt2mcode ")" rp, e)) )}

cast_expr_eexpr_invalid_:
  _1 = unary_expr_eexpr_invalid_
    {                                          ( _1 )}
| lp = TOPar t = ctype rp = TCPar e = cast_expr_eexpr_invalid_
    {      ( Ast0.wrap(Ast0.Cast (P.clt2mcode "(" lp, t,
			     P.clt2mcode ")" rp, e)) )}

cast_expr_eexpr_nest_expressions_:
  _1 = unary_expr_eexpr_nest_expressions_
    {                                          ( _1 )}
| lp = TOPar t = ctype rp = TCPar e = cast_expr_eexpr_nest_expressions_
    {      ( Ast0.wrap(Ast0.Cast (P.clt2mcode "(" lp, t,
			     P.clt2mcode ")" rp, e)) )}

cast_expr_expr_invalid_:
  _1 = unary_expr_expr_invalid_
    {                                          ( _1 )}
| lp = TOPar t = ctype rp = TCPar e = cast_expr_expr_invalid_
    {      ( Ast0.wrap(Ast0.Cast (P.clt2mcode "(" lp, t,
			     P.clt2mcode ")" rp, e)) )}

unary_expr_eexpr_dot_expressions_:
  _1 = postfix_expr_eexpr_dot_expressions_
    {                                         ( _1 )}
| _1 = TInc _2 = unary_expr_bis
    {      ( Ast0.wrap(Ast0.Infix (_2, P.clt2mcode Ast.Inc _1)) )}
| _1 = TDec _2 = unary_expr_bis
    {      ( Ast0.wrap(Ast0.Infix (_2, P.clt2mcode Ast.Dec _1)) )}
| _1 = unary_op _2 = cast_expr_eexpr_dot_expressions_
    {      ( let mcode = _1 in Ast0.wrap(Ast0.Unary(_2, mcode)) )}
| _1 = TSizeof _2 = unary_expr_bis
    {      ( Ast0.wrap(Ast0.SizeOfExpr (P.clt2mcode "sizeof" _1, _2)) )}
| s = TSizeof lp = TOPar t = ctype rp = TCPar
    {      ( Ast0.wrap(Ast0.SizeOfType (P.clt2mcode "sizeof" s,
                                   P.clt2mcode "(" lp,t,
                                   P.clt2mcode ")" rp)) )}

unary_expr_eexpr_invalid_:
  _1 = postfix_expr_eexpr_invalid_
    {                                         ( _1 )}
| _1 = TInc _2 = unary_expr_bis
    {      ( Ast0.wrap(Ast0.Infix (_2, P.clt2mcode Ast.Inc _1)) )}
| _1 = TDec _2 = unary_expr_bis
    {      ( Ast0.wrap(Ast0.Infix (_2, P.clt2mcode Ast.Dec _1)) )}
| _1 = unary_op _2 = cast_expr_eexpr_invalid_
    {      ( let mcode = _1 in Ast0.wrap(Ast0.Unary(_2, mcode)) )}
| _1 = TSizeof _2 = unary_expr_bis
    {      ( Ast0.wrap(Ast0.SizeOfExpr (P.clt2mcode "sizeof" _1, _2)) )}
| s = TSizeof lp = TOPar t = ctype rp = TCPar
    {      ( Ast0.wrap(Ast0.SizeOfType (P.clt2mcode "sizeof" s,
                                   P.clt2mcode "(" lp,t,
                                   P.clt2mcode ")" rp)) )}

unary_expr_eexpr_nest_expressions_:
  _1 = postfix_expr_eexpr_nest_expressions_
    {                                         ( _1 )}
| _1 = TInc _2 = unary_expr_bis
    {      ( Ast0.wrap(Ast0.Infix (_2, P.clt2mcode Ast.Inc _1)) )}
| _1 = TDec _2 = unary_expr_bis
    {      ( Ast0.wrap(Ast0.Infix (_2, P.clt2mcode Ast.Dec _1)) )}
| _1 = unary_op _2 = cast_expr_eexpr_nest_expressions_
    {      ( let mcode = _1 in Ast0.wrap(Ast0.Unary(_2, mcode)) )}
| _1 = TSizeof _2 = unary_expr_bis
    {      ( Ast0.wrap(Ast0.SizeOfExpr (P.clt2mcode "sizeof" _1, _2)) )}
| s = TSizeof lp = TOPar t = ctype rp = TCPar
    {      ( Ast0.wrap(Ast0.SizeOfType (P.clt2mcode "sizeof" s,
                                   P.clt2mcode "(" lp,t,
                                   P.clt2mcode ")" rp)) )}

unary_expr_expr_invalid_:
  _1 = postfix_expr_expr_invalid_
    {                                         ( _1 )}
| _1 = TInc _2 = unary_expr_bis
    {      ( Ast0.wrap(Ast0.Infix (_2, P.clt2mcode Ast.Inc _1)) )}
| _1 = TDec _2 = unary_expr_bis
    {      ( Ast0.wrap(Ast0.Infix (_2, P.clt2mcode Ast.Dec _1)) )}
| _1 = unary_op _2 = cast_expr_expr_invalid_
    {      ( let mcode = _1 in Ast0.wrap(Ast0.Unary(_2, mcode)) )}
| _1 = TSizeof _2 = unary_expr_bis
    {      ( Ast0.wrap(Ast0.SizeOfExpr (P.clt2mcode "sizeof" _1, _2)) )}
| s = TSizeof lp = TOPar t = ctype rp = TCPar
    {      ( Ast0.wrap(Ast0.SizeOfType (P.clt2mcode "sizeof" s,
                                   P.clt2mcode "(" lp,t,
                                   P.clt2mcode ")" rp)) )}

unary_expr_bis:
  _1 = postfix_expr_eexpr_dot_expressions_
    {                                                          ( _1 )}
| _1 = TInc _2 = unary_expr_bis
    {      ( Ast0.wrap(Ast0.Infix (_2, P.clt2mcode Ast.Inc _1)) )}
| _1 = TDec _2 = unary_expr_bis
    {      ( Ast0.wrap(Ast0.Infix (_2, P.clt2mcode Ast.Dec _1)) )}
| _1 = unary_op _2 = cast_expr_eexpr_dot_expressions_
    {      ( let mcode = _1 in Ast0.wrap(Ast0.Unary(_2, mcode)) )}
| _1 = TSizeof _2 = unary_expr_bis
    {      ( Ast0.wrap(Ast0.SizeOfExpr (P.clt2mcode "sizeof" _1, _2)) )}
| s = TSizeof lp = TOPar t = ctype rp = TCPar
    {      ( Ast0.wrap(Ast0.SizeOfType (P.clt2mcode "sizeof" s,
                                   P.clt2mcode "(" lp,t,
                                   P.clt2mcode ")" rp)) )}

unary_op:
  _1 = TAnd
    {                  ( P.clt2mcode Ast.GetRef _1 )}
| _1 = TMul
    {           ( P.clt2mcode Ast.DeRef _1 )}
| _1 = TPlus
    {           ( P.clt2mcode Ast.UnPlus _1 )}
| _1 = TMinus
    {           ( P.clt2mcode Ast.UnMinus _1 )}
| _1 = TTilde
    {           ( P.clt2mcode Ast.Tilde _1 )}
| _1 = TBang
    {           ( P.clt2mcode Ast.Not _1 )}

postfix_expr_eexpr_dot_expressions_:
  _1 = primary_expr_eexpr_dot_expressions_
    {                                                 ( _1 )}
| _1 = postfix_expr_eexpr_dot_expressions_ _2 = TOCro _3 = eexpr _4 = TCCro
    {     ( Ast0.wrap(Ast0.ArrayAccess (_1,P.clt2mcode "[" _2,_3,
				       P.clt2mcode "]" _4)) )}
| _1 = postfix_expr_eexpr_dot_expressions_ _2 = TDot _3 = disj_ident
    {     ( Ast0.wrap(Ast0.RecordAccess(_1, P.clt2mcode "." _2, _3)) )}
| _1 = postfix_expr_eexpr_dot_expressions_ _2 = TPtrOp _3 = disj_ident
    {     ( Ast0.wrap(Ast0.RecordPtAccess(_1, P.clt2mcode "->" _2,
				     _3)) )}
| _1 = postfix_expr_eexpr_dot_expressions_ _2 = TInc
    {     ( Ast0.wrap(Ast0.Postfix (_1, P.clt2mcode Ast.Inc _2)) )}
| _1 = postfix_expr_eexpr_dot_expressions_ _2 = TDec
    {     ( Ast0.wrap(Ast0.Postfix (_1, P.clt2mcode Ast.Dec _2)) )}
| _1 = postfix_expr_eexpr_dot_expressions_ _2 = TOPar _3 = eexpr_list_option _4 = TCPar
    {     ( Ast0.wrap(Ast0.FunCall(_1,P.clt2mcode "(" _2,
			      _3,
			      P.clt2mcode ")" _4)) )}
| _1 = TOPar _2 = ctype _3 = TCPar _4 = TOBrace _5 = initialize_list _6 = TCBrace
    {     ( let init =
       if P.struct_initializer _5
       then
	 let il = P.drop_dot_commas _5 in
	 Ast0.wrap
	   (Ast0.InitList(P.clt2mcode "{" _4,il,P.clt2mcode "}" _6,false))
       else
	 Ast0.wrap
	   (Ast0.InitList(P.clt2mcode "{" _4,_5,P.clt2mcode "}" _6,true)) in
     Ast0.wrap
       (Ast0.Constructor(P.clt2mcode "(" _1, _2, P.clt2mcode ")" _3, init)) )}

postfix_expr_eexpr_invalid_:
  _1 = primary_expr_eexpr_invalid_
    {                                                 ( _1 )}
| _1 = postfix_expr_eexpr_invalid_ _2 = TOCro _3 = eexpr _4 = TCCro
    {     ( Ast0.wrap(Ast0.ArrayAccess (_1,P.clt2mcode "[" _2,_3,
				       P.clt2mcode "]" _4)) )}
| _1 = postfix_expr_eexpr_invalid_ _2 = TDot _3 = disj_ident
    {     ( Ast0.wrap(Ast0.RecordAccess(_1, P.clt2mcode "." _2, _3)) )}
| _1 = postfix_expr_eexpr_invalid_ _2 = TPtrOp _3 = disj_ident
    {     ( Ast0.wrap(Ast0.RecordPtAccess(_1, P.clt2mcode "->" _2,
				     _3)) )}
| _1 = postfix_expr_eexpr_invalid_ _2 = TInc
    {     ( Ast0.wrap(Ast0.Postfix (_1, P.clt2mcode Ast.Inc _2)) )}
| _1 = postfix_expr_eexpr_invalid_ _2 = TDec
    {     ( Ast0.wrap(Ast0.Postfix (_1, P.clt2mcode Ast.Dec _2)) )}
| _1 = postfix_expr_eexpr_invalid_ _2 = TOPar _3 = eexpr_list_option _4 = TCPar
    {     ( Ast0.wrap(Ast0.FunCall(_1,P.clt2mcode "(" _2,
			      _3,
			      P.clt2mcode ")" _4)) )}
| _1 = TOPar _2 = ctype _3 = TCPar _4 = TOBrace _5 = initialize_list _6 = TCBrace
    {     ( let init =
       if P.struct_initializer _5
       then
	 let il = P.drop_dot_commas _5 in
	 Ast0.wrap
	   (Ast0.InitList(P.clt2mcode "{" _4,il,P.clt2mcode "}" _6,false))
       else
	 Ast0.wrap
	   (Ast0.InitList(P.clt2mcode "{" _4,_5,P.clt2mcode "}" _6,true)) in
     Ast0.wrap
       (Ast0.Constructor(P.clt2mcode "(" _1, _2, P.clt2mcode ")" _3, init)) )}

postfix_expr_eexpr_nest_expressions_:
  _1 = primary_expr_eexpr_nest_expressions_
    {                                                 ( _1 )}
| _1 = postfix_expr_eexpr_nest_expressions_ _2 = TOCro _3 = eexpr _4 = TCCro
    {     ( Ast0.wrap(Ast0.ArrayAccess (_1,P.clt2mcode "[" _2,_3,
				       P.clt2mcode "]" _4)) )}
| _1 = postfix_expr_eexpr_nest_expressions_ _2 = TDot _3 = disj_ident
    {     ( Ast0.wrap(Ast0.RecordAccess(_1, P.clt2mcode "." _2, _3)) )}
| _1 = postfix_expr_eexpr_nest_expressions_ _2 = TPtrOp _3 = disj_ident
    {     ( Ast0.wrap(Ast0.RecordPtAccess(_1, P.clt2mcode "->" _2,
				     _3)) )}
| _1 = postfix_expr_eexpr_nest_expressions_ _2 = TInc
    {     ( Ast0.wrap(Ast0.Postfix (_1, P.clt2mcode Ast.Inc _2)) )}
| _1 = postfix_expr_eexpr_nest_expressions_ _2 = TDec
    {     ( Ast0.wrap(Ast0.Postfix (_1, P.clt2mcode Ast.Dec _2)) )}
| _1 = postfix_expr_eexpr_nest_expressions_ _2 = TOPar _3 = eexpr_list_option _4 = TCPar
    {     ( Ast0.wrap(Ast0.FunCall(_1,P.clt2mcode "(" _2,
			      _3,
			      P.clt2mcode ")" _4)) )}
| _1 = TOPar _2 = ctype _3 = TCPar _4 = TOBrace _5 = initialize_list _6 = TCBrace
    {     ( let init =
       if P.struct_initializer _5
       then
	 let il = P.drop_dot_commas _5 in
	 Ast0.wrap
	   (Ast0.InitList(P.clt2mcode "{" _4,il,P.clt2mcode "}" _6,false))
       else
	 Ast0.wrap
	   (Ast0.InitList(P.clt2mcode "{" _4,_5,P.clt2mcode "}" _6,true)) in
     Ast0.wrap
       (Ast0.Constructor(P.clt2mcode "(" _1, _2, P.clt2mcode ")" _3, init)) )}

postfix_expr_expr_invalid_:
  _1 = primary_expr_expr_invalid_
    {                                                 ( _1 )}
| _1 = postfix_expr_expr_invalid_ _2 = TOCro _3 = eexpr _4 = TCCro
    {     ( Ast0.wrap(Ast0.ArrayAccess (_1,P.clt2mcode "[" _2,_3,
				       P.clt2mcode "]" _4)) )}
| _1 = postfix_expr_expr_invalid_ _2 = TDot _3 = disj_ident
    {     ( Ast0.wrap(Ast0.RecordAccess(_1, P.clt2mcode "." _2, _3)) )}
| _1 = postfix_expr_expr_invalid_ _2 = TPtrOp _3 = disj_ident
    {     ( Ast0.wrap(Ast0.RecordPtAccess(_1, P.clt2mcode "->" _2,
				     _3)) )}
| _1 = postfix_expr_expr_invalid_ _2 = TInc
    {     ( Ast0.wrap(Ast0.Postfix (_1, P.clt2mcode Ast.Inc _2)) )}
| _1 = postfix_expr_expr_invalid_ _2 = TDec
    {     ( Ast0.wrap(Ast0.Postfix (_1, P.clt2mcode Ast.Dec _2)) )}
| _1 = postfix_expr_expr_invalid_ _2 = TOPar _3 = eexpr_list_option _4 = TCPar
    {     ( Ast0.wrap(Ast0.FunCall(_1,P.clt2mcode "(" _2,
			      _3,
			      P.clt2mcode ")" _4)) )}
| _1 = TOPar _2 = ctype _3 = TCPar _4 = TOBrace _5 = initialize_list _6 = TCBrace
    {     ( let init =
       if P.struct_initializer _5
       then
	 let il = P.drop_dot_commas _5 in
	 Ast0.wrap
	   (Ast0.InitList(P.clt2mcode "{" _4,il,P.clt2mcode "}" _6,false))
       else
	 Ast0.wrap
	   (Ast0.InitList(P.clt2mcode "{" _4,_5,P.clt2mcode "}" _6,true)) in
     Ast0.wrap
       (Ast0.Constructor(P.clt2mcode "(" _1, _2, P.clt2mcode ")" _3, init)) )}

primary_expr_eexpr_dot_expressions_:
  _1 = func_ident
    {                ( Ast0.wrap(Ast0.Ident(_1)) )}
| _1 = TAndLog _2 = ident
    {     ( let op = P.clt2mcode Ast.GetRefLabel _1 in
     Ast0.wrap(Ast0.Unary(Ast0.wrap(Ast0.Ident(_2)), op)) )}
| _1 = TInt
    {     ( let (x,clt) = _1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Int x) clt)) )}
| _1 = TFloat
    {     ( let (x,clt) = _1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Float x) clt)) )}
| _1 = TString
    {     ( let (x,clt) = _1 in P.parse_string x clt )}
| _1 = TChar
    {     ( let (x,clt) = _1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Char x) clt)) )}
| _1 = TDecimalCst
    {     ( let (x,l,p,clt) = _1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.DecimalConst(x,l,p)) clt)) )}
| _1 = TMetaConst
    {     ( let (nm,constraints,pure,ty,clt) = _1 in
     Ast0.wrap
       (Ast0.MetaExpr(P.clt2mcode nm clt,constraints,ty,Ast.CONST,pure)) )}
| _1 = TMetaErr
    {     ( let (nm,constraints,pure,clt) = _1 in
     Ast0.wrap(Ast0.MetaErr(P.clt2mcode nm clt,constraints,pure)) )}
| _1 = TMetaExp
    {     ( let (nm,constraints,pure,ty,clt) = _1 in
     Ast0.wrap
       (Ast0.MetaExpr(P.clt2mcode nm clt,constraints,ty,Ast.ANY,pure)) )}
| _1 = TMetaIdExp
    {     ( let (nm,constraints,pure,ty,clt) = _1 in
     Ast0.wrap
       (Ast0.MetaExpr(P.clt2mcode nm clt,constraints,ty,Ast.ID,pure)) )}
| _1 = TMetaLocalIdExp
    {     ( let (nm,constraints,pure,ty,clt) = _1 in
     Ast0.wrap
       (Ast0.MetaExpr(P.clt2mcode nm clt,constraints,ty,Ast.LocalID,pure)) )}
| _1 = TMetaGlobalIdExp
    {     ( let (nm,constraints,pure,ty,clt) = _1 in
     Ast0.wrap
       (Ast0.MetaExpr(P.clt2mcode nm clt,constraints,ty,Ast.GlobalID,pure)) )}
| _1 = TOPar _2 = eexpr _3 = TCPar
    {     ( Ast0.wrap(Ast0.Paren(P.clt2mcode "(" _1,_2,
			    P.clt2mcode ")" _3)) )}
| _1 = TOPar0 _2 = midzero_list_eexpr_eexpr_ _3 = TCPar0
    {     ( let (mids,code) = _2 in
       Ast0.wrap(Ast0.DisjExpr(P.id2mcode _1,
			       code, mids,
			       P.id2mcode _3)) )}
| _1 = dot_expressions
    {                 ( _1 )}

primary_expr_eexpr_invalid_:
  _1 = func_ident
    {                ( Ast0.wrap(Ast0.Ident(_1)) )}
| _1 = TAndLog _2 = ident
    {     ( let op = P.clt2mcode Ast.GetRefLabel _1 in
     Ast0.wrap(Ast0.Unary(Ast0.wrap(Ast0.Ident(_2)), op)) )}
| _1 = TInt
    {     ( let (x,clt) = _1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Int x) clt)) )}
| _1 = TFloat
    {     ( let (x,clt) = _1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Float x) clt)) )}
| _1 = TString
    {     ( let (x,clt) = _1 in P.parse_string x clt )}
| _1 = TChar
    {     ( let (x,clt) = _1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Char x) clt)) )}
| _1 = TDecimalCst
    {     ( let (x,l,p,clt) = _1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.DecimalConst(x,l,p)) clt)) )}
| _1 = TMetaConst
    {     ( let (nm,constraints,pure,ty,clt) = _1 in
     Ast0.wrap
       (Ast0.MetaExpr(P.clt2mcode nm clt,constraints,ty,Ast.CONST,pure)) )}
| _1 = TMetaErr
    {     ( let (nm,constraints,pure,clt) = _1 in
     Ast0.wrap(Ast0.MetaErr(P.clt2mcode nm clt,constraints,pure)) )}
| _1 = TMetaExp
    {     ( let (nm,constraints,pure,ty,clt) = _1 in
     Ast0.wrap
       (Ast0.MetaExpr(P.clt2mcode nm clt,constraints,ty,Ast.ANY,pure)) )}
| _1 = TMetaIdExp
    {     ( let (nm,constraints,pure,ty,clt) = _1 in
     Ast0.wrap
       (Ast0.MetaExpr(P.clt2mcode nm clt,constraints,ty,Ast.ID,pure)) )}
| _1 = TMetaLocalIdExp
    {     ( let (nm,constraints,pure,ty,clt) = _1 in
     Ast0.wrap
       (Ast0.MetaExpr(P.clt2mcode nm clt,constraints,ty,Ast.LocalID,pure)) )}
| _1 = TMetaGlobalIdExp
    {     ( let (nm,constraints,pure,ty,clt) = _1 in
     Ast0.wrap
       (Ast0.MetaExpr(P.clt2mcode nm clt,constraints,ty,Ast.GlobalID,pure)) )}
| _1 = TOPar _2 = eexpr _3 = TCPar
    {     ( Ast0.wrap(Ast0.Paren(P.clt2mcode "(" _1,_2,
			    P.clt2mcode ")" _3)) )}
| _1 = TOPar0 _2 = midzero_list_eexpr_eexpr_ _3 = TCPar0
    {     ( let (mids,code) = _2 in
       Ast0.wrap(Ast0.DisjExpr(P.id2mcode _1,
			       code, mids,
			       P.id2mcode _3)) )}
| _1 = invalid
    {                 ( _1 )}

primary_expr_eexpr_nest_expressions_:
  _1 = func_ident
    {                ( Ast0.wrap(Ast0.Ident(_1)) )}
| _1 = TAndLog _2 = ident
    {     ( let op = P.clt2mcode Ast.GetRefLabel _1 in
     Ast0.wrap(Ast0.Unary(Ast0.wrap(Ast0.Ident(_2)), op)) )}
| _1 = TInt
    {     ( let (x,clt) = _1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Int x) clt)) )}
| _1 = TFloat
    {     ( let (x,clt) = _1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Float x) clt)) )}
| _1 = TString
    {     ( let (x,clt) = _1 in P.parse_string x clt )}
| _1 = TChar
    {     ( let (x,clt) = _1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Char x) clt)) )}
| _1 = TDecimalCst
    {     ( let (x,l,p,clt) = _1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.DecimalConst(x,l,p)) clt)) )}
| _1 = TMetaConst
    {     ( let (nm,constraints,pure,ty,clt) = _1 in
     Ast0.wrap
       (Ast0.MetaExpr(P.clt2mcode nm clt,constraints,ty,Ast.CONST,pure)) )}
| _1 = TMetaErr
    {     ( let (nm,constraints,pure,clt) = _1 in
     Ast0.wrap(Ast0.MetaErr(P.clt2mcode nm clt,constraints,pure)) )}
| _1 = TMetaExp
    {     ( let (nm,constraints,pure,ty,clt) = _1 in
     Ast0.wrap
       (Ast0.MetaExpr(P.clt2mcode nm clt,constraints,ty,Ast.ANY,pure)) )}
| _1 = TMetaIdExp
    {     ( let (nm,constraints,pure,ty,clt) = _1 in
     Ast0.wrap
       (Ast0.MetaExpr(P.clt2mcode nm clt,constraints,ty,Ast.ID,pure)) )}
| _1 = TMetaLocalIdExp
    {     ( let (nm,constraints,pure,ty,clt) = _1 in
     Ast0.wrap
       (Ast0.MetaExpr(P.clt2mcode nm clt,constraints,ty,Ast.LocalID,pure)) )}
| _1 = TMetaGlobalIdExp
    {     ( let (nm,constraints,pure,ty,clt) = _1 in
     Ast0.wrap
       (Ast0.MetaExpr(P.clt2mcode nm clt,constraints,ty,Ast.GlobalID,pure)) )}
| _1 = TOPar _2 = eexpr _3 = TCPar
    {     ( Ast0.wrap(Ast0.Paren(P.clt2mcode "(" _1,_2,
			    P.clt2mcode ")" _3)) )}
| _1 = TOPar0 _2 = midzero_list_eexpr_eexpr_ _3 = TCPar0
    {     ( let (mids,code) = _2 in
       Ast0.wrap(Ast0.DisjExpr(P.id2mcode _1,
			       code, mids,
			       P.id2mcode _3)) )}
| _1 = nest_expressions
    {                 ( _1 )}

primary_expr_expr_invalid_:
  _1 = func_ident
    {                ( Ast0.wrap(Ast0.Ident(_1)) )}
| _1 = TAndLog _2 = ident
    {     ( let op = P.clt2mcode Ast.GetRefLabel _1 in
     Ast0.wrap(Ast0.Unary(Ast0.wrap(Ast0.Ident(_2)), op)) )}
| _1 = TInt
    {     ( let (x,clt) = _1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Int x) clt)) )}
| _1 = TFloat
    {     ( let (x,clt) = _1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Float x) clt)) )}
| _1 = TString
    {     ( let (x,clt) = _1 in P.parse_string x clt )}
| _1 = TChar
    {     ( let (x,clt) = _1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Char x) clt)) )}
| _1 = TDecimalCst
    {     ( let (x,l,p,clt) = _1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.DecimalConst(x,l,p)) clt)) )}
| _1 = TMetaConst
    {     ( let (nm,constraints,pure,ty,clt) = _1 in
     Ast0.wrap
       (Ast0.MetaExpr(P.clt2mcode nm clt,constraints,ty,Ast.CONST,pure)) )}
| _1 = TMetaErr
    {     ( let (nm,constraints,pure,clt) = _1 in
     Ast0.wrap(Ast0.MetaErr(P.clt2mcode nm clt,constraints,pure)) )}
| _1 = TMetaExp
    {     ( let (nm,constraints,pure,ty,clt) = _1 in
     Ast0.wrap
       (Ast0.MetaExpr(P.clt2mcode nm clt,constraints,ty,Ast.ANY,pure)) )}
| _1 = TMetaIdExp
    {     ( let (nm,constraints,pure,ty,clt) = _1 in
     Ast0.wrap
       (Ast0.MetaExpr(P.clt2mcode nm clt,constraints,ty,Ast.ID,pure)) )}
| _1 = TMetaLocalIdExp
    {     ( let (nm,constraints,pure,ty,clt) = _1 in
     Ast0.wrap
       (Ast0.MetaExpr(P.clt2mcode nm clt,constraints,ty,Ast.LocalID,pure)) )}
| _1 = TMetaGlobalIdExp
    {     ( let (nm,constraints,pure,ty,clt) = _1 in
     Ast0.wrap
       (Ast0.MetaExpr(P.clt2mcode nm clt,constraints,ty,Ast.GlobalID,pure)) )}
| _1 = TOPar _2 = eexpr _3 = TCPar
    {     ( Ast0.wrap(Ast0.Paren(P.clt2mcode "(" _1,_2,
			    P.clt2mcode ")" _3)) )}
| _1 = TOPar0 _2 = midzero_list_expr_eexpr_ _3 = TCPar0
    {     ( let (mids,code) = _2 in
       Ast0.wrap(Ast0.DisjExpr(P.id2mcode _1,
			       code, mids,
			       P.id2mcode _3)) )}
| _1 = invalid
    {                 ( _1 )}

expr_dots_TEllipsis_:
  r = no_dot_start_end_dexpr_edots_when_TEllipsis_eexpr__
    {                                                       ( r )}

no_dot_start_end_dexpr_edots_when_TEllipsis_eexpr__:
  g = dexpr dg = list_pair_edots_when_TEllipsis_eexpr__dexpr__
    {  ( function dot_builder ->
      g :: (List.concat(List.map (function (d,g) -> [dot_builder d;g]) dg)) )}

pure_ident:
  _1 = TIdent
    {           ( _1 )}

pure_ident_or_symbol:
  _1 = pure_ident
    {               ( _1 )}
| _1 = TSymId
    {           ( _1 )}

pure_ident_kwd:
  _1 = TIdentifier
    {                 ( "identifier" )}
| _1 = TExpression
    {                 ( "expression" )}
| _1 = TStatement
    {                ( "statement" )}
| _1 = TFunction
    {               ( "function" )}
| _1 = TLocal
    {            ( "local" )}
| _1 = TType
    {           ( "type" )}
| _1 = TParameter
    {                ( "parameter" )}
| _1 = TIdExpression
    {                   ( "idexpression" )}
| _1 = TInitialiser
    {                  ( "initialiser" )}
| _1 = Tlist
    {           ( "list" )}
| _1 = TFresh
    {            ( "fresh" )}
| _1 = TConstant
    {               ( "constant" )}
| _1 = TError
    {            ( "error" )}
| _1 = TWords
    {            ( "words" )}
| _1 = TPure
    {           ( "pure" )}
| _1 = TContext
    {              ( "context" )}
| _1 = TGenerated
    {                ( "generated" )}
| _1 = TTypedef
    {              ( "typedef" )}
| _1 = TDeclarer
    {               ( "declarer" )}
| _1 = TIterator
    {               ( "iterator" )}
| _1 = TName
    {           ( "name" )}
| _1 = TPosition
    {               ( "position" )}
| _1 = TSymbol
    {             ( "symbol" )}

meta_ident:
  _1 = TRuleName _2 = TDot _3 = pure_ident
    {                                   ( (Some _1,P.id2name _3) )}
| _1 = TRuleName _2 = TDot _3 = pure_ident_kwd
    {                                   ( (Some _1,_3) )}

pure_ident_or_meta_ident:
  _1 = pure_ident
    {                                 ( (None,P.id2name _1) )}
| _1 = pure_ident_kwd
    {                                 ( (None,_1) )}
| _1 = meta_ident
    {                                 ( _1 )}

wrapped_sym_ident:
  _1 = TSymId
    {         ( Ast0.wrap(Ast0.Id(P.sym2mcode _1)) )}

pure_ident_or_meta_ident_with_seed:
  _1 = pure_ident_or_meta_ident
    {                                ( (_1,Ast.NoVal) )}
| _1 = pure_ident_or_meta_ident _2 = TEq _3 = separated_nonempty_list_TCppConcatOp_seed_elem_
    {  ( match _3 with
	   [Ast.SeedString s] -> (_1,Ast.StringSeed s)
	 | _ -> (_1,Ast.ListSeed _3) )}

seed_elem:
  _1 = TString
    {          ( let (x,_) = _1 in Ast.SeedString x )}
| _1 = TMetaId
    {          ( let (x,_,_,_,_) = _1 in Ast.SeedId x )}
| _1 = TMeta
    {        (failwith "tmeta")}
| _1 = TVirtual _2 = TDot _3 = pure_ident
    {    ( let nm = ("virtual",P.id2name _3) in
     Iteration.parsed_virtual_identifiers :=
       Common.union_set [snd nm]
	 !Iteration.parsed_virtual_identifiers;
    try Ast.SeedString (List.assoc (snd nm) !Flag.defined_virtual_env)
    with Not_found -> Ast.SeedId nm )}
| _1 = TRuleName _2 = TDot _3 = pure_ident
    {    ( let nm = (_1,P.id2name _3) in
      P.check_meta(Ast.MetaIdDecl(Ast.NONE,nm));
      Ast.SeedId nm )}

pure_ident_or_meta_ident_with_x_eq_not_pos_:
  i = pure_ident_or_meta_ident l = loption_not_pos_
    {    (
      (i, l)
    )}

pure_ident_or_meta_ident_with_econstraint_not_ceq_or_sub_:
  i = pure_ident_or_meta_ident optc = option_not_ceq_or_sub_
    {    (
      match optc with
	  None   -> (i, Ast0.NoConstraint)
	| Some c -> (i, c)
    )}

pure_ident_or_meta_ident_with_econstraint_re_or_not_eqe_or_sub_:
  i = pure_ident_or_meta_ident optc = option_re_or_not_eqe_or_sub_
    {    (
      match optc with
	  None   -> (i, Ast0.NoConstraint)
	| Some c -> (i, c)
    )}

pure_ident_or_meta_ident_with_idconstraint_virt_re_or_not_eqid_:
  i = pure_ident_or_meta_ident c = option_re_or_not_eqid_
    {    (
      Common.Left
        (match c with
	  None -> (i, Ast.IdNoConstraint)
	| Some constraint_ -> (i,constraint_))
    )}
| _1 = TVirtual _2 = TDot _3 = pure_ident
    {    (
     let nm = P.id2name _3 in
     Iteration.parsed_virtual_identifiers :=
       Common.union_set [nm]
	 !Iteration.parsed_virtual_identifiers;
     Common.Right nm
    )}

pure_ident_or_meta_ident_with_idconstraint_re_only_:
  i = pure_ident_or_meta_ident c = option_re_only_
    {    (
      match c with
	  None -> (i, Ast.IdNoConstraint)
	| Some constraint_ -> (i,constraint_)
    )}

pure_ident_or_meta_ident_with_idconstraint_re_or_not_eqid_:
  i = pure_ident_or_meta_ident c = option_re_or_not_eqid_
    {    (
      match c with
	  None -> (i, Ast.IdNoConstraint)
	| Some constraint_ -> (i,constraint_)
    )}

re_or_not_eqid:
  re = regexp_eqid
    {                    (Ast.IdRegExpConstraint re)}
| _1 = TEq ne = idcstr
    {                    (Ast.IdPosIdSet (fst ne,snd ne))}
| _1 = TNotEq ne = idcstr
    {                    (Ast.IdNegIdSet (fst ne,snd ne))}

re_only:
  re = regexp_eqid
    {                  (Ast.IdRegExpConstraint re)}

regexp_eqid:
  _1 = TTildeEq re = TString
    {         ( (if !Data.in_iso
	    then failwith "constraints not allowed in iso file");
	   (if !Data.in_generating
	    then failwith "constraints not allowed in a generated rule file");
	   let (s,_) = re in Ast.IdRegExp (s,Regexp.regexp s)
	 )}
| _1 = TTildeExclEq re = TString
    {         ( (if !Data.in_iso
	    then failwith "constraints not allowed in iso file");
	   (if !Data.in_generating
	    then failwith "constraints not allowed in a generated rule file");
	   let (s,_) = re in Ast.IdNotRegExp (s,Regexp.regexp s)
	 )}

idcstr:
  i = pure_ident_or_meta_ident
    {         ( (if !Data.in_iso
	   then failwith "constraints not allowed in iso file");
	   (if !Data.in_generating
           (* pb: constraints not stored with metavars; too lazy to search for
	      them in the pattern *)
	   then failwith "constraints not allowed in a generated rule file");
	   (match i with
	     (Some rn,id) ->
	       let i =
		 P.check_inherited_constraint i
		   (function mv -> Ast.MetaIdDecl(Ast.NONE,mv)) in
	       ([],[i])
	   | (None,i) -> ([i],[])) )}
| _1 = TOBrace l = separated_nonempty_list_TComma_pure_ident_or_meta_ident_ _3 = TCBrace
    {let l =                                          ( l ) in
  ( (if !Data.in_iso
	   then failwith "constraints not allowed in iso file");
	   (if !Data.in_generating
	   then failwith "constraints not allowed in a generated rule file");
	   let (str,meta) =
	     List.fold_left
	       (function (str,meta) ->
		 function
		   (Some rn,id) as i ->
		     let i =
		       P.check_inherited_constraint i
			 (function mv -> Ast.MetaIdDecl(Ast.NONE,mv)) in
		     (str,i::meta)
		 | (None,i) -> (i::str,meta))
	       ([],[]) l in
	   (str,meta)
	 )}

re_or_not_eqe_or_sub:
  re = regexp_eqid
    {                  (Ast0.NotIdCstrt  re)}
| ne = not_eqe
    {                  (Ast0.NotExpCstrt ne)}
| s = sub
    {                  (Ast0.SubExpCstrt s)}

not_ceq_or_sub:
  ceq = not_ceq
    {                  (Ast0.NotExpCstrt ceq)}
| s = sub
    {                  (Ast0.SubExpCstrt s)}

not_eqe:
  _1 = TNotEq i = pure_ident
    {         ( (if !Data.in_iso
	   then failwith "constraints not allowed in iso file");
	   (if !Data.in_generating
	   then failwith "constraints not allowed in a generated rule file");
	   [Ast0.wrap(Ast0.Ident(Ast0.wrap(Ast0.Id(P.id2mcode i))))]
	 )}
| _1 = TNotEq _2 = TOBrace l = separated_nonempty_list_TComma_pure_ident_ _4 = TCBrace
    {let l =                                          ( l ) in
  ( (if !Data.in_iso
	   then failwith "constraints not allowed in iso file");
	   (if !Data.in_generating
	   then failwith "constraints not allowed in a generated rule file");
	   List.map
	     (function i ->
		Ast0.wrap(Ast0.Ident(Ast0.wrap(Ast0.Id(P.id2mcode i)))))
	     l
	 )}

not_ceq:
  _1 = TNotEq i = ident_or_const
    {         ( (if !Data.in_iso
	   then failwith "constraints not allowed in iso file");
	   (if !Data.in_generating
	   then failwith "constraints not allowed in a generated rule file");
	   [i] )}
| _1 = TNotEq _2 = TOBrace l = separated_nonempty_list_TComma_ident_or_const_ _4 = TCBrace
    {let l =                                          ( l ) in
  ( (if !Data.in_iso
	   then failwith "constraints not allowed in iso file");
	   (if !Data.in_generating
	   then failwith "constraints not allowed in a generated rule file");
	   l )}

sub:
  _1 = TSub i = meta_ident
    {         ( (if !Data.in_iso
	   then failwith "constraints not allowed in iso file");
	   (if !Data.in_generating
	   then failwith "constraints not allowed in a generated rule file");
	   let i =
	     P.check_inherited_constraint i
	       (function mv -> Ast.MetaExpDecl(Ast.NONE,mv,None)) in
	   [i] )}
| _1 = TSub _2 = TOBrace l = separated_nonempty_list_TComma_meta_ident_ _4 = TCBrace
    {let l =                                          ( l ) in
  ( (if !Data.in_iso
	   then failwith "constraints not allowed in iso file");
	   (if !Data.in_generating
	   then failwith "constraints not allowed in a generated rule file");
           List.map
	     (function i ->
	       P.check_inherited_constraint i
		 (function mv -> Ast.MetaExpDecl(Ast.NONE,mv,None)))
	     l)}

ident_or_const:
  i = pure_ident
    {                    ( Ast0.wrap(Ast0.Ident(Ast0.wrap(Ast0.Id(P.id2mcode i)))) )}
| _1 = wrapped_sym_ident
    {                         ( Ast0.wrap(Ast0.Ident(_1)) )}
| _1 = TInt
    {  ( let (x,clt) = _1 in
	 Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Int x) clt)) )}

not_pos:
  _1 = TNotEq i = meta_ident
    {         ( (if !Data.in_iso
	   then failwith "constraints not allowed in iso file");
	   (if !Data.in_generating
	   then failwith "constraints not allowed in a generated rule file");
	   let i =
	     P.check_inherited_constraint i
	       (function mv -> Ast.MetaPosDecl(Ast.NONE,mv)) in
	   [i] )}
| _1 = TNotEq _2 = TOBrace l = separated_nonempty_list_TComma_meta_ident_ _4 = TCBrace
    {let l =                                          ( l ) in
  ( (if !Data.in_iso
	   then failwith "constraints not allowed in iso file");
	   (if !Data.in_generating
	   then failwith "constraints not allowed in a generated rule file");
	   List.map
	     (function i ->
	       P.check_inherited_constraint i
		 (function mv -> Ast.MetaPosDecl(Ast.NONE,mv)))
	     l )}

func_ident:
  _1 = ident
    {             ( _1 )}
| _1 = TMetaFunc
    {         ( let (nm,constraints,pure,clt) = _1 in
	 Ast0.wrap(Ast0.MetaFunc(P.clt2mcode nm clt,constraints,pure)) )}
| _1 = TMetaLocalFunc
    {  ( let (nm,constraints,pure,clt) = _1 in
	 Ast0.wrap
	   (Ast0.MetaLocalFunc(P.clt2mcode nm clt,constraints,pure)) )}

fn_ident:
  _1 = disj_ident
    {                     ( _1 )}
| _1 = TMetaFunc
    {         ( let (nm,constraints,pure,clt) = _1 in
	 Ast0.wrap(Ast0.MetaFunc(P.clt2mcode nm clt,constraints,pure)) )}
| _1 = TMetaLocalFunc
    {  ( let (nm,constraints,pure,clt) = _1 in
	 Ast0.wrap
	   (Ast0.MetaLocalFunc(P.clt2mcode nm clt,constraints,pure)) )}

ident:
  _1 = pure_ident
    {         ( Ast0.wrap(Ast0.Id(P.id2mcode _1)) )}
| _1 = wrapped_sym_ident
    {                         ( _1 )}
| _1 = TMetaId
    {         ( let (nm,constraints,seed,pure,clt) = _1 in
         Ast0.wrap(Ast0.MetaId(P.clt2mcode nm clt,constraints,seed,pure)) )}

ident_or_kwd:
  _1 = pure_ident
    {         ( Ast0.wrap(Ast0.Id(P.id2mcode _1)) )}
| _1 = wrapped_sym_ident
    {                         ( _1 )}
| _1 = TMeta
    {             ( tmeta_to_ident _1 )}
| _1 = TMetaId
    {         ( let (nm,constraints,seed,pure,clt) = _1 in
         Ast0.wrap(Ast0.MetaId(P.clt2mcode nm clt,constraints,seed,pure)) )}
| _1 = Tinline
    {               ( Ast0.wrap(Ast0.Id(P.clt2mcode "inline" _1)) )}

mident:
  _1 = pure_ident
    {         ( Ast0.wrap(Ast0.Id(P.id2mcode _1)) )}
| _1 = wrapped_sym_ident
    {                         ( _1 )}
| _1 = TMeta
    {             ( tmeta_to_ident _1 )}
| _1 = TMetaId
    {         ( let (nm,constraints,seed,pure,clt) = _1 in
         Ast0.wrap(Ast0.MetaId(P.clt2mcode nm clt,constraints,seed,pure)) )}

disj_ident:
  _1 = mident
    {              ( _1 )}
| lp = TOPar0 t = midzero_list_disj_ident_disj_ident_ rp = TCPar0
    {  ( let (mids,code) = t in
	 Ast0.wrap
	   (Ast0.DisjId(P.id2mcode lp,code,mids, P.id2mcode rp)) )}

top_ident:
  _1 = disj_ident
    {             ( Ast0.wrap(Ast0.OTHER(Ast0.wrap(Ast0.TopId(_1)))) )}

type_ident:
  _1 = disj_ident
    {                       ( _1 )}
| _1 = TTypeId
    {         ( Ast0.wrap(Ast0.Id(P.id2mcode _1)) )}

decl_ident:
  _1 = TDeclarerId
    {         ( Ast0.wrap(Ast0.Id(P.id2mcode _1)) )}
| _1 = TMetaDeclarer
    {         ( let (nm,constraints,pure,clt) = _1 in
         Ast0.wrap(Ast0.MetaId(P.clt2mcode nm clt,constraints,Ast.NoVal,pure)) )}

iter_ident:
  _1 = TIteratorId
    {         ( Ast0.wrap(Ast0.Id(P.id2mcode _1)) )}
| _1 = TMetaIterator
    {         ( let (nm,constraints,pure,clt) = _1 in
         Ast0.wrap(Ast0.MetaId(P.clt2mcode nm clt,constraints,Ast.NoVal,pure)) )}

typedef_ident:
  _1 = pure_ident_or_symbol
    {         ( Ast0.wrap(Ast0.TypeName(P.id2mcode _1)) )}
| _1 = TMeta
    {             ( tmeta_to_type _1 )}
| _1 = TMetaType
    {         ( let (nm,pure,clt) = _1 in
	 Ast0.wrap(Ast0.MetaType(P.clt2mcode nm clt,pure)) )}

decl_list_name_opt_decl_:
  _1 = empty_list_start_one_dec_name_opt_decl__TEllipsis_
    {     ( Ast0.wrap
	 (Ast0.DOTS
	    (_1
	       (fun _ d -> Ast0.wrap(Ast0.Pdots(P.clt2mcode "..." d)))
	       (fun c -> Ast0.PComma c))) )}

one_dec_name_opt_decl_:
  _1 = name_opt_decl
    {        ( _1 )}
| _1 = TMetaParamList
    {    ( let (nm,lenname,pure,clt) = _1 in
    let nm = P.clt2mcode nm clt in
      let lenname =
	match lenname with
	  Ast.AnyLen -> Ast0.AnyListLen
	| Ast.MetaLen nm -> Ast0.MetaListLen(P.clt2mcode nm clt)
	| Ast.CstLen n -> Ast0.CstListLen n in
    Ast0.wrap(Ast0.MetaParamList(nm,lenname,pure)) )}

empty_list_start_aexpr_TEllipsis_:
  
    {              ( fun build_dots build_comma -> [] )}
| list = nonempty_list_start_aexpr_TEllipsis_
    {                                        ( list )}

empty_list_start_dparam_TEllipsis_:
  
    {              ( fun build_dots build_comma -> [] )}
| list = nonempty_list_start_dparam_TEllipsis_
    {                                        ( list )}

empty_list_start_initialize2_edots_when_TEllipsis_initialize__:
  
    {              ( fun build_dots build_comma -> [] )}
| list = nonempty_list_start_initialize2_edots_when_TEllipsis_initialize__
    {                                        ( list )}

empty_list_start_one_dec_name_opt_decl__TEllipsis_:
  
    {              ( fun build_dots build_comma -> [] )}
| list = nonempty_list_start_one_dec_name_opt_decl__TEllipsis_
    {                                        ( list )}

nonempty_list_start_aexpr_TEllipsis_:
  element = aexpr
    {               ( fun build_dots build_comma -> [element] )}
| element = aexpr comma = TComma
    {    ( fun build_dots build_comma ->
      element::[Ast0.wrap(build_comma(P.clt2mcode "," comma))] )}
| element = aexpr comma = TComma remainder = nonempty_list_start_aexpr_TEllipsis_
    {    ( fun build_dots build_comma ->
      element::(Ast0.wrap(build_comma(P.clt2mcode "," comma)))::
      (remainder build_dots build_comma) )}
| _1 = TNothing list = nonempty_list_start_aexpr_TEllipsis_
    {                                                 ( list )}
| dotter = TEllipsis
    {                ( fun build_dots build_comma -> [(build_dots "..." dotter)] )}
| dotter = TEllipsis comma = TComma
    {      ( fun build_dots build_comma ->
	[(build_dots "..." dotter);Ast0.wrap(build_comma(P.clt2mcode "," comma))] )}
| dotter = TEllipsis comma = TComma remainder = continue_list_aexpr_TEllipsis_
    {    ( fun build_dots build_comma ->
      (build_dots "..." dotter)::
      (Ast0.wrap(build_comma(P.clt2mcode "," comma)))::
      (remainder build_dots build_comma) )}

nonempty_list_start_dparam_TEllipsis_:
  element = dparam
    {               ( fun build_dots build_comma -> [element] )}
| element = dparam comma = TComma
    {    ( fun build_dots build_comma ->
      element::[Ast0.wrap(build_comma(P.clt2mcode "," comma))] )}
| element = dparam comma = TComma remainder = nonempty_list_start_dparam_TEllipsis_
    {    ( fun build_dots build_comma ->
      element::(Ast0.wrap(build_comma(P.clt2mcode "," comma)))::
      (remainder build_dots build_comma) )}
| _1 = TNothing list = nonempty_list_start_dparam_TEllipsis_
    {                                                 ( list )}
| dotter = TEllipsis
    {                ( fun build_dots build_comma -> [(build_dots "..." dotter)] )}
| dotter = TEllipsis comma = TComma
    {      ( fun build_dots build_comma ->
	[(build_dots "..." dotter);Ast0.wrap(build_comma(P.clt2mcode "," comma))] )}
| dotter = TEllipsis comma = TComma remainder = continue_list_dparam_TEllipsis_
    {    ( fun build_dots build_comma ->
      (build_dots "..." dotter)::
      (Ast0.wrap(build_comma(P.clt2mcode "," comma)))::
      (remainder build_dots build_comma) )}

nonempty_list_start_enum_decl_one_edots_when_TEllipsis_enum_decl_one__:
  element = enum_decl_one
    {               ( fun build_dots build_comma -> [element] )}
| element = enum_decl_one comma = TComma
    {    ( fun build_dots build_comma ->
      element::[Ast0.wrap(build_comma(P.clt2mcode "," comma))] )}
| element = enum_decl_one comma = TComma remainder = nonempty_list_start_enum_decl_one_edots_when_TEllipsis_enum_decl_one__
    {    ( fun build_dots build_comma ->
      element::(Ast0.wrap(build_comma(P.clt2mcode "," comma)))::
      (remainder build_dots build_comma) )}
| _1 = TNothing list = nonempty_list_start_enum_decl_one_edots_when_TEllipsis_enum_decl_one__
    {                                                 ( list )}
| dotter = edots_when_TEllipsis_enum_decl_one_
    {                ( fun build_dots build_comma -> [(build_dots "..." dotter)] )}
| dotter = edots_when_TEllipsis_enum_decl_one_ comma = TComma
    {      ( fun build_dots build_comma ->
	[(build_dots "..." dotter);Ast0.wrap(build_comma(P.clt2mcode "," comma))] )}
| dotter = edots_when_TEllipsis_enum_decl_one_ comma = TComma remainder = continue_list_enum_decl_one_edots_when_TEllipsis_enum_decl_one__
    {    ( fun build_dots build_comma ->
      (build_dots "..." dotter)::
      (Ast0.wrap(build_comma(P.clt2mcode "," comma)))::
      (remainder build_dots build_comma) )}

nonempty_list_start_initialize2_edots_when_TEllipsis_initialize__:
  element = initialize2
    {               ( fun build_dots build_comma -> [element] )}
| element = initialize2 comma = TComma
    {    ( fun build_dots build_comma ->
      element::[Ast0.wrap(build_comma(P.clt2mcode "," comma))] )}
| element = initialize2 comma = TComma remainder = nonempty_list_start_initialize2_edots_when_TEllipsis_initialize__
    {    ( fun build_dots build_comma ->
      element::(Ast0.wrap(build_comma(P.clt2mcode "," comma)))::
      (remainder build_dots build_comma) )}
| _1 = TNothing list = nonempty_list_start_initialize2_edots_when_TEllipsis_initialize__
    {                                                 ( list )}
| dotter = edots_when_TEllipsis_initialize_
    {                ( fun build_dots build_comma -> [(build_dots "..." dotter)] )}
| dotter = edots_when_TEllipsis_initialize_ comma = TComma
    {      ( fun build_dots build_comma ->
	[(build_dots "..." dotter);Ast0.wrap(build_comma(P.clt2mcode "," comma))] )}
| dotter = edots_when_TEllipsis_initialize_ comma = TComma remainder = continue_list_initialize2_edots_when_TEllipsis_initialize__
    {    ( fun build_dots build_comma ->
      (build_dots "..." dotter)::
      (Ast0.wrap(build_comma(P.clt2mcode "," comma)))::
      (remainder build_dots build_comma) )}

nonempty_list_start_one_dec_name_opt_decl__TEllipsis_:
  element = one_dec_name_opt_decl_
    {               ( fun build_dots build_comma -> [element] )}
| element = one_dec_name_opt_decl_ comma = TComma
    {    ( fun build_dots build_comma ->
      element::[Ast0.wrap(build_comma(P.clt2mcode "," comma))] )}
| element = one_dec_name_opt_decl_ comma = TComma remainder = nonempty_list_start_one_dec_name_opt_decl__TEllipsis_
    {    ( fun build_dots build_comma ->
      element::(Ast0.wrap(build_comma(P.clt2mcode "," comma)))::
      (remainder build_dots build_comma) )}
| _1 = TNothing list = nonempty_list_start_one_dec_name_opt_decl__TEllipsis_
    {                                                 ( list )}
| dotter = TEllipsis
    {                ( fun build_dots build_comma -> [(build_dots "..." dotter)] )}
| dotter = TEllipsis comma = TComma
    {      ( fun build_dots build_comma ->
	[(build_dots "..." dotter);Ast0.wrap(build_comma(P.clt2mcode "," comma))] )}
| dotter = TEllipsis comma = TComma remainder = continue_list_one_dec_name_opt_decl__TEllipsis_
    {    ( fun build_dots build_comma ->
      (build_dots "..." dotter)::
      (Ast0.wrap(build_comma(P.clt2mcode "," comma)))::
      (remainder build_dots build_comma) )}

continue_list_aexpr_TEllipsis_:
  element = aexpr
    {               ( fun build_dots build_comma -> [element] )}
| element = aexpr comma = TComma
    {    ( fun build_dots build_comma ->
      element::[Ast0.wrap(build_comma(P.clt2mcode "," comma))] )}
| element = aexpr comma = TComma remainder = nonempty_list_start_aexpr_TEllipsis_
    {    ( fun build_dots build_comma ->
      element::(Ast0.wrap(build_comma(P.clt2mcode "," comma)))::
      (remainder build_dots build_comma) )}
| _1 = TNothing list = nonempty_list_start_aexpr_TEllipsis_
    {                                                 ( list )}

continue_list_dparam_TEllipsis_:
  element = dparam
    {               ( fun build_dots build_comma -> [element] )}
| element = dparam comma = TComma
    {    ( fun build_dots build_comma ->
      element::[Ast0.wrap(build_comma(P.clt2mcode "," comma))] )}
| element = dparam comma = TComma remainder = nonempty_list_start_dparam_TEllipsis_
    {    ( fun build_dots build_comma ->
      element::(Ast0.wrap(build_comma(P.clt2mcode "," comma)))::
      (remainder build_dots build_comma) )}
| _1 = TNothing list = nonempty_list_start_dparam_TEllipsis_
    {                                                 ( list )}

continue_list_enum_decl_one_edots_when_TEllipsis_enum_decl_one__:
  element = enum_decl_one
    {               ( fun build_dots build_comma -> [element] )}
| element = enum_decl_one comma = TComma
    {    ( fun build_dots build_comma ->
      element::[Ast0.wrap(build_comma(P.clt2mcode "," comma))] )}
| element = enum_decl_one comma = TComma remainder = nonempty_list_start_enum_decl_one_edots_when_TEllipsis_enum_decl_one__
    {    ( fun build_dots build_comma ->
      element::(Ast0.wrap(build_comma(P.clt2mcode "," comma)))::
      (remainder build_dots build_comma) )}
| _1 = TNothing list = nonempty_list_start_enum_decl_one_edots_when_TEllipsis_enum_decl_one__
    {                                                 ( list )}

continue_list_initialize2_edots_when_TEllipsis_initialize__:
  element = initialize2
    {               ( fun build_dots build_comma -> [element] )}
| element = initialize2 comma = TComma
    {    ( fun build_dots build_comma ->
      element::[Ast0.wrap(build_comma(P.clt2mcode "," comma))] )}
| element = initialize2 comma = TComma remainder = nonempty_list_start_initialize2_edots_when_TEllipsis_initialize__
    {    ( fun build_dots build_comma ->
      element::(Ast0.wrap(build_comma(P.clt2mcode "," comma)))::
      (remainder build_dots build_comma) )}
| _1 = TNothing list = nonempty_list_start_initialize2_edots_when_TEllipsis_initialize__
    {                                                 ( list )}

continue_list_one_dec_name_opt_decl__TEllipsis_:
  element = one_dec_name_opt_decl_
    {               ( fun build_dots build_comma -> [element] )}
| element = one_dec_name_opt_decl_ comma = TComma
    {    ( fun build_dots build_comma ->
      element::[Ast0.wrap(build_comma(P.clt2mcode "," comma))] )}
| element = one_dec_name_opt_decl_ comma = TComma remainder = nonempty_list_start_one_dec_name_opt_decl__TEllipsis_
    {    ( fun build_dots build_comma ->
      element::(Ast0.wrap(build_comma(P.clt2mcode "," comma)))::
      (remainder build_dots build_comma) )}
| _1 = TNothing list = nonempty_list_start_one_dec_name_opt_decl__TEllipsis_
    {                                                 ( list )}

minus_start:
  _1 = fundecl
    {                         ( [Ast0.wrap(Ast0.OTHER(_1))] )}
| _1 = ctype
    {                         ( [Ast0.wrap(Ast0.OTHER(Ast0.wrap(Ast0.Ty(_1))))] )}
| _1 = top_init
    {                    ( [Ast0.wrap(Ast0.OTHER(Ast0.wrap(Ast0.TopInit(_1))))] )}
| _1 = toplevel_seq_startne_toplevel_after_dots_init_
    {    ( List.map (function x -> Ast0.wrap(Ast0.OTHER(x))) _1 )}

toplevel_seq_startne_toplevel_after_dots_init_:
  a = TEllipsis w = list_whenppdecs_ b = toplevel_after_dots_init
    {let a =     ( Ast0.wrap(Ast0.Dots(P.clt2mcode "..." a, List.concat w)) ) in
                                             ( a::b )}
| a = TOEllipsis w = list_whenppdecs_ b_inlined1 = nest_start c = TCEllipsis b = toplevel_after_dots_init
    {let a =
  let b = b_inlined1 in
      ( Ast0.wrap(Ast0.Nest(P.clt2mcode "<..." a, b,
			  P.clt2mcode "...>" c, List.concat w, false)) )
in
                                              ( a::b )}
| a = TPOEllipsis w = list_whenppdecs_ b_inlined1 = nest_start c = TPCEllipsis b = toplevel_after_dots_init
    {let a =
  let b = b_inlined1 in
      ( Ast0.wrap(Ast0.Nest(P.clt2mcode "<+..." a, b,
			  P.clt2mcode "...+>" c, List.concat w, true)) )
in
                                              ( a::b )}
| a = TOEllipsis w = list_whenppdecs_ b = nest_start c = TCEllipsis
    {let a =     ( Ast0.wrap(Ast0.Nest(P.clt2mcode "<..." a, b,
			  P.clt2mcode "...>" c, List.concat w, false)) ) in
                                       ( [a] )}
| a = TPOEllipsis w = list_whenppdecs_ b = nest_start c = TPCEllipsis
    {let a =     ( Ast0.wrap(Ast0.Nest(P.clt2mcode "<+..." a, b,
			  P.clt2mcode "...+>" c, List.concat w, true)) ) in
                                       ( [a] )}
| _1 = expr _2 = toplevel_after_exp
    {                                     ( (Ast0.wrap(Ast0.Exp(_1)))::_2 )}
| _1 = decl_statement_expr _2 = toplevel_after_stm
    {                                          ( _1@_2 )}

toplevel_seq_start_toplevel_after_dots_:
  _1 = stm_dots _2 = toplevel_after_dots
    {                                     ( _1::_2 )}
| _1 = expr _2 = toplevel_after_exp
    {                                     ( (Ast0.wrap(Ast0.Exp(_1)))::_2 )}
| _1 = decl_statement_expr _2 = toplevel_after_stm
    {                                          ( _1@_2 )}

toplevel_after_dots_init:
  _1 = TNothing _2 = toplevel_after_exp
    {                                     (_2)}
| _1 = expr _2 = toplevel_after_exp
    {                                     ((Ast0.wrap(Ast0.Exp(_1)))::_2)}
| _1 = decl_statement_expr _2 = toplevel_after_stm
    {                                          (_1@_2)}

toplevel_after_exp:
  
    {                                     ([])}
| _1 = stm_dots _2 = toplevel_after_dots
    {                                     (_1::_2)}

toplevel_after_dots:
  
    {                                     ([])}
| _1 = TNothing _2 = toplevel_after_exp
    {                                     (_2)}
| _1 = expr _2 = toplevel_after_exp
    {                                     ((Ast0.wrap(Ast0.Exp(_1)))::_2)}
| _1 = decl_statement_expr _2 = toplevel_after_stm
    {                                          (_1@_2)}

toplevel_after_stm:
  
    {                                     ([])}
| _1 = stm_dots _2 = toplevel_after_dots
    {                                     (_1::_2)}
| _1 = decl_statement _2 = toplevel_after_stm
    {                                     (_1@_2)}

top_init:
  _1 = TOInit _2 = initialize_list _3 = TCBrace
    {    ( if P.struct_initializer _2
    then
      let il = P.drop_dot_commas _2 in
      Ast0.wrap(Ast0.InitList(P.clt2mcode "{" _1,il,P.clt2mcode "}" _3,false))
    else
      Ast0.wrap(Ast0.InitList(P.clt2mcode "{" _1,_2,P.clt2mcode "}" _3,true)) )}

plus_start:
  _1 = ctype
    {                          ( [Ast0.wrap(Ast0.OTHER(Ast0.wrap(Ast0.Ty(_1))))] )}
| _1 = top_init
    {                     ( [Ast0.wrap(Ast0.OTHER(Ast0.wrap(Ast0.TopInit(_1))))] )}
| _1 = stm_dots _2 = plus_after_dots
    {                                          ( (Ast0.wrap(Ast0.OTHER(_1)))::_2 )}
| _1 = expr _2 = plus_after_exp
    {                     ( (Ast0.wrap(Ast0.OTHER(Ast0.wrap(Ast0.Exp(_1)))))::_2 )}
| _1 = fundecl _2 = plus_after_stm
    {                                             ( Ast0.wrap(Ast0.OTHER(_1))::_2 )}
| _1 = decl_statement_expr _2 = plus_after_stm
    {                ( (List.map (function x -> Ast0.wrap(Ast0.OTHER(x))) _1)@_2 )}

plus_after_exp:
  
    {                                                                         ([])}
| _1 = stm_dots _2 = plus_after_dots
    {                                          ( (Ast0.wrap(Ast0.OTHER(_1)))::_2 )}

plus_after_dots:
  
    {                                                                         ([])}
| _1 = TNothing _2 = plus_after_exp
    {                                                                         (_2)}
| _1 = expr _2 = plus_after_exp
    {                     ( (Ast0.wrap(Ast0.OTHER(Ast0.wrap(Ast0.Exp(_1)))))::_2 )}
| _1 = fundecl _2 = plus_after_stm
    {                                             ( Ast0.wrap(Ast0.OTHER(_1))::_2 )}
| _1 = decl_statement_expr _2 = plus_after_stm
    {                ( (List.map (function x -> Ast0.wrap(Ast0.OTHER(x))) _1)@_2 )}

plus_after_stm:
  
    {                                                                         ([])}
| _1 = stm_dots _2 = plus_after_dots
    {                                          ( (Ast0.wrap(Ast0.OTHER(_1)))::_2 )}
| _1 = fundecl _2 = plus_after_stm
    {                                             ( Ast0.wrap(Ast0.OTHER(_1))::_2 )}
| _1 = decl_statement _2 = plus_after_stm
    {                ( (List.map (function x -> Ast0.wrap(Ast0.OTHER(x))) _1)@_2 )}

fun_start:
  _1 = fun_after_stm
    {                 ( Ast0.wrap(Ast0.DOTS(_1)) )}

fun_after_stm:
  
    {                               ([])}
| _1 = stm_dots _2 = fun_after_dots
    {                               (_1::_2)}
| _1 = decl_statement _2 = fun_after_stm
    {                               (_1@_2)}

fun_after_dots:
  
    {                               ([])}
| _1 = TNothing _2 = fun_after_exp
    {                               (_2)}
| _1 = expr _2 = fun_after_exp
    {                               (Ast0.wrap(Ast0.Exp(_1))::_2)}
| _1 = decl_statement_expr _2 = fun_after_stm
    {                                    (_1@_2)}

fun_after_exp:
  _1 = stm_dots _2 = fun_after_dots
    {                               (_1::_2)}

fun_after_dots_or:
  
    {                               ([])}
| _1 = TNothing _2 = fun_after_exp_or
    {                               (_2)}
| _1 = expr _2 = fun_after_exp_or
    {                               (Ast0.wrap(Ast0.Exp(_1))::_2)}
| _1 = decl_statement_expr _2 = fun_after_stm
    {                                    (_1@_2)}

fun_after_exp_or:
  
    {                               ([])}
| _1 = stm_dots _2 = fun_after_dots
    {                               (_1::_2)}

nest_start:
  _1 = nest_after_dots
    {                   ( Ast0.wrap(Ast0.DOTS(_1)) )}

nest_after_dots:
  _1 = decl_statement_expr _2 = nest_after_stm
    {                                     (_1@_2)}
| _1 = TNothing _2 = nest_after_exp
    {                                (_2)}
| _1 = expr _2 = nest_after_exp
    {                                ((Ast0.wrap(Ast0.Exp(_1)))::_2)}

nest_after_stm:
  
    {                                ([])}
| _1 = stm_dots _2 = nest_after_dots
    {                                (_1::_2)}
| _1 = decl_statement _2 = nest_after_stm
    {                                (_1@_2)}

nest_after_exp:
  
    {                                ([])}
| _1 = stm_dots _2 = nest_after_dots
    {                                (_1::_2)}

when_start:
  _1 = expr _2 = toplevel_after_exp
    {    ( Ast0.wrap(Ast0.DOTS((Ast0.wrap(Ast0.Exp(_1)))::_2)) )}
| _1 = decl_statement _2 = toplevel_after_stm
    {    ( Ast0.wrap(Ast0.DOTS(_1@_2)) )}

aexpr:
  _1 = dargexpr
    {             ( Ast0.set_arg_exp _1 )}
| _1 = TMetaExpList
    {      ( let (nm,lenname,pure,clt) = _1 in
      let nm = P.clt2mcode nm clt in
      let lenname =
	match lenname with
	  Ast.AnyLen -> Ast0.AnyListLen
	| Ast.MetaLen nm -> Ast0.MetaListLen(P.clt2mcode nm clt)
	| Ast.CstLen n -> Ast0.CstListLen n in
      Ast0.wrap(Ast0.MetaExprList(nm,lenname,pure)) )}
| _1 = ctype
    {      ( Ast0.set_arg_exp(Ast0.wrap(Ast0.TypeExp(_1))) )}

eexpr_list_option:
  _1 = empty_list_start_aexpr_TEllipsis_
    {      ( Ast0.wrap
	  (Ast0.DOTS
	     (_1
		(fun _ d -> Ast0.wrap(Ast0.Edots(P.clt2mcode "..." d,None)))
		(fun c -> Ast0.EComma c))) )}

exec_list:
  
    {                ( [] )}
| _1 = TDotDot _2 = exec_front_ident _3 = exec_ident _4 = exec_list
    {      ( Ast0.wrap(Ast0.ExecEval(P.clt2mcode ":" _1,_3 _2)) :: _4 )}
| _1 = TIdent _2 = exec_ident2 _3 = exec_list
    {      ( Ast0.wrap(Ast0.ExecToken(P.clt2mcode (fst _1) (snd _1))) ::
	List.map (function x -> Ast0.wrap(Ast0.ExecToken x)) _2 @ _3 )}
| _1 = token _2 = exec_list
    {                    ( Ast0.wrap(Ast0.ExecToken _1) :: _2 )}
| _1 = TEllipsis _2 = exec_list
    {      ( Ast0.wrap(Ast0.ExecDots(P.clt2mcode "..." _1)) :: _2 )}

exec_front_ident:
  _1 = ident
    {          ( Ast0.wrap(Ast0.Ident(_1)) )}
| _1 = TMetaIdExp
    {     ( let (nm,constraints,pure,ty,clt) = _1 in
     Ast0.wrap
       (Ast0.MetaExpr(P.clt2mcode nm clt,constraints,ty,Ast.ID,pure)) )}
| _1 = TMetaExp
    {     ( let (nm,constraints,pure,ty,clt) = _1 in
     Ast0.wrap
       (Ast0.MetaExpr(P.clt2mcode nm clt,constraints,ty,Ast.ANY,pure)) )}

exec_ident:
  
    {     ( function prev -> prev )}
| _1 = TDot _2 = disj_ident _3 = exec_ident
    {     ( function prev ->
       _3 (Ast0.wrap(Ast0.RecordAccess(prev, P.clt2mcode "." _1, _2))) )}
| _1 = TPtrOp _2 = disj_ident _3 = exec_ident
    {     ( function prev ->
       _3 (Ast0.wrap(Ast0.RecordPtAccess(prev, P.clt2mcode "->" _1,
				     _2))) )}

exec_ident2:
  
    {     ( [] )}
| _1 = TDot _2 = TIdent _3 = exec_ident2
    {     ( (P.clt2mcode "." _1) :: (P.clt2mcode (fst _2) (snd _2)) :: _3 )}
| _1 = TPtrOp _2 = TIdent _3 = exec_ident2
    {     ( (P.clt2mcode "." _1) :: (P.clt2mcode (fst _2) (snd _2)) :: _3 )}

token:
  _1 = TPlus
    {          ( P.clt2mcode "+" _1 )}
| _1 = TMinus
    {           ( P.clt2mcode "-" _1 )}
| _1 = TMul
    {         ( P.clt2mcode "*" _1 )}
| _1 = TEqEq
    {          ( P.clt2mcode "==" _1 )}
| _1 = TNotEq
    {           ( P.clt2mcode "!=" _1 )}
| _1 = TDmOp
    {          ( P.clt2mcode (arithOp(fst _1)) (snd _1) )}
| _1 = TShLOp
    {           ( P.clt2mcode (arithOp(fst _1)) (snd _1) )}
| _1 = TShROp
    {           ( P.clt2mcode (arithOp(fst _1)) (snd _1) )}
| _1 = TLogOp
    {           ( P.clt2mcode (logicalOp(fst _1)) (snd _1) )}
| _1 = TOr
    {        ( P.clt2mcode "|" _1 )}
| _1 = TXor
    {         ( P.clt2mcode "+" _1 )}
| _1 = TAnd
    {         ( P.clt2mcode "&" _1 )}
| _1 = TOrLog
    {           ( P.clt2mcode "||" _1 )}
| _1 = TAndLog
    {            ( P.clt2mcode "&&" _1 )}
| _1 = TOBrace
    {            ( P.clt2mcode "{" _1 )}
| _1 = TCBrace
    {            ( P.clt2mcode "}" _1 )}
| _1 = TOCro
    {          ( P.clt2mcode "[" _1 )}
| _1 = TCCro
    {          ( P.clt2mcode "]" _1 )}
| _1 = TEq
    {        ( P.clt2mcode "=" _1 )}
| _1 = TWhy
    {         ( P.clt2mcode "?" _1 )}
| _1 = TBang
    {          ( P.clt2mcode "!" _1 )}
| _1 = TOPar
    {          ( P.clt2mcode "(" _1 )}
| _1 = TCPar
    {          ( P.clt2mcode ")" _1 )}
| _1 = TIf
    {        ( P.clt2mcode "if" _1 )}
| _1 = TElse
    {          ( P.clt2mcode "else" _1 )}

midzero_list_ctype_ctype_:
  a = ctype b = list_mzl_ctype__
    {     ( let (mids,code) = List.split b in (mids,(a::code)) )}

midzero_list_disj_ident_disj_ident_:
  a = disj_ident b = list_mzl_disj_ident__
    {     ( let (mids,code) = List.split b in (mids,(a::code)) )}

midzero_list_eexpr_eexpr_:
  a = eexpr b = list_mzl_eexpr__
    {     ( let (mids,code) = List.split b in (mids,(a::code)) )}

midzero_list_expr_eexpr_:
  a = expr b = list_mzl_eexpr__
    {     ( let (mids,code) = List.split b in (mids,(a::code)) )}

midzero_list_fun_after_stm_fun_after_dots_or_:
  a = fun_after_stm b = list_mzl_fun_after_dots_or__
    {     ( let (mids,code) = List.split b in (mids,(a::code)) )}

midzero_list_fun_start_fun_start_:
  a = fun_start b = list_mzl_fun_start__
    {     ( let (mids,code) = List.split b in (mids,(a::code)) )}

midzero_list_mctype_mctype_:
  a = mctype b = list_mzl_mctype__
    {     ( let (mids,code) = List.split b in (mids,(a::code)) )}

midzero_list_rule_elem_statement_rule_elem_statement_:
  a = rule_elem_statement b = list_mzl_rule_elem_statement__
    {     ( let (mids,code) = List.split b in (mids,(a::code)) )}

midzero_list_statement_statement_:
  a = statement b = list_mzl_statement__
    {     ( let (mids,code) = List.split b in (mids,(a::code)) )}

midzero_list_struct_decl_one_struct_decl_one_:
  a = struct_decl_one b = list_mzl_struct_decl_one__
    {     ( let (mids,code) = List.split b in (mids,(a::code)) )}

mzl_ctype_:
  a = TMid0 b = ctype
    {                 ( (P.id2mcode a, b) )}

mzl_disj_ident_:
  a = TMid0 b = disj_ident
    {                 ( (P.id2mcode a, b) )}

mzl_eexpr_:
  a = TMid0 b = eexpr
    {                 ( (P.id2mcode a, b) )}

mzl_fun_after_dots_or_:
  a = TMid0 b = fun_after_dots_or
    {                 ( (P.id2mcode a, b) )}

mzl_fun_start_:
  a = TMid0 b = fun_start
    {                 ( (P.id2mcode a, b) )}

mzl_mctype_:
  a = TMid0 b = mctype
    {                 ( (P.id2mcode a, b) )}

mzl_rule_elem_statement_:
  a = TMid0 b = rule_elem_statement
    {                 ( (P.id2mcode a, b) )}

mzl_statement_:
  a = TMid0 b = statement
    {                 ( (P.id2mcode a, b) )}

mzl_struct_decl_one_:
  a = TMid0 b = struct_decl_one
    {                 ( (P.id2mcode a, b) )}

edots_when_TEllipsis_eexpr_:
  d = TEllipsis
    {                                                  ( (d,None) )}
| d = TEllipsis t = TWhen e = TNotEq w = eexpr _5 = TLineEnd
    {    ( (d, Some (P.clt2mcode "when" t, P.clt2mcode "!=" e,w)) )}

edots_when_TEllipsis_enum_decl_one_:
  d = TEllipsis
    {                                                  ( (d,None) )}
| d = TEllipsis t = TWhen e = TNotEq w = enum_decl_one _5 = TLineEnd
    {    ( (d, Some (P.clt2mcode "when" t, P.clt2mcode "!=" e,w)) )}

edots_when_TEllipsis_initialize_:
  d = TEllipsis
    {                                                  ( (d,None) )}
| d = TEllipsis t = TWhen e = TNotEq w = initialize _5 = TLineEnd
    {    ( (d, Some (P.clt2mcode "when" t, P.clt2mcode "!=" e,w)) )}

edots_when_TEllipsis_struct_decl_one_:
  d = TEllipsis
    {                                                  ( (d,None) )}
| d = TEllipsis t = TWhen e = TNotEq w = struct_decl_one _5 = TLineEnd
    {    ( (d, Some (P.clt2mcode "when" t, P.clt2mcode "!=" e,w)) )}

whens_when_start_rule_elem_statement_any_strict_:
  t = TWhen e = TNotEq w = when_start _4 = TLineEnd
    {      ( [Ast0.WhenNot (P.clt2mcode "when" t, P.clt2mcode "!=" e, w)] )}
| t = TWhen e = TEq w = rule_elem_statement _4 = TLineEnd
    {      ( [Ast0.WhenAlways (P.clt2mcode "when" t, P.clt2mcode "=" e, w)] )}
| t = TWhen l = separated_nonempty_list_TComma_any_strict_ _3 = TLineEnd
    {let l =                                          ( l ) in
      ( List.map (function x -> Ast0.WhenModifier(P.clt2mcode "when" t,x)) l )}
| t = TWhenTrue ee = TNotEq e = eexpr _4 = TLineEnd
    {      ( [Ast0.WhenNotTrue (P.clt2mcode "when" t, P.clt2mcode "!=" ee, e)] )}
| t = TWhenFalse ee = TNotEq e = eexpr _4 = TLineEnd
    {      ( [Ast0.WhenNotFalse (P.clt2mcode "when" t, P.clt2mcode "!=" ee, e)] )}

any_strict:
  _1 = TAny
    {            ( Ast.WhenAny )}
| _1 = TStrict
    {            ( Ast.WhenStrict )}
| _1 = TForall
    {            ( Ast.WhenForall )}
| _1 = TExists
    {            ( Ast.WhenExists )}

iso_main:
  _1 = TIsoExpression e1 = eexpr el = list_iso_eexpr__ _4 = EOF
    {    ( let fn x = Ast0.ExprTag x in P.iso_adjust fn fn e1 el )}
| _1 = TIsoArgExpression e1 = eexpr el = list_iso_eexpr__ _4 = EOF
    {    ( let fn x = Ast0.ArgExprTag x in P.iso_adjust fn fn e1 el )}
| _1 = TIsoTestExpression e1 = eexpr el = list_iso_eexpr__ _4 = EOF
    {    ( let fn x = Ast0.TestExprTag x in P.iso_adjust fn fn e1 el )}
| _1 = TIsoToTestExpression e1 = eexpr el = list_iso_eexpr__ _4 = EOF
    {    ( let ffn x = Ast0.ExprTag x in
      let fn x =  Ast0.TestExprTag x in
      P.iso_adjust ffn fn e1 el )}
| _1 = TIsoStatement s1 = iso_statement sl = list_iso_iso_statement__ _4 = EOF
    {    ( let fn x = Ast0.StmtTag x in P.iso_adjust fn fn s1 sl )}
| _1 = TIsoType t1 = ctype tl = list_iso_ctype__ _4 = EOF
    {    ( let fn x = Ast0.TypeCTag x in P.iso_adjust fn fn t1 tl )}
| _1 = TIsoTopLevel e1 = nest_start el = list_iso_nest_start__ _4 = EOF
    {    ( let fn x = Ast0.DotsStmtTag x in P.iso_adjust fn fn e1 el )}
| _1 = TIsoDeclaration d1 = decl_var dl = list_iso_decl_var__ _4 = EOF
    {    ( let check_one = function
	[x] -> x
      | _ ->
	  raise
	    (Semantic_cocci.Semantic
	       "only one variable per declaration in an isomorphism rule") in
    let d1 = check_one d1 in
    let dl =
      List.map
	(function
	    Common.Left x -> Common.Left(check_one x)
	  | Common.Right x -> Common.Right(check_one x))
	dl in
    let fn x = Ast0.DeclTag x in P.iso_adjust fn fn d1 dl )}

iso_ctype_:
  _1 = TIso t = ctype
    {                ( Common.Left t )}
| _1 = TRightIso t = ctype
    {                     ( Common.Right t )}

iso_decl_var_:
  _1 = TIso t = decl_var
    {                ( Common.Left t )}
| _1 = TRightIso t = decl_var
    {                     ( Common.Right t )}

iso_eexpr_:
  _1 = TIso t = eexpr
    {                ( Common.Left t )}
| _1 = TRightIso t = eexpr
    {                     ( Common.Right t )}

iso_iso_statement_:
  _1 = TIso t = iso_statement
    {                ( Common.Left t )}
| _1 = TRightIso t = iso_statement
    {                     ( Common.Right t )}

iso_nest_start_:
  _1 = TIso t = nest_start
    {                ( Common.Left t )}
| _1 = TRightIso t = nest_start
    {                     ( Common.Right t )}

never_used:
  _1 = TDirective
    {                       ( () )}
| _1 = TPArob _2 = TMetaPos
    {                    ( () )}
| _1 = TScriptData
    {                    ( () )}
| _1 = TAnalysis
    {                  ( () )}
| _1 = TWhitespace
    {                ( () )}

script_meta_main:
  py = pure_ident _2 = TMPtVirg
    {  ( ((Some (P.id2name py), None), None) )}
| py = pure_ident _2 = script_name_decl _3 = TMPtVirg
    {  ( ((Some (P.id2name py), None), Some _2) )}
| _1 = TOPar _2 = TUnderscore _3 = TComma ast = pure_ident _5 = TCPar _6 = script_name_decl _7 = TMPtVirg
    {  ( ((None, Some (P.id2name ast)), Some _6) )}
| _1 = TOPar str = pure_ident _3 = TComma _4 = TUnderscore _5 = TCPar _6 = script_name_decl _7 = TMPtVirg
    {  ( ((Some (P.id2name str), None), Some _6) )}
| _1 = TOPar str = pure_ident _3 = TComma ast = pure_ident _5 = TCPar _6 = script_name_decl _7 = TMPtVirg
    {  ( ((Some (P.id2name str), Some (P.id2name ast)), Some _6) )}

script_name_decl:
  _1 = TShLOp _2 = TRuleName _3 = TDot cocci = pure_ident
    {      ( let nm = P.id2name cocci in
        let mv = Parse_aux.lookup _2 nm in
        ((_2, nm), mv) )}
| _1 = TShLOp _2 = TVirtual _3 = TDot cocci = pure_ident
    {      ( let nm = P.id2name cocci in
	 Iteration.parsed_virtual_identifiers :=
	   Common.union_set [nm]
	     !Iteration.parsed_virtual_identifiers;
        let name = ("virtual", nm) in
        let mv = Ast.MetaIdDecl(Ast.NONE,name) in
        (name,mv) )}

script_meta_virt_nofresh_main:
  py = pure_ident _2 = script_virt_name_decl _3 = TMPtVirg
    {  ( ((Some (P.id2name py), None), Some _2) )}

script_virt_name_decl:
  _1 = TShLOp _2 = TVirtual _3 = TDot cocci = pure_ident
    {      ( let nm = P.id2name cocci in
	 Iteration.parsed_virtual_identifiers :=
	   Common.union_set [nm]
	     !Iteration.parsed_virtual_identifiers;
        let name = ("virtual", nm) in
        let mv = Ast.MetaIdDecl(Ast.NONE,name) in
        (name,mv) )}

%%


