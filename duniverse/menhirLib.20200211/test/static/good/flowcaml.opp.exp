File "flowcaml.mly", line 205, characters 7-12:
Warning: the token CLASS is unused.
File "flowcaml.mly", line 209, characters 7-19:
Warning: the token COLONGREATER is unused.
File "flowcaml.mly", line 230, characters 7-20:
Warning: the token GREATERRBRACE is unused.
File "flowcaml.mly", line 231, characters 7-22:
Warning: the token GREATERRBRACKET is unused.
File "flowcaml.mly", line 240, characters 7-14:
Warning: the token INHERIT is unused.
File "flowcaml.mly", line 241, characters 7-17:
Warning: the token INITIALIZE is unused.
File "flowcaml.mly", line 242, characters 7-18:
Warning: the token INITIALIZER is unused.
File "flowcaml.mly", line 247, characters 7-17:
Warning: the token LBRACELESS is unused.
File "flowcaml.mly", line 258, characters 7-13:
Warning: the token METHOD is unused.
File "flowcaml.mly", line 264, characters 7-10:
Warning: the token NEW is unused.
File "flowcaml.mly", line 265, characters 7-13:
Warning: the token OBJECT is unused.
File "flowcaml.mly", line 268, characters 16-24:
Warning: the token OPTLABEL is unused.
File "flowcaml.mly", line 272, characters 7-14:
Warning: the token PRIVATE is unused.
File "flowcaml.mly", line 273, characters 7-15:
Warning: the token QUESTION is unused.
File "flowcaml.mly", line 295, characters 7-14:
Warning: the token VIRTUAL is unused.
%{
open Location
open Longident
open Asttypes
open Parsetree



let mktyp d =
  { ptyp_desc = d; ptyp_loc = symbol_rloc() }
let mktys typ tyc_list =
  { ptys_type = typ; ptys_constraints = tyc_list; ptys_loc = symbol_rloc () }
let mktyc d =
  { ptyc_desc = d; ptyc_loc = symbol_rloc() }
let mkpat d =
  { ppat_desc = d; ppat_loc = symbol_rloc() }
let mktry d =
  { ptry_desc = d; ptry_loc = symbol_rloc() }
let mktryi lid opt_pat =
  { ptryi_exception = lid;
    ptryi_arg = opt_pat;
    ptryi_loc = symbol_rloc() }
let mkexp d =
  { pexp_desc = d; pexp_loc = symbol_rloc() }
let mkstr d =
  { pstr_desc = d; pstr_loc = symbol_rloc() }
let mkmty d =
  { pmty_desc = d; pmty_loc = symbol_rloc() }
let mksig d =
  { psig_desc = d; psig_loc = symbol_rloc() }
let mkmod d =
  { pmod_desc = d; pmod_loc = symbol_rloc() }
let mklvd (f, t) =
  { plvd_lb = f; plvd_ub = t; plvd_loc = symbol_rloc() }
let mklvl d =
  { plvl_desc = d; plvl_loc = symbol_rloc() }
let mkexn t m =
  { pexn_type = t; pexn_manifest = m; pexn_loc = symbol_rloc() }
let mkwth lid d =
  { pwth_ident = lid; pwth_desc = d; pwth_loc = symbol_rloc() }

let mkoperator name pos =
  { pexp_desc = Pexp_ident(Lident name); pexp_loc = rhs_loc pos }

let ghexp d = { pexp_desc = d; pexp_loc = symbol_gloc () };;
let ghpat d = { ppat_desc = d; ppat_loc = symbol_gloc () };;
let ghtyp d = { ptyp_desc = d; ptyp_loc = symbol_gloc () };;

let ptyp_any =
  let count = ref 0 in
  function () -> incr count; Ptyp_var ("%" ^ (string_of_int !count))

let mkassert e =
  match e with
  | {pexp_desc = Pexp_construct (Lident "false", None, false) } ->
         mkexp (Pexp_assertfalse)
  | _ -> mkexp (Pexp_assert (e))

let mklazy e =
  let void_pat = ghpat (Ppat_construct (Lident "()", None, false)) in
  let f = ghexp (Pexp_function ([void_pat, None, e])) in
  let delayed = Ldot (Lident "Lazy", "Delayed") in
  let df = ghexp (Pexp_construct (delayed, Some f, false)) in
  let r = ghexp (Pexp_ident (Ldot (Lident "Pervasives", "ref"))) in
  ghexp (Pexp_apply (r, [df]))

let mkinfix arg1 name arg2 =
  mkexp(Pexp_apply(mkoperator name 2, [arg1; arg2]))

let neg_float_string f =
  if String.length f > 0 && f.[0] = '-'
  then String.sub f 1 (String.length f - 1)
  else "-" ^ f

let mkuminus name arg =
  match arg.pexp_desc with
    Pexp_constant(Const_int n) ->
      mkexp(Pexp_constant(Const_int(-n)))
  | Pexp_constant(Const_float f) ->
      mkexp(Pexp_constant(Const_float(neg_float_string f)))
  | _ ->
      mkexp(Pexp_apply(mkoperator ("~" ^ name) 1, [arg]))

let rec mktailexp = function
    [] ->
      ghexp(Pexp_construct(Lident "[]", None, false))
  | e1 :: el ->
      let exp_el = mktailexp el in
      let l = {loc_start = e1.pexp_loc.loc_start;
               loc_end = exp_el.pexp_loc.loc_end;
               loc_ghost = false}
      in
      let arg = {pexp_desc = Pexp_tuple [e1; exp_el];
                 pexp_loc = {l with loc_ghost = true} } in
      {pexp_desc = Pexp_construct(Lident "::", Some arg, false); pexp_loc = l}

let rec mktailpat = function
    [] ->
      ghpat(Ppat_construct(Lident "[]", None, false))
  | p1 :: pl ->
      let pat_pl = mktailpat pl in
      let l = {loc_start = p1.ppat_loc.loc_start;
               loc_end = pat_pl.ppat_loc.loc_end;
               loc_ghost = false}
      in
      let arg = {ppat_desc = Ppat_tuple [p1; pat_pl];
                 ppat_loc = {l with loc_ghost = true} } in
      {ppat_desc = Ppat_construct(Lident "::", Some arg, false); ppat_loc = l}

let syntax_error () =
  raise Syntaxerr.Escape_error

let unclosed opening_name opening_num closing_name closing_num =
  raise(Syntaxerr.Error(Syntaxerr.Unclosed(rhs_loc opening_num, opening_name,
                                           rhs_loc closing_num, closing_name)))

let mkstrexp e =
  { pstr_desc = Pstr_eval e; pstr_loc = {e.pexp_loc with loc_ghost = true} }

let array_function str name =
  Ldot(Lident str, name)

let rec mkrangepat c1 c2 =
  if c1 > c2 then mkrangepat c2 c1 else
  if c1 = c2 then ghpat(Ppat_constant(Const_char c1)) else
  ghpat(Ppat_or(ghpat(Ppat_constant(Const_char c1)),
                mkrangepat (Char.chr(Char.code c1 + 1)) c2))


let bigarray_function str name =
  Ldot(Ldot(Lident "Bigarray", str), name)

let bigarray_untuplify = function
    { pexp_desc = Pexp_tuple explist} -> explist
  | exp -> [exp]

let bigarray_get arr arg =
  match bigarray_untuplify arg with
    [c1] ->
      mkexp(Pexp_apply(ghexp(Pexp_ident(bigarray_function "Array1" "get")),
                       [arr; c1]))
  | [c1;c2] ->
      mkexp(Pexp_apply(ghexp(Pexp_ident(bigarray_function "Array2" "get")),
                       [arr; c1; c2]))
  | [c1;c2;c3] ->
      mkexp(Pexp_apply(ghexp(Pexp_ident(bigarray_function "Array3" "get")),
                       [arr; c1; c2; c3]))
  | coords ->
      mkexp(Pexp_apply(ghexp(Pexp_ident(bigarray_function "Genarray" "get")),
                       [arr; ghexp(Pexp_array coords)]))

let bigarray_set arr arg newval =
  match bigarray_untuplify arg with
    [c1] ->
      mkexp(Pexp_apply(ghexp(Pexp_ident(bigarray_function "Array1" "set")),
                       [arr; c1; newval]))
  | [c1;c2] ->
      mkexp(Pexp_apply(ghexp(Pexp_ident(bigarray_function "Array2" "set")),
                       [arr; c1; c2; newval]))
  | [c1;c2;c3] ->
      mkexp(Pexp_apply(ghexp(Pexp_ident(bigarray_function "Array3" "set")),
                       [arr; c1; c2; c3; newval]))
  | coords ->
      mkexp(Pexp_apply(ghexp(Pexp_ident(bigarray_function "Genarray" "set")),
                       [arr;
                        ghexp(Pexp_array coords);
                        newval]))
%}
%start exception_longident
%start implementation
%start interface
%start level_longident
%start toplevel_phrase
%start type_longident
%start use_file
%start val_longident
%token AFFECTS
%token AMPERAMPER
%token AMPERSAND
%token AND
%token AS
%token ASSERT
%token BAR
%token BARBAR
%token BARRBRACKET
%token BEGIN
%token BRACEEQUALGREATER
%token BRACEMINUSGREATER
%token <char> CHAR
%token <string> CHARVECT
%token CLASS
%token COLON
%token COLONCOLON
%token COLONEQUAL
%token COLONGREATER
%token COMMA
%token CONSTRAINT
%token CONTENT
%token DO
%token DONE
%token DOT
%token DOTDOT
%token DOWNTO
%token ELSE
%token END
%token EOF
%token EQUAL
%token EQUALBRACE
%token EQUALGREATER
%token EXCEPTION
%token EXTERNAL
%token FALSE
%token FINALLY
%token <string> FLOAT
%token FLOW
%token FOR
%token FUN
%token FUNCTION
%token FUNCTOR
%token GREATER
%token GREATERRBRACE
%token GREATERRBRACKET
%token GREATERWORD
%token IF
%token IN
%token INCLUDE
%token <string> INFIXOP0
%token <string> INFIXOP1
%token <string> INFIXOP2
%token <string> INFIXOP3
%token <string> INFIXOP4
%token INHERIT
%token INITIALIZE
%token INITIALIZER
%token <int> INT
%token <string> LABEL
%token LAZY
%token LBRACE
%token LBRACELESS
%token LBRACKET
%token LBRACKETBAR
%token LBRACKETGREATER
%token LBRACKETLESS
%token LESS
%token LESSMINUS
%token LESSWORD
%token LET
%token LEVEL
%token <string> LIDENT
%token LPAREN
%token MATCH
%token METHOD
%token MINUS
%token MINUSBRACE
%token MINUSDOT
%token MINUSGREATER
%token MODULE
%token MUTABLE
%token NEW
%token NONEQ
%token OBJECT
%token OF
%token OPEN
%token <string> OPTLABEL
%token OR
%token PLUS
%token <string> PREFIXOP
%token PRIVATE
%token PROPAGATE
%token QUESTION
%token QUOTE
%token RAISE
%token RAISES
%token RBRACE
%token RBRACKET
%token REC
%token ROW
%token RPAREN
%token SEMI
%token SEMISEMI
%token SHARP
%token SIG
%token STAR
%token <string> STRING
%token STRUCT
%token THAN
%token THEN
%token TILDE
%token TO
%token TRUE
%token TRY
%token TYPE
%token <string> UIDENT
%token UNDERSCORE
%token VAL
%token VIRTUAL
%token WHEN
%token WHILE
%token WITH
%right prec_reraise
%right PROPAGATE
%right prec_let
%right prec_type_def
%right SEMI
%right prec_fun prec_match prec_try
%right prec_list
%right prec_if
%right COLONEQUAL LESSMINUS
%left AS
%left BAR
%left COMMA
%right prec_type_arrow
%right BARBAR OR
%right AMPERAMPER AMPERSAND
%left EQUAL GREATER INFIXOP0 LESS
%right INFIXOP1
%right COLONCOLON
%left INFIXOP2 MINUS MINUSDOT PLUS
%left INFIXOP3 STAR
%right INFIXOP4
%right prec_unary_minus
%left prec_appl
%right prec_constr_appl
%left SHARP
%left DOT
%right PREFIXOP
%type <Longident.t> exception_longident
%type <Parsetree.implementation> implementation
%type <Parsetree.interface> interface
%type <Longident.t> level_longident
%type <Parsetree.toplevel_phrase> toplevel_phrase
%type <Longident.t> type_longident
%type <Parsetree.toplevel_phrase list> use_file
%type <Longident.t> val_longident
%%

implementation:
  _1 = flows_declaration _2 = structure _3 = EOF
    {      ( { pimp_structure = _2;
	  pimp_flows = _1;
	  pimp_header_loc = rhs_loc 1
	}
      )}

interface:
  _1 = flows_declaration _2 = affects _3 = raises _4 = signature _5 = EOF
    {      ( { pint_signature = List.rev _4;
	  pint_flows = _1;
	  pint_pci = _2;
	  pint_pcf = _3;
	  pint_header_loc = rhs_locs 1 3
	}
      )}

toplevel_phrase:
  _1 = top_structure _2 = SEMISEMI
    {                                               ( Ptop_def _1 )}
| _1 = FLOW _2 = flows _3 = SEMISEMI
    {                                               ( Ptop_flow _2 )}
| _1 = seq_expr _2 = SEMISEMI
    {                                               ( Ptop_def[mkstrexp _1] )}
| _1 = toplevel_directive _2 = SEMISEMI
    {                                               ( _1 )}
| _1 = EOF
    {                                               ( raise End_of_file )}

top_structure:
  _1 = structure_item
    {                                         ( [_1] )}
| _1 = structure_item _2 = top_structure
    {                                         ( _1 :: _2 )}

use_file:
  _1 = use_file_tail
    {                                         ( _1 )}
| _1 = seq_expr _2 = use_file_tail
    {                                         ( Ptop_def[mkstrexp _1] :: _2 )}

use_file_tail:
  _1 = EOF
    {                                                ( [] )}
| _1 = SEMISEMI _2 = EOF
    {                                                ( [] )}
| _1 = SEMISEMI _2 = seq_expr _3 = use_file_tail
    {                                                ( Ptop_def[mkstrexp _2] :: _3 )}
| _1 = SEMISEMI _2 = structure_item _3 = use_file_tail
    {                                                ( Ptop_def[_2] :: _3 )}
| _1 = SEMISEMI _2 = toplevel_directive _3 = use_file_tail
    {                                                ( _2 :: _3 )}
| _1 = structure_item _2 = use_file_tail
    {                                                ( Ptop_def[_1] :: _2 )}

affects:
  
    {                                                ( [] )}
| _1 = AFFECTS _2 = level_comma_list
    {                                                ( _2 )}

raises:
  
    {                                                ( [] )}
| _1 = RAISES _2 = level_comma_list
    {                                               ( _2 )}

flows_declaration:
  
    {    ( [] )}
| _1 = FLOW _2 = flows
    {    ( List.rev _2 )}

flows:
  _1 = flow
    {                                             ( _1 :: [] )}
| _1 = flows _2 = AND _3 = flow
    {                                             ( _3 :: _1 )}

flow:
  _1 = flow_hand_side _2 = LESS _3 = flow_hand_side
    {                                             ( (_1, _3) )}

flow_hand_side:
  _1 = principal
    {                                             ( _1 :: [] )}
| _1 = flow_hand_side _2 = COMMA _3 = principal
    {                                             ( _3 :: _1 )}

module_expr:
  _1 = mod_longident
    {      ( mkmod(Pmod_ident _1) )}
| _1 = STRUCT _2 = structure _3 = END
    {      ( mkmod(Pmod_structure(_2)) )}
| _1 = STRUCT _2 = structure _3 = error
    {      ( unclosed "struct" 1 "end" 3 )}
| _1 = FUNCTOR _2 = LPAREN _3 = UIDENT _4 = COLON _5 = module_type _6 = RPAREN _7 = MINUSGREATER _8 = module_expr %prec prec_fun
    {      ( mkmod(Pmod_functor(_3, _5, _8)) )}
| _1 = module_expr _2 = LPAREN _3 = module_expr _4 = RPAREN
    {      ( mkmod(Pmod_apply(_1, _3)) )}
| _1 = LPAREN _2 = module_expr _3 = COLON _4 = module_type _5 = RPAREN
    {      ( mkmod(Pmod_constraint(_2, _4)) )}
| _1 = LPAREN _2 = module_expr _3 = COLON _4 = module_type _5 = error
    {      ( unclosed "(" 1 ")" 5 )}
| _1 = LPAREN _2 = module_expr _3 = RPAREN
    {      ( mkmod (Pmod_paren _2) )}
| _1 = LPAREN _2 = module_expr _3 = error
    {      ( unclosed "(" 1 ")" 3 )}

structure:
  _1 = structure_tail
    {                                                ( _1 )}
| _1 = seq_expr _2 = structure_tail
    {                                                ( mkstrexp _1 :: _2 )}

structure_tail:
  
    {                                                ( [] )}
| _1 = SEMISEMI
    {                                                ( [] )}
| _1 = SEMISEMI _2 = seq_expr _3 = structure_tail
    {                                                ( mkstrexp _2 :: _3 )}
| _1 = SEMISEMI _2 = structure_item _3 = structure_tail
    {                                                ( _2 :: _3 )}
| _1 = structure_item _2 = structure_tail
    {                                                ( _1 :: _2 )}

structure_item:
  _1 = LET _2 = rec_flag _3 = let_bindings
    {      ( match _3 with
          [{ppat_desc = Ppat_any}, exp] -> mkstr(Pstr_eval exp)
        | _ -> mkstr(Pstr_value(_2, List.rev _3)) )}
| _1 = EXTERNAL _2 = val_ident_colon _3 = core_type_scheme _4 = EQUAL _5 = primitive_declaration
    {      ( mkstr(Pstr_primitive(_2, {pval_type = _3; pval_prim = _5})) )}
| _1 = TYPE _2 = type_declarations
    {      ( mkstr(Pstr_type(List.rev _2)) )}
| _1 = LEVEL _2 = level_declaration
    {      ( let name, decl = _2 in
        mkstr(Pstr_level (name, decl)) )}
| _1 = EXCEPTION _2 = UIDENT _3 = exception_declaration
    {      ( mkstr(Pstr_exception(_2, _3)) )}
| _1 = MODULE _2 = UIDENT _3 = module_binding
    {      ( mkstr(Pstr_module(_2, _3)) )}
| _1 = MODULE _2 = TYPE _3 = ident _4 = EQUAL _5 = module_type
    {      ( mkstr(Pstr_modtype(_3, _5)) )}
| _1 = OPEN _2 = mod_longident
    {      ( mkstr(Pstr_open _2) )}
| _1 = INCLUDE _2 = module_expr
    {      ( mkstr(Pstr_include _2) )}

module_binding:
  _1 = EQUAL _2 = module_expr
    {      ( _2 )}
| _1 = COLON _2 = module_type _3 = EQUAL _4 = module_expr
    {      ( mkmod(Pmod_constraint(_4, _2)) )}
| _1 = LPAREN _2 = UIDENT _3 = COLON _4 = module_type _5 = RPAREN _6 = module_binding
    {      ( mkmod(Pmod_functor(_2, _4, _6)) )}

exception_declaration:
  _1 = exception_arguments
    {      ( mkexn (None, _1) None )}
| _1 = COLON _2 = QUOTE _3 = LIDENT _4 = exception_arguments
    {      ( mkexn (Some (_3, rhs_locs 1 3), _4) None )}
| _1 = exception_arguments _2 = EQUAL _3 = constr_longident
    {      ( mkexn (None, _1) (Some (_3, rhs_locs 2 3)) )}
| _1 = COLON _2 = QUOTE _3 = LIDENT _4 = exception_arguments _5 = EQUAL _6 = constr_longident
    {      ( mkexn (Some (_3, rhs_locs 1 3), _4) (Some (_6, rhs_locs 5 6)) )}

exception_arguments:
  
    {                                                ( [] )}
| _1 = OF _2 = extcore_type_list
    {                                                ( List.rev _2 )}

module_type:
  _1 = mty_longident
    {      ( mkmty(Pmty_ident _1) )}
| _1 = SIG _2 = signature _3 = END
    {      ( mkmty(Pmty_signature(List.rev _2)) )}
| _1 = SIG _2 = signature _3 = error
    {      ( unclosed "sig" 1 "end" 3 )}
| _1 = FUNCTOR _2 = LPAREN _3 = UIDENT _4 = COLON _5 = module_type _6 = RPAREN _7 = module_type_arrow _8 = module_type %prec prec_fun
    {      ( let lb, ub = _7 in
        mkmty(Pmty_functor(_3, _5, lb, ub, _8, Some (rhs_loc 7)))
      )}
| _1 = module_type _2 = WITH _3 = with_constraints
    {      ( mkmty(Pmty_with(_1, List.rev _3)) )}
| _1 = LPAREN _2 = module_type _3 = RPAREN
    {      ( mkmty (Pmty_paren _2) )}
| _1 = LPAREN _2 = module_type _3 = error
    {      ( unclosed "(" 1 ")" 3 )}

module_type_arrow:
  _1 = MINUSGREATER
    {      ( [], [] )}
| _1 = MINUSBRACE _2 = level_comma_list _3 = BAR _4 = level_comma_list _5 = BRACEMINUSGREATER
    {      ( _2, _4 )}

signature:
  
    {                                                ( [] )}
| _1 = signature _2 = signature_item
    {                                                ( _2 :: _1 )}
| _1 = signature _2 = signature_item _3 = SEMISEMI
    {                                                ( _2 :: _1 )}

signature_item:
  _1 = VAL _2 = val_ident_colon _3 = core_type_scheme
    {      ( mksig(Psig_value(_2, {pval_type = _3; pval_prim = []})) )}
| _1 = EXTERNAL _2 = val_ident_colon _3 = core_type_scheme _4 = EQUAL _5 = primitive_declaration
    {      ( mksig(Psig_value(_2, {pval_type = _3; pval_prim = _5})) )}
| _1 = TYPE _2 = type_declarations
    {      ( mksig(Psig_type(List.rev _2)) )}
| _1 = LEVEL _2 = level_declaration
    {      ( let name, decl = _2 in
        mksig(Psig_level (name, decl)) )}
| _1 = EXCEPTION _2 = UIDENT _3 = exception_declaration
    {      ( mksig(Psig_exception(_2, _3)) )}
| _1 = MODULE _2 = UIDENT _3 = module_declaration
    {      ( mksig(Psig_module(_2, _3)) )}
| _1 = MODULE _2 = TYPE _3 = ident
    {      ( mksig(Psig_modtype(_3, Pmodtype_abstract)) )}
| _1 = MODULE _2 = TYPE _3 = ident _4 = EQUAL _5 = module_type
    {      ( mksig(Psig_modtype(_3, Pmodtype_manifest _5)) )}
| _1 = OPEN _2 = mod_longident
    {      ( mksig(Psig_open _2) )}
| _1 = INCLUDE _2 = module_type
    {      ( mksig(Psig_include _2) )}

module_declaration:
  _1 = COLON _2 = module_type
    {      ( _2 )}
| _1 = LPAREN _2 = UIDENT _3 = COLON _4 = module_type _5 = RPAREN _6 = module_declaration
    {      ( mkmty(Pmty_functor(_2, _4, [], [], _6, None)) )}

with_constraints:
  _1 = with_constraint
    {                                                ( [_1] )}
| _1 = with_constraints _2 = AND _3 = with_constraint
    {                                                ( _3 :: _1 )}

with_constraint:
  _1 = TYPE _2 = type_parameters _3 = label_longident _4 = EQUAL _5 = core_type _6 = constraints
    {      ( let params, variance = List.split _2 in
        mkwth _3 (Pwith_type { ptype_params = _2;
			       ptype_fun = false;
                               ptype_cstrs = List.rev _6;
                               ptype_repr = Ptype_abstract;
                               ptype_manifest = Some _5;
                               ptype_loc = rhs_locs 2 6;
			       ptype_loc' = rhs_loc 3;
			       ptype_topo = 0;
			       ptype_pred = [] })
      )}
| _1 = LEVEL _2 = level_strict_longident _3 = level_repr
    {      ( mkwth _2 (Pwith_level (mklvd _3)) )}
| _1 = MODULE _2 = mod_longident _3 = EQUAL _4 = mod_ext_longident
    {      ( mkwth _2 (Pwith_module _4) )}

seq_expr:
  _1 = expr %prec SEMI
    {                                  ( _1 )}
| _1 = expr _2 = SEMI
    {                                  ( _1 )}
| _1 = expr _2 = SEMI _3 = seq_expr
    {                                  ( mkexp(Pexp_sequence(_1, _3)) )}

expr:
  _1 = simple_expr
    {      ( _1 )}
| _1 = simple_expr _2 = simple_expr_list %prec prec_appl
    {      ( mkexp(Pexp_apply(_1, List.rev _2)) )}
| _1 = LET _2 = rec_flag _3 = let_bindings _4 = IN _5 = seq_expr %prec prec_let
    {      ( mkexp(Pexp_let(_2, List.rev _3, _5)) )}
| _1 = FUNCTION _2 = opt_bar _3 = match_cases %prec prec_fun
    {      ( mkexp(Pexp_function(List.rev _3)) )}
| _1 = FUN _2 = simple_pattern _3 = fun_def %prec prec_fun
    {      ( mkexp(Pexp_function([_2, fst _3, snd _3])) )}
| _1 = MATCH _2 = seq_expr _3 = WITH _4 = opt_bar _5 = match_cases %prec prec_match
    {      ( mkexp(Pexp_match(_2, List.rev _5)) )}
| _1 = RAISE _2 = simple_exception_longident
    {      ( mkexp(Pexp_raise(_2, None)) )}
| _1 = RAISE _2 = LPAREN _3 = constr_longident _4 = simple_expr _5 = RPAREN
    {      ( mkexp(Pexp_raise(_3, Some _4)) )}
| _1 = TRY _2 = seq_expr _3 = FINALLY _4 = seq_expr
    {      ( mkexp(Pexp_finally(_2, _4)) )}
| _1 = TRY _2 = seq_expr _3 = WITH _4 = opt_bar _5 = try_cases %prec prec_try
    {      ( mkexp(Pexp_try(_2, List.rev _5)) )}
| _1 = TRY _2 = seq_expr _3 = WITH _4 = error %prec prec_try
    {      ( syntax_error() )}
| _1 = expr_comma_list
    {      ( mkexp(Pexp_tuple(List.rev _1)) )}
| _1 = constr_longident _2 = simple_expr %prec prec_constr_appl
    {      ( mkexp(Pexp_construct(_1, Some _2, false)) )}
| _1 = IF _2 = seq_expr _3 = THEN _4 = expr _5 = ELSE _6 = expr %prec prec_if
    {      ( mkexp(Pexp_ifthenelse(_2, _4, Some _6)) )}
| _1 = IF _2 = seq_expr _3 = THEN _4 = expr %prec prec_if
    {      ( mkexp(Pexp_ifthenelse(_2, _4, None)) )}
| _1 = WHILE _2 = seq_expr _3 = DO _4 = seq_expr _5 = DONE
    {      ( mkexp(Pexp_while(_2, _4)) )}
| _1 = FOR _2 = val_ident _3 = EQUAL _4 = seq_expr _5 = direction_flag _6 = seq_expr _7 = DO _8 = seq_expr _9 = DONE
    {      ( mkexp(Pexp_for(_2, _4, _6, _5, _8)) )}
| _1 = expr _2 = COLONCOLON _3 = expr
    {      ( mkexp(Pexp_construct(Lident "::",
                             Some(ghexp(Pexp_tuple[_1;_3])),
                             false)) )}
| _1 = expr _2 = INFIXOP0 _3 = expr
    {      ( mkinfix _1 _2 _3 )}
| _1 = expr _2 = INFIXOP1 _3 = expr
    {      ( mkinfix _1 _2 _3 )}
| _1 = expr _2 = INFIXOP2 _3 = expr
    {      ( mkinfix _1 _2 _3 )}
| _1 = expr _2 = INFIXOP3 _3 = expr
    {      ( mkinfix _1 _2 _3 )}
| _1 = expr _2 = INFIXOP4 _3 = expr
    {      ( mkinfix _1 _2 _3 )}
| _1 = expr _2 = PLUS _3 = expr
    {      ( mkinfix _1 "+" _3 )}
| _1 = expr _2 = MINUS _3 = expr
    {      ( mkinfix _1 "-" _3 )}
| _1 = expr _2 = MINUSDOT _3 = expr
    {      ( mkinfix _1 "-." _3 )}
| _1 = expr _2 = STAR _3 = expr
    {      ( mkinfix _1 "*" _3 )}
| _1 = expr _2 = EQUAL _3 = expr
    {      ( mkinfix _1 "=" _3 )}
| _1 = expr _2 = LESS _3 = expr
    {      ( mkinfix _1 "<" _3 )}
| _1 = expr _2 = GREATER _3 = expr
    {      ( mkinfix _1 ">" _3 )}
| _1 = expr _2 = OR _3 = expr
    {      ( mkinfix _1 "or" _3 )}
| _1 = expr _2 = BARBAR _3 = expr
    {      ( mkinfix _1 "||" _3 )}
| _1 = expr _2 = AMPERSAND _3 = expr
    {      ( mkinfix _1 "&" _3 )}
| _1 = expr _2 = AMPERAMPER _3 = expr
    {      ( mkinfix _1 "&&" _3 )}
| _1 = expr _2 = COLONEQUAL _3 = expr
    {      ( mkinfix _1 ":=" _3 )}
| _1 = subtractive _2 = expr %prec prec_unary_minus
    {      ( mkuminus _1 _2 )}
| _1 = simple_expr _2 = DOT _3 = label_longident _4 = LESSMINUS _5 = expr
    {      ( mkexp(Pexp_setfield(_1, _3, _5)) )}
| _1 = simple_expr _2 = DOT _3 = LPAREN _4 = seq_expr _5 = RPAREN _6 = LESSMINUS _7 = expr
    {      ( mkexp(Pexp_apply(ghexp(Pexp_ident(array_function "Array" "set")),
                         [_1; _4; _7])) )}
| _1 = simple_expr _2 = DOT _3 = LBRACKET _4 = seq_expr _5 = RBRACKET _6 = LESSMINUS _7 = expr
    {      ( mkexp(Pexp_apply(ghexp(Pexp_ident(array_function "Charray" "set")),
                         [_1; _4; _7])) )}
| _1 = simple_expr _2 = DOT _3 = LBRACE _4 = expr _5 = RBRACE _6 = LESSMINUS _7 = expr
    {      ( bigarray_set _1 _4 _7 )}
| _1 = ASSERT _2 = simple_expr %prec prec_appl
    {      ( mkassert _2 )}
| _1 = LAZY _2 = simple_expr %prec prec_appl
    {      ( mklazy _2 )}

simple_expr:
  _1 = val_longident
    {      ( mkexp(Pexp_ident _1) )}
| _1 = constant
    {      ( mkexp(Pexp_constant _1) )}
| _1 = constr_longident
    {      ( mkexp(Pexp_construct(_1, None, false)) )}
| _1 = LPAREN _2 = seq_expr _3 = RPAREN
    {      ( mkexp (Pexp_paren _2) )}
| _1 = LPAREN _2 = seq_expr _3 = error
    {      ( unclosed "(" 1 ")" 3 )}
| _1 = BEGIN _2 = seq_expr _3 = END
    {      ( mkexp (Pexp_paren _2) )}
| _1 = BEGIN _2 = END
    {      ( mkexp (Pexp_construct (Lident "()", None, false)) )}
| _1 = BEGIN _2 = seq_expr _3 = error
    {      ( unclosed "begin" 1 "end" 3 )}
| _1 = LPAREN _2 = seq_expr _3 = type_constraint _4 = RPAREN
    {      ( mkexp(Pexp_constraint(_2, _3)) )}
| _1 = simple_expr _2 = DOT _3 = label_longident
    {      ( mkexp(Pexp_field(_1, _3)) )}
| _1 = simple_expr _2 = DOT _3 = LPAREN _4 = seq_expr _5 = RPAREN
    {      ( mkexp(Pexp_apply(ghexp(Pexp_ident(array_function "Array" "get")),
                         [_1; _4])) )}
| _1 = simple_expr _2 = DOT _3 = LPAREN _4 = seq_expr _5 = error
    {      ( unclosed "(" 3 ")" 5 )}
| _1 = simple_expr _2 = DOT _3 = LBRACKET _4 = seq_expr _5 = RBRACKET
    {      ( mkexp(Pexp_apply(ghexp(Pexp_ident(array_function "Charray" "get")),
                         [_1; _4])) )}
| _1 = simple_expr _2 = DOT _3 = LBRACKET _4 = seq_expr _5 = error
    {      ( unclosed "[" 3 "]" 5 )}
| _1 = simple_expr _2 = DOT _3 = LBRACE _4 = expr _5 = RBRACE
    {      ( bigarray_get _1 _4 )}
| _1 = simple_expr _2 = DOT _3 = LBRACE _4 = expr_comma_list _5 = error
    {      ( unclosed "{" 3 "}" 5 )}
| _1 = LBRACE _2 = record_expr _3 = RBRACE
    {      ( let (exten, fields) = _2 in mkexp(Pexp_record(fields, exten)) )}
| _1 = LBRACE _2 = record_expr _3 = error
    {      ( unclosed "{" 1 "}" 5 )}
| _1 = LBRACKETBAR _2 = expr_semi_list _3 = opt_semi _4 = BARRBRACKET
    {      ( mkexp(Pexp_array(List.rev _2)) )}
| _1 = LBRACKETBAR _2 = expr_semi_list _3 = opt_semi _4 = error
    {      ( unclosed "[|" 1 "|]" 4 )}
| _1 = LBRACKETBAR _2 = BARRBRACKET
    {      ( mkexp(Pexp_array []) )}
| _1 = LBRACKET _2 = expr_semi_list _3 = opt_semi _4 = RBRACKET
    {      ( mkexp (mktailexp (List.rev _2)).pexp_desc )}
| _1 = LBRACKET _2 = expr_semi_list _3 = opt_semi _4 = error
    {      ( unclosed "[" 1 "]" 4 )}
| _1 = PREFIXOP _2 = simple_expr
    {      ( mkexp(Pexp_apply(mkoperator _1 1, [_2])) )}

simple_expr_list:
  _1 = simple_expr
    {      ( [_1] )}
| _1 = simple_expr_list _2 = simple_expr
    {      ( _2 :: _1 )}

let_bindings:
  _1 = let_binding
    {                                                ( [_1] )}
| _1 = let_bindings _2 = AND _3 = let_binding
    {                                                ( _3 :: _1 )}

let_binding:
  _1 = val_ident _2 = fun_binding
    {      ( ({ppat_desc = Ppat_var _1; ppat_loc = rhs_loc 1}, _2) )}
| _1 = pattern _2 = EQUAL _3 = seq_expr %prec prec_let
    {      ( (_1, _3) )}

fun_binding:
  _1 = EQUAL _2 = seq_expr %prec prec_let
    {      ( _2 )}
| _1 = type_constraint _2 = EQUAL _3 = seq_expr %prec prec_let
    {      ( mkexp(Pexp_constraint(_3, _1)) )}
| _1 = simple_pattern _2 = fun_binding
    {      ( mkexp(Pexp_function([_1, None, _2])) )}

match_cases:
  _1 = pattern _2 = match_action
    {      ( [_1, fst _2, snd _2] )}
| _1 = match_cases _2 = BAR _3 = pattern _4 = match_action
    {      ( (_3, fst _4, snd _4) :: _1 )}

try_cases:
  _1 = try_pattern _2 = MINUSGREATER _3 = seq_expr %prec prec_reraise
    {      ( [_1, _3, Throw] )}
| _1 = try_cases _2 = BAR _3 = try_pattern _4 = MINUSGREATER _5 = seq_expr %prec prec_reraise
    {      ( (_3, _5, Throw) :: _1 )}
| _1 = try_pattern _2 = MINUSGREATER _3 = seq_expr _4 = PROPAGATE
    {      ( [_1, _3, Propagate (rhs_loc 4)] )}
| _1 = try_cases _2 = BAR _3 = try_pattern _4 = MINUSGREATER _5 = seq_expr _6 = PROPAGATE
    {      ( (_3, _5, Propagate (rhs_loc 6)) :: _1 )}

fun_def:
  _1 = match_action
    {      ( _1 )}
| _1 = simple_pattern _2 = fun_def
    {      ( None, mkexp(Pexp_function([_1, fst _2, snd _2])) )}

match_action:
  _1 = MINUSGREATER _2 = seq_expr
    {                                                ( None, _2 )}
| _1 = WHEN _2 = seq_expr _3 = MINUSGREATER _4 = seq_expr
    {                                                ( Some _2, _4 )}

expr_comma_list:
  _1 = expr_comma_list _2 = COMMA _3 = expr
    {                                                ( _3 :: _1 )}
| _1 = expr _2 = COMMA _3 = expr
    {                                                ( [_3; _1] )}

record_expr:
  _1 = simple_expr _2 = WITH _3 = lbl_expr_list _4 = opt_semi
    {                                                ( (Some _1, List.rev _3) )}
| _1 = lbl_expr_list _2 = opt_semi
    {                                                ( (None, List.rev _1) )}

lbl_expr_list:
  _1 = label_longident _2 = EQUAL _3 = expr %prec prec_list
    {      ( [_1,_3] )}
| _1 = lbl_expr_list _2 = SEMI _3 = label_longident _4 = EQUAL _5 = expr %prec prec_list
    {      ( (_3, _5) :: _1 )}

expr_semi_list:
  _1 = expr %prec prec_list
    {                                                ( [_1] )}
| _1 = expr_semi_list _2 = SEMI _3 = expr %prec prec_list
    {                                                ( _3 :: _1 )}

type_constraint:
  _1 = COLON _2 = core_type_scheme
    {                                                ( _2 )}
| _1 = COLON _2 = error
    {                                                ( syntax_error() )}

pattern:
  _1 = simple_pattern
    {      ( _1 )}
| _1 = pattern _2 = AS _3 = val_ident
    {      ( mkpat(Ppat_alias(_1, _3)) )}
| _1 = pattern_comma_list
    {      ( mkpat(Ppat_tuple(List.rev _1)) )}
| _1 = constr_longident _2 = pattern %prec prec_constr_appl
    {      ( mkpat(Ppat_construct(_1, Some _2, false)) )}
| _1 = pattern _2 = COLONCOLON _3 = pattern
    {      ( mkpat(Ppat_construct(Lident "::", Some(ghpat(Ppat_tuple[_1;_3])),
                             false)) )}
| _1 = pattern _2 = BAR _3 = pattern
    {      ( mkpat(Ppat_or(_1, _3)) )}

simple_pattern:
  _1 = val_ident
    {      ( mkpat(Ppat_var _1) )}
| _1 = UNDERSCORE
    {      ( mkpat(Ppat_any) )}
| _1 = signed_constant
    {      ( mkpat(Ppat_constant _1) )}
| _1 = CHAR _2 = DOTDOT _3 = CHAR
    {      ( mkrangepat _1 _3 )}
| _1 = constr_longident
    {      ( mkpat(Ppat_construct(_1, None, false)) )}
| _1 = LBRACE _2 = lbl_pattern_list _3 = opt_semi _4 = RBRACE
    {      ( mkpat(Ppat_record(List.rev _2)) )}
| _1 = LBRACE _2 = lbl_pattern_list _3 = opt_semi _4 = error
    {      ( unclosed "{" 1 "}" 4 )}
| _1 = LBRACKET _2 = pattern_semi_list _3 = opt_semi _4 = RBRACKET
    {      ( mkpat (mktailpat (List.rev _2)).ppat_desc )}
| _1 = LBRACKET _2 = pattern_semi_list _3 = opt_semi _4 = error
    {      ( unclosed "[" 1 "]" 4 )}
| _1 = LBRACKETBAR _2 = pattern_semi_list _3 = opt_semi _4 = BARRBRACKET
    {      ( mkpat(Ppat_array(List.rev _2)) )}
| _1 = LBRACKETBAR _2 = BARRBRACKET
    {      ( mkpat(Ppat_array []) )}
| _1 = LBRACKETBAR _2 = pattern_semi_list _3 = opt_semi _4 = error
    {      ( unclosed "[|" 1 "|]" 4 )}
| _1 = LPAREN _2 = pattern _3 = RPAREN
    {      ( mkpat (Ppat_paren _2) )}
| _1 = LPAREN _2 = pattern _3 = error
    {      ( unclosed "(" 1 ")" 3 )}
| _1 = LPAREN _2 = pattern _3 = COLON _4 = core_type_scheme _5 = RPAREN
    {      ( mkpat(Ppat_constraint(_2, _4)) )}
| _1 = LPAREN _2 = pattern _3 = COLON _4 = core_type_scheme _5 = error
    {      ( unclosed "(" 1 ")" 5 )}

pattern_comma_list:
  _1 = pattern_comma_list _2 = COMMA _3 = pattern
    {                                                ( _3 :: _1 )}
| _1 = pattern _2 = COMMA _3 = pattern
    {                                                ( [_3; _1] )}

pattern_semi_list:
  _1 = pattern
    {                                                ( [_1] )}
| _1 = pattern_semi_list _2 = SEMI _3 = pattern
    {                                                ( _3 :: _1 )}

lbl_pattern_list:
  _1 = label_longident _2 = EQUAL _3 = pattern
    {                                                ( [(_1, _3)] )}
| _1 = lbl_pattern_list _2 = SEMI _3 = label_longident _4 = EQUAL _5 = pattern
    {                                                        ( (_3, _5) :: _1 )}

try_pattern:
  _1 = UNDERSCORE
    {                                                ( mktry Ptry_any )}
| _1 = try_pattern_list
    {                                                ( mktry (Ptry_list _1) )}

try_pattern_list:
  _1 = try_pattern_item
    {                                                ( _1 :: [] )}
| _1 = try_pattern_item _2 = BAR _3 = try_pattern_list
    {                                                ( _1 :: _3 )}

try_pattern_item:
  _1 = simple_exception_longident
    {                                                ( mktryi _1 None )}
| _1 = simple_exception_longident _2 = simple_pattern
    {                                                ( mktryi _1 (Some _2) )}

primitive_declaration:
  _1 = STRING
    {                                                ( [_1] )}
| _1 = STRING _2 = primitive_declaration
    {                                                ( _1 :: _2 )}

type_declarations:
  _1 = type_declaration
    {                                                ( [_1] )}
| _1 = type_declarations _2 = AND _3 = type_declaration
    {                                                ( _3 :: _1 )}

type_declaration:
  _1 = opt_fun _2 = type_parameters _3 = LIDENT _4 = type_kind _5 = constraints
    {      ( let repr, manifest = _4 in
        (_3, { ptype_params = _2;
	       ptype_fun = _1;
               ptype_cstrs = List.rev _5;
               ptype_repr = repr;
               ptype_manifest = manifest;
               ptype_loc = symbol_rloc();
	       ptype_loc' = rhs_loc 3;
	       ptype_topo = 0;
	       ptype_pred = []
	     }) )}

opt_fun:
  
    {              ( false )}
| _1 = NONEQ
    {          ( true )}

constraints:
  _1 = constraints _2 = CONSTRAINT _3 = constrain
    {                                                ( _3 :: _1 )}
| 
    {                                                ( [] )}

constrain:
  _1 = core_type _2 = EQUAL _3 = core_type
    {                                           ( _1, _3, symbol_rloc () )}

type_kind:
  
    {      ( (Ptype_abstract, None) )}
| _1 = EQUAL _2 = core_type %prec prec_type_def
    {      ( (Ptype_abstract, Some _2) )}
| _1 = EQUAL _2 = type_kind_variant
    {      ( _2, None )}
| _1 = EQUAL _2 = BAR _3 = type_kind_variant
    {      ( _3, None )}
| _1 = EQUAL _2 = type_kind_record
    {      ( _2, None )}
| _1 = EQUAL _2 = core_type _3 = EQUAL _4 = type_kind_variant %prec prec_type_def
    {      ( _4, Some _2 )}
| _1 = EQUAL _2 = core_type _3 = EQUAL _4 = type_kind_record %prec prec_type_def
    {      ( _4, Some _2 )}

type_kind_variant:
  _1 = constructor_declarations _2 = opt_annot_level
    {      ( Ptype_variant(List.rev _1, _2) )}

type_kind_record:
  _1 = LBRACE _2 = label_declarations _3 = opt_semi _4 = RBRACE _5 = opt_annot_level
    {      ( Ptype_record(List.rev _2, _5) )}

opt_annot_level:
  
    {                                                ( None )}
| _1 = SHARP _2 = simple_core_type
    {                                                ( Some (_2, symbol_rloc ()) )}

type_parameters:
  
    {                                                ( [] )}
| _1 = type_parameter
    {                                                ( [_1] )}
| _1 = LPAREN _2 = type_parameter_list _3 = RPAREN
    {                                                ( List.rev _2 )}

type_parameter:
  _1 = opt_variance _2 = QUOTE _3 = ident _4 = opt_kind
    {      ( (_3, (_4, _1)) )}

type_parameter_list:
  _1 = type_parameter
    {      ( [_1] )}
| _1 = type_parameter_list _2 = COMMA _3 = type_parameter
    {      ( _3 :: _1 )}

opt_kind:
  
    {      ( Pak_var )}
| _1 = COLON _2 = LEVEL
    {      ( Pak_level )}
| _1 = COLON _2 = TYPE
    {      ( Pak_type )}
| _1 = COLON _2 = ROW _3 = LBRACKET _4 = opt_rowlabel_list _5 = RBRACKET
    {      ( Pak_row _4 )}

opt_variance:
  
    {                                                ( Pvar_none )}
| _1 = PLUS
    {                                                ( Pvar_covariant )}
| _1 = EQUAL
    {                                                ( Pvar_invariant )}
| _1 = MINUS
    {                                                ( Pvar_contravariant )}
| _1 = SHARP
    {                                                ( Pvar_guarded )}

opt_rowlabel_list:
  
    {                                                ( [] )}
| _1 = rowlabel_list
    {                                                ( _1 )}

rowlabel_list:
  _1 = mod_longident
    {      ( [ _1 ] )}
| _1 = mod_longident _2 = COMMA _3 = rowlabel_list
    {      ( _1 :: _3 )}

constructor_declarations:
  _1 = constructor_declaration
    {                                                ( [_1] )}
| _1 = constructor_declarations _2 = BAR _3 = constructor_declaration
    {                                                         ( _3 :: _1 )}

constructor_declaration:
  _1 = constr_ident _2 = constructor_arguments
    {                                                ( (_1, _2) )}

constructor_arguments:
  
    {                                                ( [] )}
| _1 = OF _2 = core_type_list
    {                                                ( List.rev _2 )}

label_declarations:
  _1 = label_declaration
    {                                                ( [_1] )}
| _1 = label_declarations _2 = SEMI _3 = label_declaration
    {                                                ( _3 :: _1 )}

label_declaration:
  _1 = mutable_flag _2 = label _3 = COLON _4 = core_type
    {                                                ( (_2, _1, _4) )}

label:
  _1 = LIDENT
    {                                                ( _1 )}

extcore_type:
  _1 = exception_longident _2 = COLON _3 = simple_extcore_type _4 = SEMI _5 = extcore_type
    {      ( mktyp(Ptyp_row(_1, _3, _5)) )}
| _1 = exception_longident _2 = COLON _3 = simple_extcore_type
    {      ( mktyp(Ptyp_row(_1, _3, mktyp(ptyp_any()))) )}
| _1 = extcore_type2
    {      ( _1 )}

extcore_type2:
  _1 = simple_extcore_type_or_tuple
    {      ( _1 )}
| _1 = extcore_type2 _2 = extcore_type_arrow _3 = extcore_type2 %prec prec_type_arrow
    {      ( let x1, x2, x3 = _2 in
	mktyp(Ptyp_arrow(_1, x1, x2, _3, x3)) )}
| _1 = extcore_type_args _2 = EQUALGREATER _3 = simple_extcore_type_or_tuple
    {      ( mktyp(Ptyp_arrow_abbrev(List.rev _1,
				mktyp(ptyp_any()), mktyp(ptyp_any()), _3)) )}
| _1 = extcore_type_args _2 = extcore_type_arrow_abbrev _3 = simple_extcore_type_or_tuple
    {      ( let x1, x2 = _2 in
        mktyp(Ptyp_arrow_abbrev(List.rev _1, x1, x2, _3)) )}

extcore_type_arrow:
  _1 = MINUSGREATER
    {      ( mktyp(ptyp_any()), mktyp(ptyp_any()), mktyp(ptyp_any()) )}
| _1 = MINUSBRACE _2 = BRACEMINUSGREATER
    {      ( mktyp(ptyp_any()), mktyp(ptyp_any()), mktyp(ptyp_any()) )}
| _1 = MINUSBRACE _2 = opt_extcore_type _3 = BAR _4 = opt_extcore_type _5 = BAR _6 = opt_extcore_type _7 = BRACEMINUSGREATER
    {      ( _2, _4, _6 )}
| _1 = MINUSBRACE _2 = opt_extcore_type _3 = BARBAR _4 = opt_extcore_type _5 = BRACEMINUSGREATER
    {      ( _2, mktyp(ptyp_any()), _4 )}

extcore_type_args:
  _1 = simple_extcore_type_or_tuple
    {      ( _1 :: [] )}
| _1 = extcore_type_args _2 = EQUALGREATER _3 = simple_extcore_type_or_tuple
    {      ( _3 :: _1 )}

extcore_type_arrow_abbrev:
  _1 = EQUALBRACE _2 = BRACEEQUALGREATER
    {      ( mktyp(ptyp_any()), mktyp(ptyp_any()) )}
| _1 = EQUALBRACE _2 = opt_extcore_type _3 = BAR _4 = opt_extcore_type _5 = BRACEEQUALGREATER
    {      ( _2, _4 )}

opt_extcore_type:
  
    {      ( mktyp(ptyp_any()) )}
| _1 = extcore_type
    {      ( _1 )}

simple_extcore_type:
  _1 = simple_extcore_type2
    {      ( _1 )}
| _1 = LPAREN _2 = extcore_type_comma_list _3 = RPAREN
    {      (
	match _2 with
	  [sty] -> mktyp (Ptyp_paren sty)
        | _ -> raise Parse_error
      )}

simple_extcore_type2:
  _1 = QUOTE _2 = ident
    {      ( mktyp(Ptyp_var _2) )}
| _1 = UNDERSCORE
    {      ( mktyp(ptyp_any ()) )}
| _1 = core_type_bounds
    {      ( let lb, ub = _1 in mktyp(Ptyp_bounds (false, lb, ub)) )}
| _1 = core_type_row_bounds
    {      ( let lb, ub = _1 in mktyp(Ptyp_bounds (true, lb, ub)) )}
| _1 = type_longident %prec prec_constr_appl
    {      ( mktyp(Ptyp_constr(_1, [])) )}
| _1 = simple_extcore_type2 _2 = type_longident %prec prec_constr_appl
    {      ( mktyp(Ptyp_constr(_2, [_1])) )}
| _1 = LPAREN _2 = extcore_type_comma_list _3 = RPAREN _4 = type_longident %prec prec_constr_appl
    {      ( mktyp(Ptyp_constr(_4, List.rev _2)) )}

simple_extcore_type_or_tuple:
  _1 = simple_extcore_type
    {      ( _1 )}
| _1 = simple_extcore_type _2 = STAR _3 = extcore_type_list
    {      ( mktyp(Ptyp_tuple(_1 :: List.rev _3)) )}

extcore_type_comma_list:
  _1 = extcore_type
    {                                                      ( [_1] )}
| _1 = extcore_type_comma_list _2 = COMMA _3 = extcore_type
    {                                                      ( _3 :: _1 )}

extcore_type_list:
  _1 = simple_extcore_type
    {                                                      ( [_1] )}
| _1 = extcore_type_list _2 = STAR _3 = simple_extcore_type
    {                                                      ( _3 :: _1 )}

core_type:
  _1 = exception_longident _2 = COLON _3 = simple_core_type _4 = SEMI _5 = core_type
    {      ( mktyp(Ptyp_row(_1, _3, _5)) )}
| _1 = core_type2
    {      ( _1 )}

core_type2:
  _1 = simple_core_type_or_tuple
    {      ( _1 )}
| _1 = core_type2 _2 = MINUSBRACE _3 = core_type _4 = BAR _5 = core_type _6 = BAR _7 = core_type _8 = BRACEMINUSGREATER _9 = core_type2 %prec prec_type_arrow
    {      ( mktyp(Ptyp_arrow(_1, _3, _5, _9, _7)) )}

simple_core_type:
  _1 = simple_core_type2
    {      ( _1 )}
| _1 = LPAREN _2 = core_type_comma_list _3 = RPAREN
    {      (
	match _2 with
	  [sty] -> mktyp (Ptyp_paren sty)
        | _ -> raise Parse_error
      )}

simple_core_type2:
  _1 = QUOTE _2 = ident
    {      ( mktyp(Ptyp_var _2) )}
| _1 = UNDERSCORE
    {      ( mktyp(ptyp_any ()) )}
| _1 = type_longident %prec prec_constr_appl
    {      ( mktyp(Ptyp_constr(_1, [])) )}
| _1 = simple_core_type2 _2 = type_longident %prec prec_constr_appl
    {      ( mktyp(Ptyp_constr(_2, [_1])) )}
| _1 = LPAREN _2 = core_type_comma_list _3 = RPAREN _4 = type_longident %prec prec_constr_appl
    {      ( mktyp(Ptyp_constr(_4, List.rev _2)) )}

simple_core_type_or_tuple:
  _1 = simple_core_type
    {                                                ( _1 )}
| _1 = simple_core_type _2 = STAR _3 = core_type_list
    {      ( mktyp(Ptyp_tuple(_1 :: List.rev _3)) )}

core_type_comma_list:
  _1 = core_type
    {                                                ( [_1] )}
| _1 = core_type_comma_list _2 = COMMA _3 = core_type
    {                                                ( _3 :: _1 )}

core_type_list:
  _1 = simple_core_type
    {                                                ( [_1] )}
| _1 = core_type_list _2 = STAR _3 = simple_core_type
    {                                                ( _3 :: _1 )}

core_type_scheme:
  _1 = extcore_type
    {       ( mktys _1 [] )}
| _1 = extcore_type _2 = WITH _3 = core_type_constraints_list
    {       ( mktys _1 (List.rev _3) )}

core_type_constraints_list:
  _1 = core_type_constraint
    {                                                         ( [_1] )}
| _1 = core_type_constraints_list _2 = AND _3 = core_type_constraint
    {                                                         ( _3 :: _1 )}

core_type_constraint:
  _1 = left_hand_side _2 = LESS _3 = right_hand_side
    {       ( mktyc(Ptyc_leq(_1, _3)) )}
| _1 = core_type_skeleton
    {      ( mktyc(Ptyc_ssk(_1)) )}

core_type_skeleton:
  _1 = extcore_type _2 = TILDE _3 = extcore_type
    {                                                      ( [_3; _1] )}
| _1 = core_type_skeleton _2 = TILDE _3 = extcore_type
    {                                                      ( _3 :: _1 )}

left_hand_side:
  _1 = extcore_type
    {                                                      ( (NoDestr, _1) :: [] )}
| _1 = CONTENT _2 = extcore_type
    {                                                      ( (Destr, _2) :: [] )}
| _1 = CONTENT _2 = TILDE _3 = extcore_type
    {                                                      ( (SkDestr, _3) :: [] )}
| _1 = extcore_type _2 = COMMA _3 = left_hand_side
    {                                                      ( (NoDestr, _1) :: _3 )}
| _1 = CONTENT _2 = extcore_type _3 = COMMA _4 = left_hand_side
    {                                                      ( (Destr, _2) :: _4 )}
| _1 = CONTENT _2 = TILDE _3 = extcore_type _4 = COMMA _5 = left_hand_side
    {                                                      ( (SkDestr, _3) :: _5 )}

right_hand_side:
  _1 = extcore_type
    {                                                      ( (NoDestr, _1) :: [] )}
| _1 = LEVEL _2 = extcore_type
    {                                                      ( (Destr, _2) :: [] )}
| _1 = LEVEL _2 = TILDE _3 = extcore_type
    {                                                      ( (SkDestr, _3) :: [] )}
| _1 = extcore_type _2 = COMMA _3 = right_hand_side
    {                                                      ( (NoDestr, _1) :: _3 )}
| _1 = LEVEL _2 = extcore_type _3 = COMMA _4 = right_hand_side
    {                                                      ( (Destr, _2) :: _4 )}
| _1 = LEVEL _2 = TILDE _3 = extcore_type _4 = COMMA _5 = right_hand_side
    {                                                      ( (SkDestr, _3) :: _5 )}

core_type_bounds:
  _1 = LBRACKETLESS _2 = level_comma_list _3 = RBRACKET
    {      ( [], _2 )}
| _1 = LBRACKETGREATER _2 = level_comma_list _3 = RBRACKET
    {      ( _2, [] )}
| _1 = LBRACKETGREATER _2 = level_comma_list _3 = INFIXOP0 _4 = level_comma_list _5 = RBRACKET
    {      ( if _3 <> "|<" then
	raise (Syntaxerr.Error (Syntaxerr.Other (rhs_loc 3)));
        _2, _4 )}
| _1 = LBRACKETLESS _2 = level_comma_list _3 = INFIXOP0 _4 = level_comma_list _5 = RBRACKET
    {      ( if _3 <> "|>" then
	raise (Syntaxerr.Error (Syntaxerr.Other (rhs_loc 3)));
        _4, _2 )}
| _1 = level
    {      ( [_1], [_1] )}

core_type_row_bounds:
  _1 = STAR _2 = COLON _3 = core_type_bounds
    {      ( _3 )}

level_declaration:
  _1 = UIDENT
    {      ( _1, mklvd ([], []) )}
| _1 = UIDENT _2 = level_repr
    {      ( _1, mklvd _2 )}

level_repr:
  _1 = GREATERWORD _2 = THAN _3 = level_comma_list
    {      ( _3, [] )}
| _1 = GREATERWORD _2 = THAN _3 = level_comma_list _4 = LESSWORD _5 = THAN _6 = level_comma_list
    {      ( _3, _6 )}
| _1 = LESSWORD _2 = THAN _3 = level_comma_list
    {      ( [], _3 )}
| _1 = EQUAL _2 = level
    {      ( [_2], [_2] )}

level_comma_list:
  
    {                                                ( [] )}
| _1 = level
    {                                                ( [_1] )}
| _1 = level_comma_list _2 = COMMA _3 = level
    {                                                ( _3 :: _1 )}

level:
  _1 = level_longident
    {                                                ( mklvl (Plvl_ident _1) )}
| _1 = principal
    {                                                ( mklvl (Plvl_principal _1) )}

constant:
  _1 = INT
    {                                       ( Const_int _1 )}
| _1 = CHAR
    {                                       ( Const_char _1 )}
| _1 = STRING
    {                                       ( Const_string _1 )}
| _1 = FLOAT
    {                                       ( Const_float _1 )}
| _1 = CHARVECT
    {                                       ( Const_charray (_1, symbol_rloc()) )}

signed_constant:
  _1 = constant
    {                                                ( _1 )}
| _1 = MINUS _2 = INT
    {                                                ( Const_int(- _2) )}
| _1 = subtractive _2 = FLOAT
    {                                                ( Const_float("-" ^ _2) )}

ident:
  _1 = UIDENT
    {                                                ( _1 )}
| _1 = LIDENT
    {                                                ( _1 )}

val_ident:
  _1 = LIDENT
    {                                                ( _1 )}
| _1 = LPAREN _2 = operator _3 = RPAREN
    {                                                ( _2 )}

val_ident_colon:
  _1 = LIDENT _2 = COLON
    {                                                ( _1 )}
| _1 = LPAREN _2 = operator _3 = RPAREN _4 = COLON
    {                                                ( _2 )}
| _1 = LABEL
    {                                                ( _1 )}

operator:
  _1 = PREFIXOP
    {                                                ( _1 )}
| _1 = INFIXOP0
    {                                                ( _1 )}
| _1 = INFIXOP1
    {                                                ( _1 )}
| _1 = INFIXOP2
    {                                                ( _1 )}
| _1 = INFIXOP3
    {                                                ( _1 )}
| _1 = INFIXOP4
    {                                                ( _1 )}
| _1 = PLUS
    {                                                ( "+" )}
| _1 = MINUS
    {                                                ( "-" )}
| _1 = MINUSDOT
    {                                                ( "-." )}
| _1 = STAR
    {                                                ( "*" )}
| _1 = EQUAL
    {                                                ( "=" )}
| _1 = LESS
    {                                                ( "<" )}
| _1 = GREATER
    {                                                ( ">" )}
| _1 = OR
    {                                                ( "or" )}
| _1 = BARBAR
    {                                                ( "||" )}
| _1 = AMPERSAND
    {                                                ( "&" )}
| _1 = AMPERAMPER
    {                                                ( "&&" )}
| _1 = COLONEQUAL
    {                                                ( ":=" )}

constr_ident:
  _1 = UIDENT
    {                                                ( _1 )}
| _1 = LBRACKET _2 = RBRACKET
    {                                                ( "[]" )}
| _1 = LPAREN _2 = RPAREN
    {                                                ( "()" )}
| _1 = COLONCOLON
    {                                                ( "::" )}
| _1 = FALSE
    {                                                ( "false" )}
| _1 = TRUE
    {                                                ( "true" )}

val_longident:
  _1 = val_ident
    {                                                ( Lident _1 )}
| _1 = mod_longident _2 = DOT _3 = val_ident
    {                                                ( Ldot(_1, _3) )}

constr_longident:
  _1 = mod_longident
    {                                                ( _1 )}
| _1 = LBRACKET _2 = RBRACKET
    {                                                ( Lident "[]" )}
| _1 = LPAREN _2 = RPAREN
    {                                                ( Lident "()" )}
| _1 = FALSE
    {                                                ( Lident "false" )}
| _1 = TRUE
    {                                                ( Lident "true" )}

label_longident:
  _1 = LIDENT
    {                                                ( Lident _1 )}
| _1 = mod_longident _2 = DOT _3 = LIDENT
    {                                                ( Ldot(_1, _3) )}

type_longident:
  _1 = LIDENT
    {                                                ( Lident _1 )}
| _1 = mod_ext_longident _2 = DOT _3 = LIDENT
    {                                                ( Ldot(_1, _3) )}

simple_exception_longident:
  _1 = mod_longident
    {                                                ( _1 )}

exception_longident:
  _1 = UIDENT
    {                                                ( Lident _1 )}
| _1 = LIDENT
    {                                                ( Lident _1 )}
| _1 = mod_ext_longident _2 = DOT _3 = UIDENT
    {                                                ( Ldot(_1, _3) )}

level_longident:
  _1 = UIDENT
    {                                                ( Lident _1 )}
| _1 = mod_ext_longident _2 = DOT _3 = UIDENT
    {                                                ( Ldot(_1, _3) )}

level_strict_longident:
  _1 = UIDENT
    {                                                ( Lident _1 )}
| _1 = mod_longident _2 = DOT _3 = UIDENT
    {                                                ( Ldot(_1, _3) )}

mod_longident:
  _1 = UIDENT
    {                                                ( Lident _1 )}
| _1 = mod_longident _2 = DOT _3 = UIDENT
    {                                                ( Ldot(_1, _3) )}

mod_ext_longident:
  _1 = UIDENT
    {                                                ( Lident _1 )}
| _1 = mod_ext_longident _2 = DOT _3 = UIDENT
    {                                                ( Ldot(_1, _3) )}
| _1 = mod_ext_longident _2 = LPAREN _3 = mod_ext_longident _4 = RPAREN
    {                                                ( Lapply(_1, _3) )}

mty_longident:
  _1 = ident
    {                                                ( Lident _1 )}
| _1 = mod_ext_longident _2 = DOT _3 = ident
    {                                                ( Ldot(_1, _3) )}

principal:
  _1 = PREFIXOP _2 = LIDENT
    {      ( if _1 <> "!" then
	raise (Syntaxerr.Error (Syntaxerr.Other (rhs_loc 1)));
	_2 )}

toplevel_directive:
  _1 = SHARP _2 = ident
    {                                ( Ptop_dir(_2, Pdir_none) )}
| _1 = SHARP _2 = ident _3 = STRING
    {                                ( Ptop_dir(_2, Pdir_string _3) )}
| _1 = SHARP _2 = ident _3 = INT
    {                                ( Ptop_dir(_2, Pdir_int _3) )}
| _1 = SHARP _2 = ident _3 = val_longident
    {                                ( Ptop_dir(_2, Pdir_ident _3) )}
| _1 = SHARP _2 = ident _3 = FALSE
    {                                ( Ptop_dir(_2, Pdir_bool false) )}
| _1 = SHARP _2 = ident _3 = TRUE
    {                                ( Ptop_dir(_2, Pdir_bool true) )}

rec_flag:
  
    {                                                ( Nonrecursive )}
| _1 = REC
    {                                                ( Recursive )}

direction_flag:
  _1 = TO
    {                                                ( Upto )}
| _1 = DOWNTO
    {                                                ( Downto )}

mutable_flag:
  
    {                                                ( Immutable )}
| _1 = MUTABLE
    {                                                ( Mutable )}

opt_bar:
  
    {                                                ( () )}
| _1 = BAR
    {                                                ( () )}

opt_semi:
  
    {                                                ( () )}
| _1 = SEMI
    {                                                ( () )}

subtractive:
  _1 = MINUS
    {                                                ( "-" )}
| _1 = MINUSDOT
    {                                                ( "-." )}

%%




