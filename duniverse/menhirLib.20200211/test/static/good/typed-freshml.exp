Grammar has 42 nonterminal symbols, among which 2 start symbols.
Grammar has 52 terminal symbols.
Grammar has 110 productions.
nullable(variables) = false
nullable(typ) = false
nullable(specification_alone) = false
nullable(specification) = false
nullable(set_operator) = false
nullable(set_function) = false
nullable(set_expression) = false
nullable(set_constraint) = false
nullable(separated_nonempty_list(STAR,located(atomic_layout))) = false
nullable(separated_nonempty_list(COMMA,pattern)) = false
nullable(separated_nonempty_list(COMMA,atomic_expression)) = false
nullable(separated_nonempty_list(COMMA,ID)) = false
nullable(raw_pattern) = false
nullable(raw_expression) = false
nullable(raw_atomic_expression) = false
nullable(program) = false
nullable(prefix_callee) = false
nullable(pattern) = false
nullable(optional_layout) = true
nullable(nonempty_list(branch)) = false
nullable(located(raw_pattern)) = false
nullable(located(raw_expression)) = false
nullable(located(raw_atomic_expression)) = false
nullable(located(optional_layout)) = true
nullable(located(layout)) = false
nullable(located(atomic_layout)) = false
nullable(list(preceded(WHERE,contrainte))) = true
nullable(list(definition)) = true
nullable(list(data_constructor_declaration)) = true
nullable(lenient_parenthesized_tuple(pattern)) = true
nullable(lenient_parenthesized_tuple(atomic_expression)) = true
nullable(layout) = false
nullable(kind) = true
nullable(expression) = false
nullable(definition) = false
nullable(data_constructor_declaration) = false
nullable(contraintes) = true
nullable(contrainte) = false
nullable(branch) = false
nullable(boolean_expression) = false
nullable(atomic_layout) = false
nullable(atomic_expression) = false
first(variables) = NOTHING ID
first(typ) = ID BOOL ATOMSET ATOM
first(specification_alone) = ACCEPTS
first(specification) = ACCEPTS
first(set_operator) = SUBSET DISJOINT CMPEQ
first(set_function) = SUPPORT OUTER INNER BOUND
first(set_expression) = SUPPORT OUTER LPAR INNER EMPTYSET BOUND
first(set_constraint) = SUPPORT OUTER LPAR INNER EMPTYSET BOUND
first(separated_nonempty_list(STAR,located(atomic_layout))) = OUTER LANGLE INNER ID BOOL ATOMSET ATOM
first(separated_nonempty_list(COMMA,pattern)) = WILD TRUE TAG ID FALSE
first(separated_nonempty_list(COMMA,atomic_expression)) = TRUE TAG SUPPORT OUTER NEXT MEMBER LPAR INNER ID FALSE CASE BOUND BNOT
first(separated_nonempty_list(COMMA,ID)) = ID
first(raw_pattern) = WILD TRUE TAG ID FALSE
first(raw_expression) = TRUE TAG SUPPORT OUTER NOTHING NEXT MEMBER LPAR LET INNER IF ID FRESH FALSE FAIL CASE BOUND BNOT ABSURD
first(raw_atomic_expression) = TRUE TAG SUPPORT OUTER NEXT MEMBER LPAR INNER ID FALSE CASE BOUND BNOT
first(program) = TYPE FUN EOF
first(prefix_callee) = SUPPORT OUTER MEMBER INNER ID BOUND
first(pattern) = WILD TRUE TAG ID FALSE
first(optional_layout) = OF
first(nonempty_list(branch)) = BAR
first(located(raw_pattern)) = WILD TRUE TAG ID FALSE
first(located(raw_expression)) = TRUE TAG SUPPORT OUTER NOTHING NEXT MEMBER LPAR LET INNER IF ID FRESH FALSE FAIL CASE BOUND BNOT ABSURD
first(located(raw_atomic_expression)) = TRUE TAG SUPPORT OUTER NEXT MEMBER LPAR INNER ID FALSE CASE BOUND BNOT
first(located(optional_layout)) = OF
first(located(layout)) = OUTER LANGLE INNER ID BOOL ATOMSET ATOM
first(located(atomic_layout)) = OUTER LANGLE INNER ID BOOL ATOMSET ATOM
first(list(preceded(WHERE,contrainte))) = WHERE
first(list(definition)) = TYPE FUN
first(list(data_constructor_declaration)) = BAR
first(lenient_parenthesized_tuple(pattern)) = LPAR
first(lenient_parenthesized_tuple(atomic_expression)) = LPAR
first(layout) = OUTER LANGLE INNER ID BOOL ATOMSET ATOM
first(kind) = BINDS
first(expression) = TRUE TAG SUPPORT OUTER NOTHING NEXT MEMBER LPAR LET INNER IF ID FRESH FALSE FAIL CASE BOUND BNOT ABSURD
first(definition) = TYPE FUN
first(data_constructor_declaration) = BAR
first(contraintes) = WHERE
first(contrainte) = TRUE SUPPORT OUTER LPAR INNER ID FALSE EMPTYSET BOUND BNOT
first(branch) = BAR
first(boolean_expression) = TRUE LPAR ID FALSE BNOT
first(atomic_layout) = OUTER LANGLE INNER ID BOOL ATOMSET ATOM
first(atomic_expression) = TRUE TAG SUPPORT OUTER NEXT MEMBER LPAR INNER ID FALSE CASE BOUND BNOT
minimal(variables) = (* 1 *) NOTHING
minimal(typ) = (* 1 *) ID
minimal(specification_alone) = (* 5 *) ACCEPTS NOTHING PRODUCES NOTHING EOF
minimal(specification) = (* 4 *) ACCEPTS NOTHING PRODUCES NOTHING
minimal(set_operator) = (* 1 *) SUBSET
minimal(set_function) = (* 1 *) SUPPORT
minimal(set_expression) = (* 1 *) EMPTYSET
minimal(set_constraint) = (* 3 *) EMPTYSET SUBSET EMPTYSET
minimal(separated_nonempty_list(STAR,located(atomic_layout))) = (* 1 *) ID
minimal(separated_nonempty_list(COMMA,pattern)) = (* 1 *) WILD
minimal(separated_nonempty_list(COMMA,atomic_expression)) = (* 1 *) ID
minimal(separated_nonempty_list(COMMA,ID)) = (* 1 *) ID
minimal(raw_pattern) = (* 1 *) WILD
minimal(raw_expression) = (* 1 *) ABSURD
minimal(raw_atomic_expression) = (* 1 *) ID
minimal(program) = (* 1 *) EOF
minimal(prefix_callee) = (* 1 *) ID
minimal(pattern) = (* 1 *) WILD
minimal(optional_layout) = (* 0 *) 
minimal(nonempty_list(branch)) = (* 4 *) BAR WILD ARROW ABSURD
minimal(located(raw_pattern)) = (* 1 *) WILD
minimal(located(raw_expression)) = (* 1 *) ABSURD
minimal(located(raw_atomic_expression)) = (* 1 *) ID
minimal(located(optional_layout)) = (* 0 *) 
minimal(located(layout)) = (* 1 *) ID
minimal(located(atomic_layout)) = (* 1 *) ID
minimal(list(preceded(WHERE,contrainte))) = (* 0 *) 
minimal(list(definition)) = (* 0 *) 
minimal(list(data_constructor_declaration)) = (* 0 *) 
minimal(lenient_parenthesized_tuple(pattern)) = (* 0 *) 
minimal(lenient_parenthesized_tuple(atomic_expression)) = (* 0 *) 
minimal(layout) = (* 1 *) ID
minimal(kind) = (* 0 *) 
minimal(expression) = (* 1 *) ABSURD
minimal(definition) = (* 3 *) TYPE ID DEFEQ
minimal(data_constructor_declaration) = (* 2 *) BAR TAG
minimal(contraintes) = (* 0 *) 
minimal(contrainte) = (* 1 *) FALSE
minimal(branch) = (* 4 *) BAR WILD ARROW ABSURD
minimal(boolean_expression) = (* 1 *) FALSE
minimal(atomic_layout) = (* 1 *) ID
minimal(atomic_expression) = (* 1 *) ID
follow(variables) = WHERE PRODUCES IN EOF DEFEQ
follow(typ) = WHERE TYPE STAR RANGLE FUN EOF BAR
follow(specification_alone) = #
follow(specification) = EOF DEFEQ
follow(set_operator) = SUPPORT OUTER LPAR INNER EMPTYSET BOUND
follow(set_function) = LPAR
follow(set_expression) = WHERE TYPE SUBSET SETUNION SETMINUS RPAR PRODUCES FUN EOF DISJOINT DEFEQ CMPEQ BAR
follow(set_constraint) = WHERE TYPE PRODUCES FUN EOF DEFEQ BAR
follow(separated_nonempty_list(STAR,located(atomic_layout))) = WHERE TYPE RANGLE FUN EOF BAR
follow(separated_nonempty_list(COMMA,pattern)) = RPAR ARROW
follow(separated_nonempty_list(COMMA,atomic_expression)) = TYPE THEN RPAR OF IN FUN EOF END ELSE BAR
follow(separated_nonempty_list(COMMA,ID)) = WHERE PRODUCES IN EOF DEFEQ
follow(raw_pattern) = RPAR COMMA ARROW
follow(raw_expression) = TYPE THEN RPAR OF IN FUN EOF END ELSE BAR
follow(raw_atomic_expression) = TYPE THEN RPAR OF IN FUN EOF END ELSE COMMA CMPEQ BOR BAR BAND
follow(program) = #
follow(prefix_callee) = LPAR
follow(pattern) = RPAR COMMA ARROW
follow(optional_layout) = WHERE TYPE FUN EOF BAR
follow(nonempty_list(branch)) = END
follow(located(raw_pattern)) = RPAR COMMA ARROW
follow(located(raw_expression)) = TYPE THEN RPAR OF IN FUN EOF END ELSE BAR
follow(located(raw_atomic_expression)) = TYPE THEN RPAR OF IN FUN EOF END ELSE COMMA CMPEQ BOR BAR BAND
follow(located(optional_layout)) = WHERE TYPE FUN EOF BAR
follow(located(layout)) = RANGLE
follow(located(atomic_layout)) = WHERE TYPE STAR RANGLE FUN EOF BAR
follow(list(preceded(WHERE,contrainte))) = TYPE PRODUCES FUN EOF DEFEQ BAR
follow(list(definition)) = EOF
follow(list(data_constructor_declaration)) = TYPE FUN EOF
follow(lenient_parenthesized_tuple(pattern)) = RPAR DEFEQ COMMA ARROW
follow(lenient_parenthesized_tuple(atomic_expression)) = TYPE THEN RPAR OF IN FUN EOF END ELSE COMMA CMPEQ BOR BAR BAND
follow(layout) = WHERE TYPE RANGLE FUN EOF BAR
follow(kind) = DEFEQ
follow(expression) = TYPE THEN RPAR OF IN FUN EOF END ELSE BAR
follow(definition) = TYPE FUN EOF
follow(data_constructor_declaration) = TYPE FUN EOF BAR
follow(contraintes) = TYPE PRODUCES FUN EOF DEFEQ BAR
follow(contrainte) = WHERE TYPE PRODUCES FUN EOF DEFEQ BAR
follow(branch) = END BAR
follow(boolean_expression) = WHERE TYPE RPAR PRODUCES FUN EOF DEFEQ CMPEQ BOR BAR BAND ARROW
follow(atomic_layout) = WHERE TYPE STAR RANGLE FUN EOF BAR
follow(atomic_expression) = TYPE THEN RPAR OF IN FUN EOF END ELSE COMMA CMPEQ BOR BAR BAND
Built an LR(0) automaton with 202 states.
The grammar is not SLR(1) -- 12 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 202 states.
28 shift/reduce conflicts were silently solved.
84 out of 202 states have a default reduction.
62 out of 202 states are represented.
36 out of 98 symbols keep track of their start position.
31 out of 98 symbols keep track of their end position.
64 out of 112 productions exploit shiftreduce optimization.
0 out of 202 states can peek at an error.
565 functions before inlining, 99 functions after inlining.
