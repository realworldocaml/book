Note: the nonterminal symbol list (from ics.mly) is renamed ics_list.
File "ics.mly", line 47, characters 13-19:
Warning: the token ACLBRA is unused.
File "ics.mly", line 47, characters 7-12:
Warning: the token ALBRA is unused.
File "ics.mly", line 50, characters 48-57:
Warning: the token BACKSLASH is unused.
File "ics.mly", line 45, characters 7-10:
Warning: the token BOT is unused.
File "ics.mly", line 57, characters 22-27:
Warning: the token BWAND is unused.
File "ics.mly", line 57, characters 45-50:
Warning: the token BWIFF is unused.
File "ics.mly", line 57, characters 39-44:
Warning: the token BWIMP is unused.
File "ics.mly", line 57, characters 16-21:
Warning: the token BWITE is unused.
File "ics.mly", line 57, characters 51-56:
Warning: the token BWNOT is unused.
File "ics.mly", line 57, characters 28-32:
Warning: the token BWOR is unused.
File "ics.mly", line 57, characters 33-38:
Warning: the token BWXOR is unused.
File "ics.mly", line 47, characters 20-25:
Warning: the token CLBRA is unused.
File "ics.mly", line 35, characters 28-36:
Warning: the token COMMANDS is unused.
File "ics.mly", line 50, characters 23-27:
Warning: the token DDOT is unused.
File "ics.mly", line 51, characters 36-40:
Warning: the token DIFF is unused.
File "ics.mly", line 61, characters 24-30:
Warning: the token DIVIDE is unused.
File "ics.mly", line 50, characters 38-47:
Warning: the token ENDMARKER is unused.
File "ics.mly", line 55, characters 13-17:
Warning: the token FREE is unused.
File "ics.mly", line 54, characters 22-27:
Warning: the token FRESH is unused.
File "ics.mly", line 37, characters 7-9:
Warning: the token IN is unused.
File "ics.mly", line 46, characters 11-17:
Warning: the token NEGINF is unused.
File "ics.mly", line 37, characters 10-15:
Warning: the token NOTIN is unused.
File "ics.mly", line 34, characters 82-91:
Warning: the token PARTITION is unused.
File "ics.mly", line 70, characters 7-11:
Warning: the token PROJ is unused.
File "ics.mly", line 49, characters 37-45:
Warning: the token PROPLPAR is unused.
File "ics.mly", line 49, characters 46-54:
Warning: the token PROPRPAR is unused.
File "ics.mly", line 68, characters 7-14:
Warning: the token PROPVAR is unused.
File "ics.mly", line 38, characters 11-16:
Warning: the token QUOTE is unused.
File "ics.mly", line 34, characters 34-37:
Warning: the token SET is unused.
File "ics.mly", line 35, characters 12-16:
Warning: the token SIGN is unused.
File "ics.mly", line 34, characters 73-81:
Warning: the token SOLUTION is unused.
File "ics.mly", line 35, characters 21-27:
Warning: the token SYNTAX is unused.
File "ics.mly", line 50, characters 35-37:
Warning: the token TO is unused.
File "ics.mly", line 34, characters 27-33:
Warning: the token TOGGLE is unused.
File "ics.mly", line 45, characters 23-26:
Warning: the token TOP is unused.
File "ics.mly", line 33, characters 7-11:
Warning: the token TYPE is unused.
File "ics.mly", line 49, characters 55-65:
Warning: the token UNDERSCORE is unused.
File "ics.mly", line 63, characters 7-15:
Warning: the token UNSIGNED is unused.
File "ics.mly", line 64, characters 7-11:
Warning: the token WITH is unused.
Grammar has 39 nonterminal symbols, among which 6 start symbols.
Grammar has 149 terminal symbols.
Grammar has 199 productions.
nullable(varname) = false
nullable(var) = false
nullable(value) = false
nullable(th) = false
nullable(termlist) = true
nullable(termeof) = false
nullable(term) = false
nullable(signature) = false
nullable(rat) = false
nullable(propset) = false
nullable(propeof) = false
nullable(prop) = false
nullable(product) = false
nullable(optvarspecs) = true
nullable(optname) = true
nullable(namelist) = false
nullable(name) = false
nullable(int) = false
nullable(identlist) = false
nullable(ics_list) = false
nullable(help) = false
nullable(funsym) = false
nullable(eqth) = false
nullable(dom) = false
nullable(coproduct) = false
nullable(commandsequence) = false
nullable(commandseof) = false
nullable(commands) = false
nullable(command) = false
nullable(cnstrnt) = false
nullable(bv) = false
nullable(boolean) = false
nullable(atomlist) = true
nullable(atomeof) = false
nullable(atom) = false
nullable(array) = false
nullable(arith) = false
nullable(apply) = false
nullable(app) = false
first(varname) = IDENT
first(var) = IDENT
first(value) = TRUE IDENT FALSE
first(th) = IDENT
first(termlist) = TRUE TAIL SUB S RATCONST OUTR OUTL OUT NIL MINUS LPAR LAMBDA K INTCONST INR INL INJ IDENT I HEAD FULL FALSE EMPTY CREATE CONS CONC COMPL COMMA CDR CAR C BVCONST
first(termeof) = TRUE TAIL SUB S RATCONST OUTR OUTL OUT NIL MINUS LPAR LAMBDA K INTCONST INR INL INJ IDENT I HEAD FULL FALSE EMPTY CREATE CONS CONC COMPL CDR CAR C BVCONST
first(term) = TRUE TAIL SUB S RATCONST OUTR OUTL OUT NIL MINUS LPAR LAMBDA K INTCONST INR INL INJ IDENT I HEAD FULL FALSE EMPTY CREATE CONS CONC COMPL CDR CAR C BVCONST
first(signature) = BV
first(rat) = RATCONST INTCONST
first(propset) = TRUE TAIL SUB S RATCONST OUTR OUTL OUT NIL MINUS LPAR LAMBDA K INTCONST INR INL INJ IDENT I HEAD FULL FALSE EMPTY CREATE CONS CONC COMPL CDR CAR C BVCONST
first(propeof) = TT TRUE TAIL SUB S RATCONST OUTR OUTL OUT NIL NEG MINUS LPAR LBRA LAMBDA K INTCONST INR INL INJ IF IDENT I HEAD FULL FF FALSE EMPTY CREATE CONS CONC COMPL CDR CAR C BVCONST
first(prop) = TT TRUE TAIL SUB S RATCONST OUTR OUTL OUT NIL NEG MINUS LPAR LBRA LAMBDA K INTCONST INR INL INJ IF IDENT I HEAD FULL FF FALSE EMPTY CREATE CONS CONC COMPL CDR CAR C BVCONST
first(product) = CONS CDR CAR
first(optvarspecs) = 
first(optname) = KLAMMERAFFE
first(namelist) = IDENT
first(name) = IDENT
first(int) = INTCONST
first(identlist) = IDENT
first(ics_list) = TRUE TAIL SUB S RATCONST OUTR OUTL OUT NIL MINUS LPAR LAMBDA K INTCONST INR INL INJ IDENT I HEAD FULL FALSE EMPTY CREATE CONS CONC COMPL CDR CAR C BVCONST
first(help) = HELP
first(funsym) = IDENT
first(eqth) = IDENT
first(dom) = REAL INT
first(coproduct) = OUTR OUTL OUT INR INL INJ
first(commandsequence) = VALID USE UNTRACE UNSAT UNDO TRUE TRACE TAIL SYMTAB SUP SUB SPLIT SOLVE SIMPLIFY SIGMA SIG SHOW SAVE SAT S RESTORE RESET REMOVE RATCONST PROP OUTR OUTL OUT NIL MODEL MINUS LPAR LAMBDA K INV INTCONST INR INL INJ INF IDENT I HELP HEAD GET FULL FORGET FIND FALSE EXIT EOF EMPTY ECHO DROP DOM DISEQ DEF CTXT CREATE CONS CONC COMPL CHECK CDR CAR CAN C BVCONST ASSERT
first(commandseof) = VALID USE UNTRACE UNSAT UNDO TRUE TRACE TAIL SYMTAB SUP SUB SPLIT SOLVE SIMPLIFY SIGMA SIG SHOW SAVE SAT S RESTORE RESET REMOVE RATCONST PROP OUTR OUTL OUT NIL MODEL MINUS LPAR LAMBDA K INV INTCONST INR INL INJ INF IDENT I HELP HEAD GET FULL FORGET FIND FALSE EXIT EMPTY ECHO DROP DOM DISEQ DEF CTXT CREATE CONS CONC COMPL CHECK CDR CAR CAN C BVCONST ASSERT
first(commands) = VALID USE UNTRACE UNSAT UNDO TRUE TRACE TAIL SYMTAB SUP SUB SPLIT SOLVE SIMPLIFY SIGMA SIG SHOW SAVE SAT S RESTORE RESET REMOVE RATCONST PROP OUTR OUTL OUT NIL MODEL MINUS LPAR LAMBDA K INV INTCONST INR INL INJ INF IDENT I HELP HEAD GET FULL FORGET FIND FALSE EXIT EOF EMPTY ECHO DROP DOM DISEQ DEF CTXT CREATE CONS CONC COMPL CHECK CDR CAR CAN C BVCONST ASSERT
first(command) = VALID USE UNTRACE UNSAT UNDO TRUE TRACE TAIL SYMTAB SUP SUB SPLIT SOLVE SIMPLIFY SIGMA SIG SHOW SAVE SAT S RESTORE RESET REMOVE RATCONST PROP OUTR OUTL OUT NIL MODEL MINUS LPAR LAMBDA K INV INTCONST INR INL INJ INF IDENT I HELP HEAD GET FULL FORGET FIND FALSE EXIT EMPTY ECHO DROP DOM DISEQ DEF CTXT CREATE CONS CONC COMPL CHECK CDR CAR CAN C BVCONST ASSERT
first(cnstrnt) = REAL INT BV
first(bv) = TRUE TAIL SUB S RATCONST OUTR OUTL OUT NIL MINUS LPAR LAMBDA K INTCONST INR INL INJ IDENT I HEAD FULL FALSE EMPTY CREATE CONS CONC COMPL CDR CAR C BVCONST
first(boolean) = TRUE FALSE
first(atomlist) = TT TRUE TAIL SUB S RATCONST OUTR OUTL OUT NIL MINUS LPAR LAMBDA K INTCONST INR INL INJ IDENT I HEAD FULL FF FALSE EMPTY CREATE CONS CONC COMPL COMMA CDR CAR C BVCONST
first(atomeof) = TT TRUE TAIL SUB S RATCONST OUTR OUTL OUT NIL MINUS LPAR LAMBDA K INTCONST INR INL INJ IDENT I HEAD FULL FF FALSE EMPTY CREATE CONS CONC COMPL CDR CAR C BVCONST
first(atom) = TT TRUE TAIL SUB S RATCONST OUTR OUTL OUT NIL MINUS LPAR LAMBDA K INTCONST INR INL INJ IDENT I HEAD FULL FF FALSE EMPTY CREATE CONS CONC COMPL CDR CAR C BVCONST
first(array) = TRUE TAIL SUB S RATCONST OUTR OUTL OUT NIL MINUS LPAR LAMBDA K INTCONST INR INL INJ IDENT I HEAD FULL FALSE EMPTY CREATE CONS CONC COMPL CDR CAR C BVCONST
first(arith) = TRUE TAIL SUB S RATCONST OUTR OUTL OUT NIL MINUS LPAR LAMBDA K INTCONST INR INL INJ IDENT I HEAD FULL FALSE EMPTY CREATE CONS CONC COMPL CDR CAR C BVCONST
first(apply) = TRUE TAIL SUB S RATCONST OUTR OUTL OUT NIL MINUS LPAR LAMBDA K INTCONST INR INL INJ IDENT I HEAD FULL FALSE EMPTY CREATE CONS CONC COMPL CDR CAR C BVCONST
first(app) = IDENT
minimal(varname) = (* 1 *) IDENT
minimal(var) = (* 1 *) IDENT
minimal(value) = (* 1 *) IDENT
minimal(th) = (* 1 *) IDENT
minimal(termlist) = (* 0 *) 
minimal(termeof) = (* 2 *) IDENT EOF
minimal(term) = (* 1 *) IDENT
minimal(signature) = (* 4 *) BV LBRA INTCONST RBRA
minimal(rat) = (* 1 *) INTCONST
minimal(propset) = (* 1 *) EMPTY
minimal(propeof) = (* 2 *) IDENT EOF
minimal(prop) = (* 1 *) IDENT
minimal(product) = (* 4 *) CAR LPAR IDENT RPAR
minimal(optvarspecs) = (* 0 *) 
minimal(optname) = (* 0 *) 
minimal(namelist) = (* 1 *) IDENT
minimal(name) = (* 1 *) IDENT
minimal(int) = (* 1 *) INTCONST
minimal(identlist) = (* 1 *) IDENT
minimal(ics_list) = (* 1 *) NIL
minimal(help) = (* 1 *) HELP
minimal(funsym) = (* 1 *) IDENT
minimal(eqth) = (* 1 *) IDENT
minimal(dom) = (* 1 *) INT
minimal(coproduct) = (* 4 *) INL LPAR IDENT RPAR
minimal(commandsequence) = (* 1 *) EOF
minimal(commandseof) = (* 2 *) RESET EOF
minimal(commands) = (* 1 *) EOF
minimal(command) = (* 1 *) RESET
minimal(cnstrnt) = (* 1 *) INT
minimal(bv) = (* 1 *) BVCONST
minimal(boolean) = (* 1 *) TRUE
minimal(atomlist) = (* 0 *) 
minimal(atomeof) = (* 2 *) FF EOF
minimal(atom) = (* 1 *) FF
minimal(array) = (* 4 *) CREATE LPAR IDENT RPAR
minimal(arith) = (* 1 *) INTCONST
minimal(apply) = (* 1 *) S
minimal(app) = (* 3 *) IDENT LPAR RPAR
follow(varname) = EOF DOT ASSIGN
follow(var) = XOR UNION TIMES THEN SUBSET RPAR RBRA PLUS MINUS LISTCONS LESSOREQUAL LESS LBRA INTER IMPL GREATEROREQUAL GREATER EXPT EQUAL EOF END ELSE DOT DISJ DISEQ CONJ COMMA CMP BVCONC BIIMPL ASSIGN APPLY
follow(value) = EOF DOT
follow(th) = TRUE TAIL SUB S RATCONST OUTR OUTL OUT NIL MINUS LPAR LAMBDA K INTCONST INR INL INJ IDENT I HEAD FULL FALSE EMPTY CREATE CONS CONC COMPL CDR CAR C BVCONST
follow(termlist) = RPAR COMMA
follow(termeof) = #
follow(term) = XOR UNION TIMES THEN SUBSET RPAR RBRA PLUS MINUS LISTCONS LESSOREQUAL LESS LBRA INTER IMPL GREATEROREQUAL GREATER EXPT EQUAL EOF END ELSE DOT DISJ DISEQ CONJ COMMA CMP BVCONC BIIMPL ASSIGN APPLY
follow(signature) = RCUR EOF DOT
follow(rat) = XOR UNION TIMES THEN SUBSET RPAR RBRA PLUS MINUS LISTCONS LESSOREQUAL LESS LBRA INTER IMPL GREATEROREQUAL GREATER EXPT EQUAL EOF END ELSE DOT DISJ DISEQ CONJ COMMA CMP BVCONC BIIMPL ASSIGN APPLY
follow(propset) = XOR UNION TIMES THEN SUBSET RPAR RBRA PLUS MINUS LISTCONS LESSOREQUAL LESS LBRA INTER IMPL GREATEROREQUAL GREATER EXPT EQUAL EOF END ELSE DOT DISJ DISEQ CONJ COMMA CMP BVCONC BIIMPL ASSIGN APPLY
follow(propeof) = #
follow(prop) = XOR THEN RBRA IMPL EOF END ELSE DOT DISJ CONJ BIIMPL
follow(product) = XOR UNION TIMES THEN SUBSET RPAR RBRA PLUS MINUS LISTCONS LESSOREQUAL LESS LBRA INTER IMPL GREATEROREQUAL GREATER EXPT EQUAL EOF END ELSE DOT DISJ DISEQ CONJ COMMA CMP BVCONC BIIMPL ASSIGN APPLY
follow(optvarspecs) = EOF DOT
follow(optname) = TT TRUE TAIL SUB S RATCONST OUTR OUTL OUT NIL NEG MINUS LPAR LBRA LAMBDA K INTCONST INR INL INJ IF IDENT I HEAD FULL FF FALSE EOF EMPTY DOT CREATE CONS CONC COMPL COMMA CDR CAR C BVCONST
follow(namelist) = COMMA COLON
follow(name) = XOR UNION TT TRUE TIMES THEN TAIL SUBSET SUB S RPAR RBRA RATCONST PLUS OUTR OUTL OUT NIL NEG MINUS LPAR LISTCONS LESSOREQUAL LESS LCUR LBRA LAMBDA K INTER INTCONST INR INL INJ IMPL IF IDENT I HEAD GREATEROREQUAL GREATER FULL FF FALSE EXPT EQUAL EOF END EMPTY ELSE DOT DISJ DISEQ CREATE CONS CONJ CONC COMPL COMMA COLON CMP CDR CAR C BVCONST BVCONC BIIMPL ASSIGN APPLY
follow(int) = XOR UNION TIMES THEN SUBSET RPAR RBRA PLUS MINUS LISTCONS LESSOREQUAL LESS LBRA INTER IMPL GREATEROREQUAL GREATER EXPT EQUAL EOF END ELSE DOT DISJ DISEQ CONJ COMMA CMP BVCONC BIIMPL ASSIGN APPLY
follow(identlist) = EOF DOT COMMA
follow(ics_list) = XOR UNION TIMES THEN SUBSET RPAR RBRA PLUS MINUS LISTCONS LESSOREQUAL LESS LBRA INTER IMPL GREATEROREQUAL GREATER EXPT EQUAL EOF END ELSE DOT DISJ DISEQ CONJ COMMA CMP BVCONC BIIMPL ASSIGN APPLY
follow(help) = EOF DOT
follow(funsym) = LPAR
follow(eqth) = TRUE TAIL SUB S RATCONST OUTR OUTL OUT NIL MINUS LPAR LAMBDA K INTCONST INR INL INJ IDENT I HEAD FULL FALSE EOF EMPTY DOT CREATE CONS CONC COMPL CDR CAR C BVCONST
follow(dom) = RCUR EOF DOT
follow(coproduct) = XOR UNION TIMES THEN SUBSET RPAR RBRA PLUS MINUS LISTCONS LESSOREQUAL LESS LBRA INTER IMPL GREATEROREQUAL GREATER EXPT EQUAL EOF END ELSE DOT DISJ DISEQ CONJ COMMA CMP BVCONC BIIMPL ASSIGN APPLY
follow(commandsequence) = #
follow(commandseof) = #
follow(commands) = #
follow(command) = EOF DOT
follow(cnstrnt) = RCUR EOF DOT
follow(bv) = XOR UNION TIMES THEN SUBSET RPAR RBRA PLUS MINUS LISTCONS LESSOREQUAL LESS LBRA INTER IMPL GREATEROREQUAL GREATER EXPT EQUAL EOF END ELSE DOT DISJ DISEQ CONJ COMMA CMP BVCONC BIIMPL ASSIGN APPLY
follow(boolean) = XOR UNION TIMES THEN SUBSET RPAR RBRA PLUS MINUS LISTCONS LESSOREQUAL LESS LBRA INTER IMPL GREATEROREQUAL GREATER EXPT EQUAL EOF END ELSE DOT DISJ DISEQ CONJ COMMA CMP BVCONC BIIMPL ASSIGN APPLY
follow(atomlist) = EOF DOT COMMA
follow(atomeof) = #
follow(atom) = XOR THEN RBRA IMPL EOF END ELSE DOT DISJ CONJ COMMA BIIMPL
follow(array) = XOR UNION TIMES THEN SUBSET RPAR RBRA PLUS MINUS LISTCONS LESSOREQUAL LESS LBRA INTER IMPL GREATEROREQUAL GREATER EXPT EQUAL EOF END ELSE DOT DISJ DISEQ CONJ COMMA CMP BVCONC BIIMPL ASSIGN APPLY
follow(arith) = XOR UNION TIMES THEN SUBSET RPAR RBRA PLUS MINUS LISTCONS LESSOREQUAL LESS LBRA INTER IMPL GREATEROREQUAL GREATER EXPT EQUAL EOF END ELSE DOT DISJ DISEQ CONJ COMMA CMP BVCONC BIIMPL ASSIGN APPLY
follow(apply) = XOR UNION TIMES THEN SUBSET RPAR RBRA PLUS MINUS LISTCONS LESSOREQUAL LESS LBRA INTER IMPL GREATEROREQUAL GREATER EXPT EQUAL EOF END ELSE DOT DISJ DISEQ CONJ COMMA CMP BVCONC BIIMPL ASSIGN APPLY
follow(app) = XOR UNION TIMES THEN SUBSET RPAR RBRA PLUS MINUS LISTCONS LESSOREQUAL LESS LBRA INTER IMPL GREATEROREQUAL GREATER EXPT EQUAL EOF END ELSE DOT DISJ DISEQ CONJ COMMA CMP BVCONC BIIMPL ASSIGN APPLY
Built an LR(0) automaton with 395 states.
The grammar is not SLR(1) -- 20 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 395 states.
140 shift/reduce conflicts were silently solved.
File "ics.mly", line 88, characters 0-5:
Warning: the precedence level assigned to BWAND is never useful.
File "ics.mly", line 88, characters 0-5:
Warning: the precedence level assigned to BWIFF is never useful.
File "ics.mly", line 87, characters 0-6:
Warning: the precedence level assigned to BWIMP is never useful.
File "ics.mly", line 87, characters 0-6:
Warning: the precedence level assigned to BWOR is never useful.
File "ics.mly", line 87, characters 0-6:
Warning: the precedence level assigned to BWXOR is never useful.
File "ics.mly", line 80, characters 0-9:
Warning: the precedence level assigned to COMPL is never useful.
File "ics.mly", line 79, characters 0-6:
Warning: the precedence level assigned to DIFF is never useful.
File "ics.mly", line 76, characters 0-9:
Warning: the precedence level assigned to DISEQ is never useful.
File "ics.mly", line 82, characters 0-5:
Warning: the precedence level assigned to DIVIDE is never useful.
File "ics.mly", line 76, characters 0-9:
Warning: the precedence level assigned to EQUAL is never useful.
File "ics.mly", line 76, characters 0-9:
Warning: the precedence level assigned to GREATER is never useful.
File "ics.mly", line 76, characters 0-9:
Warning: the precedence level assigned to GREATEROREQUAL is never useful.
File "ics.mly", line 90, characters 0-9:
Warning: the precedence level assigned to IN is never useful.
File "ics.mly", line 91, characters 0-9:
Warning: the precedence level assigned to LCUR is never useful.
File "ics.mly", line 76, characters 0-9:
Warning: the precedence level assigned to LESS is never useful.
File "ics.mly", line 76, characters 0-9:
Warning: the precedence level assigned to LESSOREQUAL is never useful.
File "ics.mly", line 90, characters 0-9:
Warning: the precedence level assigned to NOTIN is never useful.
File "ics.mly", line 76, characters 0-9:
Warning: the precedence level assigned to SUBSET is never useful.
File "ics.mly", line 89, characters 0-9:
Warning: the precedence level assigned to TO is never useful.
Warning: one state has shift/reduce conflicts.
Warning: one shift/reduce conflict was arbitrarily resolved.
Warning: one state has an end-of-stream conflict.
File "ics.mly", line 125, characters 2-13:
Warning: production commandsequence -> command DOT is never reduced.
Warning: in total, 1 production is never reduced.
152 out of 395 states have a default reduction.
115 out of 395 states are represented.
0 out of 196 symbols keep track of their start position.
0 out of 196 symbols keep track of their end position.
125 out of 205 productions exploit shiftreduce optimization.
0 out of 395 states can peek at an error.
1044 functions before inlining, 145 functions after inlining.
