Grammar has 257 nonterminal symbols, among which 6 start symbols.
Grammar has 119 terminal symbols.
Grammar has 650 productions.
nullable(xsymbol) = false
nullable(with_logic_decl) = false
nullable(with_list1(type_decl)) = false
nullable(with_list1(rec_defn)) = false
nullable(with_list1(inductive_decl)) = false
nullable(vis_mut) = true
nullable(variant) = false
nullable(val_defn) = true
nullable(use_clone) = false
nullable(use_as) = false
nullable(uqualid) = false
nullable(uident_nq) = false
nullable(uident) = false
nullable(typedefn) = true
nullable(type_witness) = true
nullable(type_field) = false
nullable(type_decl) = false
nullable(type_case) = false
nullable(ty_var) = false
nullable(ty_block) = false
nullable(ty_arg) = false
nullable(ty) = false
nullable(triggers) = true
nullable(tqualid) = false
nullable(term_sub_) = false
nullable(term_eof) = false
nullable(term_dot_) = false
nullable(term_dot) = false
nullable(term_comma_list_eof) = false
nullable(term_block_) = false
nullable(term_arg_) = false
nullable(term_arg) = false
nullable(term_) = false
nullable(term) = false
nullable(squalid) = false
nullable(spec) = true
nullable(single_variant) = false
nullable(single_term_) = false
nullable(single_term) = false
nullable(single_spec) = false
nullable(single_expr_) = false
nullable(single_expr) = false
nullable(single_clone_subst) = false
nullable(sident) = false
nullable(seq_expr) = false
nullable(separated_nonempty_list(WITH,type_decl)) = false
nullable(separated_nonempty_list(WITH,rec_defn)) = false
nullable(separated_nonempty_list(WITH,inductive_decl)) = false
nullable(separated_nonempty_list(COMMA,xsymbol)) = false
nullable(separated_nonempty_list(COMMA,use_as)) = false
nullable(separated_nonempty_list(COMMA,ty)) = false
nullable(separated_nonempty_list(COMMA,single_variant)) = false
nullable(separated_nonempty_list(COMMA,single_term)) = false
nullable(separated_nonempty_list(COMMA,single_clone_subst)) = false
nullable(separated_nonempty_list(COMMA,ret_cast)) = false
nullable(separated_nonempty_list(COMMA,quant_vars)) = false
nullable(separated_nonempty_list(COMMA,qualid)) = false
nullable(separated_nonempty_list(COMMA,mk_pat(pat_uni_))) = false
nullable(separated_nonempty_list(COMMA,meta_arg)) = false
nullable(separated_nonempty_list(COMMA,lqualid)) = false
nullable(separated_nonempty_list(COMMA,ident)) = false
nullable(separated_nonempty_list(COMMA,alias)) = false
nullable(separated_nonempty_list(BAR,type_case)) = false
nullable(separated_nonempty_list(BAR,raises)) = false
nullable(separated_nonempty_list(BAR,match_case(term))) = false
nullable(separated_nonempty_list(BAR,ind_case)) = false
nullable(separated_nonempty_list(BAR,exn_handler)) = false
nullable(separated_nonempty_list(BAR,comma_list1(single_term))) = false
nullable(semicolon_list1(type_field)) = false
nullable(semicolon_list1(separated_pair(lqualid,EQUAL,term))) = false
nullable(semicolon_list1(separated_pair(lqualid,EQUAL,pattern))) = false
nullable(semicolon_list1(separated_pair(lqualid,EQUAL,expr))) = false
nullable(scope_head) = false
nullable(rightsq) = false
nullable(return_opt) = true
nullable(return_named) = false
nullable(return) = false
nullable(ret_rest) = false
nullable(ret_ident) = false
nullable(ret_ghost) = false
nullable(ret_cast) = false
nullable(rec_defn) = false
nullable(raises) = false
nullable(quote_lident) = false
nullable(quant_vars) = false
nullable(quant) = false
nullable(qualid_eof) = false
nullable(qualid_comma_list_eof) = false
nullable(qualid) = false
nullable(pure_decl) = false
nullable(prog_decl) = false
nullable(prefix_op) = false
nullable(predicate_decl) = false
nullable(pattern_) = false
nullable(pattern) = false
nullable(pat_uni_) = false
nullable(pat_conj_) = false
nullable(pat_block_) = false
nullable(pat_arg_) = false
nullable(pat_arg) = false
nullable(params) = true
nullable(param) = false
nullable(option(preceded(WITH,lqualid))) = true
nullable(option(preceded(EQUAL,term))) = true
nullable(option(preceded(AS,uident))) = true
nullable(option(pat_arg)) = true
nullable(option(expr_arg)) = true
nullable(option(cast)) = true
nullable(option(UNDERSCORE)) = true
nullable(op_symbol) = false
nullable(numeral) = false
nullable(nonempty_list(ty_arg)) = false
nullable(nonempty_list(pat_arg)) = false
nullable(nonempty_list(module_decl)) = false
nullable(nonempty_list(located(term_arg))) = false
nullable(nonempty_list(located(expr_arg))) = false
nullable(nonempty_list(binder_var)) = false
nullable(nonempty_list(binder)) = false
nullable(nonempty_list(attr)) = false
nullable(module_head) = false
nullable(module_decl) = false
nullable(mlw_module) = false
nullable(mlw_file) = false
nullable(mk_term(term_dot_)) = false
nullable(mk_term(term_block_)) = false
nullable(mk_term(term_arg_)) = false
nullable(mk_term(single_term_)) = false
nullable(mk_term(lam_defn)) = false
nullable(mk_pat(pattern_)) = false
nullable(mk_pat(pat_uni_)) = false
nullable(mk_pat(pat_conj_)) = false
nullable(mk_pat(pat_block_)) = false
nullable(mk_pat(pat_arg_)) = false
nullable(mk_pat(let_pattern_)) = false
nullable(mk_pat(let_pat_uni_)) = false
nullable(mk_pat(let_pat_conj_)) = false
nullable(mk_expr(val_defn)) = true
nullable(mk_expr(single_expr_)) = false
nullable(mk_expr(fun_defn)) = false
nullable(mk_expr(expr_pure_)) = false
nullable(mk_expr(expr_dot_)) = false
nullable(mk_expr(expr_block_)) = false
nullable(mk_expr(expr_arg_)) = false
nullable(meta_decl) = false
nullable(meta_arg) = false
nullable(match_cases(term)) = false
nullable(match_case(term)) = false
nullable(match_case(seq_expr)) = false
nullable(lqualid_rich) = false
nullable(lqualid) = false
nullable(loption(separated_nonempty_list(COMMA,single_term))) = true
nullable(loption(separated_nonempty_list(COMMA,lqualid))) = true
nullable(loption(separated_nonempty_list(COMMA,alias))) = true
nullable(loption(semicolon_list1(type_field))) = true
nullable(loop_body) = true
nullable(loop_annotation) = true
nullable(located(term_arg)) = false
nullable(located(expr_arg)) = false
nullable(list(with_logic_decl)) = true
nullable(list(ty_var)) = true
nullable(list(param)) = true
nullable(list(module_decl)) = true
nullable(list(mlw_module)) = true
nullable(list(invariant)) = true
nullable(list(binder_var)) = true
nullable(list(attr)) = true
nullable(lident_rich) = false
nullable(lident_op_str) = false
nullable(lident_op_nq) = false
nullable(lident_op) = false
nullable(lident_nq) = false
nullable(lident_keyword) = false
nullable(lident) = false
nullable(let_pattern_) = false
nullable(let_pattern) = false
nullable(let_pat_uni_) = false
nullable(let_pat_conj_) = false
nullable(lam_defn) = false
nullable(kind) = true
nullable(invariant) = false
nullable(int_constant) = false
nullable(inductive_decl) = false
nullable(ind_defn) = true
nullable(ind_case) = false
nullable(ident_nq) = false
nullable(ident_comma_list_eof) = false
nullable(ident) = false
nullable(ghost) = true
nullable(function_decl) = false
nullable(fun_defn) = false
nullable(for_direction) = false
nullable(field_modifiers) = false
nullable(field_list1(term)) = false
nullable(field_list1(pattern)) = false
nullable(field_list1(expr)) = false
nullable(ext_match_cases1) = false
nullable(ext_match_cases0) = true
nullable(ext_match_cases) = false
nullable(expr_sub_) = false
nullable(expr_pure_) = false
nullable(expr_list1) = false
nullable(expr_dot_) = false
nullable(expr_dot) = false
nullable(expr_block_) = false
nullable(expr_arg_) = false
nullable(expr_arg) = false
nullable(expr) = false
nullable(exn_handler) = false
nullable(ensures) = false
nullable(contract_expr) = false
nullable(constant_decl) = false
nullable(const_defn) = false
nullable(comma_list2(ty)) = false
nullable(comma_list2(ret_cast)) = false
nullable(comma_list2(mk_pat(pat_uni_))) = false
nullable(comma_list1(xsymbol)) = false
nullable(comma_list1(use_as)) = false
nullable(comma_list1(ty)) = false
nullable(comma_list1(single_variant)) = false
nullable(comma_list1(single_term)) = false
nullable(comma_list1(single_clone_subst)) = false
nullable(comma_list1(ret_cast)) = false
nullable(comma_list1(quant_vars)) = false
nullable(comma_list1(qualid)) = false
nullable(comma_list1(mk_pat(pat_uni_))) = false
nullable(comma_list1(meta_arg)) = false
nullable(comma_list1(ident)) = false
nullable(comma_list0(single_term)) = true
nullable(comma_list0(lqualid)) = true
nullable(comma_list0(alias)) = true
nullable(clone_subst) = true
nullable(cast) = false
nullable(boption(IMPORT)) = true
nullable(binders) = false
nullable(binder_vars_rest) = false
nullable(binder_vars_head) = false
nullable(binder_vars) = false
nullable(binder_var) = false
nullable(binder) = false
nullable(bar_list1(type_case)) = false
nullable(bar_list1(raises)) = false
nullable(bar_list1(match_case(term))) = false
nullable(bar_list1(ind_case)) = false
nullable(bar_list1(exn_handler)) = false
nullable(attrs(uident_nq)) = false
nullable(attrs(uident)) = false
nullable(attrs(quote_lident)) = false
nullable(attrs(lident_rich)) = false
nullable(attrs(lident_op_nq)) = false
nullable(attrs(lident_nq)) = false
nullable(attrs(ident_nq)) = false
nullable(attr) = false
nullable(assign_expr) = false
nullable(assertion_kind) = false
nullable(anon_binder) = false
nullable(alias) = false
nullable(abstract) = false
first(xsymbol) = UIDENT CORE_UIDENT
first(with_logic_decl) = WITH
first(with_list1(type_decl)) = RANGE LIDENT FLOAT CORE_LIDENT
first(with_list1(rec_defn)) = RANGE PREDICATE LIDENT LEMMA LEFTPAR GHOST FUNCTION FLOAT CORE_LIDENT CONSTANT
first(with_list1(inductive_decl)) = RANGE LIDENT LEFTPAR FLOAT CORE_LIDENT
first(vis_mut) = PRIVATE MUTABLE ABSTRACT
first(variant) = VARIANT
first(val_defn) = WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ALIAS
first(use_clone) = USE CLONE
first(use_as) = UIDENT STRING RANGE LIDENT FLOAT CORE_UIDENT CORE_LIDENT
first(uqualid) = UIDENT CORE_UIDENT
first(uident_nq) = UIDENT CORE_UIDENT
first(uident) = UIDENT CORE_UIDENT
first(typedefn) = EQUAL
first(type_witness) = BY
first(type_field) = RANGE MUTABLE LIDENT GHOST FLOAT CORE_LIDENT
first(type_decl) = RANGE LIDENT FLOAT CORE_LIDENT
first(type_case) = UIDENT CORE_UIDENT
first(ty_var) = QUOTE_LIDENT
first(ty_block) = LEFTPAR LEFTBRC
first(ty_arg) = UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
first(ty) = UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
first(triggers) = LEFTSQ
first(tqualid) = UIDENT STRING RANGE LIDENT FLOAT CORE_UIDENT CORE_LIDENT
first(term_sub_) = UIDENT TRUE REAL RANGE OPPREF LIDENT LEFTPAR LEFTBRC INTEGER FLOAT FALSE CORE_UIDENT CORE_LIDENT BEGIN
first(term_eof) = UIDENT TRUE REAL RANGE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC INTEGER IF GT FUN FORALL FLOAT FALSE EXISTS EPSILON CORE_UIDENT CORE_LIDENT BEGIN ATTRIBUTE
first(term_dot_) = UIDENT TRUE REAL RANGE OPPREF LIDENT LEFTPAR LEFTBRC INTEGER FLOAT FALSE CORE_UIDENT CORE_LIDENT BEGIN
first(term_dot) = UIDENT TRUE REAL RANGE OPPREF LIDENT LEFTPAR LEFTBRC INTEGER FLOAT FALSE CORE_UIDENT CORE_LIDENT BEGIN
first(term_comma_list_eof) = UIDENT TRUE REAL RANGE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC INTEGER IF GT FUN FORALL FLOAT FALSE EXISTS EPSILON CORE_UIDENT CORE_LIDENT BEGIN ATTRIBUTE
first(term_block_) = LEFTPAR LEFTBRC BEGIN
first(term_arg_) = UIDENT TRUE REAL RANGE OPPREF LIDENT LEFTPAR LEFTBRC INTEGER FLOAT FALSE CORE_UIDENT CORE_LIDENT BEGIN
first(term_arg) = UIDENT TRUE REAL RANGE OPPREF LIDENT LEFTPAR LEFTBRC INTEGER FLOAT FALSE CORE_UIDENT CORE_LIDENT BEGIN
first(term_) = UIDENT TRUE REAL RANGE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC INTEGER IF GT FUN FORALL FLOAT FALSE EXISTS EPSILON CORE_UIDENT CORE_LIDENT BEGIN ATTRIBUTE
first(term) = UIDENT TRUE REAL RANGE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC INTEGER IF GT FUN FORALL FLOAT FALSE EXISTS EPSILON CORE_UIDENT CORE_LIDENT BEGIN ATTRIBUTE
first(squalid) = UIDENT STRING RANGE LIDENT FLOAT CORE_UIDENT CORE_LIDENT
first(spec) = WRITES VARIANT RETURNS REQUIRES READS RAISES ENSURES DIVERGES ALIAS
first(single_variant) = UIDENT TRUE REAL RANGE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC INTEGER IF GT FUN FORALL FLOAT FALSE EXISTS EPSILON CORE_UIDENT CORE_LIDENT BEGIN ATTRIBUTE
first(single_term_) = UIDENT TRUE REAL RANGE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC INTEGER IF GT FUN FORALL FLOAT FALSE EXISTS EPSILON CORE_UIDENT CORE_LIDENT BEGIN ATTRIBUTE
first(single_term) = UIDENT TRUE REAL RANGE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC INTEGER IF GT FUN FORALL FLOAT FALSE EXISTS EPSILON CORE_UIDENT CORE_LIDENT BEGIN ATTRIBUTE
first(single_spec) = WRITES VARIANT RETURNS REQUIRES READS RAISES ENSURES DIVERGES ALIAS
first(single_expr_) = WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
first(single_expr) = WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
first(single_clone_subst) = VAL TYPE PREDICATE LEMMA GOAL FUNCTION EXCEPTION CONSTANT AXIOM
first(sident) = UIDENT STRING RANGE LIDENT FLOAT CORE_UIDENT CORE_LIDENT
first(seq_expr) = WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
first(separated_nonempty_list(WITH,type_decl)) = RANGE LIDENT FLOAT CORE_LIDENT
first(separated_nonempty_list(WITH,rec_defn)) = RANGE PREDICATE LIDENT LEMMA LEFTPAR GHOST FUNCTION FLOAT CORE_LIDENT CONSTANT
first(separated_nonempty_list(WITH,inductive_decl)) = RANGE LIDENT LEFTPAR FLOAT CORE_LIDENT
first(separated_nonempty_list(COMMA,xsymbol)) = UIDENT CORE_UIDENT
first(separated_nonempty_list(COMMA,use_as)) = UIDENT STRING RANGE LIDENT FLOAT CORE_UIDENT CORE_LIDENT
first(separated_nonempty_list(COMMA,ty)) = UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
first(separated_nonempty_list(COMMA,single_variant)) = UIDENT TRUE REAL RANGE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC INTEGER IF GT FUN FORALL FLOAT FALSE EXISTS EPSILON CORE_UIDENT CORE_LIDENT BEGIN ATTRIBUTE
first(separated_nonempty_list(COMMA,single_term)) = UIDENT TRUE REAL RANGE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC INTEGER IF GT FUN FORALL FLOAT FALSE EXISTS EPSILON CORE_UIDENT CORE_LIDENT BEGIN ATTRIBUTE
first(separated_nonempty_list(COMMA,single_clone_subst)) = VAL TYPE PREDICATE LEMMA GOAL FUNCTION EXCEPTION CONSTANT AXIOM
first(separated_nonempty_list(COMMA,ret_cast)) = UNDERSCORE RANGE LIDENT GHOST FLOAT CORE_LIDENT
first(separated_nonempty_list(COMMA,quant_vars)) = UNDERSCORE RANGE LIDENT FLOAT CORE_LIDENT
first(separated_nonempty_list(COMMA,qualid)) = UIDENT RANGE LIDENT LEFTPAR FLOAT CORE_UIDENT CORE_LIDENT
first(separated_nonempty_list(COMMA,mk_pat(pat_uni_))) = UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC GHOST FLOAT CORE_UIDENT CORE_LIDENT
first(separated_nonempty_list(COMMA,meta_arg)) = TYPE STRING PREDICATE LEMMA INTEGER GOAL FUNCTION CONSTANT AXIOM
first(separated_nonempty_list(COMMA,lqualid)) = UIDENT RANGE LIDENT FLOAT CORE_UIDENT CORE_LIDENT
first(separated_nonempty_list(COMMA,ident)) = UIDENT RANGE LIDENT LEFTPAR FLOAT CORE_UIDENT CORE_LIDENT
first(separated_nonempty_list(COMMA,alias)) = UIDENT TRUE REAL RANGE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC INTEGER IF GT FUN FORALL FLOAT FALSE EXISTS EPSILON CORE_UIDENT CORE_LIDENT BEGIN ATTRIBUTE
first(separated_nonempty_list(BAR,type_case)) = UIDENT CORE_UIDENT
first(separated_nonempty_list(BAR,raises)) = UIDENT CORE_UIDENT
first(separated_nonempty_list(BAR,match_case(term))) = UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC GHOST FLOAT CORE_UIDENT CORE_LIDENT
first(separated_nonempty_list(BAR,ind_case)) = UIDENT RANGE LIDENT LEFTPAR FLOAT CORE_UIDENT CORE_LIDENT
first(separated_nonempty_list(BAR,exn_handler)) = UIDENT CORE_UIDENT
first(separated_nonempty_list(BAR,comma_list1(single_term))) = UIDENT TRUE REAL RANGE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC INTEGER IF GT FUN FORALL FLOAT FALSE EXISTS EPSILON CORE_UIDENT CORE_LIDENT BEGIN ATTRIBUTE
first(semicolon_list1(type_field)) = RANGE MUTABLE LIDENT GHOST FLOAT CORE_LIDENT
first(semicolon_list1(separated_pair(lqualid,EQUAL,term))) = UIDENT RANGE LIDENT FLOAT CORE_UIDENT CORE_LIDENT
first(semicolon_list1(separated_pair(lqualid,EQUAL,pattern))) = UIDENT RANGE LIDENT FLOAT CORE_UIDENT CORE_LIDENT
first(semicolon_list1(separated_pair(lqualid,EQUAL,expr))) = UIDENT RANGE LIDENT FLOAT CORE_UIDENT CORE_LIDENT
first(scope_head) = SCOPE
first(rightsq) = RIGHTSQ_QUOTE RIGHTSQ
first(return_opt) = COLON
first(return_named) = UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC GHOST FLOAT CORE_UIDENT CORE_LIDENT
first(return) = UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC GHOST FLOAT CORE_UIDENT CORE_LIDENT
first(ret_rest) = UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC GHOST FLOAT CORE_UIDENT CORE_LIDENT
first(ret_ident) = UNDERSCORE RANGE LIDENT FLOAT CORE_LIDENT
first(ret_ghost) = UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC GHOST FLOAT CORE_UIDENT CORE_LIDENT
first(ret_cast) = UNDERSCORE RANGE LIDENT GHOST FLOAT CORE_LIDENT
first(rec_defn) = RANGE PREDICATE LIDENT LEMMA LEFTPAR GHOST FUNCTION FLOAT CORE_LIDENT CONSTANT
first(raises) = UIDENT CORE_UIDENT
first(quote_lident) = QUOTE_LIDENT
first(quant_vars) = UNDERSCORE RANGE LIDENT FLOAT CORE_LIDENT
first(quant) = FORALL EXISTS
first(qualid_eof) = UIDENT RANGE LIDENT LEFTPAR FLOAT CORE_UIDENT CORE_LIDENT
first(qualid_comma_list_eof) = UIDENT RANGE LIDENT LEFTPAR FLOAT CORE_UIDENT CORE_LIDENT
first(qualid) = UIDENT RANGE LIDENT LEFTPAR FLOAT CORE_UIDENT CORE_LIDENT
first(pure_decl) = TYPE PREDICATE LEMMA INDUCTIVE GOAL FUNCTION CONSTANT COINDUCTIVE AXIOM
first(prog_decl) = VAL LET EXCEPTION
first(prefix_op) = OP4 OP3 OP2 OP1 MINUS LT GT
first(predicate_decl) = RANGE LIDENT LEFTPAR FLOAT CORE_LIDENT
first(pattern_) = UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC GHOST FLOAT CORE_UIDENT CORE_LIDENT
first(pattern) = UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC GHOST FLOAT CORE_UIDENT CORE_LIDENT
first(pat_uni_) = UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC GHOST FLOAT CORE_UIDENT CORE_LIDENT
first(pat_conj_) = UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC GHOST FLOAT CORE_UIDENT CORE_LIDENT
first(pat_block_) = LEFTPAR LEFTBRC
first(pat_arg_) = UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
first(pat_arg) = UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
first(params) = UNDERSCORE UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
first(param) = UNDERSCORE UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
first(option(preceded(WITH,lqualid))) = WITH
first(option(preceded(EQUAL,term))) = EQUAL
first(option(preceded(AS,uident))) = AS
first(option(pat_arg)) = UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
first(option(expr_arg)) = UIDENT TRUE REAL RANGE PURE OPPREF LIDENT LEFTPAR LEFTBRC INTEGER FLOAT FALSE CORE_UIDENT CORE_LIDENT BEGIN
first(option(cast)) = COLON
first(option(UNDERSCORE)) = UNDERSCORE
first(op_symbol) = OP4 OP3 OP2 OP1 LT GT
first(numeral) = REAL INTEGER
first(nonempty_list(ty_arg)) = UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
first(nonempty_list(pat_arg)) = UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
first(nonempty_list(module_decl)) = VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION CONSTANT COINDUCTIVE CLONE AXIOM
first(nonempty_list(located(term_arg))) = UIDENT TRUE REAL RANGE OPPREF LIDENT LEFTPAR LEFTBRC INTEGER FLOAT FALSE CORE_UIDENT CORE_LIDENT BEGIN
first(nonempty_list(located(expr_arg))) = UIDENT TRUE REAL RANGE PURE OPPREF LIDENT LEFTPAR LEFTBRC INTEGER FLOAT FALSE CORE_UIDENT CORE_LIDENT BEGIN
first(nonempty_list(binder_var)) = UNDERSCORE RANGE LIDENT FLOAT CORE_LIDENT
first(nonempty_list(binder)) = UNDERSCORE UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
first(nonempty_list(attr)) = POSITION ATTRIBUTE
first(module_head) = THEORY MODULE
first(module_decl) = VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION CONSTANT COINDUCTIVE CLONE AXIOM
first(mlw_module) = THEORY MODULE
first(mlw_file) = VAL USE TYPE THEORY SCOPE PREDICATE MODULE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF CONSTANT COINDUCTIVE CLONE AXIOM
first(mk_term(term_dot_)) = UIDENT TRUE REAL RANGE OPPREF LIDENT LEFTPAR LEFTBRC INTEGER FLOAT FALSE CORE_UIDENT CORE_LIDENT BEGIN
first(mk_term(term_block_)) = LEFTPAR LEFTBRC BEGIN
first(mk_term(term_arg_)) = UIDENT TRUE REAL RANGE OPPREF LIDENT LEFTPAR LEFTBRC INTEGER FLOAT FALSE CORE_UIDENT CORE_LIDENT BEGIN
first(mk_term(single_term_)) = UIDENT TRUE REAL RANGE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC INTEGER IF GT FUN FORALL FLOAT FALSE EXISTS EPSILON CORE_UIDENT CORE_LIDENT BEGIN ATTRIBUTE
first(mk_term(lam_defn)) = UNDERSCORE UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
first(mk_pat(pattern_)) = UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC GHOST FLOAT CORE_UIDENT CORE_LIDENT
first(mk_pat(pat_uni_)) = UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC GHOST FLOAT CORE_UIDENT CORE_LIDENT
first(mk_pat(pat_conj_)) = UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC GHOST FLOAT CORE_UIDENT CORE_LIDENT
first(mk_pat(pat_block_)) = LEFTPAR LEFTBRC
first(mk_pat(pat_arg_)) = UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
first(mk_pat(let_pattern_)) = UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
first(mk_pat(let_pat_uni_)) = UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
first(mk_pat(let_pat_conj_)) = UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
first(mk_expr(val_defn)) = WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ALIAS
first(mk_expr(single_expr_)) = WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
first(mk_expr(fun_defn)) = UNDERSCORE UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
first(mk_expr(expr_pure_)) = UIDENT LEFTBRC CORE_UIDENT
first(mk_expr(expr_dot_)) = UIDENT TRUE REAL RANGE PURE OPPREF LIDENT LEFTPAR LEFTBRC INTEGER FLOAT FALSE CORE_UIDENT CORE_LIDENT BEGIN
first(mk_expr(expr_block_)) = LEFTPAR LEFTBRC BEGIN
first(mk_expr(expr_arg_)) = UIDENT TRUE REAL RANGE PURE OPPREF LIDENT LEFTPAR LEFTBRC INTEGER FLOAT FALSE CORE_UIDENT CORE_LIDENT BEGIN
first(meta_decl) = META
first(meta_arg) = TYPE STRING PREDICATE LEMMA INTEGER GOAL FUNCTION CONSTANT AXIOM
first(match_cases(term)) = UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC GHOST FLOAT CORE_UIDENT CORE_LIDENT BAR
first(match_case(term)) = UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC GHOST FLOAT CORE_UIDENT CORE_LIDENT
first(match_case(seq_expr)) = UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC GHOST FLOAT CORE_UIDENT CORE_LIDENT
first(lqualid_rich) = UIDENT RANGE LIDENT LEFTPAR FLOAT CORE_UIDENT CORE_LIDENT
first(lqualid) = UIDENT RANGE LIDENT FLOAT CORE_UIDENT CORE_LIDENT
first(loption(separated_nonempty_list(COMMA,single_term))) = UIDENT TRUE REAL RANGE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC INTEGER IF GT FUN FORALL FLOAT FALSE EXISTS EPSILON CORE_UIDENT CORE_LIDENT BEGIN ATTRIBUTE
first(loption(separated_nonempty_list(COMMA,lqualid))) = UIDENT RANGE LIDENT FLOAT CORE_UIDENT CORE_LIDENT
first(loption(separated_nonempty_list(COMMA,alias))) = UIDENT TRUE REAL RANGE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC INTEGER IF GT FUN FORALL FLOAT FALSE EXISTS EPSILON CORE_UIDENT CORE_LIDENT BEGIN ATTRIBUTE
first(loption(semicolon_list1(type_field))) = RANGE MUTABLE LIDENT GHOST FLOAT CORE_LIDENT
first(loop_body) = WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
first(loop_annotation) = VARIANT INVARIANT
first(located(term_arg)) = UIDENT TRUE REAL RANGE OPPREF LIDENT LEFTPAR LEFTBRC INTEGER FLOAT FALSE CORE_UIDENT CORE_LIDENT BEGIN
first(located(expr_arg)) = UIDENT TRUE REAL RANGE PURE OPPREF LIDENT LEFTPAR LEFTBRC INTEGER FLOAT FALSE CORE_UIDENT CORE_LIDENT BEGIN
first(list(with_logic_decl)) = WITH
first(list(ty_var)) = QUOTE_LIDENT
first(list(param)) = UNDERSCORE UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
first(list(module_decl)) = VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION CONSTANT COINDUCTIVE CLONE AXIOM
first(list(mlw_module)) = THEORY MODULE
first(list(invariant)) = INVARIANT
first(list(binder_var)) = UNDERSCORE RANGE LIDENT FLOAT CORE_LIDENT
first(list(attr)) = POSITION ATTRIBUTE
first(lident_rich) = RANGE LIDENT LEFTPAR FLOAT CORE_LIDENT
first(lident_op_str) = OPPREF OP4 OP3 OP2 OP1 MINUS LT LEFTSQ GT EQUAL
first(lident_op_nq) = LEFTPAR
first(lident_op) = LEFTPAR
first(lident_nq) = RANGE LIDENT FLOAT CORE_LIDENT
first(lident_keyword) = RANGE FLOAT
first(lident) = RANGE LIDENT FLOAT CORE_LIDENT
first(let_pattern_) = UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
first(let_pattern) = UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
first(let_pat_uni_) = UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
first(let_pat_conj_) = UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
first(lam_defn) = UNDERSCORE UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
first(kind) = PREDICATE LEMMA FUNCTION CONSTANT
first(invariant) = INVARIANT
first(int_constant) = MINUS INTEGER
first(inductive_decl) = RANGE LIDENT LEFTPAR FLOAT CORE_LIDENT
first(ind_defn) = EQUAL
first(ind_case) = UIDENT RANGE LIDENT LEFTPAR FLOAT CORE_UIDENT CORE_LIDENT
first(ident_nq) = UIDENT RANGE LIDENT LEFTPAR FLOAT CORE_UIDENT CORE_LIDENT
first(ident_comma_list_eof) = UIDENT RANGE LIDENT LEFTPAR FLOAT CORE_UIDENT CORE_LIDENT
first(ident) = UIDENT RANGE LIDENT LEFTPAR FLOAT CORE_UIDENT CORE_LIDENT
first(ghost) = GHOST
first(function_decl) = RANGE LIDENT LEFTPAR FLOAT CORE_LIDENT
first(fun_defn) = UNDERSCORE UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
first(for_direction) = TO DOWNTO
first(field_modifiers) = MUTABLE GHOST
first(field_list1(term)) = UIDENT RANGE LIDENT FLOAT CORE_UIDENT CORE_LIDENT
first(field_list1(pattern)) = UIDENT RANGE LIDENT FLOAT CORE_UIDENT CORE_LIDENT
first(field_list1(expr)) = UIDENT RANGE LIDENT FLOAT CORE_UIDENT CORE_LIDENT
first(ext_match_cases1) = UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC GHOST FLOAT EXCEPTION CORE_UIDENT CORE_LIDENT
first(ext_match_cases0) = BAR
first(ext_match_cases) = UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC GHOST FLOAT EXCEPTION CORE_UIDENT CORE_LIDENT BAR
first(expr_sub_) = UIDENT TRUE REAL RANGE PURE OPPREF LIDENT LEFTPAR LEFTBRC INTEGER FLOAT FALSE CORE_UIDENT CORE_LIDENT BEGIN
first(expr_pure_) = UIDENT LEFTBRC CORE_UIDENT
first(expr_list1) = WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
first(expr_dot_) = UIDENT TRUE REAL RANGE PURE OPPREF LIDENT LEFTPAR LEFTBRC INTEGER FLOAT FALSE CORE_UIDENT CORE_LIDENT BEGIN
first(expr_dot) = UIDENT TRUE REAL RANGE PURE OPPREF LIDENT LEFTPAR LEFTBRC INTEGER FLOAT FALSE CORE_UIDENT CORE_LIDENT BEGIN
first(expr_block_) = LEFTPAR LEFTBRC BEGIN
first(expr_arg_) = UIDENT TRUE REAL RANGE PURE OPPREF LIDENT LEFTPAR LEFTBRC INTEGER FLOAT FALSE CORE_UIDENT CORE_LIDENT BEGIN
first(expr_arg) = UIDENT TRUE REAL RANGE PURE OPPREF LIDENT LEFTPAR LEFTBRC INTEGER FLOAT FALSE CORE_UIDENT CORE_LIDENT BEGIN
first(expr) = WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
first(exn_handler) = UIDENT CORE_UIDENT
first(ensures) = UIDENT TRUE REAL RANGE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC INTEGER IF GT FUN FORALL FLOAT FALSE EXISTS EPSILON CORE_UIDENT CORE_LIDENT BEGIN ATTRIBUTE
first(contract_expr) = WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
first(constant_decl) = RANGE LIDENT LEFTPAR FLOAT CORE_LIDENT
first(const_defn) = EQUAL COLON
first(comma_list2(ty)) = UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
first(comma_list2(ret_cast)) = UNDERSCORE RANGE LIDENT GHOST FLOAT CORE_LIDENT
first(comma_list2(mk_pat(pat_uni_))) = UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC GHOST FLOAT CORE_UIDENT CORE_LIDENT
first(comma_list1(xsymbol)) = UIDENT CORE_UIDENT
first(comma_list1(use_as)) = UIDENT STRING RANGE LIDENT FLOAT CORE_UIDENT CORE_LIDENT
first(comma_list1(ty)) = UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
first(comma_list1(single_variant)) = UIDENT TRUE REAL RANGE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC INTEGER IF GT FUN FORALL FLOAT FALSE EXISTS EPSILON CORE_UIDENT CORE_LIDENT BEGIN ATTRIBUTE
first(comma_list1(single_term)) = UIDENT TRUE REAL RANGE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC INTEGER IF GT FUN FORALL FLOAT FALSE EXISTS EPSILON CORE_UIDENT CORE_LIDENT BEGIN ATTRIBUTE
first(comma_list1(single_clone_subst)) = VAL TYPE PREDICATE LEMMA GOAL FUNCTION EXCEPTION CONSTANT AXIOM
first(comma_list1(ret_cast)) = UNDERSCORE RANGE LIDENT GHOST FLOAT CORE_LIDENT
first(comma_list1(quant_vars)) = UNDERSCORE RANGE LIDENT FLOAT CORE_LIDENT
first(comma_list1(qualid)) = UIDENT RANGE LIDENT LEFTPAR FLOAT CORE_UIDENT CORE_LIDENT
first(comma_list1(mk_pat(pat_uni_))) = UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC GHOST FLOAT CORE_UIDENT CORE_LIDENT
first(comma_list1(meta_arg)) = TYPE STRING PREDICATE LEMMA INTEGER GOAL FUNCTION CONSTANT AXIOM
first(comma_list1(ident)) = UIDENT RANGE LIDENT LEFTPAR FLOAT CORE_UIDENT CORE_LIDENT
first(comma_list0(single_term)) = UIDENT TRUE REAL RANGE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC INTEGER IF GT FUN FORALL FLOAT FALSE EXISTS EPSILON CORE_UIDENT CORE_LIDENT BEGIN ATTRIBUTE
first(comma_list0(lqualid)) = UIDENT RANGE LIDENT FLOAT CORE_UIDENT CORE_LIDENT
first(comma_list0(alias)) = UIDENT TRUE REAL RANGE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC INTEGER IF GT FUN FORALL FLOAT FALSE EXISTS EPSILON CORE_UIDENT CORE_LIDENT BEGIN ATTRIBUTE
first(clone_subst) = WITH
first(cast) = COLON
first(boption(IMPORT)) = IMPORT
first(binders) = UNDERSCORE UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
first(binder_vars_rest) = UNDERSCORE UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
first(binder_vars_head) = UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
first(binder_vars) = UNDERSCORE UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
first(binder_var) = UNDERSCORE RANGE LIDENT FLOAT CORE_LIDENT
first(binder) = UNDERSCORE UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
first(bar_list1(type_case)) = UIDENT CORE_UIDENT BAR
first(bar_list1(raises)) = UIDENT CORE_UIDENT BAR
first(bar_list1(match_case(term))) = UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC GHOST FLOAT CORE_UIDENT CORE_LIDENT BAR
first(bar_list1(ind_case)) = UIDENT RANGE LIDENT LEFTPAR FLOAT CORE_UIDENT CORE_LIDENT BAR
first(bar_list1(exn_handler)) = UIDENT CORE_UIDENT BAR
first(attrs(uident_nq)) = UIDENT CORE_UIDENT
first(attrs(uident)) = UIDENT CORE_UIDENT
first(attrs(quote_lident)) = QUOTE_LIDENT
first(attrs(lident_rich)) = RANGE LIDENT LEFTPAR FLOAT CORE_LIDENT
first(attrs(lident_op_nq)) = LEFTPAR
first(attrs(lident_nq)) = RANGE LIDENT FLOAT CORE_LIDENT
first(attrs(ident_nq)) = UIDENT RANGE LIDENT LEFTPAR FLOAT CORE_UIDENT CORE_LIDENT
first(attr) = POSITION ATTRIBUTE
first(assign_expr) = WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
first(assertion_kind) = CHECK ASSUME ASSERT
first(anon_binder) = UNDERSCORE
first(alias) = UIDENT TRUE REAL RANGE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC INTEGER IF GT FUN FORALL FLOAT FALSE EXISTS EPSILON CORE_UIDENT CORE_LIDENT BEGIN ATTRIBUTE
first(abstract) = PRIVATE ABSTRACT
minimal(xsymbol) = (* 1 *) UIDENT
minimal(with_logic_decl) = (* 2 *) WITH LIDENT
minimal(with_list1(type_decl)) = (* 1 *) LIDENT
minimal(with_list1(rec_defn)) = (* 4 *) LIDENT UNDERSCORE EQUAL UIDENT
minimal(with_list1(inductive_decl)) = (* 1 *) LIDENT
minimal(vis_mut) = (* 0 *) 
minimal(variant) = (* 4 *) VARIANT LEFTBRC UIDENT RIGHTBRC
minimal(val_defn) = (* 0 *) 
minimal(use_clone) = (* 2 *) USE UIDENT
minimal(use_as) = (* 1 *) UIDENT
minimal(uqualid) = (* 1 *) UIDENT
minimal(uident_nq) = (* 1 *) UIDENT
minimal(uident) = (* 1 *) UIDENT
minimal(typedefn) = (* 0 *) 
minimal(type_witness) = (* 0 *) 
minimal(type_field) = (* 3 *) LIDENT COLON LIDENT
minimal(type_decl) = (* 1 *) LIDENT
minimal(type_case) = (* 1 *) UIDENT
minimal(ty_var) = (* 1 *) QUOTE_LIDENT
minimal(ty_block) = (* 2 *) LEFTPAR RIGHTPAR
minimal(ty_arg) = (* 1 *) LIDENT
minimal(ty) = (* 1 *) LIDENT
minimal(triggers) = (* 0 *) 
minimal(tqualid) = (* 1 *) UIDENT
minimal(term_sub_) = (* 2 *) BEGIN END
minimal(term_eof) = (* 2 *) UIDENT EOF
minimal(term_dot_) = (* 1 *) LIDENT
minimal(term_dot) = (* 1 *) LIDENT
minimal(term_comma_list_eof) = (* 2 *) UIDENT EOF
minimal(term_block_) = (* 2 *) BEGIN END
minimal(term_arg_) = (* 1 *) UIDENT
minimal(term_arg) = (* 1 *) UIDENT
minimal(term_) = (* 1 *) UIDENT
minimal(term) = (* 1 *) UIDENT
minimal(squalid) = (* 1 *) LIDENT
minimal(spec) = (* 0 *) 
minimal(single_variant) = (* 1 *) UIDENT
minimal(single_term_) = (* 1 *) UIDENT
minimal(single_term) = (* 1 *) UIDENT
minimal(single_spec) = (* 1 *) DIVERGES
minimal(single_expr_) = (* 1 *) UIDENT
minimal(single_expr) = (* 1 *) UIDENT
minimal(single_clone_subst) = (* 2 *) TYPE UIDENT
minimal(sident) = (* 1 *) LIDENT
minimal(seq_expr) = (* 1 *) UIDENT
minimal(separated_nonempty_list(WITH,type_decl)) = (* 1 *) LIDENT
minimal(separated_nonempty_list(WITH,rec_defn)) = (* 4 *) LIDENT UNDERSCORE EQUAL UIDENT
minimal(separated_nonempty_list(WITH,inductive_decl)) = (* 1 *) LIDENT
minimal(separated_nonempty_list(COMMA,xsymbol)) = (* 1 *) UIDENT
minimal(separated_nonempty_list(COMMA,use_as)) = (* 1 *) UIDENT
minimal(separated_nonempty_list(COMMA,ty)) = (* 1 *) LIDENT
minimal(separated_nonempty_list(COMMA,single_variant)) = (* 1 *) UIDENT
minimal(separated_nonempty_list(COMMA,single_term)) = (* 1 *) UIDENT
minimal(separated_nonempty_list(COMMA,single_clone_subst)) = (* 2 *) TYPE UIDENT
minimal(separated_nonempty_list(COMMA,ret_cast)) = (* 3 *) LIDENT COLON LIDENT
minimal(separated_nonempty_list(COMMA,quant_vars)) = (* 1 *) LIDENT
minimal(separated_nonempty_list(COMMA,qualid)) = (* 1 *) UIDENT
minimal(separated_nonempty_list(COMMA,mk_pat(pat_uni_))) = (* 1 *) UNDERSCORE
minimal(separated_nonempty_list(COMMA,meta_arg)) = (* 1 *) STRING
minimal(separated_nonempty_list(COMMA,lqualid)) = (* 1 *) LIDENT
minimal(separated_nonempty_list(COMMA,ident)) = (* 1 *) UIDENT
minimal(separated_nonempty_list(COMMA,alias)) = (* 3 *) UIDENT WITH UIDENT
minimal(separated_nonempty_list(BAR,type_case)) = (* 1 *) UIDENT
minimal(separated_nonempty_list(BAR,raises)) = (* 3 *) UIDENT ARROW UIDENT
minimal(separated_nonempty_list(BAR,match_case(term))) = (* 3 *) UNDERSCORE ARROW UIDENT
minimal(separated_nonempty_list(BAR,ind_case)) = (* 3 *) UIDENT COLON UIDENT
minimal(separated_nonempty_list(BAR,exn_handler)) = (* 3 *) UIDENT ARROW UIDENT
minimal(separated_nonempty_list(BAR,comma_list1(single_term))) = (* 1 *) UIDENT
minimal(semicolon_list1(type_field)) = (* 3 *) LIDENT COLON LIDENT
minimal(semicolon_list1(separated_pair(lqualid,EQUAL,term))) = (* 3 *) LIDENT EQUAL UIDENT
minimal(semicolon_list1(separated_pair(lqualid,EQUAL,pattern))) = (* 3 *) LIDENT EQUAL UNDERSCORE
minimal(semicolon_list1(separated_pair(lqualid,EQUAL,expr))) = (* 3 *) LIDENT EQUAL UIDENT
minimal(scope_head) = (* 2 *) SCOPE UIDENT
minimal(rightsq) = (* 1 *) RIGHTSQ
minimal(return_opt) = (* 0 *) 
minimal(return_named) = (* 1 *) LIDENT
minimal(return) = (* 1 *) LIDENT
minimal(ret_rest) = (* 1 *) LIDENT
minimal(ret_ident) = (* 1 *) LIDENT
minimal(ret_ghost) = (* 4 *) LIDENT COMMA GHOST LIDENT
minimal(ret_cast) = (* 3 *) LIDENT COLON LIDENT
minimal(rec_defn) = (* 4 *) LIDENT UNDERSCORE EQUAL UIDENT
minimal(raises) = (* 3 *) UIDENT ARROW UIDENT
minimal(quote_lident) = (* 1 *) QUOTE_LIDENT
minimal(quant_vars) = (* 1 *) LIDENT
minimal(quant) = (* 1 *) FORALL
minimal(qualid_eof) = (* 2 *) UIDENT EOF
minimal(qualid_comma_list_eof) = (* 2 *) UIDENT EOF
minimal(qualid) = (* 1 *) UIDENT
minimal(pure_decl) = (* 2 *) TYPE LIDENT
minimal(prog_decl) = (* 2 *) VAL LIDENT
minimal(prefix_op) = (* 1 *) OP1
minimal(predicate_decl) = (* 1 *) LIDENT
minimal(pattern_) = (* 1 *) UNDERSCORE
minimal(pattern) = (* 1 *) UNDERSCORE
minimal(pat_uni_) = (* 1 *) UNDERSCORE
minimal(pat_conj_) = (* 1 *) UNDERSCORE
minimal(pat_block_) = (* 2 *) LEFTPAR RIGHTPAR
minimal(pat_arg_) = (* 1 *) UNDERSCORE
minimal(pat_arg) = (* 1 *) UNDERSCORE
minimal(params) = (* 0 *) 
minimal(param) = (* 1 *) UNDERSCORE
minimal(option(preceded(WITH,lqualid))) = (* 0 *) 
minimal(option(preceded(EQUAL,term))) = (* 0 *) 
minimal(option(preceded(AS,uident))) = (* 0 *) 
minimal(option(pat_arg)) = (* 0 *) 
minimal(option(expr_arg)) = (* 0 *) 
minimal(option(cast)) = (* 0 *) 
minimal(option(UNDERSCORE)) = (* 0 *) 
minimal(op_symbol) = (* 1 *) OP1
minimal(numeral) = (* 1 *) INTEGER
minimal(nonempty_list(ty_arg)) = (* 1 *) LIDENT
minimal(nonempty_list(pat_arg)) = (* 1 *) UNDERSCORE
minimal(nonempty_list(module_decl)) = (* 2 *) IMPORT UIDENT
minimal(nonempty_list(located(term_arg))) = (* 1 *) UIDENT
minimal(nonempty_list(located(expr_arg))) = (* 1 *) UIDENT
minimal(nonempty_list(binder_var)) = (* 1 *) LIDENT
minimal(nonempty_list(binder)) = (* 1 *) UNDERSCORE
minimal(nonempty_list(attr)) = (* 1 *) ATTRIBUTE
minimal(module_head) = (* 2 *) THEORY UIDENT
minimal(module_decl) = (* 2 *) IMPORT UIDENT
minimal(mlw_module) = (* 3 *) THEORY UIDENT END
minimal(mlw_file) = (* 1 *) EOF
minimal(mk_term(term_dot_)) = (* 1 *) LIDENT
minimal(mk_term(term_block_)) = (* 2 *) BEGIN END
minimal(mk_term(term_arg_)) = (* 1 *) UIDENT
minimal(mk_term(single_term_)) = (* 1 *) UIDENT
minimal(mk_term(lam_defn)) = (* 3 *) UNDERSCORE EQUAL UIDENT
minimal(mk_pat(pattern_)) = (* 1 *) UNDERSCORE
minimal(mk_pat(pat_uni_)) = (* 1 *) UNDERSCORE
minimal(mk_pat(pat_conj_)) = (* 1 *) UNDERSCORE
minimal(mk_pat(pat_block_)) = (* 2 *) LEFTPAR RIGHTPAR
minimal(mk_pat(pat_arg_)) = (* 1 *) UNDERSCORE
minimal(mk_pat(let_pattern_)) = (* 1 *) UNDERSCORE
minimal(mk_pat(let_pat_uni_)) = (* 1 *) UNDERSCORE
minimal(mk_pat(let_pat_conj_)) = (* 1 *) UNDERSCORE
minimal(mk_expr(val_defn)) = (* 0 *) 
minimal(mk_expr(single_expr_)) = (* 1 *) UIDENT
minimal(mk_expr(fun_defn)) = (* 3 *) UNDERSCORE EQUAL UIDENT
minimal(mk_expr(expr_pure_)) = (* 3 *) LEFTBRC UIDENT RIGHTBRC
minimal(mk_expr(expr_dot_)) = (* 1 *) LIDENT
minimal(mk_expr(expr_block_)) = (* 2 *) BEGIN END
minimal(mk_expr(expr_arg_)) = (* 1 *) UIDENT
minimal(meta_decl) = (* 3 *) META LIDENT STRING
minimal(meta_arg) = (* 1 *) STRING
minimal(match_cases(term)) = (* 3 *) UNDERSCORE ARROW UIDENT
minimal(match_case(term)) = (* 3 *) UNDERSCORE ARROW UIDENT
minimal(match_case(seq_expr)) = (* 3 *) UNDERSCORE ARROW UIDENT
minimal(lqualid_rich) = (* 1 *) LIDENT
minimal(lqualid) = (* 1 *) LIDENT
minimal(loption(separated_nonempty_list(COMMA,single_term))) = (* 0 *) 
minimal(loption(separated_nonempty_list(COMMA,lqualid))) = (* 0 *) 
minimal(loption(separated_nonempty_list(COMMA,alias))) = (* 0 *) 
minimal(loption(semicolon_list1(type_field))) = (* 0 *) 
minimal(loop_body) = (* 0 *) 
minimal(loop_annotation) = (* 0 *) 
minimal(located(term_arg)) = (* 1 *) UIDENT
minimal(located(expr_arg)) = (* 1 *) UIDENT
minimal(list(with_logic_decl)) = (* 0 *) 
minimal(list(ty_var)) = (* 0 *) 
minimal(list(param)) = (* 0 *) 
minimal(list(module_decl)) = (* 0 *) 
minimal(list(mlw_module)) = (* 0 *) 
minimal(list(invariant)) = (* 0 *) 
minimal(list(binder_var)) = (* 0 *) 
minimal(list(attr)) = (* 0 *) 
minimal(lident_rich) = (* 1 *) LIDENT
minimal(lident_op_str) = (* 1 *) OP1
minimal(lident_op_nq) = (* 3 *) LEFTPAR OP1 RIGHTPAR
minimal(lident_op) = (* 3 *) LEFTPAR OP1 RIGHTPAR
minimal(lident_nq) = (* 1 *) LIDENT
minimal(lident_keyword) = (* 1 *) RANGE
minimal(lident) = (* 1 *) LIDENT
minimal(let_pattern_) = (* 1 *) UNDERSCORE
minimal(let_pattern) = (* 1 *) UNDERSCORE
minimal(let_pat_uni_) = (* 1 *) UNDERSCORE
minimal(let_pat_conj_) = (* 1 *) UNDERSCORE
minimal(lam_defn) = (* 3 *) UNDERSCORE EQUAL UIDENT
minimal(kind) = (* 0 *) 
minimal(invariant) = (* 4 *) INVARIANT LEFTBRC UIDENT RIGHTBRC
minimal(int_constant) = (* 1 *) INTEGER
minimal(inductive_decl) = (* 1 *) LIDENT
minimal(ind_defn) = (* 0 *) 
minimal(ind_case) = (* 3 *) UIDENT COLON UIDENT
minimal(ident_nq) = (* 1 *) UIDENT
minimal(ident_comma_list_eof) = (* 2 *) UIDENT EOF
minimal(ident) = (* 1 *) UIDENT
minimal(ghost) = (* 0 *) 
minimal(function_decl) = (* 3 *) LIDENT COLON LIDENT
minimal(fun_defn) = (* 3 *) UNDERSCORE EQUAL UIDENT
minimal(for_direction) = (* 1 *) TO
minimal(field_modifiers) = (* 1 *) MUTABLE
minimal(field_list1(term)) = (* 3 *) LIDENT EQUAL UIDENT
minimal(field_list1(pattern)) = (* 3 *) LIDENT EQUAL UNDERSCORE
minimal(field_list1(expr)) = (* 3 *) LIDENT EQUAL UIDENT
minimal(ext_match_cases1) = (* 3 *) UNDERSCORE ARROW UIDENT
minimal(ext_match_cases0) = (* 0 *) 
minimal(ext_match_cases) = (* 3 *) UNDERSCORE ARROW UIDENT
minimal(expr_sub_) = (* 2 *) BEGIN END
minimal(expr_pure_) = (* 3 *) LEFTBRC UIDENT RIGHTBRC
minimal(expr_list1) = (* 1 *) UIDENT
minimal(expr_dot_) = (* 1 *) LIDENT
minimal(expr_dot) = (* 1 *) LIDENT
minimal(expr_block_) = (* 2 *) BEGIN END
minimal(expr_arg_) = (* 1 *) UIDENT
minimal(expr_arg) = (* 1 *) UIDENT
minimal(expr) = (* 1 *) UIDENT
minimal(exn_handler) = (* 3 *) UIDENT ARROW UIDENT
minimal(ensures) = (* 1 *) UIDENT
minimal(contract_expr) = (* 1 *) UIDENT
minimal(constant_decl) = (* 3 *) LIDENT COLON LIDENT
minimal(const_defn) = (* 2 *) EQUAL UIDENT
minimal(comma_list2(ty)) = (* 3 *) LIDENT COMMA LIDENT
minimal(comma_list2(ret_cast)) = (* 7 *) LIDENT COLON LIDENT COMMA LIDENT COLON LIDENT
minimal(comma_list2(mk_pat(pat_uni_))) = (* 3 *) UNDERSCORE COMMA UNDERSCORE
minimal(comma_list1(xsymbol)) = (* 1 *) UIDENT
minimal(comma_list1(use_as)) = (* 1 *) UIDENT
minimal(comma_list1(ty)) = (* 1 *) LIDENT
minimal(comma_list1(single_variant)) = (* 1 *) UIDENT
minimal(comma_list1(single_term)) = (* 1 *) UIDENT
minimal(comma_list1(single_clone_subst)) = (* 2 *) TYPE UIDENT
minimal(comma_list1(ret_cast)) = (* 3 *) LIDENT COLON LIDENT
minimal(comma_list1(quant_vars)) = (* 1 *) LIDENT
minimal(comma_list1(qualid)) = (* 1 *) UIDENT
minimal(comma_list1(mk_pat(pat_uni_))) = (* 1 *) UNDERSCORE
minimal(comma_list1(meta_arg)) = (* 1 *) STRING
minimal(comma_list1(ident)) = (* 1 *) UIDENT
minimal(comma_list0(single_term)) = (* 0 *) 
minimal(comma_list0(lqualid)) = (* 0 *) 
minimal(comma_list0(alias)) = (* 0 *) 
minimal(clone_subst) = (* 0 *) 
minimal(cast) = (* 2 *) COLON LIDENT
minimal(boption(IMPORT)) = (* 0 *) 
minimal(binders) = (* 1 *) UNDERSCORE
minimal(binder_vars_rest) = (* 1 *) UNDERSCORE
minimal(binder_vars_head) = (* 1 *) LIDENT
minimal(binder_vars) = (* 1 *) UNDERSCORE
minimal(binder_var) = (* 1 *) LIDENT
minimal(binder) = (* 1 *) UNDERSCORE
minimal(bar_list1(type_case)) = (* 1 *) UIDENT
minimal(bar_list1(raises)) = (* 3 *) UIDENT ARROW UIDENT
minimal(bar_list1(match_case(term))) = (* 3 *) UNDERSCORE ARROW UIDENT
minimal(bar_list1(ind_case)) = (* 3 *) UIDENT COLON UIDENT
minimal(bar_list1(exn_handler)) = (* 3 *) UIDENT ARROW UIDENT
minimal(attrs(uident_nq)) = (* 1 *) UIDENT
minimal(attrs(uident)) = (* 1 *) UIDENT
minimal(attrs(quote_lident)) = (* 1 *) QUOTE_LIDENT
minimal(attrs(lident_rich)) = (* 1 *) LIDENT
minimal(attrs(lident_op_nq)) = (* 3 *) LEFTPAR OP1 RIGHTPAR
minimal(attrs(lident_nq)) = (* 1 *) LIDENT
minimal(attrs(ident_nq)) = (* 1 *) UIDENT
minimal(attr) = (* 1 *) ATTRIBUTE
minimal(assign_expr) = (* 1 *) UIDENT
minimal(assertion_kind) = (* 1 *) ASSERT
minimal(anon_binder) = (* 1 *) UNDERSCORE
minimal(alias) = (* 3 *) UIDENT WITH UIDENT
minimal(abstract) = (* 1 *) PRIVATE
follow(xsymbol) = RIGHTBRC COMMA
follow(with_logic_decl) = WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(with_list1(type_decl)) = VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(with_list1(rec_defn)) = VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(with_list1(inductive_decl)) = VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(vis_mut) = UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT BAR
follow(variant) = WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INVARIANT INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD
follow(val_defn) = VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(use_clone) = VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(use_as) = VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
follow(uqualid) = WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AS ARROW AMPAMP ALIAS
follow(uident_nq) = WITH VAL USE UNDERSCORE UIDENT TYPE SCOPE RANGE QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL GHOST FUNCTION FLOAT EXCEPTION EOF END CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ATTRIBUTE
follow(uident) = WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN STRING SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE POSITION OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL GHOST FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS
follow(typedefn) = WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM
follow(type_witness) = WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(type_field) = SEMICOLON RIGHTBRC
follow(type_decl) = WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(type_case) = WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY BAR AXIOM
follow(ty_var) = WITH VAL USE TYPE SCOPE QUOTE_LIDENT PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM
follow(ty_block) = WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS
follow(ty_arg) = WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS
follow(ty) = WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS
follow(triggers) = DOT
follow(tqualid) = WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM AS
follow(term_sub_) = WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP
follow(term_eof) = #
follow(term_dot_) = DOT
follow(term_dot) = DOT
follow(term_comma_list_eof) = #
follow(term_block_) = WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP
follow(term_arg_) = WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP
follow(term_arg) = WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP
follow(term_) = WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP
follow(term) = WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP
follow(squalid) = DOT
follow(spec) = WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD
follow(single_variant) = RIGHTBRC COMMA
follow(single_term_) = WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP
follow(single_term) = WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP
follow(single_spec) = WRITES WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW LABEL INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BREAK BEGIN BARBAR BAR AXIOM ATTRIBUTE ASSUME ASSERT ARROW ANY AMPAMP ALIAS ABSURD
follow(single_expr_) = WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
follow(single_expr) = WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
follow(single_clone_subst) = VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
follow(sident) = TYPE STRING PREDICATE LEMMA INTEGER GOAL FUNCTION DOT CONSTANT AXIOM
follow(seq_expr) = WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
follow(separated_nonempty_list(WITH,type_decl)) = VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(separated_nonempty_list(WITH,rec_defn)) = VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(separated_nonempty_list(WITH,inductive_decl)) = VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(separated_nonempty_list(COMMA,xsymbol)) = RIGHTBRC
follow(separated_nonempty_list(COMMA,use_as)) = VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(separated_nonempty_list(COMMA,ty)) = RIGHTPAR
follow(separated_nonempty_list(COMMA,single_variant)) = RIGHTBRC
follow(separated_nonempty_list(COMMA,single_term)) = RIGHTSQ RIGHTBRC EOF BAR
follow(separated_nonempty_list(COMMA,single_clone_subst)) = VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(separated_nonempty_list(COMMA,ret_cast)) = RIGHTPAR
follow(separated_nonempty_list(COMMA,quant_vars)) = LEFTSQ DOT
follow(separated_nonempty_list(COMMA,qualid)) = EOF
follow(separated_nonempty_list(COMMA,mk_pat(pat_uni_))) = SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW
follow(separated_nonempty_list(COMMA,meta_arg)) = VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(separated_nonempty_list(COMMA,lqualid)) = RIGHTBRC
follow(separated_nonempty_list(COMMA,ident)) = EOF
follow(separated_nonempty_list(COMMA,alias)) = RIGHTBRC
follow(separated_nonempty_list(BAR,type_case)) = WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM
follow(separated_nonempty_list(BAR,raises)) = RIGHTBRC
follow(separated_nonempty_list(BAR,match_case(term))) = RIGHTBRC END
follow(separated_nonempty_list(BAR,ind_case)) = WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(separated_nonempty_list(BAR,exn_handler)) = END
follow(separated_nonempty_list(BAR,comma_list1(single_term))) = RIGHTSQ
follow(semicolon_list1(type_field)) = RIGHTBRC
follow(semicolon_list1(separated_pair(lqualid,EQUAL,term))) = RIGHTBRC
follow(semicolon_list1(separated_pair(lqualid,EQUAL,pattern))) = RIGHTBRC
follow(semicolon_list1(separated_pair(lqualid,EQUAL,expr))) = RIGHTBRC
follow(scope_head) = VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM
follow(rightsq) = WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS
follow(return_opt) = WRITES VARIANT VAL USE TYPE SCOPE RETURNS REQUIRES READS RAISES PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END DIVERGES CONSTANT COINDUCTIVE CLONE AXIOM ALIAS
follow(return_named) = WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
follow(return) = WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
follow(ret_rest) = RIGHTPAR
follow(ret_ident) = COLON
follow(ret_ghost) = RIGHTPAR
follow(ret_cast) = RIGHTPAR COMMA
follow(rec_defn) = WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(raises) = RIGHTBRC BAR
follow(quote_lident) = WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS
follow(quant_vars) = LEFTSQ DOT COMMA
follow(quant) = UNDERSCORE RANGE LIDENT FLOAT CORE_LIDENT
follow(qualid_eof) = #
follow(qualid_comma_list_eof) = #
follow(qualid) = WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS
follow(pure_decl) = VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(prog_decl) = VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(prefix_op) = WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FORALL FOR FLOAT FALSE EXISTS EXCEPTION EPSILON CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
follow(predicate_decl) = WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(pattern_) = SEMICOLON RIGHTPAR RIGHTBRC EQUAL ARROW
follow(pattern) = SEMICOLON RIGHTPAR RIGHTBRC EQUAL ARROW
follow(pat_uni_) = SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW
follow(pat_conj_) = SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW
follow(pat_block_) = UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW
follow(pat_arg_) = UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW
follow(pat_arg) = UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW
follow(params) = WRITES WITH VARIANT VAL USE TYPE SCOPE RETURNS REQUIRES READS RAISES PREDICATE META LET LEMMA INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END DIVERGES CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS
follow(param) = WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS
follow(option(preceded(WITH,lqualid))) = RIGHTBRC COMMA
follow(option(preceded(EQUAL,term))) = WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(option(preceded(AS,uident))) = WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
follow(option(pat_arg)) = ARROW
follow(option(expr_arg)) = WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
follow(option(cast)) = WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA LEFTSQ INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END DOT CONSTANT COMMA COINDUCTIVE CLONE AXIOM
follow(option(UNDERSCORE)) = RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR
follow(op_symbol) = WHILE VAL UNDERSCORE UIDENT TRY TRUE RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FORALL FOR FLOAT FALSE EXISTS EXCEPTION EPSILON CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
follow(numeral) = WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS
follow(nonempty_list(ty_arg)) = WRITES WITH VARIANT VAL USE UNDERSCORE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS
follow(nonempty_list(pat_arg)) = SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW
follow(nonempty_list(module_decl)) = EOF
follow(nonempty_list(located(term_arg))) = WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP
follow(nonempty_list(located(expr_arg))) = WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
follow(nonempty_list(binder_var)) = LEFTSQ DOT COMMA COLON
follow(nonempty_list(binder)) = WRITES VARIANT RETURNS REQUIRES READS RAISES EQUAL ENSURES DIVERGES COLON ARROW ALIAS
follow(nonempty_list(attr)) = WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RIGHTPAR RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ARROW ALIAS
follow(module_head) = VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION END CONSTANT COINDUCTIVE CLONE AXIOM
follow(module_decl) = VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(mlw_module) = THEORY MODULE EOF
follow(mlw_file) = #
follow(mk_term(term_dot_)) = DOT
follow(mk_term(term_block_)) = WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP
follow(mk_term(term_arg_)) = WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP
follow(mk_term(single_term_)) = WITH VAL USE TYPE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF END ELSE DOTDOT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT ARROW AND AMPAMP
follow(mk_term(lam_defn)) = IN
follow(mk_pat(pattern_)) = SEMICOLON RIGHTPAR RIGHTBRC EQUAL ARROW
follow(mk_pat(pat_uni_)) = SEMICOLON RIGHTPAR RIGHTBRC EQUAL COMMA COLON BAR AS ARROW
follow(mk_pat(pat_conj_)) = BAR
follow(mk_pat(pat_block_)) = UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW
follow(mk_pat(pat_arg_)) = UNDERSCORE UIDENT SEMICOLON RIGHTPAR RIGHTBRC RANGE LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT COMMA COLON BAR AS ARROW
follow(mk_pat(let_pattern_)) = EQUAL
follow(mk_pat(let_pat_uni_)) = COMMA COLON AS
follow(mk_pat(let_pat_conj_)) = BAR
follow(mk_expr(val_defn)) = VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(mk_expr(single_expr_)) = WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
follow(mk_expr(fun_defn)) = VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(mk_expr(expr_pure_)) = WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
follow(mk_expr(expr_dot_)) = DOT
follow(mk_expr(expr_block_)) = WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
follow(mk_expr(expr_arg_)) = WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
follow(meta_decl) = VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(meta_arg) = VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COMMA COINDUCTIVE CLONE AXIOM
follow(match_cases(term)) = RIGHTBRC END
follow(match_case(term)) = RIGHTBRC END BAR
follow(match_case(seq_expr)) = END BAR
follow(lqualid_rich) = WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS
follow(lqualid) = WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS
follow(loption(separated_nonempty_list(COMMA,single_term))) = RIGHTBRC
follow(loption(separated_nonempty_list(COMMA,lqualid))) = RIGHTBRC
follow(loption(separated_nonempty_list(COMMA,alias))) = RIGHTBRC
follow(loption(semicolon_list1(type_field))) = RIGHTBRC
follow(loop_body) = DONE
follow(loop_annotation) = WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION DONE CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
follow(located(term_arg)) = WITH VAL USE UIDENT TYPE TRUE THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC REAL RANGE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF END ELSE DOTDOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP
follow(located(expr_arg)) = WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
follow(list(with_logic_decl)) = VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(list(ty_var)) = WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM
follow(list(param)) = WRITES WITH VARIANT VAL USE TYPE SCOPE RETURNS REQUIRES READS RAISES PREDICATE META LET LEMMA INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END DIVERGES CONSTANT COLON COINDUCTIVE CLONE BY BAR AXIOM ALIAS
follow(list(module_decl)) = END
follow(list(mlw_module)) = EOF
follow(list(invariant)) = WITH WHILE VAL USE UIDENT TYPE TRY TRUE SCOPE RETURN REAL RANGE RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LT LIDENT LET LEMMA LEFTPAR LEFTBRC LABEL INTEGER INDUCTIVE IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EOF END DONE CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COINDUCTIVE CLONE CHECK BY BREAK BEGIN AXIOM ATTRIBUTE ASSUME ASSERT ANY ABSURD
follow(list(binder_var)) = RIGHTPAR COLON
follow(list(attr)) = WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SEMICOLON SCOPE RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL GHOST FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DOT DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BAR AXIOM AS ARROW ALIAS
follow(lident_rich) = WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ATTRIBUTE ALIAS
follow(lident_op_str) = RIGHTPAR_USCORE RIGHTPAR_QUOTE RIGHTPAR
follow(lident_op_nq) = WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ATTRIBUTE ALIAS
follow(lident_op) = WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS
follow(lident_nq) = WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SEMICOLON SCOPE RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE POSITION META LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DOT DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BAR AXIOM ATTRIBUTE AS ARROW ALIAS
follow(lident_keyword) = WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN STRING SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE POSITION OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS
follow(lident) = WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE TRUE TO THEN STRING SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE POSITION OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INVARIANT INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM ATTRIBUTE AT AS ARROW AND AMPAMP ALIAS
follow(let_pattern_) = EQUAL
follow(let_pattern) = EQUAL
follow(let_pat_uni_) = EQUAL COMMA COLON BAR AS
follow(let_pat_conj_) = EQUAL BAR
follow(lam_defn) = IN
follow(kind) = UNDERSCORE UIDENT RANGE LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT
follow(invariant) = WITH WHILE VARIANT VAL USE UIDENT TYPE TRY TRUE SCOPE RETURN REAL RANGE RAISE PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS META MATCH LT LIDENT LET LEMMA LEFTPAR LEFTBRC LABEL INVARIANT INTEGER INDUCTIVE IMPORT IF GT GOAL GHOST FUNCTION FUN FOR FLOAT FALSE EXCEPTION EOF END DONE CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COINDUCTIVE CLONE CHECK BY BREAK BEGIN AXIOM ATTRIBUTE ASSUME ASSERT ANY ABSURD
follow(int_constant) = MINUS INTEGER GT
follow(inductive_decl) = WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(ind_defn) = WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(ind_case) = WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BAR AXIOM
follow(ident_nq) = POSITION COLON ATTRIBUTE
follow(ident_comma_list_eof) = #
follow(ident) = WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES QUOTE_LIDENT PURE PREDICATE OR OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BEGIN BARBAR BAR AXIOM AT ARROW AND AMPAMP ALIAS
follow(ghost) = UNDERSCORE UIDENT RANGE PREDICATE LIDENT LEMMA LEFTPAR LEFTBRC FUNCTION FLOAT CORE_UIDENT CORE_LIDENT CONSTANT
follow(function_decl) = WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(fun_defn) = VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IN IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(for_direction) = WHILE VAL UIDENT TRY TRUE RETURN REAL RANGE RAISE PURE POSITION OPPREF OP4 OP3 OP2 OP1 NOT MINUS MATCH LT LIDENT LET LEFTPAR LEFTBRC LABEL INTEGER IF GT GHOST FUN FOR FLOAT FALSE EXCEPTION CORE_UIDENT CORE_LIDENT CONTINUE CHECK BREAK BEGIN ATTRIBUTE ASSUME ASSERT ANY ABSURD
follow(field_modifiers) = RANGE LIDENT FLOAT CORE_LIDENT
follow(field_list1(term)) = RIGHTBRC
follow(field_list1(pattern)) = RIGHTBRC
follow(field_list1(expr)) = RIGHTBRC
follow(ext_match_cases1) = END
follow(ext_match_cases0) = END
follow(ext_match_cases) = END
follow(expr_sub_) = WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
follow(expr_pure_) = WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
follow(expr_list1) = WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
follow(expr_dot_) = DOT
follow(expr_dot) = DOT
follow(expr_block_) = WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
follow(expr_arg_) = WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
follow(expr_arg) = WRITES WITH VARIANT VAL USE UIDENT TYPE TRUE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES REAL READS RANGE RAISES PURE PREDICATE OPPREF OP4 OP3 OP2 OP1 MINUS META LTGT LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LARROW INTEGER INDUCTIVE IN IMPORT GT GOAL FUNCTION FLOAT FALSE EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BEGIN BARBAR BAR AXIOM AMPAMP ALIAS
follow(expr) = WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
follow(exn_handler) = END BAR
follow(ensures) = RIGHTBRC
follow(contract_expr) = WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
follow(constant_decl) = VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(const_defn) = VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(comma_list2(ty)) = RIGHTPAR
follow(comma_list2(ret_cast)) = RIGHTPAR
follow(comma_list2(mk_pat(pat_uni_))) = SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW
follow(comma_list1(xsymbol)) = RIGHTBRC
follow(comma_list1(use_as)) = VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(comma_list1(ty)) = RIGHTPAR
follow(comma_list1(single_variant)) = RIGHTBRC
follow(comma_list1(single_term)) = RIGHTSQ EOF BAR
follow(comma_list1(single_clone_subst)) = VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(comma_list1(ret_cast)) = RIGHTPAR
follow(comma_list1(quant_vars)) = LEFTSQ DOT
follow(comma_list1(qualid)) = EOF
follow(comma_list1(mk_pat(pat_uni_))) = SEMICOLON RIGHTPAR RIGHTBRC EQUAL BAR ARROW
follow(comma_list1(meta_arg)) = VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(comma_list1(ident)) = EOF
follow(comma_list0(single_term)) = RIGHTBRC
follow(comma_list0(lqualid)) = RIGHTBRC
follow(comma_list0(alias)) = RIGHTBRC
follow(clone_subst) = VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(cast) = WRITES WITH VARIANT VAL USE TYPE TO THEN SO SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OR OP4 OP3 OP2 OP1 MINUS META LTGT LT LRARROW LET LEMMA LEFTSQ LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BY BARBAR BAR AXIOM AT AS ARROW AND AMPAMP ALIAS
follow(boption(IMPORT)) = UIDENT STRING RANGE LIDENT FLOAT CORE_UIDENT CORE_LIDENT
follow(binders) = WRITES VARIANT RETURNS REQUIRES READS RAISES EQUAL ENSURES DIVERGES COLON ARROW ALIAS
follow(binder_vars_rest) = RIGHTPAR COLON
follow(binder_vars_head) = UNDERSCORE POSITION COLON ATTRIBUTE
follow(binder_vars) = COLON
follow(binder_var) = UNDERSCORE RIGHTPAR RANGE LIDENT LEFTSQ FLOAT DOT CORE_LIDENT COMMA COLON
follow(binder) = WRITES VARIANT UNDERSCORE UIDENT RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL ENSURES DIVERGES CORE_UIDENT CORE_LIDENT COLON ARROW ALIAS
follow(bar_list1(type_case)) = WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM
follow(bar_list1(raises)) = RIGHTBRC
follow(bar_list1(match_case(term))) = RIGHTBRC END
follow(bar_list1(ind_case)) = WITH VAL USE TYPE SCOPE PREDICATE META LET LEMMA INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EOF END CONSTANT COINDUCTIVE CLONE AXIOM
follow(bar_list1(exn_handler)) = END
follow(attrs(uident_nq)) = WITH VAL USE UNDERSCORE UIDENT TYPE SCOPE RANGE QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL GHOST FUNCTION FLOAT EXCEPTION EOF END CORE_UIDENT CORE_LIDENT CONSTANT COINDUCTIVE CLONE BY BAR AXIOM
follow(attrs(uident)) = UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC IN GHOST FLOAT CORE_UIDENT CORE_LIDENT
follow(attrs(quote_lident)) = WITH VAL USE TYPE SCOPE QUOTE_LIDENT PREDICATE META LET LEMMA INVARIANT INDUCTIVE IMPORT GOAL FUNCTION EXCEPTION EQUAL EOF END CONSTANT COINDUCTIVE CLONE BY AXIOM
follow(attrs(lident_rich)) = WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTPAR LEFTBRC INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COLON COINDUCTIVE CLONE AXIOM ALIAS
follow(attrs(lident_op_nq)) = UNDERSCORE UIDENT RANGE QUOTE_LIDENT LIDENT LEFTPAR LEFTBRC FLOAT EQUAL CORE_UIDENT CORE_LIDENT
follow(attrs(lident_nq)) = WITH VAL USE UNDERSCORE UIDENT TYPE SEMICOLON SCOPE RIGHTPAR RIGHTBRC RANGE QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC INVARIANT INDUCTIVE IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF END DOT CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BAR AXIOM AS ARROW
follow(attrs(ident_nq)) = COLON
follow(attr) = WRITES WITH WHILE VARIANT VAL USE UNDERSCORE UIDENT TYPE TRY TRUE SEMICOLON SCOPE RIGHTPAR RIGHTBRC RETURNS RETURN REQUIRES REAL READS RANGE RAISES RAISE QUOTE_LIDENT PURE PREDICATE POSITION OPPREF OP4 OP3 OP2 OP1 OLD NOT MINUS META MATCH LT LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC LABEL INVARIANT INTEGER INDUCTIVE IN IMPORT IF GT GOAL GHOST FUNCTION FUN FORALL FOR FLOAT FALSE EXISTS EXCEPTION EQUAL EPSILON EOF ENSURES END DOT DIVERGES CORE_UIDENT CORE_LIDENT CONTINUE CONSTANT COMMA COLON COINDUCTIVE CLONE CHECK BY BREAK BEGIN BAR AXIOM ATTRIBUTE ASSUME ASSERT AS ARROW ANY ALIAS ABSURD
follow(assign_expr) = WRITES WITH VARIANT VAL USE TYPE TO THEN SEMICOLON SCOPE RIGHTSQ_QUOTE RIGHTSQ RIGHTPAR RIGHTBRC RETURNS REQUIRES READS RAISES PREDICATE OP4 OP3 OP2 OP1 MINUS META LTGT LT LET LEMMA LARROW INDUCTIVE IN IMPORT GT GOAL FUNCTION EXCEPTION EQUAL EOF ENSURES END ELSE DOWNTO DOTDOT DONE DO DIVERGES CONSTANT COMMA COLON COINDUCTIVE CLONE BARBAR BAR AXIOM AMPAMP ALIAS
follow(assertion_kind) = LEFTBRC
follow(anon_binder) = WRITES WITH VARIANT VAL USE UNDERSCORE UIDENT TYPE SCOPE RIGHTPAR RETURNS REQUIRES READS RANGE RAISES QUOTE_LIDENT PREDICATE META LIDENT LET LEMMA LEFTSQ LEFTPAR LEFTBRC INVARIANT INDUCTIVE IN IMPORT GOAL FUNCTION FLOAT EXCEPTION EQUAL EOF ENSURES END DOT DIVERGES CORE_UIDENT CORE_LIDENT CONSTANT COMMA COLON COINDUCTIVE CLONE BY BAR AXIOM ARROW ALIAS
follow(alias) = RIGHTBRC COMMA
follow(abstract) = UIDENT RANGE QUOTE_LIDENT MUTABLE LIDENT LEFTPAR LEFTBRC FLOAT CORE_UIDENT CORE_LIDENT BAR
Built an LR(0) automaton with 1190 states.
The grammar is not SLR(1) -- 90 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 1199 states.
720 shift/reduce conflicts were silently solved.
490 out of 1199 states have a default reduction.
494 out of 1199 states are represented.
176 out of 384 symbols keep track of their start position.
225 out of 384 symbols keep track of their end position.
315 out of 656 productions exploit shiftreduce optimization.
0 out of 1199 states can peek at an error.
3322 functions before inlining, 440 functions after inlining.
