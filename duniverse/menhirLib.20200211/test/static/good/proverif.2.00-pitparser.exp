Grammar has 74 nonterminal symbols, among which 5 start symbols.
Grammar has 85 terminal symbols.
Grammar has 288 productions.
nullable(typeoptlist) = false
nullable(typeoptions) = true
nullable(typeopt) = false
nullable(typeidseq) = true
nullable(typeid) = false
nullable(treducotherwise) = false
nullable(treducmayfail) = false
nullable(treduc) = false
nullable(tqueryseq) = false
nullable(tquery) = false
nullable(tprocess) = false
nullable(tpatternseq) = true
nullable(tpattern) = false
nullable(tfnebindingseq) = false
nullable(termseq) = true
nullable(term) = false
nullable(tclauses) = false
nullable(tclause) = false
nullable(tag) = false
nullable(stringlistne) = false
nullable(ptermseq) = true
nullable(pterm) = false
nullable(prooftoken) = false
nullable(proofcommand) = false
nullable(proof) = false
nullable(programoptions) = true
nullable(progoptlist) = false
nullable(progopt) = false
nullable(progend) = true
nullable(progbegin) = false
nullable(permut) = true
nullable(order) = false
nullable(opttprocess) = true
nullable(optpublicvars) = true
nullable(optphase) = true
nullable(options) = true
nullable(optint) = true
nullable(optinprocess) = true
nullable(optelseprocess) = true
nullable(onepermut) = false
nullable(niseq) = false
nullable(ni) = false
nullable(newarg) = true
nullable(nevartype) = false
nullable(netypeidseq) = false
nullable(netermseq) = false
nullable(nesbindingseq) = false
nullable(neptermseq) = false
nullable(nepatternseq) = false
nullable(nemayfailvartypeseq) = false
nullable(neidentseq) = false
nullable(negtermseq) = false
nullable(negformatseq) = false
nullable(mayfailvartypeseq) = true
nullable(mayfailvartype) = false
nullable(lib) = true
nullable(impllist) = false
nullable(impl) = false
nullable(gtermseq) = true
nullable(gterm) = false
nullable(gformatseq) = true
nullable(gformat) = false
nullable(funoptlist) = false
nullable(funopt) = false
nullable(functionoptions) = true
nullable(forallvartype) = true
nullable(forallmayfailvartype) = true
nullable(fnesbindingseq) = false
nullable(fbindingseq) = true
nullable(eqlist) = false
nullable(cvtypeid) = false
nullable(bindingseq) = true
nullable(basicpattern) = false
nullable(all) = false
first(typeoptlist) = PREDICATE IDENT
first(typeoptions) = LBRACKET
first(typeopt) = PREDICATE IDENT
first(typeidseq) = IDENT CHANNEL
first(typeid) = IDENT CHANNEL
first(treducotherwise) = OTHERWISE
first(treducmayfail) = PROJECTION NOT LPAREN IDENT FORALL FAIL CHOICE
first(treduc) = PROJECTION NOT LPAREN IDENT FORALL FAIL CHOICE
first(tqueryseq) = TABLE SECRET PUTBEGIN NOT NEW LPAREN LET INJEVENT IDENT EVENT CHOICE
first(tquery) = TABLE SECRET PUTBEGIN NOT NEW LPAREN LET INJEVENT IDENT EVENT CHOICE
first(tprocess) = YIELD REPL PHASE OUT NEW LPAREN LET INT INSERT IN IF IDENT GET FOREACH EVENT BARRIER
first(tpatternseq) = LPAREN IDENT EQUAL
first(tpattern) = LPAREN IDENT EQUAL
first(tfnebindingseq) = TABLE LET IDENT
first(termseq) = PROJECTION NOT LPAREN IDENT FAIL CHOICE
first(term) = PROJECTION NOT LPAREN IDENT FAIL CHOICE
first(tclauses) = PROJECTION NOT LPAREN IDENT FORALL FAIL CHOICE
first(tclause) = PROJECTION NOT LPAREN IDENT FAIL CHOICE
first(tag) = IDENT ATIDENT
first(stringlistne) = STRING
first(ptermseq) = NOT NEW LPAREN LET INSERT IF IDENT GET EVENT CHOICE
first(pterm) = NOT NEW LPAREN LET INSERT IF IDENT GET EVENT CHOICE
first(prooftoken) = STRING STAR SET RPAREN LPAREN INT INSERT IDENT EQUAL DOT COMMA
first(proofcommand) = STRING STAR SET RPAREN LPAREN INT INSERT IDENT EQUAL DOT COMMA
first(proof) = STRING STAR SET RPAREN LPAREN INT INSERT IDENT EQUAL DOT COMMA
first(programoptions) = LBRACKET
first(progoptlist) = IDENT
first(progopt) = IDENT
first(progend) = RBRACE
first(progbegin) = IDENT
first(permut) = IDENT ATIDENT
first(order) = IDENT
first(opttprocess) = SEMI
first(optpublicvars) = PUBLICVARS
first(optphase) = PHASE
first(options) = LBRACKET
first(optint) = SLASH
first(optinprocess) = IN
first(optelseprocess) = ELSE
first(onepermut) = IDENT ATIDENT
first(niseq) = IDENT
first(ni) = IDENT
first(newarg) = LBRACKET
first(nevartype) = IDENT
first(netypeidseq) = IDENT CHANNEL
first(netermseq) = PROJECTION NOT LPAREN IDENT FAIL CHOICE
first(nesbindingseq) = REPL IDENT
first(neptermseq) = NOT NEW LPAREN LET INSERT IF IDENT GET EVENT CHOICE
first(nepatternseq) = LPAREN IDENT EQUAL
first(nemayfailvartypeseq) = IDENT
first(neidentseq) = IDENT
first(negtermseq) = TABLE NOT NEW LPAREN LET INJEVENT IDENT EVENT CHOICE
first(negformatseq) = STAR NEW LPAREN LET IDENT CHOICE
first(mayfailvartypeseq) = IDENT
first(mayfailvartype) = IDENT
first(lib) = WEAKSECRET TYPE TABLE SET REDUCTION QUERY PROOF PROBA PREDICATE PARAM NOUNIF NOT NONINTERF LETFUN LET IMPLEMENTATION FUN FREE EXPAND EVENT EQUATION ELIMTRUE DEFINE CONST CLAUSES CHANNEL
first(impllist) = TYPE TABLE FUN CONST
first(impl) = TYPE TABLE FUN CONST
first(gtermseq) = TABLE NOT NEW LPAREN LET INJEVENT IDENT EVENT CHOICE
first(gterm) = TABLE NOT NEW LPAREN LET INJEVENT IDENT EVENT CHOICE
first(gformatseq) = STAR NEW LPAREN LET IDENT CHOICE
first(gformat) = STAR NEW LPAREN LET IDENT CHOICE
first(funoptlist) = IDENT
first(funopt) = IDENT
first(functionoptions) = LBRACKET
first(forallvartype) = FORALL
first(forallmayfailvartype) = FORALL
first(fnesbindingseq) = REPL IDENT
first(fbindingseq) = REPL IDENT
first(eqlist) = PROJECTION NOT LPAREN IDENT FORALL FAIL CHOICE
first(cvtypeid) = STRING INT
first(bindingseq) = REPL IDENT
first(basicpattern) = IDENT
first(all) = WEAKSECRET TYPE TABLE SET REDUCTION QUERY PROOF PROCESS PROBA PREDICATE PARAM NOUNIF NOT NONINTERF LETFUN LET IMPLEMENTATION FUN FREE EXPAND EVENT EQUIVALENCE EQUATION ELIMTRUE DEFINE CONST CLAUSES CHANNEL
minimal(typeoptlist) = (* 3 *) IDENT EQUAL STRING
minimal(typeoptions) = (* 0 *) 
minimal(typeopt) = (* 3 *) IDENT EQUAL STRING
minimal(typeidseq) = (* 0 *) 
minimal(typeid) = (* 1 *) IDENT
minimal(treducotherwise) = (* 4 *) OTHERWISE FAIL EQUAL FAIL
minimal(treducmayfail) = (* 3 *) FAIL EQUAL FAIL
minimal(treduc) = (* 3 *) FAIL EQUAL FAIL
minimal(tqueryseq) = (* 1 *) IDENT
minimal(tquery) = (* 1 *) IDENT
minimal(tprocess) = (* 1 *) IDENT
minimal(tpatternseq) = (* 0 *) 
minimal(tpattern) = (* 1 *) IDENT
minimal(tfnebindingseq) = (* 1 *) IDENT
minimal(termseq) = (* 0 *) 
minimal(term) = (* 1 *) FAIL
minimal(tclauses) = (* 2 *) FAIL DOT
minimal(tclause) = (* 1 *) FAIL
minimal(tag) = (* 1 *) IDENT
minimal(stringlistne) = (* 1 *) STRING
minimal(ptermseq) = (* 0 *) 
minimal(pterm) = (* 1 *) IDENT
minimal(prooftoken) = (* 1 *) IDENT
minimal(proofcommand) = (* 1 *) IDENT
minimal(proof) = (* 1 *) IDENT
minimal(programoptions) = (* 0 *) 
minimal(progoptlist) = (* 3 *) IDENT GREATER IDENT
minimal(progopt) = (* 3 *) IDENT GREATER IDENT
minimal(progend) = (* 0 *) 
minimal(progbegin) = (* 2 *) IDENT LBRACE
minimal(permut) = (* 0 *) 
minimal(order) = (* 1 *) IDENT
minimal(opttprocess) = (* 0 *) 
minimal(optpublicvars) = (* 0 *) 
minimal(optphase) = (* 0 *) 
minimal(options) = (* 0 *) 
minimal(optint) = (* 0 *) 
minimal(optinprocess) = (* 0 *) 
minimal(optelseprocess) = (* 0 *) 
minimal(onepermut) = (* 3 *) IDENT RED IDENT
minimal(niseq) = (* 1 *) IDENT
minimal(ni) = (* 1 *) IDENT
minimal(newarg) = (* 0 *) 
minimal(nevartype) = (* 3 *) IDENT COLON IDENT
minimal(netypeidseq) = (* 1 *) IDENT
minimal(netermseq) = (* 1 *) FAIL
minimal(nesbindingseq) = (* 3 *) IDENT EQUAL IDENT
minimal(neptermseq) = (* 1 *) IDENT
minimal(nepatternseq) = (* 1 *) IDENT
minimal(nemayfailvartypeseq) = (* 3 *) IDENT COLON IDENT
minimal(neidentseq) = (* 1 *) IDENT
minimal(negtermseq) = (* 1 *) IDENT
minimal(negformatseq) = (* 1 *) IDENT
minimal(mayfailvartypeseq) = (* 0 *) 
minimal(mayfailvartype) = (* 3 *) IDENT COLON IDENT
minimal(lib) = (* 0 *) 
minimal(impllist) = (* 4 *) TYPE IDENT EQUAL INT
minimal(impl) = (* 4 *) TYPE IDENT EQUAL INT
minimal(gtermseq) = (* 0 *) 
minimal(gterm) = (* 1 *) IDENT
minimal(gformatseq) = (* 0 *) 
minimal(gformat) = (* 1 *) IDENT
minimal(funoptlist) = (* 3 *) IDENT EQUAL STRING
minimal(funopt) = (* 3 *) IDENT EQUAL STRING
minimal(functionoptions) = (* 0 *) 
minimal(forallvartype) = (* 0 *) 
minimal(forallmayfailvartype) = (* 0 *) 
minimal(fnesbindingseq) = (* 3 *) IDENT EQUAL IDENT
minimal(fbindingseq) = (* 0 *) 
minimal(eqlist) = (* 1 *) FAIL
minimal(cvtypeid) = (* 1 *) INT
minimal(bindingseq) = (* 0 *) 
minimal(basicpattern) = (* 1 *) IDENT
minimal(all) = (* 3 *) PROCESS IDENT EOF
follow(typeoptlist) = RBRACKET
follow(typeoptions) = SEMI DOT
follow(typeopt) = SEMI RBRACKET
follow(typeidseq) = RPAREN
follow(typeid) = YIELD SUCHTHAT SEMI RPAREN REPL REDUCTION PHASE OUT ORTEXT NEW LPAREN LET LEFTARROW LBRACKET INT INSERT IN IF IDENT GET FOREACH EVENT EQUAL EOF ELSE DOT COMMA BARRIER BAR
follow(treducotherwise) = LBRACKET DOT
follow(treducmayfail) = LBRACKET DOT
follow(treduc) = LBRACKET DOT
follow(tqueryseq) = DOT
follow(tquery) = SEMI DOT
follow(tprocess) = YIELD RPAREN REPL PHASE OUT NEW LPAREN LET INT INSERT IN IF IDENT GET FOREACH EVENT EOF ELSE DOT BARRIER BAR
follow(tpatternseq) = RPAREN
follow(tpattern) = RPAREN EQUAL COMMA
follow(tfnebindingseq) = DOT
follow(termseq) = RPAREN
follow(term) = WEDGE SEMI RPAREN RED RBRACKET OTHERWISE OR LBRACKET EQUIVEQ EQUIV EQUAL DOT DIFF COMMA #
follow(tclauses) = WEAKSECRET TYPE TABLE SET REDUCTION RBRACE QUERY PROOF PROCESS PROBA PREDICATE PARAM NOUNIF NOT NONINTERF LETFUN LET IMPLEMENTATION FUN FREE EXPAND EVENT EQUIVALENCE EQUATION ELIMTRUE DEFINE CONST CLAUSES CHANNEL #
follow(tclause) = SEMI DOT
follow(tag) = SEMI RED #
follow(stringlistne) = SEMI RBRACKET
follow(ptermseq) = RPAREN
follow(pterm) = YIELD WEDGE THEN SEMI RPAREN REPL RBRACKET PHASE OUT OR NEW LPAREN LET INT INSERT IN IF IDENT GET FOREACH EVENT EQUAL EOF ELSE DOT DIFF COMMA BARRIER BAR
follow(prooftoken) = STRING STAR SET SEMI RPAREN RBRACE LPAREN INT INSERT IDENT EQUAL DOT COMMA
follow(proofcommand) = SEMI RBRACE
follow(proof) = RBRACE
follow(programoptions) = LBRACE
follow(progoptlist) = RBRACKET
follow(progopt) = RBRACKET COMMA
follow(progend) = YIELD SEMI RPAREN REPL PHASE OUT NEW LPAREN LET INT INSERT IN IF IDENT GET FOREACH EVENT EOF ELSE DOT BARRIER BAR
follow(progbegin) = YIELD REPL PHASE OUT NEW LPAREN LET INT INSERT IN IF IDENT GET FOREACH EVENT BARRIER
follow(permut) = #
follow(order) = #
follow(opttprocess) = YIELD RPAREN REPL PHASE OUT NEW LPAREN LET INT INSERT IN IF IDENT GET FOREACH EVENT EOF ELSE DOT BARRIER BAR
follow(optpublicvars) = SEMI LBRACKET DOT
follow(optphase) = SLASH DOT
follow(options) = SEMI DOT
follow(optint) = DOT
follow(optinprocess) = YIELD RPAREN REPL PHASE OUT NEW LPAREN LET INT INSERT IN IF IDENT GET FOREACH EVENT EOF ELSE DOT BARRIER BAR
follow(optelseprocess) = YIELD RPAREN REPL PHASE OUT NEW LPAREN LET INT INSERT IN IF IDENT GET FOREACH EVENT EOF ELSE DOT BARRIER BAR
follow(onepermut) = SEMI #
follow(niseq) = DOT
follow(ni) = DOT COMMA
follow(newarg) = YIELD SEMI RPAREN REPL PHASE OUT NEW LPAREN LET INT INSERT IN IF IDENT GET FOREACH EVENT EOF ELSE DOT COLON BARRIER BAR
follow(nevartype) = SUCHTHAT SEMI
follow(netypeidseq) = RPAREN
follow(netermseq) = RPAREN
follow(nesbindingseq) = RBRACKET
follow(neptermseq) = RPAREN
follow(nepatternseq) = RPAREN
follow(nemayfailvartypeseq) = SEMI RPAREN
follow(neidentseq) = SEMI RBRACKET LBRACKET DOT COLON
follow(negtermseq) = RPAREN
follow(negformatseq) = RPAREN
follow(mayfailvartypeseq) = RPAREN
follow(mayfailvartype) = SEMI RPAREN COMMA
follow(lib) = RBRACE PROCESS EQUIVALENCE #
follow(impllist) = DOT
follow(impl) = SEMI DOT
follow(gtermseq) = RPAREN
follow(gterm) = WEDGE SEMI RPAREN RBRACKET PUBLICVARS OR IN EQUAL DOT DIFF COMMA BEFORE
follow(gformatseq) = RPAREN
follow(gformat) = SEMI RPAREN RBRACKET IN COMMA
follow(funoptlist) = RBRACKET
follow(funopt) = SEMI RBRACKET
follow(functionoptions) = SEMI DOT
follow(forallvartype) = PROJECTION NOT LPAREN IDENT FAIL CHOICE
follow(forallmayfailvartype) = PROJECTION NOT LPAREN IDENT FAIL CHOICE
follow(fnesbindingseq) = RBRACKET
follow(fbindingseq) = RBRACKET
follow(eqlist) = LBRACKET DOT
follow(cvtypeid) = SEMI LBRACKET DOT
follow(bindingseq) = RBRACKET
follow(basicpattern) = RPAREN LEFTARROW EQUAL COMMA
follow(all) = #
Built an LR(0) automaton with 805 states.
The grammar is not SLR(1) -- 57 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 1004 states.
74 shift/reduce conflicts were silently solved.
Warning: 34 states have shift/reduce conflicts.
Warning: 94 shift/reduce conflicts were arbitrarily resolved.
Warning: 61 states have an end-of-stream conflict.
File "proverif.2.00-pitparser.mly", line 414, characters 0-4:
Warning: symbol term is never accepted.
File "proverif.2.00-pitparser.mly", line 969, characters 4-9:
Warning: production order -> IDENT is never reduced.
File "proverif.2.00-pitparser.mly", line 954, characters 7-7:
Warning: production permut -> is never reduced.
File "proverif.2.00-pitparser.mly", line 957, characters 4-13:
Warning: production permut -> onepermut is never reduced.
Warning: in total, 4 productions are never reduced.
222 out of 1004 states have a default reduction.
476 out of 1004 states are represented.
0 out of 166 symbols keep track of their start position.
0 out of 166 symbols keep track of their end position.
118 out of 293 productions exploit shiftreduce optimization.
0 out of 1004 states can peek at an error.
2381 functions before inlining, 327 functions after inlining.
