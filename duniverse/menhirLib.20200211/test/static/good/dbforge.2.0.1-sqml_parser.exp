File "dbforge.2.0.1-sqml_parser.mly", line 43, characters 67-75:
Warning: the token FLOATNUM is unused.
Grammar has 105 nonterminal symbols, among which 5 start symbols.
Grammar has 109 terminal symbols.
Grammar has 250 productions.
nullable(where_clause) = false
nullable(when_action) = false
nullable(view_def) = false
nullable(values_or_select_exp) = false
nullable(user) = false
nullable(update_statement_searched) = false
nullable(update_statement_positioned) = false
nullable(ugly_eof) = false
nullable(test_for_null) = false
nullable(target_commalist) = false
nullable(target) = false
nullable(table_ref) = false
nullable(table_exp) = false
nullable(table_constraint_def) = false
nullable(table) = false
nullable(sqlmodule) = false
nullable(sql_cmd_list) = false
nullable(selection) = false
nullable(select_statement) = false
nullable(select_exp) = false
nullable(search_condition) = false
nullable(schema_element) = false
nullable(schema) = false
nullable(scalar_exp) = false
nullable(rollback_statement) = false
nullable(rev_table_ref_commalist) = false
nullable(rev_schema_element_list) = false
nullable(rev_scalar_exp_commalist) = false
nullable(rev_insert_atom_commalist) = false
nullable(rev_column_ref_commalist) = false
nullable(rev_atom_commalist) = false
nullable(query_term) = false
nullable(query_exp) = false
nullable(query) = false
nullable(procedure_def_list) = false
nullable(procedure_def) = false
nullable(procedure) = false
nullable(privileges) = false
nullable(privilege_def) = false
nullable(predicate) = false
nullable(parameter_ref) = false
nullable(parameter_def_list) = false
nullable(parameter_def) = false
nullable(parameter) = false
nullable(ordering_spec_commalist) = false
nullable(ordering_spec) = false
nullable(opt_with_grant_option) = true
nullable(opt_with_check_option) = true
nullable(opt_where_clause) = true
nullable(opt_schema_element_list) = true
nullable(opt_order_by_clause) = true
nullable(opt_module) = true
nullable(opt_having_clause) = true
nullable(opt_group_by_clause) = true
nullable(opt_escape) = true
nullable(opt_cursor_def_list) = true
nullable(opt_column_commalist) = true
nullable(opt_asc_desc) = true
nullable(opt_all_distinct) = true
nullable(operation_commalist) = false
nullable(operation) = false
nullable(open_statement) = false
nullable(module_def) = false
nullable(manipulative_statement_list) = false
nullable(manipulative_statement) = false
nullable(literal) = false
nullable(like_predicate) = false
nullable(lang) = false
nullable(insert_statement) = false
nullable(insert_atom) = false
nullable(in_predicate) = false
nullable(grantee_commalist) = false
nullable(grantee) = false
nullable(function_ref) = false
nullable(full_select) = false
nullable(from_clause) = false
nullable(fetch_statement) = false
nullable(existence_test) = false
nullable(endsql) = false
nullable(delete_statement_searched) = false
nullable(delete_statement_positioned) = false
nullable(data_type) = false
nullable(cursor_def_list) = false
nullable(cursor_def) = false
nullable(cursor) = false
nullable(comparison_predicate) = false
nullable(commit_statement) = false
nullable(column_ref) = false
nullable(column_def_opt_list) = true
nullable(column_def_opt) = false
nullable(column_def) = false
nullable(column_commalist) = false
nullable(column) = false
nullable(cmd) = false
nullable(close_statement) = false
nullable(between_predicate) = false
nullable(base_table_element_commalist) = false
nullable(base_table_element) = false
nullable(base_table_def) = false
nullable(atom) = false
nullable(assignment_commalist) = false
nullable(assignment) = false
nullable(any_all_some) = false
nullable(ammsc) = false
nullable(all_or_any_predicate) = false
first(where_clause) = WHERE
first(when_action) = GOTO CONTINUE
first(view_def) = CREATE
first(values_or_select_exp) = VALUES SELECT
first(user) = IDENT
first(update_statement_searched) = UPDATE
first(update_statement_positioned) = UPDATE
first(ugly_eof) = EOF
first(test_for_null) = IDENT
first(target_commalist) = COLON
first(target) = COLON
first(table_ref) = IDENT
first(table_exp) = FROM
first(table_constraint_def) = UNIQUE PRIMARY FOREIGN CHECK
first(table) = IDENT
first(sqlmodule) = IDENT
first(sql_cmd_list) = WHENEVER UPDATE SELECT ROLLBACK OPEN MODULE INSERT GRANT FETCH DELETE CREATE COMMIT CLOSE
first(selection) = USER TIMES SUM STRING PLUS MINUS MIN MAX LPAREN INTNUM IDENT COUNT COLON AVG
first(select_statement) = SELECT
first(select_exp) = SELECT
first(search_condition) = USER SUM STRING PLUS NOT MINUS MIN MAX LPAREN INTNUM IDENT EXISTS COUNT COLON AVG
first(schema_element) = GRANT CREATE
first(schema) = CREATE
first(scalar_exp) = USER SUM STRING PLUS MINUS MIN MAX LPAREN INTNUM IDENT COUNT COLON AVG
first(rollback_statement) = ROLLBACK
first(rev_table_ref_commalist) = IDENT
first(rev_schema_element_list) = GRANT CREATE
first(rev_scalar_exp_commalist) = USER SUM STRING PLUS MINUS MIN MAX LPAREN INTNUM IDENT COUNT COLON AVG
first(rev_insert_atom_commalist) = USER STRING NULL INTNUM COLON
first(rev_column_ref_commalist) = IDENT
first(rev_atom_commalist) = USER STRING INTNUM COLON
first(query_term) = SELECT LPAREN
first(query_exp) = SELECT LPAREN
first(query) = SELECT LPAREN
first(procedure_def_list) = PROCEDURE
first(procedure_def) = PROCEDURE
first(procedure) = IDENT
first(privileges) = UPDATE SELECT REFERENCES INSERT DELETE ALL
first(privilege_def) = GRANT
first(predicate) = USER SUM STRING PLUS MINUS MIN MAX LPAREN INTNUM IDENT EXISTS COUNT COLON AVG
first(parameter_ref) = COLON
first(parameter_def_list) = SQLCODE COLON
first(parameter_def) = SQLCODE COLON
first(parameter) = COLON
first(ordering_spec_commalist) = INTNUM IDENT
first(ordering_spec) = INTNUM IDENT
first(opt_with_grant_option) = WITH
first(opt_with_check_option) = WITH
first(opt_where_clause) = WHERE
first(opt_schema_element_list) = GRANT CREATE
first(opt_order_by_clause) = ORDER
first(opt_module) = IDENT
first(opt_having_clause) = HAVING
first(opt_group_by_clause) = GROUP
first(opt_escape) = ESCAPE
first(opt_cursor_def_list) = DECLARE
first(opt_column_commalist) = LPAREN
first(opt_asc_desc) = DESC ASC
first(opt_all_distinct) = DISTINCT ALL
first(operation_commalist) = UPDATE SELECT REFERENCES INSERT DELETE
first(operation) = UPDATE SELECT REFERENCES INSERT DELETE
first(open_statement) = OPEN
first(module_def) = MODULE
first(manipulative_statement_list) = UPDATE SELECT ROLLBACK OPEN INSERT FETCH DELETE COMMIT CLOSE
first(manipulative_statement) = UPDATE SELECT ROLLBACK OPEN INSERT FETCH DELETE COMMIT CLOSE
first(literal) = STRING INTNUM
first(like_predicate) = USER SUM STRING PLUS MINUS MIN MAX LPAREN INTNUM IDENT COUNT COLON AVG
first(lang) = PLI PASCAL OCAML FORTRAN COBOL C ADA
first(insert_statement) = INSERT
first(insert_atom) = USER STRING NULL INTNUM COLON
first(in_predicate) = USER SUM STRING PLUS MINUS MIN MAX LPAREN INTNUM IDENT COUNT COLON AVG
first(grantee_commalist) = PUBLIC IDENT
first(grantee) = PUBLIC IDENT
first(function_ref) = SUM MIN MAX IDENT COUNT AVG
first(full_select) = SELECT
first(from_clause) = FROM
first(fetch_statement) = FETCH
first(existence_test) = EXISTS
first(endsql) = SEMICOLON EOF
first(delete_statement_searched) = DELETE
first(delete_statement_positioned) = DELETE
first(data_type) = SMALLINT REAL NUMERIC INTEGER FLOAT DOUBLE DECIMAL CHARACTER
first(cursor_def_list) = DECLARE
first(cursor_def) = DECLARE
first(cursor) = IDENT
first(comparison_predicate) = USER SUM STRING PLUS MINUS MIN MAX LPAREN INTNUM IDENT COUNT COLON AVG
first(commit_statement) = COMMIT
first(column_ref) = IDENT
first(column_def_opt_list) = REFERENCES NOT DEFAULT CHECK
first(column_def_opt) = REFERENCES NOT DEFAULT CHECK
first(column_def) = IDENT
first(column_commalist) = IDENT
first(column) = IDENT
first(cmd) = WHENEVER UPDATE SELECT ROLLBACK OPEN MODULE INSERT GRANT FETCH DELETE CREATE COMMIT CLOSE
first(close_statement) = CLOSE
first(between_predicate) = USER SUM STRING PLUS MINUS MIN MAX LPAREN INTNUM IDENT COUNT COLON AVG
first(base_table_element_commalist) = UNIQUE PRIMARY IDENT FOREIGN CHECK
first(base_table_element) = UNIQUE PRIMARY IDENT FOREIGN CHECK
first(base_table_def) = CREATE
first(atom) = USER STRING INTNUM COLON
first(assignment_commalist) = IDENT
first(assignment) = IDENT
first(any_all_some) = SOME ANY ALL
first(ammsc) = SUM MIN MAX IDENT COUNT AVG
first(all_or_any_predicate) = USER SUM STRING PLUS MINUS MIN MAX LPAREN INTNUM IDENT COUNT COLON AVG
minimal(where_clause) = (* 4 *) WHERE STRING COMPARISON STRING
minimal(when_action) = (* 1 *) CONTINUE
minimal(view_def) = (* 8 *) CREATE VIEW IDENT AS SELECT STRING FROM IDENT
minimal(values_or_select_exp) = (* 4 *) VALUES LPAREN STRING RPAREN
minimal(user) = (* 1 *) IDENT
minimal(update_statement_searched) = (* 6 *) UPDATE IDENT SET IDENT COMPARISON STRING
minimal(update_statement_positioned) = (* 10 *) UPDATE IDENT SET IDENT COMPARISON STRING WHERE CURRENT OF IDENT
minimal(ugly_eof) = (* 1 *) EOF
minimal(test_for_null) = (* 3 *) IDENT IS NULL
minimal(target_commalist) = (* 2 *) COLON IDENT
minimal(target) = (* 2 *) COLON IDENT
minimal(table_ref) = (* 1 *) IDENT
minimal(table_exp) = (* 2 *) FROM IDENT
minimal(table_constraint_def) = (* 4 *) UNIQUE LPAREN IDENT RPAREN
minimal(table) = (* 1 *) IDENT
minimal(sqlmodule) = (* 1 *) IDENT
minimal(sql_cmd_list) = (* 3 *) CLOSE IDENT EOF
minimal(selection) = (* 1 *) STRING
minimal(select_statement) = (* 7 *) SELECT STRING INTO COLON IDENT FROM IDENT
minimal(select_exp) = (* 4 *) SELECT STRING FROM IDENT
minimal(search_condition) = (* 3 *) STRING COMPARISON STRING
minimal(schema_element) = (* 6 *) GRANT ALL ON IDENT TO PUBLIC
minimal(schema) = (* 4 *) CREATE SCHEMA AUTHORIZATION IDENT
minimal(scalar_exp) = (* 1 *) STRING
minimal(rollback_statement) = (* 2 *) ROLLBACK WORK
minimal(rev_table_ref_commalist) = (* 1 *) IDENT
minimal(rev_schema_element_list) = (* 6 *) GRANT ALL ON IDENT TO PUBLIC
minimal(rev_scalar_exp_commalist) = (* 1 *) STRING
minimal(rev_insert_atom_commalist) = (* 1 *) STRING
minimal(rev_column_ref_commalist) = (* 1 *) IDENT
minimal(rev_atom_commalist) = (* 1 *) STRING
minimal(query_term) = (* 4 *) SELECT STRING FROM IDENT
minimal(query_exp) = (* 4 *) SELECT STRING FROM IDENT
minimal(query) = (* 5 *) SELECT STRING FROM IDENT EOF
minimal(procedure_def_list) = (* 6 *) PROCEDURE IDENT SQLCODE SEMICOLON CLOSE IDENT
minimal(procedure_def) = (* 6 *) PROCEDURE IDENT SQLCODE SEMICOLON CLOSE IDENT
minimal(procedure) = (* 1 *) IDENT
minimal(privileges) = (* 1 *) ALL
minimal(privilege_def) = (* 6 *) GRANT ALL ON IDENT TO PUBLIC
minimal(predicate) = (* 3 *) STRING COMPARISON STRING
minimal(parameter_ref) = (* 2 *) COLON IDENT
minimal(parameter_def_list) = (* 1 *) SQLCODE
minimal(parameter_def) = (* 1 *) SQLCODE
minimal(parameter) = (* 2 *) COLON IDENT
minimal(ordering_spec_commalist) = (* 1 *) INTNUM
minimal(ordering_spec) = (* 1 *) INTNUM
minimal(opt_with_grant_option) = (* 0 *) 
minimal(opt_with_check_option) = (* 0 *) 
minimal(opt_where_clause) = (* 0 *) 
minimal(opt_schema_element_list) = (* 0 *) 
minimal(opt_order_by_clause) = (* 0 *) 
minimal(opt_module) = (* 0 *) 
minimal(opt_having_clause) = (* 0 *) 
minimal(opt_group_by_clause) = (* 0 *) 
minimal(opt_escape) = (* 0 *) 
minimal(opt_cursor_def_list) = (* 0 *) 
minimal(opt_column_commalist) = (* 0 *) 
minimal(opt_asc_desc) = (* 0 *) 
minimal(opt_all_distinct) = (* 0 *) 
minimal(operation_commalist) = (* 1 *) SELECT
minimal(operation) = (* 1 *) SELECT
minimal(open_statement) = (* 2 *) OPEN IDENT
minimal(module_def) = (* 11 *) MODULE LANGUAGE COBOL AUTHORIZATION IDENT PROCEDURE IDENT SQLCODE SEMICOLON CLOSE IDENT
minimal(manipulative_statement_list) = (* 2 *) CLOSE IDENT
minimal(manipulative_statement) = (* 2 *) CLOSE IDENT
minimal(literal) = (* 1 *) STRING
minimal(like_predicate) = (* 3 *) STRING LIKE STRING
minimal(lang) = (* 1 *) COBOL
minimal(insert_statement) = (* 7 *) INSERT INTO IDENT VALUES LPAREN STRING RPAREN
minimal(insert_atom) = (* 1 *) STRING
minimal(in_predicate) = (* 5 *) STRING IN LPAREN STRING RPAREN
minimal(grantee_commalist) = (* 1 *) PUBLIC
minimal(grantee) = (* 1 *) PUBLIC
minimal(function_ref) = (* 4 *) AVG LPAREN TIMES RPAREN
minimal(full_select) = (* 5 *) SELECT STRING FROM IDENT EOF
minimal(from_clause) = (* 2 *) FROM IDENT
minimal(fetch_statement) = (* 5 *) FETCH IDENT INTO COLON IDENT
minimal(existence_test) = (* 7 *) EXISTS LPAREN SELECT STRING FROM IDENT RPAREN
minimal(endsql) = (* 1 *) EOF
minimal(delete_statement_searched) = (* 3 *) DELETE FROM IDENT
minimal(delete_statement_positioned) = (* 7 *) DELETE FROM IDENT WHERE CURRENT OF IDENT
minimal(data_type) = (* 1 *) CHARACTER
minimal(cursor_def_list) = (* 8 *) DECLARE IDENT CURSOR FOR SELECT STRING FROM IDENT
minimal(cursor_def) = (* 8 *) DECLARE IDENT CURSOR FOR SELECT STRING FROM IDENT
minimal(cursor) = (* 1 *) IDENT
minimal(comparison_predicate) = (* 3 *) STRING COMPARISON STRING
minimal(commit_statement) = (* 2 *) COMMIT WORK
minimal(column_ref) = (* 1 *) IDENT
minimal(column_def_opt_list) = (* 0 *) 
minimal(column_def_opt) = (* 2 *) NOT NULL
minimal(column_def) = (* 2 *) IDENT CHARACTER
minimal(column_commalist) = (* 1 *) IDENT
minimal(column) = (* 1 *) IDENT
minimal(cmd) = (* 2 *) CLOSE IDENT
minimal(close_statement) = (* 2 *) CLOSE IDENT
minimal(between_predicate) = (* 5 *) STRING BETWEEN STRING AND STRING
minimal(base_table_element_commalist) = (* 2 *) IDENT CHARACTER
minimal(base_table_element) = (* 2 *) IDENT CHARACTER
minimal(base_table_def) = (* 7 *) CREATE TABLE IDENT LPAREN IDENT CHARACTER RPAREN
minimal(atom) = (* 1 *) STRING
minimal(assignment_commalist) = (* 3 *) IDENT COMPARISON STRING
minimal(assignment) = (* 3 *) IDENT COMPARISON STRING
minimal(any_all_some) = (* 1 *) ANY
minimal(ammsc) = (* 1 *) AVG
minimal(all_or_any_predicate) = (* 9 *) STRING COMPARISON ANY LPAREN SELECT STRING FROM IDENT RPAREN
follow(where_clause) = WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE #
follow(when_action) = SEMICOLON EOF #
follow(view_def) = SEMICOLON GRANT EOF CREATE #
follow(values_or_select_exp) = UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE #
follow(user) = WITH SEMICOLON PROCEDURE GRANT EOF DECLARE CREATE COMMA #
follow(update_statement_searched) = UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE #
follow(update_statement_positioned) = UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE #
follow(ugly_eof) = #
follow(test_for_null) = WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND #
follow(target_commalist) = UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FROM FETCH EOF DELETE COMMIT COMMA CLOSE #
follow(target) = UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FROM FETCH EOF DELETE COMMIT COMMA CLOSE #
follow(table_ref) = WITH WHERE UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT COMMA CLOSE #
follow(table_exp) = WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE #
follow(table_constraint_def) = RPAREN COMMA
follow(table) = WITH WHERE VALUES UPDATE UNION TO SET SEMICOLON SELECT RPAREN ROLLBACK REFERENCES PROCEDURE ORDER OPEN NOT LPAREN INSERT HAVING GROUP GRANT FETCH EOF DELETE DEFAULT DECLARE CREATE COMMIT COMMA CLOSE CHECK AS #
follow(sqlmodule) = LANGUAGE
follow(sql_cmd_list) = #
follow(selection) = INTO FROM
follow(select_statement) = UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE #
follow(select_exp) = WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE #
follow(search_condition) = WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND #
follow(schema_element) = SEMICOLON GRANT EOF CREATE #
follow(schema) = SEMICOLON EOF #
follow(scalar_exp) = WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND #
follow(rollback_statement) = UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE #
follow(rev_table_ref_commalist) = WITH WHERE UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT COMMA CLOSE #
follow(rev_schema_element_list) = SEMICOLON GRANT EOF CREATE #
follow(rev_scalar_exp_commalist) = INTO FROM COMMA
follow(rev_insert_atom_commalist) = RPAREN COMMA
follow(rev_column_ref_commalist) = WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GRANT FETCH EOF DELETE DECLARE CREATE COMMIT COMMA CLOSE #
follow(rev_atom_commalist) = RPAREN COMMA
follow(query_term) = UNION SEMICOLON RPAREN PROCEDURE ORDER EOF DECLARE
follow(query_exp) = UNION SEMICOLON RPAREN PROCEDURE ORDER EOF DECLARE
follow(query) = #
follow(procedure_def_list) = SEMICOLON PROCEDURE EOF #
follow(procedure_def) = SEMICOLON PROCEDURE EOF #
follow(procedure) = SQLCODE COLON
follow(privileges) = ON
follow(privilege_def) = SEMICOLON GRANT EOF CREATE #
follow(predicate) = WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND #
follow(parameter_ref) = WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH ESCAPE EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND #
follow(parameter_def_list) = SQLCODE SEMICOLON COLON
follow(parameter_def) = SQLCODE SEMICOLON COLON
follow(parameter) = WITH WHERE UPDATE UNION TIMES SMALLINT SEMICOLON SELECT RPAREN ROLLBACK REAL PROCEDURE PLUS ORDER OR OPEN NUMERIC NOT MINUS LIKE INTO INTEGER INSERT INDICATOR IN HAVING GROUP GRANT FROM FLOAT FETCH ESCAPE EOF DOUBLE DIV DELETE DECLARE DECIMAL CREATE COMPARISON COMMIT COMMA COLON CLOSE CHARACTER BETWEEN AND #
follow(ordering_spec_commalist) = SEMICOLON PROCEDURE EOF DECLARE COMMA
follow(ordering_spec) = SEMICOLON PROCEDURE EOF DECLARE COMMA
follow(opt_with_grant_option) = SEMICOLON GRANT EOF CREATE #
follow(opt_with_check_option) = SEMICOLON GRANT EOF CREATE #
follow(opt_where_clause) = WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE #
follow(opt_schema_element_list) = SEMICOLON EOF #
follow(opt_order_by_clause) = SEMICOLON PROCEDURE EOF DECLARE
follow(opt_module) = LANGUAGE
follow(opt_having_clause) = WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE #
follow(opt_group_by_clause) = WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE #
follow(opt_escape) = WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND #
follow(opt_cursor_def_list) = PROCEDURE
follow(opt_column_commalist) = VALUES SELECT ON COMMA AS
follow(opt_asc_desc) = SEMICOLON PROCEDURE EOF DECLARE COMMA
follow(opt_all_distinct) = USER TIMES SUM STRING PLUS MINUS MIN MAX LPAREN INTNUM IDENT COUNT COLON AVG
follow(operation_commalist) = ON COMMA
follow(operation) = ON COMMA
follow(open_statement) = UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE #
follow(module_def) = SEMICOLON EOF #
follow(manipulative_statement_list) = UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE #
follow(manipulative_statement) = UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE #
follow(literal) = WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK REFERENCES PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH ESCAPE EOF DIV DELETE DEFAULT DECLARE CREATE COMPARISON COMMIT COMMA CLOSE CHECK BETWEEN AND #
follow(like_predicate) = WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND #
follow(lang) = AUTHORIZATION
follow(insert_statement) = UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE #
follow(insert_atom) = RPAREN COMMA
follow(in_predicate) = WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND #
follow(grantee_commalist) = WITH SEMICOLON GRANT EOF CREATE COMMA #
follow(grantee) = WITH SEMICOLON GRANT EOF CREATE COMMA #
follow(function_ref) = WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND #
follow(full_select) = #
follow(from_clause) = WITH WHERE UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE #
follow(fetch_statement) = UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE #
follow(existence_test) = WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND #
follow(endsql) = #
follow(delete_statement_searched) = UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE #
follow(delete_statement_positioned) = UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE #
follow(data_type) = SQLCODE SEMICOLON RPAREN REFERENCES NOT DEFAULT COMMA COLON CHECK
follow(cursor_def_list) = PROCEDURE DECLARE
follow(cursor_def) = PROCEDURE DECLARE
follow(cursor) = UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INTO INSERT FETCH EOF DELETE CURSOR COMMIT CLOSE #
follow(comparison_predicate) = WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND #
follow(commit_statement) = UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE #
follow(column_ref) = WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE IS INTO INSERT IN HAVING GROUP GRANT FROM FETCH EOF DIV DESC DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN ASC AND #
follow(column_def_opt_list) = RPAREN REFERENCES NOT DEFAULT COMMA CHECK
follow(column_def_opt) = RPAREN REFERENCES NOT DEFAULT COMMA CHECK
follow(column_def) = RPAREN COMMA
follow(column_commalist) = RPAREN COMMA
follow(column) = SMALLINT RPAREN REAL NUMERIC INTEGER FLOAT DOUBLE DECIMAL COMPARISON COMMA CHARACTER
follow(cmd) = SEMICOLON EOF #
follow(close_statement) = UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT CLOSE #
follow(between_predicate) = WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND #
follow(base_table_element_commalist) = RPAREN COMMA
follow(base_table_element) = RPAREN COMMA
follow(base_table_def) = SEMICOLON GRANT EOF CREATE #
follow(atom) = WITH WHERE UPDATE UNION TIMES SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE PLUS ORDER OR OPEN NOT MINUS LIKE INTO INSERT IN HAVING GROUP GRANT FROM FETCH ESCAPE EOF DIV DELETE DECLARE CREATE COMPARISON COMMIT COMMA CLOSE BETWEEN AND #
follow(assignment_commalist) = WHERE UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT COMMA CLOSE #
follow(assignment) = WHERE UPDATE SEMICOLON SELECT ROLLBACK PROCEDURE OPEN INSERT FETCH EOF DELETE COMMIT COMMA CLOSE #
follow(any_all_some) = LPAREN
follow(ammsc) = LPAREN
follow(all_or_any_predicate) = WITH UPDATE UNION SEMICOLON SELECT RPAREN ROLLBACK PROCEDURE ORDER OR OPEN INSERT HAVING GROUP GRANT FETCH EOF DELETE DECLARE CREATE COMMIT CLOSE AND #
Built an LR(0) automaton with 471 states.
The grammar is not SLR(1) -- 9 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 498 states.
30 shift/reduce conflicts were silently solved.
File "dbforge.2.0.1-sqml_parser.mly", line 75, characters 0-5:
Warning: the precedence level assigned to COMPARISON is never useful.
Warning: 134 states have an end-of-stream conflict.
217 out of 498 states have a default reduction.
144 out of 498 states are represented.
0 out of 221 symbols keep track of their start position.
0 out of 221 symbols keep track of their end position.
174 out of 255 productions exploit shiftreduce optimization.
0 out of 498 states can peek at an error.
1366 functions before inlining, 200 functions after inlining.
