File "sibylfs-lem.0.4.0-parser.mly", line 166, characters 22-28:
Warning: the token Module is unused.
File "sibylfs-lem.0.4.0-parser.mly", line 158, characters 66-69:
Warning: the token Oct is unused.
File "sibylfs-lem.0.4.0-parser.mly", line 162, characters 41-52:
Warning: the token TargetConst is unused.
File "sibylfs-lem.0.4.0-parser.mly", line 162, characters 30-40:
Warning: the token TargetType is unused.
File "sibylfs-lem.0.4.0-parser.mly", line 1150, characters 0-20:
Warning: symbol semi_backtickstrings is unreachable from any of the start symbol(s).
File "sibylfs-lem.0.4.0-parser.mly", line 1142, characters 0-25:
Warning: symbol semi_backtickstrings_help is unreachable from any of the start symbol(s).
Grammar has 123 nonterminal symbols, among which 1 start symbols.
Grammar has 116 terminal symbols.
Grammar has 366 productions.
nullable(xtyps) = false
nullable(xtyp) = false
nullable(x_ls) = true
nullable(x) = false
nullable(witness_clause) = false
nullable(val_spec) = false
nullable(val_defs) = false
nullable(val_def) = false
nullable(typschm) = false
nullable(typ) = false
nullable(tnvs) = true
nullable(tnvar_list) = true
nullable(tnvar) = false
nullable(texp) = false
nullable(termination_setting) = false
nullable(tds) = false
nullable(td) = false
nullable(targets_opt) = true
nullable(targets) = false
nullable(target_rep_rhs_type) = false
nullable(target_rep_rhs_term) = true
nullable(target) = false
nullable(starstar_right_atomic_exp) = false
nullable(starstar_exp) = false
nullable(star_typ_list) = false
nullable(star_typ) = false
nullable(star_right_atomic_exp) = false
nullable(star_nexp) = false
nullable(star_exp) = false
nullable(semi_pats_help) = false
nullable(semi_pats_atomic) = false
nullable(semi_pats) = true
nullable(semi_ids_help) = false
nullable(semi_ids) = true
nullable(semi_exps_help) = false
nullable(semi_exps) = true
nullable(right_atomic_exp) = false
nullable(ranges) = false
nullable(range) = false
nullable(quant_bindings) = false
nullable(plus_right_atomic_exp) = false
nullable(plus_exp) = false
nullable(patsexp) = false
nullable(patexps) = false
nullable(pat) = false
nullable(or_right_atomic_exp) = false
nullable(or_exp) = false
nullable(opt_typ_annot) = true
nullable(open_import) = false
nullable(nexp) = false
nullable(name_ts) = true
nullable(name_sect) = false
nullable(lit) = false
nullable(letbind) = false
nullable(lemma_typ) = false
nullable(lemma) = false
nullable(insttyp) = false
nullable(instschm) = false
nullable(indreln_name) = false
nullable(indreln_clause) = false
nullable(imp_right_atomic_exp) = false
nullable(imp_exp) = false
nullable(ids) = false
nullable(id_help) = false
nullable(id) = false
nullable(functions_clause) = false
nullable(funcls) = false
nullable(funcl) = false
nullable(fpats) = false
nullable(fpat) = false
nullable(fixity_decl) = true
nullable(file) = false
nullable(field_exp) = false
nullable(fexps_help) = false
nullable(fexps) = false
nullable(fexp) = false
nullable(exps) = true
nullable(exp) = false
nullable(exhaustivity_setting) = false
nullable(eq_right_atomic_exp) = false
nullable(eq_exp) = false
nullable(elim_opt) = true
nullable(do_exps) = true
nullable(defs_help) = false
nullable(defs) = false
nullable(def) = false
nullable(declaration) = false
nullable(ctor_texps) = false
nullable(ctor_texp) = false
nullable(ctor_single_texp) = false
nullable(cs2) = false
nullable(cs) = false
nullable(cons_right_atomic_exp) = false
nullable(cons_exp) = false
nullable(component_type) = false
nullable(component_term) = false
nullable(component) = false
nullable(comma_pats) = false
nullable(comma_exps) = false
nullable(class_val_specs) = false
nullable(class_val_spec) = false
nullable(check_clause) = true
nullable(c2) = false
nullable(c) = false
nullable(backtickstrings) = false
nullable(atomic_typs) = false
nullable(atomic_typ) = false
nullable(atomic_pats_two) = false
nullable(atomic_pats1) = false
nullable(atomic_pats) = false
nullable(atomic_pat) = false
nullable(atomic_nexp) = false
nullable(atomic_exp) = false
nullable(at_right_atomic_exp) = false
nullable(at_exp) = false
nullable(appt_typ) = false
nullable(app_typ) = false
nullable(app_pat) = false
nullable(app_exp) = false
nullable(and_right_atomic_exp) = false
nullable(and_indreln_names) = false
nullable(and_indreln_clauses) = false
nullable(and_exp) = false
first(xtyps) = X Lparen
first(xtyp) = X Lparen
first(x_ls) = X
first(x) = X Lparen
first(witness_clause) = Witness Semi
first(val_spec) = Val
first(val_defs) = Let_
first(val_def) = Let_
first(typschm) = X Under Tyvar Lparen Forall BacktickString
first(typ) = X Under Tyvar Lparen BacktickString
first(tnvs) = Tyvar Nvar
first(tnvar_list) = Tyvar Nvar
first(tnvar) = Tyvar Nvar
first(texp) = X Under Tyvar LtBar Lparen Bar BacktickString
first(termination_setting) = Manual Automatic
first(tds) = X Lparen
first(td) = X Lparen
first(targets_opt) = NonExec NegLcurly Lcurly
first(targets) = X
first(target_rep_rhs_type) = X Under Tyvar Lparen BacktickString
first(target_rep_rhs_term) = X True String Special OctNum Nvar Num Match LtBar Lsquare Lparen Let_ Lcurly Infix If_ HexNum Hex HashZero HashOne Function_ Fun_ Forall False Exists Do Char BraceBar BinNum Bin Begin_ BacktickString
first(target) = X
first(starstar_right_atomic_exp) = X True String OctNum Nvar Num Match LtBar Lsquare Lparen Let_ Lcurly If_ HexNum Hex HashZero HashOne Function_ Fun_ Forall False Exists Do Char BraceBar BinNum Bin Begin_ BacktickString
first(starstar_exp) = X True String OctNum Nvar Num Match LtBar Lsquare Lparen Lcurly HexNum Hex HashZero HashOne Function_ False Do Char BraceBar BinNum Bin Begin_ BacktickString
first(star_typ_list) = X Under Tyvar Lparen BacktickString
first(star_typ) = X Under Tyvar Lparen BacktickString
first(star_right_atomic_exp) = X True String OctNum Nvar Num Match LtBar Lsquare Lparen Let_ Lcurly If_ HexNum Hex HashZero HashOne Function_ Fun_ Forall False Exists Do Char BraceBar BinNum Bin Begin_ BacktickString
first(star_nexp) = Nvar Num Lparen
first(star_exp) = X True String OctNum Nvar Num Match LtBar Lsquare Lparen Lcurly HexNum Hex HashZero HashOne Function_ False Do Char BraceBar BinNum Bin Begin_ BacktickString
first(semi_pats_help) = X Under True String OctNum Num LtBar Lsquare Lparen HexNum Hex HashZero HashOne False Char BraceBar BinNum Bin
first(semi_pats_atomic) = X Under True String OctNum Num LtBar Lsquare Lparen HexNum Hex HashZero HashOne False Char BraceBar BinNum Bin
first(semi_pats) = X Under True String OctNum Num LtBar Lsquare Lparen HexNum Hex HashZero HashOne False Char BraceBar BinNum Bin
first(semi_ids_help) = X Lparen
first(semi_ids) = X Lparen
first(semi_exps_help) = X True String OctNum Nvar Num Match LtBar Lsquare Lparen Let_ Lcurly If_ HexNum Hex HashZero HashOne Function_ Fun_ Forall False Exists Do Char BraceBar BinNum Bin Begin_ BacktickString
first(semi_exps) = X True String OctNum Nvar Num Match LtBar Lsquare Lparen Let_ Lcurly If_ HexNum Hex HashZero HashOne Function_ Fun_ Forall False Exists Do Char BraceBar BinNum Bin Begin_ BacktickString
first(right_atomic_exp) = Let_ If_ Fun_ Forall Exists
first(ranges) = Nvar Num Lparen
first(range) = Nvar Num Lparen
first(quant_bindings) = X Lparen
first(plus_right_atomic_exp) = X True String OctNum Nvar Num Match LtBar Lsquare Lparen Let_ Lcurly If_ HexNum Hex HashZero HashOne Function_ Fun_ Forall False Exists Do Char BraceBar BinNum Bin Begin_ BacktickString
first(plus_exp) = X True String OctNum Nvar Num Match LtBar Lsquare Lparen Lcurly HexNum Hex HashZero HashOne Function_ False Do Char BraceBar BinNum Bin Begin_ BacktickString
first(patsexp) = X Under True String OctNum Num LtBar Lsquare Lparen HexNum Hex HashZero HashOne False Char BraceBar BinNum Bin
first(patexps) = X Under True String OctNum Num LtBar Lsquare Lparen HexNum Hex HashZero HashOne False Char BraceBar BinNum Bin
first(pat) = X Under True String OctNum Num LtBar Lsquare Lparen HexNum Hex HashZero HashOne False Char BraceBar BinNum Bin
first(or_right_atomic_exp) = X True String OctNum Nvar Num Match LtBar Lsquare Lparen Let_ Lcurly If_ HexNum Hex HashZero HashOne Function_ Fun_ Forall False Exists Do Char BraceBar BinNum Bin Begin_ BacktickString
first(or_exp) = X True String OctNum Nvar Num Match LtBar Lsquare Lparen Lcurly HexNum Hex HashZero HashOne Function_ False Do Char BraceBar BinNum Bin Begin_ BacktickString
first(opt_typ_annot) = Colon
first(open_import) = Open_ Include_ Import_
first(nexp) = Nvar Num Lparen
first(name_ts) = X Lparen
first(name_sect) = Lsquare
first(lit) = True String OctNum Num Lparen HexNum Hex HashZero HashOne False Char BinNum Bin
first(letbind) = X Under True String OctNum Num LtBar Lsquare Lparen HexNum Hex HashZero HashOne False Char BraceBar BinNum Bin
first(lemma_typ) = Theorem Lemma Assert
first(lemma) = Theorem Lemma Assert
first(insttyp) = X Under Tyvar Nvar Num Lparen BacktickString
first(instschm) = Lparen Forall
first(indreln_name) = Lsquare
first(indreln_clause) = X Lparen
first(imp_right_atomic_exp) = X True String OctNum Nvar Num Match LtBar Lsquare Lparen Let_ Lcurly If_ HexNum Hex HashZero HashOne Function_ Fun_ Forall False Exists Do Char BraceBar BinNum Bin Begin_ BacktickString
first(imp_exp) = X True String OctNum Nvar Num Match LtBar Lsquare Lparen Lcurly HexNum Hex HashZero HashOne Function_ False Do Char BraceBar BinNum Bin Begin_ BacktickString
first(ids) = X Lparen
first(id_help) = X Lparen
first(id) = X Lparen
first(functions_clause) = X Lparen
first(funcls) = X Lparen
first(funcl) = X Lparen
first(fpats) = X Lparen
first(fpat) = X Lparen
first(fixity_decl) = RightAssoc NonAssoc LeftAssoc
first(file) = Val Type Theorem Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ Import_ Declare Class_ Assert
first(field_exp) = X True String OctNum Nvar Num Match LtBar Lsquare Lparen Lcurly HexNum Hex HashZero HashOne Function_ False Do Char BraceBar BinNum Bin Begin_ BacktickString
first(fexps_help) = X Lparen
first(fexps) = X Lparen
first(fexp) = X Lparen
first(exps) = X True String OctNum Nvar Num Match LtBar Lsquare Lparen Lcurly HexNum Hex HashZero HashOne Function_ False Do Char BraceBar BinNum Bin Begin_ BacktickString
first(exp) = X True String OctNum Nvar Num Match LtBar Lsquare Lparen Let_ Lcurly If_ HexNum Hex HashZero HashOne Function_ Fun_ Forall False Exists Do Char BraceBar BinNum Bin Begin_ BacktickString
first(exhaustivity_setting) = Inexhaustive Exhaustive
first(eq_right_atomic_exp) = X True String OctNum Nvar Num Match LtBar Lsquare Lparen Let_ Lcurly If_ HexNum Hex HashZero HashOne Function_ Fun_ Forall False Exists Do Char BraceBar BinNum Bin Begin_ BacktickString
first(eq_exp) = X True String OctNum Nvar Num Match LtBar Lsquare Lparen Lcurly HexNum Hex HashZero HashOne Function_ False Do Char BraceBar BinNum Bin Begin_ BacktickString
first(elim_opt) = X Lparen
first(do_exps) = X Under True String OctNum Num LtBar Lsquare Lparen HexNum Hex HashZero HashOne False Char BraceBar BinNum Bin
first(defs_help) = Val Type Theorem Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ Import_ Declare Class_ Assert
first(defs) = Val Type Theorem Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ Import_ Declare Class_ Assert
first(def) = Val Type Theorem Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ Import_ Declare Class_ Assert
first(declaration) = Declare
first(ctor_texps) = X Lparen
first(ctor_texp) = X Lparen
first(ctor_single_texp) = X Lparen
first(cs2) = X Lparen
first(cs) = X Lparen
first(cons_right_atomic_exp) = X True String OctNum Nvar Num Match LtBar Lsquare Lparen Let_ Lcurly If_ HexNum Hex HashZero HashOne Function_ Fun_ Forall False Exists Do Char BraceBar BinNum Bin Begin_ BacktickString
first(cons_exp) = X True String OctNum Nvar Num Match LtBar Lsquare Lparen Lcurly HexNum Hex HashZero HashOne Function_ False Do Char BraceBar BinNum Bin Begin_ BacktickString
first(component_type) = Type
first(component_term) = Function_ Field
first(component) = Type Module_ Function_ Field
first(comma_pats) = X Under True String OctNum Num LtBar Lsquare Lparen HexNum Hex HashZero HashOne False Char BraceBar BinNum Bin
first(comma_exps) = X True String OctNum Nvar Num Match LtBar Lsquare Lparen Let_ Lcurly If_ HexNum Hex HashZero HashOne Function_ Fun_ Forall False Exists Do Char BraceBar BinNum Bin Begin_ BacktickString
first(class_val_specs) = Val
first(class_val_spec) = Val
first(check_clause) = Check
first(c2) = X Lparen
first(c) = X Lparen
first(backtickstrings) = BacktickString
first(atomic_typs) = X Under Tyvar Nvar Num Lparen BacktickString
first(atomic_typ) = X Under Tyvar Lparen BacktickString
first(atomic_pats_two) = X Under True String OctNum Num LtBar Lsquare Lparen HexNum Hex HashZero HashOne False Char BraceBar BinNum Bin
first(atomic_pats1) = X Under True String OctNum Num LtBar Lsquare Lparen HexNum Hex HashZero HashOne False Char BraceBar BinNum Bin
first(atomic_pats) = X Under True String OctNum Num LtBar Lsquare Lparen HexNum Hex HashZero HashOne False Char BraceBar BinNum Bin
first(atomic_pat) = X Under True String OctNum Num LtBar Lsquare Lparen HexNum Hex HashZero HashOne False Char BraceBar BinNum Bin
first(atomic_nexp) = Nvar Num Lparen
first(atomic_exp) = True String OctNum Nvar Num Match LtBar Lsquare Lparen Lcurly HexNum Hex HashZero HashOne Function_ False Do Char BraceBar BinNum Bin Begin_ BacktickString
first(at_right_atomic_exp) = X True String OctNum Nvar Num Match LtBar Lsquare Lparen Let_ Lcurly If_ HexNum Hex HashZero HashOne Function_ Fun_ Forall False Exists Do Char BraceBar BinNum Bin Begin_ BacktickString
first(at_exp) = X True String OctNum Nvar Num Match LtBar Lsquare Lparen Lcurly HexNum Hex HashZero HashOne Function_ False Do Char BraceBar BinNum Bin Begin_ BacktickString
first(appt_typ) = X Under Tyvar Nvar Num Lparen BacktickString
first(app_typ) = X Under Tyvar Lparen BacktickString
first(app_pat) = X Under True String OctNum Num LtBar Lsquare Lparen HexNum Hex HashZero HashOne False Char BraceBar BinNum Bin
first(app_exp) = X True String OctNum Nvar Num Match LtBar Lsquare Lparen Lcurly HexNum Hex HashZero HashOne Function_ False Do Char BraceBar BinNum Bin Begin_ BacktickString
first(and_right_atomic_exp) = X True String OctNum Nvar Num Match LtBar Lsquare Lparen Let_ Lcurly If_ HexNum Hex HashZero HashOne Function_ Fun_ Forall False Exists Do Char BraceBar BinNum Bin Begin_ BacktickString
first(and_indreln_names) = Lsquare
first(and_indreln_clauses) = X Lparen
first(and_exp) = X True String OctNum Nvar Num Match LtBar Lsquare Lparen Lcurly HexNum Hex HashZero HashOne Function_ False Do Char BraceBar BinNum Bin Begin_ BacktickString
minimal(xtyps) = (* 3 *) X Colon Under
minimal(xtyp) = (* 3 *) X Colon Under
minimal(x_ls) = (* 0 *) 
minimal(x) = (* 1 *) X
minimal(witness_clause) = (* 1 *) Semi
minimal(val_spec) = (* 4 *) Val X Colon Under
minimal(val_defs) = (* 4 *) Let_ Under Eq True
minimal(val_def) = (* 4 *) Let_ Under Eq True
minimal(typschm) = (* 1 *) Under
minimal(typ) = (* 1 *) Under
minimal(tnvs) = (* 0 *) 
minimal(tnvar_list) = (* 0 *) 
minimal(tnvar) = (* 1 *) Tyvar
minimal(texp) = (* 1 *) Under
minimal(termination_setting) = (* 1 *) Automatic
minimal(tds) = (* 1 *) X
minimal(td) = (* 1 *) X
minimal(targets_opt) = (* 0 *) 
minimal(targets) = (* 1 *) X
minimal(target_rep_rhs_type) = (* 1 *) Under
minimal(target_rep_rhs_term) = (* 0 *) 
minimal(target) = (* 1 *) X
minimal(starstar_right_atomic_exp) = (* 4 *) Forall X Dot True
minimal(starstar_exp) = (* 1 *) True
minimal(star_typ_list) = (* 1 *) Under
minimal(star_typ) = (* 1 *) Under
minimal(star_right_atomic_exp) = (* 4 *) Forall X Dot True
minimal(star_nexp) = (* 1 *) Nvar
minimal(star_exp) = (* 1 *) True
minimal(semi_pats_help) = (* 1 *) Under
minimal(semi_pats_atomic) = (* 1 *) Under
minimal(semi_pats) = (* 0 *) 
minimal(semi_ids_help) = (* 1 *) X
minimal(semi_ids) = (* 0 *) 
minimal(semi_exps_help) = (* 1 *) True
minimal(semi_exps) = (* 0 *) 
minimal(right_atomic_exp) = (* 4 *) Forall X Dot True
minimal(ranges) = (* 3 *) Nvar Eq Nvar
minimal(range) = (* 3 *) Nvar Eq Nvar
minimal(quant_bindings) = (* 1 *) X
minimal(plus_right_atomic_exp) = (* 4 *) Forall X Dot True
minimal(plus_exp) = (* 1 *) True
minimal(patsexp) = (* 3 *) Under Arrow True
minimal(patexps) = (* 3 *) Under Arrow True
minimal(pat) = (* 1 *) Under
minimal(or_right_atomic_exp) = (* 4 *) Forall X Dot True
minimal(or_exp) = (* 1 *) True
minimal(opt_typ_annot) = (* 0 *) 
minimal(open_import) = (* 1 *) Open_
minimal(nexp) = (* 1 *) Nvar
minimal(name_ts) = (* 0 *) 
minimal(name_sect) = (* 5 *) Lsquare X Eq String Rsquare
minimal(lit) = (* 1 *) True
minimal(letbind) = (* 3 *) Under Eq True
minimal(lemma_typ) = (* 1 *) Lemma
minimal(lemma) = (* 4 *) Lemma X Colon True
minimal(insttyp) = (* 1 *) Under
minimal(instschm) = (* 4 *) Lparen X Under Rparen
minimal(indreln_name) = (* 5 *) Lsquare X Colon Under Rsquare
minimal(indreln_clause) = (* 7 *) X Colon Forall Dot True EqEqGt X
minimal(imp_right_atomic_exp) = (* 4 *) Forall X Dot True
minimal(imp_exp) = (* 1 *) True
minimal(ids) = (* 1 *) X
minimal(id_help) = (* 1 *) X
minimal(id) = (* 1 *) X
minimal(functions_clause) = (* 3 *) X Colon Under
minimal(funcls) = (* 4 *) X Under Eq True
minimal(funcl) = (* 4 *) X Under Eq True
minimal(fpats) = (* 3 *) X Eq Under
minimal(fpat) = (* 3 *) X Eq Under
minimal(fixity_decl) = (* 0 *) 
minimal(file) = (* 3 *) Type X Eof
minimal(field_exp) = (* 1 *) True
minimal(fexps_help) = (* 3 *) X Eq True
minimal(fexps) = (* 3 *) X Eq True
minimal(fexp) = (* 3 *) X Eq True
minimal(exps) = (* 0 *) 
minimal(exp) = (* 1 *) True
minimal(exhaustivity_setting) = (* 1 *) Exhaustive
minimal(eq_right_atomic_exp) = (* 4 *) Forall X Dot True
minimal(eq_exp) = (* 1 *) True
minimal(elim_opt) = (* 0 *) 
minimal(do_exps) = (* 0 *) 
minimal(defs_help) = (* 2 *) Type X
minimal(defs) = (* 2 *) Type X
minimal(def) = (* 2 *) Type X
minimal(declaration) = (* 5 *) Declare CompileMessage X Eq String
minimal(ctor_texps) = (* 1 *) X
minimal(ctor_texp) = (* 1 *) X
minimal(ctor_single_texp) = (* 3 *) X Of Under
minimal(cs2) = (* 2 *) X Under
minimal(cs) = (* 2 *) X Tyvar
minimal(cons_right_atomic_exp) = (* 4 *) Forall X Dot True
minimal(cons_exp) = (* 1 *) True
minimal(component_type) = (* 1 *) Type
minimal(component_term) = (* 1 *) Function_
minimal(component) = (* 1 *) Function_
minimal(comma_pats) = (* 3 *) Under Comma Under
minimal(comma_exps) = (* 3 *) True Comma True
minimal(class_val_specs) = (* 4 *) Val X Colon Under
minimal(class_val_spec) = (* 4 *) Val X Colon Under
minimal(check_clause) = (* 0 *) 
minimal(c2) = (* 2 *) X Under
minimal(c) = (* 2 *) X Tyvar
minimal(backtickstrings) = (* 1 *) BacktickString
minimal(atomic_typs) = (* 1 *) Under
minimal(atomic_typ) = (* 1 *) Under
minimal(atomic_pats_two) = (* 2 *) Under Under
minimal(atomic_pats1) = (* 1 *) Under
minimal(atomic_pats) = (* 1 *) Under
minimal(atomic_pat) = (* 1 *) Under
minimal(atomic_nexp) = (* 1 *) Nvar
minimal(atomic_exp) = (* 1 *) True
minimal(at_right_atomic_exp) = (* 4 *) Forall X Dot True
minimal(at_exp) = (* 1 *) True
minimal(appt_typ) = (* 1 *) Under
minimal(app_typ) = (* 1 *) Under
minimal(app_pat) = (* 1 *) Under
minimal(app_exp) = (* 1 *) True
minimal(and_right_atomic_exp) = (* 4 *) Forall X Dot True
minimal(and_indreln_names) = (* 5 *) Lsquare X Colon Under Rsquare
minimal(and_indreln_clauses) = (* 7 *) X Colon Forall Dot True EqEqGt X
minimal(and_exp) = (* 1 *) True
follow(xtyps) = BarGt
follow(xtyp) = Semi BarGt
follow(x_ls) = Eq
follow(x) = X Witness With Val Under Tyvar Type True Theorem Then String StarstarX StarX Star SemiSemi Semi Rsquare Rparen Rcurly PlusX Plus Open_ Of OctNum Nvar Num Module_ MinusMinusGt Match MEM LtBar Lsquare Lparen Let_ Lemma LeftArrow Lcurly Inst_default Inst Indreln Include_ In Import_ IN HexNum Hex HashZero HashOne GtEqX GtEq Function_ False EqualX EqGt EqEqGt Eq Eof End Else DotBrace Dot Do Declare Comma ColonColon Colon Class_ Char BraceBar BinNum Bin Begin_ BarGt BarBrace BarBar Bar BacktickString AtX At Assert As Arrow And AmpAmp
follow(witness_clause) = X Rsquare Lparen Check
follow(val_spec) = Val Type Theorem SemiSemi Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ Import_ Eof End Declare Class_ Assert
follow(val_defs) = End
follow(val_def) = Val Type Theorem SemiSemi Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ Import_ Eof End Declare Class_ Assert
follow(typschm) = Witness Val Type Theorem SemiSemi Semi Rsquare Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ Import_ Eof End Declare Class_ Assert
follow(typ) = Witness Val Type Theorem SemiSemi Semi Rsquare Rparen Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ Import_ EqGt Eq Eof End Declare Comma Class_ BarGt Assert And
follow(tnvs) = Val Type Theorem SemiSemi Open_ Module_ Lsquare Let_ Lemma Inst_default Inst Indreln Include_ Import_ Eq Eof End Dot Declare Class_ Assert And
follow(tnvar_list) = Eq
follow(tnvar) = Val Tyvar Type Theorem SemiSemi Semi Rparen Open_ Nvar Module_ Lsquare Let_ Lemma Inst_default Inst Indreln Include_ Import_ EqGt Eq Eof End Dot Declare Comma Class_ Assert And
follow(texp) = Val Type Theorem SemiSemi Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ Import_ Eof End Declare Class_ Assert And
follow(termination_setting) = Val Type Theorem SemiSemi Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ Import_ Eof End Declare Class_ Assert
follow(tds) = Val Type Theorem SemiSemi Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ Import_ Eof End Declare Class_ Assert
follow(td) = Val Type Theorem SemiSemi Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ Import_ Eof End Declare Class_ Assert And
follow(targets_opt) = X Under True TerminationArgument String Rename PatternMatch OctNum Num LtBar Lsquare Lparen HexNum Hex HashZero HashOne False CompileMessage Char BraceBar BinNum Bin BacktickString AsciiRep
follow(targets) = Rcurly
follow(target_rep_rhs_type) = Val Type Theorem SemiSemi Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ Import_ Eof End Declare Class_ Assert
follow(target_rep_rhs_term) = Val Type Theorem SemiSemi Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ Import_ Eof End Declare Class_ Assert
follow(target) = TargetRep Semi Rcurly
follow(starstar_right_atomic_exp) = With Val Type Theorem Then SemiSemi Semi Rsquare Rparen Rcurly Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ In Import_ EqEqGt Eof End Else Declare Comma Colon Class_ BarGt BarBrace Bar Assert And
follow(starstar_exp) = With Val Type Theorem Then StarX Star SemiSemi Semi Rsquare Rparen Rcurly PlusX Plus Open_ Module_ MinusMinusGt MEM Let_ Lemma Inst_default Inst Indreln Include_ In Import_ IN GtEqX GtEq EqualX EqEqGt Eq Eof End Else Declare Comma ColonColon Colon Class_ BarGt BarBrace BarBar Bar AtX At Assert And AmpAmp
follow(star_typ_list) = Witness Val Type Theorem SemiSemi Semi Rsquare Rparen Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ Import_ EqGt Eq Eof End Declare Comma Class_ BarGt Bar Assert Arrow And
follow(star_typ) = Witness Val Type Theorem SemiSemi Semi Rsquare Rparen Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ Import_ EqGt Eq Eof End Declare Comma Class_ BarGt Assert Arrow And
follow(star_right_atomic_exp) = With Val Type Theorem Then SemiSemi Semi Rsquare Rparen Rcurly Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ In Import_ EqEqGt Eof End Else Declare Comma Colon Class_ BarGt BarBrace Bar Assert And
follow(star_nexp) = Rsquare Rparen Plus GtEq EqGt Eq Dot Comma
follow(star_exp) = With Val Type Theorem Then StarX Star SemiSemi Semi Rsquare Rparen Rcurly PlusX Plus Open_ Module_ MinusMinusGt MEM Let_ Lemma Inst_default Inst Indreln Include_ In Import_ IN GtEqX GtEq EqualX EqEqGt Eq Eof End Else Declare Comma ColonColon Colon Class_ BarGt BarBrace BarBar Bar AtX At Assert And AmpAmp
follow(semi_pats_help) = Rsquare
follow(semi_pats_atomic) = BarBrace
follow(semi_pats) = Rsquare
follow(semi_ids_help) = Rsquare
follow(semi_ids) = Rsquare
follow(semi_exps_help) = Rsquare Rcurly BarBrace
follow(semi_exps) = Rsquare Rcurly BarBrace
follow(right_atomic_exp) = With Val Type Theorem Then SemiSemi Semi Rsquare Rparen Rcurly Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ In Import_ EqEqGt Eof End Else Declare Comma Colon Class_ BarGt BarBrace Bar Assert And
follow(ranges) = EqGt
follow(range) = EqGt Comma
follow(quant_bindings) = Dot Bar
follow(plus_right_atomic_exp) = With Val Type Theorem Then SemiSemi Semi Rsquare Rparen Rcurly Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ In Import_ EqEqGt Eof End Else Declare Comma Colon Class_ BarGt BarBrace Bar Assert And
follow(plus_exp) = With Val Type Theorem Then SemiSemi Semi Rsquare Rparen Rcurly PlusX Plus Open_ Module_ MinusMinusGt MEM Let_ Lemma Inst_default Inst Indreln Include_ In Import_ IN GtEqX GtEq EqualX EqEqGt Eq Eof End Else Declare Comma ColonColon Colon Class_ BarGt BarBrace BarBar Bar AtX At Assert And AmpAmp
follow(patsexp) = With Val Type Theorem Then SemiSemi Semi Rsquare Rparen Rcurly Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ In Import_ EqEqGt Eof End Else Declare Comma Colon Class_ BarGt BarBrace Bar Assert And
follow(patexps) = End
follow(pat) = Semi Rsquare Rparen MEM LeftArrow IN Eq Comma Colon BarGt As Arrow
follow(or_right_atomic_exp) = With Val Type Theorem Then SemiSemi Semi Rsquare Rparen Rcurly Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ In Import_ EqEqGt Eof End Else Declare Comma Colon Class_ BarGt BarBrace Bar Assert And
follow(or_exp) = With Val Type Theorem Then SemiSemi Semi Rsquare Rparen Rcurly Open_ Module_ MinusMinusGt Let_ Lemma Inst_default Inst Indreln Include_ In Import_ EqEqGt Eof End Else Declare Comma Colon Class_ BarGt BarBrace Bar Assert And
follow(opt_typ_annot) = Eq
follow(open_import) = X NonExec NegLcurly Lparen Lcurly BacktickString
follow(nexp) = Rsquare Rparen GtEq EqGt Eq Dot Comma
follow(name_ts) = Dot
follow(name_sect) = Val Type Theorem SemiSemi Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ Import_ Eq Eof End Declare Class_ Assert And
follow(lit) = X With Val Under Type True Theorem Then String StarstarX StarX Star SemiSemi Semi Rsquare Rparen Rcurly PlusX Plus Open_ OctNum Nvar Num Module_ MinusMinusGt Match MEM LtBar Lsquare Lparen Let_ Lemma LeftArrow Lcurly Inst_default Inst Indreln Include_ In Import_ IN HexNum Hex HashZero HashOne GtEqX GtEq Function_ False EqualX EqEqGt Eq Eof End Else DotBrace Dot Do Declare Comma ColonColon Colon Class_ Char BraceBar BinNum Bin Begin_ BarGt BarBrace BarBar Bar BacktickString AtX At Assert As Arrow And AmpAmp
follow(letbind) = Val Type Theorem SemiSemi Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ In Import_ Eof End Declare Class_ Assert
follow(lemma_typ) = X NonExec NegLcurly Lparen Lcurly
follow(lemma) = Val Type Theorem SemiSemi Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ Import_ Eof End Declare Class_ Assert
follow(insttyp) = Rparen
follow(instschm) = Let_
follow(indreln_name) = X Lparen And
follow(indreln_clause) = Val Type Theorem SemiSemi Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ Import_ Eof End Declare Class_ Assert And
follow(imp_right_atomic_exp) = With Val Type Theorem Then SemiSemi Semi Rsquare Rparen Rcurly Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ In Import_ EqEqGt Eof End Else Declare Comma Colon Class_ BarGt BarBrace Bar Assert And
follow(imp_exp) = With Val Type Theorem Then SemiSemi Semi Rsquare Rparen Rcurly Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ In Import_ EqEqGt Eof End Else Declare Comma Colon Class_ BarGt BarBrace Bar Assert And
follow(ids) = Val Type Theorem SemiSemi Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ Import_ Eof End Declare Class_ Assert
follow(id_help) = X Witness With Val Under Tyvar Type True Theorem Then String StarstarX StarX Star SemiSemi Semi Rsquare Rparen Rcurly PlusX Plus Open_ OctNum Nvar Num Module_ MinusMinusGt Match MEM LtBar Lsquare Lparen Let_ Lemma LeftArrow Lcurly Inst_default Inst Indreln Include_ In Import_ IN HexNum Hex HashZero HashOne GtEqX GtEq Function_ False EqualX EqGt EqEqGt Eq Eof End Else DotBrace Do Declare Comma ColonColon Colon Class_ Char BraceBar BinNum Bin Begin_ BarGt BarBrace BarBar Bar BacktickString AtX At Assert As Arrow And AmpAmp
follow(id) = X Witness With Val Under Tyvar Type True Theorem Then String StarstarX StarX Star SemiSemi Semi Rsquare Rparen Rcurly PlusX Plus Open_ OctNum Nvar Num Module_ MinusMinusGt Match MEM LtBar Lsquare Lparen Let_ Lemma LeftArrow Lcurly Inst_default Inst Indreln Include_ In Import_ IN HexNum Hex HashZero HashOne GtEqX GtEq Function_ False EqualX EqGt EqEqGt Eq Eof End Else DotBrace Do Declare Comma ColonColon Colon Class_ Char BraceBar BinNum Bin Begin_ BarGt BarBrace BarBar Bar BacktickString AtX At Assert As Arrow And AmpAmp
follow(functions_clause) = Rsquare
follow(funcls) = Val Type Theorem SemiSemi Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ Import_ Eof End Declare Class_ Assert
follow(funcl) = And
follow(fpats) = BarGt
follow(fpat) = Semi BarGt
follow(fixity_decl) = BacktickString
follow(file) = #
follow(field_exp) = X With Val Type True Theorem Then String StarstarX StarX Star SemiSemi Semi Rsquare Rparen Rcurly PlusX Plus Open_ OctNum Nvar Num Module_ MinusMinusGt Match MEM LtBar Lsquare Lparen Let_ Lemma Lcurly Inst_default Inst Indreln Include_ In Import_ IN HexNum Hex HashZero HashOne GtEqX GtEq Function_ False EqualX EqEqGt Eq Eof End Else Do Declare Comma ColonColon Colon Class_ Char BraceBar BinNum Bin Begin_ BarGt BarBrace BarBar Bar BacktickString AtX At Assert And AmpAmp
follow(fexps_help) = BarGt
follow(fexps) = BarGt
follow(fexp) = Semi BarGt
follow(exps) = Val Type Theorem SemiSemi Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ Import_ Eof End Declare Class_ Assert And
follow(exp) = With Val Type Theorem Then SemiSemi Semi Rsquare Rparen Rcurly Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ In Import_ EqEqGt Eof End Else Declare Comma Colon Class_ BarGt BarBrace Bar Assert And
follow(exhaustivity_setting) = X Lparen
follow(eq_right_atomic_exp) = With Val Type Theorem Then SemiSemi Semi Rsquare Rparen Rcurly Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ In Import_ EqEqGt Eof End Else Declare Comma Colon Class_ BarGt BarBrace Bar Assert And
follow(eq_exp) = With Val Type Theorem Then SemiSemi Semi Rsquare Rparen Rcurly Open_ Module_ MinusMinusGt MEM Let_ Lemma Inst_default Inst Indreln Include_ In Import_ IN GtEqX GtEq EqualX EqEqGt Eq Eof End Else Declare Comma Colon Class_ BarGt BarBrace BarBar Bar Assert And AmpAmp
follow(elim_opt) = Val Type Theorem SemiSemi Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ Import_ Eof End Declare Class_ Assert
follow(do_exps) = In
follow(defs_help) = Eof End
follow(defs) = Eof End
follow(def) = Val Type Theorem SemiSemi Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ Import_ Eof End Declare Class_ Assert
follow(declaration) = Val Type Theorem SemiSemi Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ Import_ Eof End Declare Class_ Assert
follow(ctor_texps) = Val Type Theorem SemiSemi Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ Import_ Eof End Declare Class_ Assert And
follow(ctor_texp) = Val Type Theorem SemiSemi Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ Import_ Eof End Declare Class_ Bar Assert And
follow(ctor_single_texp) = Val Type Theorem SemiSemi Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ Import_ Eof End Declare Class_ Assert And
follow(cs2) = EqGt
follow(cs) = Semi EqGt
follow(cons_right_atomic_exp) = With Val Type Theorem Then SemiSemi Semi Rsquare Rparen Rcurly Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ In Import_ EqEqGt Eof End Else Declare Comma Colon Class_ BarGt BarBrace Bar Assert And
follow(cons_exp) = With Val Type Theorem Then SemiSemi Semi Rsquare Rparen Rcurly Open_ Module_ MinusMinusGt MEM Let_ Lemma Inst_default Inst Indreln Include_ In Import_ IN GtEqX GtEq EqualX EqEqGt Eq Eof End Else Declare Comma Colon Class_ BarGt BarBrace BarBar Bar AtX At Assert And AmpAmp
follow(component_type) = X Lparen
follow(component_term) = X Lparen
follow(component) = X Lparen
follow(comma_pats) = Rparen
follow(comma_exps) = Rparen
follow(class_val_specs) = End
follow(class_val_spec) = Val End
follow(check_clause) = X Rsquare Lparen
follow(c2) = EqGt Comma
follow(c) = Semi EqGt Comma
follow(backtickstrings) = Val Type Theorem SemiSemi Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ Import_ Eof End Declare Class_ Assert
follow(atomic_typs) = Witness Val Type Theorem Star SemiSemi Semi Rsquare Rparen Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ Import_ EqGt Eq Eof End Declare Comma Class_ BarGt Bar Assert Arrow And
follow(atomic_typ) = X Witness Val Under Tyvar Type Theorem Star SemiSemi Semi Rsquare Rparen Open_ Nvar Num Module_ Lparen Let_ Lemma Inst_default Inst Indreln Include_ Import_ EqGt Eq Eof End Declare Comma Class_ BarGt Bar BacktickString Assert Arrow And
follow(atomic_pats_two) = BarBrace
follow(atomic_pats1) = Eq Colon Arrow
follow(atomic_pats) = Semi Rsquare Rparen MEM LeftArrow IN Eq Comma ColonColon Colon BarGt As Arrow
follow(atomic_pat) = X Under True String Semi Rsquare Rparen OctNum Num MEM LtBar Lsquare Lparen LeftArrow IN HexNum Hex HashZero HashOne False Eq Comma ColonColon Colon Char BraceBar BinNum Bin BarGt BarBrace As Arrow
follow(atomic_nexp) = X Witness Val Under Tyvar Type Theorem Star SemiSemi Semi Rsquare Rparen Plus Open_ Nvar Num Module_ Lparen Let_ Lemma Inst_default Inst Indreln Include_ Import_ GtEq EqGt Eq Eof End Dot Declare Comma Class_ BarGt Bar BacktickString Assert Arrow And
follow(atomic_exp) = X With Val Type True Theorem Then String StarstarX StarX Star SemiSemi Semi Rsquare Rparen Rcurly PlusX Plus Open_ OctNum Nvar Num Module_ MinusMinusGt Match MEM LtBar Lsquare Lparen Let_ Lemma Lcurly Inst_default Inst Indreln Include_ In Import_ IN HexNum Hex HashZero HashOne GtEqX GtEq Function_ False EqualX EqEqGt Eq Eof End Else DotBrace Dot Do Declare Comma ColonColon Colon Class_ Char BraceBar BinNum Bin Begin_ BarGt BarBrace BarBar Bar BacktickString AtX At Assert And AmpAmp
follow(at_right_atomic_exp) = With Val Type Theorem Then SemiSemi Semi Rsquare Rparen Rcurly Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ In Import_ EqEqGt Eof End Else Declare Comma Colon Class_ BarGt BarBrace Bar Assert And
follow(at_exp) = With Val Type Theorem Then SemiSemi Semi Rsquare Rparen Rcurly Open_ Module_ MinusMinusGt MEM Let_ Lemma Inst_default Inst Indreln Include_ In Import_ IN GtEqX GtEq EqualX EqEqGt Eq Eof End Else Declare Comma Colon Class_ BarGt BarBrace BarBar Bar Assert And AmpAmp
follow(appt_typ) = X Witness Val Under Tyvar Type Theorem Star SemiSemi Semi Rsquare Rparen Open_ Nvar Num Module_ Lparen Let_ Lemma Inst_default Inst Indreln Include_ Import_ EqGt Eq Eof End Declare Comma Class_ BarGt Bar BacktickString Assert Arrow And
follow(app_typ) = Witness Val Type Theorem Star SemiSemi Semi Rsquare Rparen Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ Import_ EqGt Eq Eof End Declare Comma Class_ BarGt Bar Assert Arrow And
follow(app_pat) = Semi Rsquare Rparen MEM LeftArrow IN Eq Comma ColonColon Colon BarGt As Arrow
follow(app_exp) = X With Val Type True Theorem Then String StarstarX StarX Star SemiSemi Semi Rsquare Rparen Rcurly PlusX Plus Open_ OctNum Nvar Num Module_ MinusMinusGt Match MEM LtBar Lsquare Lparen Let_ Lemma Lcurly Inst_default Inst Indreln Include_ In Import_ IN HexNum Hex HashZero HashOne GtEqX GtEq Function_ False EqualX EqEqGt Eq Eof End Else Do Declare Comma ColonColon Colon Class_ Char BraceBar BinNum Bin Begin_ BarGt BarBrace BarBar Bar BacktickString AtX At Assert And AmpAmp
follow(and_right_atomic_exp) = With Val Type Theorem Then SemiSemi Semi Rsquare Rparen Rcurly Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ In Import_ EqEqGt Eof End Else Declare Comma Colon Class_ BarGt BarBrace Bar Assert And
follow(and_indreln_names) = X Lparen
follow(and_indreln_clauses) = Val Type Theorem SemiSemi Open_ Module_ Let_ Lemma Inst_default Inst Indreln Include_ Import_ Eof End Declare Class_ Assert
follow(and_exp) = With Val Type Theorem Then SemiSemi Semi Rsquare Rparen Rcurly Open_ Module_ MinusMinusGt Let_ Lemma Inst_default Inst Indreln Include_ In Import_ EqEqGt Eof End Else Declare Comma Colon Class_ BarGt BarBrace BarBar Bar Assert And
Built an LR(0) automaton with 733 states.
The grammar is not SLR(1) -- 14 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 733 states.
Warning: 2 states have shift/reduce conflicts.
Warning: 2 states have reduce/reduce conflicts.
2 conflicts could not be explained.
Warning: 2 shift/reduce conflicts were arbitrarily resolved.
Warning: 2 reduce/reduce conflicts were arbitrarily resolved.
288 out of 733 states have a default reduction.
242 out of 733 states are represented.
0 out of 242 symbols keep track of their start position.
0 out of 242 symbols keep track of their end position.
191 out of 367 productions exploit shiftreduce optimization.
0 out of 733 states can peek at an error.
1962 functions before inlining, 246 functions after inlining.
