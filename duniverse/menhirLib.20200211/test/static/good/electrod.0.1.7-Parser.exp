Grammar has 43 nonterminal symbols, among which 1 start symbols.
Grammar has 75 terminal symbols.
Grammar has 161 productions.
nullable(urelements) = false
nullable(universe) = false
nullable(tuple) = false
nullable(syms) = false
nullable(symmetry) = false
nullable(sym_element) = false
nullable(specification) = true
nullable(separated_nonempty_list(COMMA,plain_id)) = false
nullable(separated_nonempty_list(COMMA,let_decl)) = false
nullable(separated_nonempty_list(COMMA,expr)) = false
nullable(separated_nonempty_list(COMMA,ae_decl)) = false
nullable(parse_problem) = false
nullable(paragraph) = false
nullable(option(next_scope)) = true
nullable(option(boundmult)) = true
nullable(option(SEMI)) = true
nullable(nonempty_list(sym_element)) = false
nullable(nonempty_list(paragraph)) = false
nullable(nonempty_list(inst)) = false
nullable(nonempty_list(formula_semi)) = false
nullable(nonempty_list(bracketed_symmetry)) = false
nullable(nonempty_list(atom)) = false
nullable(next_scope) = false
nullable(list(urelements)) = true
nullable(list(tuple)) = true
nullable(list(formula_semi)) = true
nullable(list(element)) = true
nullable(list(declaration)) = true
nullable(interval) = false
nullable(insts) = false
nullable(inst) = false
nullable(iexpr) = false
nullable(icomp_op) = false
nullable(formula_semi) = false
nullable(formula) = false
nullable(expr) = false
nullable(element) = false
nullable(declaration) = false
nullable(colon_w_or_wo_arity) = false
nullable(bracketed_symmetry) = false
nullable(boundmult) = false
nullable(bound) = false
nullable(atom) = false
first(urelements) = PLAIN_ID NUMBER IDX_ID
first(universe) = UNIV
first(tuple) = LPAREN
first(syms) = SYM
first(symmetry) = LPAREN
first(sym_element) = LPAREN
first(specification) = UNIV TRUE TILDE SUB STAR SOMETIME SOME PREVIOUS PLAIN_ID ONE ONCE NUMBER NOT NONE NO NEXT NEG LPAREN LONE LET LBRACE IDEN HISTORICALLY HAT HASH FALSE EVENTUALLY ALWAYS ALL ADD
first(separated_nonempty_list(COMMA,plain_id)) = PLAIN_ID
first(separated_nonempty_list(COMMA,let_decl)) = PLAIN_ID
first(separated_nonempty_list(COMMA,expr)) = UNIV TRUE TILDE SUB STAR SOMETIME SOME PREVIOUS PLAIN_ID ONE ONCE NUMBER NOT NONE NO NEXT NEG LPAREN LONE LET LBRACE IDEN HISTORICALLY HAT HASH FALSE EVENTUALLY ALWAYS ALL ADD
first(separated_nonempty_list(COMMA,ae_decl)) = PLAIN_ID DISJ
first(parse_problem) = UNIV
first(paragraph) = SYM RUN INVARIANT INST
first(option(next_scope)) = THEN
first(option(boundmult)) = ONE LONE
first(option(SEMI)) = SEMI
first(nonempty_list(sym_element)) = LPAREN
first(nonempty_list(paragraph)) = SYM RUN INVARIANT INST
first(nonempty_list(inst)) = PLAIN_ID
first(nonempty_list(formula_semi)) = UNIV TRUE TILDE SUB STAR SOMETIME SOME PREVIOUS PLAIN_ID ONE ONCE NUMBER NOT NONE NO NEXT NEG LPAREN LONE LET LBRACE IDEN HISTORICALLY HAT HASH FALSE EVENTUALLY ALWAYS ALL ADD
first(nonempty_list(bracketed_symmetry)) = LBRACKET
first(nonempty_list(atom)) = PLAIN_ID NUMBER IDX_ID
first(next_scope) = THEN
first(list(urelements)) = PLAIN_ID NUMBER IDX_ID
first(list(tuple)) = LPAREN
first(list(formula_semi)) = UNIV TRUE TILDE SUB STAR SOMETIME SOME PREVIOUS PLAIN_ID ONE ONCE NUMBER NOT NONE NO NEXT NEG LPAREN LONE LET LBRACE IDEN HISTORICALLY HAT HASH FALSE EVENTUALLY ALWAYS ALL ADD
first(list(element)) = PLAIN_ID NUMBER LPAREN IDX_ID
first(list(declaration)) = VAR CONST
first(interval) = IDX_ID
first(insts) = INST
first(inst) = PLAIN_ID
first(iexpr) = SUB NUMBER NEG LPAREN HASH ADD
first(icomp_op) = NEQ LTE LT GTE GT EQ
first(formula_semi) = UNIV TRUE TILDE SUB STAR SOMETIME SOME PREVIOUS PLAIN_ID ONE ONCE NUMBER NOT NONE NO NEXT NEG LPAREN LONE LET LBRACE IDEN HISTORICALLY HAT HASH FALSE EVENTUALLY ALWAYS ALL ADD
first(formula) = UNIV TRUE TILDE SUB STAR SOMETIME SOME PREVIOUS PLAIN_ID ONE ONCE NUMBER NOT NONE NO NEXT NEG LPAREN LONE LET LBRACE IDEN HISTORICALLY HAT HASH FALSE EVENTUALLY ALWAYS ALL ADD
first(expr) = UNIV TRUE TILDE SUB STAR SOMETIME SOME PREVIOUS PLAIN_ID ONE ONCE NUMBER NOT NONE NO NEXT NEG LPAREN LONE LET LBRACE IDEN HISTORICALLY HAT HASH FALSE EVENTUALLY ALWAYS ALL ADD
first(element) = PLAIN_ID NUMBER LPAREN IDX_ID
first(declaration) = VAR CONST
first(colon_w_or_wo_arity) = COLON_ARITY COLON
first(bracketed_symmetry) = LBRACKET
first(boundmult) = ONE LONE
first(bound) = UNIV PLAIN_ID LPAREN LBRACE
first(atom) = PLAIN_ID NUMBER IDX_ID
minimal(urelements) = (* 1 *) PLAIN_ID
minimal(universe) = (* 4 *) UNIV COLON LBRACE RBRACE
minimal(tuple) = (* 3 *) LPAREN PLAIN_ID RPAREN
minimal(syms) = (* 10 *) SYM LBRACKET LPAREN PLAIN_ID RPAREN LTE LPAREN PLAIN_ID RPAREN RBRACKET
minimal(symmetry) = (* 7 *) LPAREN PLAIN_ID RPAREN LTE LPAREN PLAIN_ID RPAREN
minimal(sym_element) = (* 3 *) LPAREN PLAIN_ID RPAREN
minimal(specification) = (* 0 *) 
minimal(separated_nonempty_list(COMMA,plain_id)) = (* 1 *) PLAIN_ID
minimal(separated_nonempty_list(COMMA,let_decl)) = (* 3 *) PLAIN_ID EQ NONE
minimal(separated_nonempty_list(COMMA,expr)) = (* 1 *) NONE
minimal(separated_nonempty_list(COMMA,ae_decl)) = (* 3 *) PLAIN_ID COLON NONE
minimal(parse_problem) = (* 6 *) UNIV COLON LBRACE RBRACE INVARIANT EOF
minimal(paragraph) = (* 1 *) INVARIANT
minimal(option(next_scope)) = (* 0 *) 
minimal(option(boundmult)) = (* 0 *) 
minimal(option(SEMI)) = (* 0 *) 
minimal(nonempty_list(sym_element)) = (* 3 *) LPAREN PLAIN_ID RPAREN
minimal(nonempty_list(paragraph)) = (* 1 *) INVARIANT
minimal(nonempty_list(inst)) = (* 4 *) PLAIN_ID EQ LBRACE RBRACE
minimal(nonempty_list(formula_semi)) = (* 1 *) TRUE
minimal(nonempty_list(bracketed_symmetry)) = (* 9 *) LBRACKET LPAREN PLAIN_ID RPAREN LTE LPAREN PLAIN_ID RPAREN RBRACKET
minimal(nonempty_list(atom)) = (* 1 *) PLAIN_ID
minimal(next_scope) = (* 2 *) THEN UNIV
minimal(list(urelements)) = (* 0 *) 
minimal(list(tuple)) = (* 0 *) 
minimal(list(formula_semi)) = (* 0 *) 
minimal(list(element)) = (* 0 *) 
minimal(list(declaration)) = (* 0 *) 
minimal(interval) = (* 3 *) IDX_ID DOTDOT IDX_ID
minimal(insts) = (* 5 *) INST PLAIN_ID EQ LBRACE RBRACE
minimal(inst) = (* 4 *) PLAIN_ID EQ LBRACE RBRACE
minimal(iexpr) = (* 1 *) NUMBER
minimal(icomp_op) = (* 1 *) LT
minimal(formula_semi) = (* 1 *) TRUE
minimal(formula) = (* 1 *) TRUE
minimal(expr) = (* 1 *) NONE
minimal(element) = (* 1 *) PLAIN_ID
minimal(declaration) = (* 4 *) CONST PLAIN_ID COLON UNIV
minimal(colon_w_or_wo_arity) = (* 1 *) COLON
minimal(bracketed_symmetry) = (* 9 *) LBRACKET LPAREN PLAIN_ID RPAREN LTE LPAREN PLAIN_ID RPAREN RBRACKET
minimal(boundmult) = (* 1 *) LONE
minimal(bound) = (* 1 *) UNIV
minimal(atom) = (* 1 *) PLAIN_ID
follow(urelements) = RBRACE PLAIN_ID NUMBER IDX_ID
follow(universe) = VAR SYM RUN INVARIANT INST CONST
follow(tuple) = RBRACE PLAIN_ID NUMBER LPAREN IDX_ID
follow(syms) = SYM RUN INVARIANT INST EOF
follow(symmetry) = RBRACKET
follow(sym_element) = RBRACKET LTE LPAREN
follow(specification) = SYM RUN RBRACE INVARIANT INST EOF
follow(separated_nonempty_list(COMMA,plain_id)) = COLON
follow(separated_nonempty_list(COMMA,let_decl)) = LBRACE BAR
follow(separated_nonempty_list(COMMA,expr)) = RBRACKET
follow(separated_nonempty_list(COMMA,ae_decl)) = LBRACE BAR
follow(parse_problem) = #
follow(paragraph) = SYM RUN INVARIANT INST EOF
follow(option(next_scope)) = VAR SYM SEMI RUN INVARIANT INST CONST
follow(option(boundmult)) = UNIV PLAIN_ID LPAREN LBRACE
follow(option(SEMI)) = SYM RUN LBRACKET INVARIANT INST EOF
follow(nonempty_list(sym_element)) = RBRACKET LTE
follow(nonempty_list(paragraph)) = EOF
follow(nonempty_list(inst)) = SYM RUN INVARIANT INST EOF
follow(nonempty_list(formula_semi)) = SYM RUN INVARIANT INST EOF
follow(nonempty_list(bracketed_symmetry)) = SYM RUN INVARIANT INST EOF
follow(nonempty_list(atom)) = RPAREN
follow(next_scope) = VAR SYM SEMI RUN INVARIANT INST CONST
follow(list(urelements)) = RBRACE
follow(list(tuple)) = RBRACE
follow(list(formula_semi)) = SYM RUN RBRACE INVARIANT INST EOF
follow(list(element)) = RBRACE
follow(list(declaration)) = SYM RUN INVARIANT INST
follow(interval) = RBRACE PLAIN_ID NUMBER LPAREN IDX_ID
follow(insts) = SYM RUN INVARIANT INST EOF
follow(inst) = SYM RUN PLAIN_ID INVARIANT INST EOF
follow(iexpr) = UNTIL UNIV TRUE TILDE SYM SUB STAR SOMETIME SOME SINCE SEMI RUN RPAREN RELEASES RBRACKET RBRACE PREVIOUS PLAIN_ID OR ONE ONCE NUMBER NOT NONE NO NEXT NEQ NEG LTE LT LPAREN LONE LET LBRACE INVARIANT INST IMPLIES IFF IDEN HISTORICALLY HAT HASH GTE GT FALSE EVENTUALLY EQ EOF ELSE COMMA AND ALWAYS ALL ADD
follow(icomp_op) = SUB NUMBER NEG LPAREN HASH ADD
follow(formula_semi) = UNIV TRUE TILDE SYM SUB STAR SOMETIME SOME RUN RBRACE PREVIOUS PLAIN_ID ONE ONCE NUMBER NOT NONE NO NEXT NEG LPAREN LONE LET LBRACE INVARIANT INST IDEN HISTORICALLY HAT HASH FALSE EVENTUALLY EOF ALWAYS ALL ADD
follow(formula) = UNTIL UNIV TRUE TILDE SYM SUB STAR SOMETIME SOME SINCE SEMI RUN RPAREN RELEASES RBRACE PREVIOUS PLAIN_ID OR ONE ONCE NUMBER NOT NONE NO NEXT NEG LPAREN LONE LET LBRACE INVARIANT INST IMPLIES IFF IDEN HISTORICALLY HAT HASH FALSE EVENTUALLY EOF ELSE AND ALWAYS ALL ADD
follow(expr) = UNTIL UNIV TRUE TILDE SYM SUB STAR SOMETIME SOME SINCE SEMI RUN RPROJ RPAREN RELEASES RBRACKET RBRACE PRIME PREVIOUS PLUS PLAIN_ID OVERRIDE OR ONE ONCE NUMBER NOT_IN NOT NONE NO NEXT NEQ NEG MINUS LTE LT LPROJ LPAREN LONE LET LBRACKET LBRACE INVARIANT INTER INST IN IMPLIES IFF IDEN HISTORICALLY HAT HASH GTE GT FALSE EVENTUALLY EQ EOF ELSE DOT COMMA BAR ARROW AND ALWAYS ALL ADD
follow(element) = RBRACE PLAIN_ID NUMBER LPAREN IDX_ID
follow(declaration) = VAR SYM RUN INVARIANT INST CONST
follow(colon_w_or_wo_arity) = UNIV PLAIN_ID LPAREN LBRACE
follow(bracketed_symmetry) = SYM RUN LBRACKET INVARIANT INST EOF
follow(boundmult) = UNIV PLAIN_ID LPAREN LBRACE
follow(bound) = VAR UNIV THEN SYM SEMI RUN RPAREN PLUS PLAIN_ID ONE LPAREN LONE LBRACE INVARIANT INST CONST ARROW
follow(atom) = RPAREN RBRACE PLAIN_ID NUMBER LPAREN IDX_ID
Built an LR(0) automaton with 315 states.
The grammar is not SLR(1) -- 38 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 319 states.
329 shift/reduce conflicts were silently solved.
100 out of 319 states have a default reduction.
119 out of 319 states are represented.
34 out of 121 symbols keep track of their start position.
15 out of 121 symbols keep track of their end position.
69 out of 162 productions exploit shiftreduce optimization.
0 out of 319 states can peek at an error.
849 functions before inlining, 144 functions after inlining.
