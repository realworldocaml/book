File "macrodown.mly", line 205, characters 7-14:
Warning: the token IGNORED is unused.
Grammar has 34 nonterminal symbols, among which 1 start symbols.
Grammar has 69 terminal symbols.
Grammar has 212 productions.
nullable(sxsepsub) = true
nullable(sxsep) = true
nullable(sxidnm) = true
nullable(sxclsnm) = true
nullable(sxbot) = false
nullable(sxblock) = true
nullable(sargsub) = true
nullable(sarg) = false
nullable(nxwhl) = false
nullable(nxun) = false
nullable(nxtoplevel) = false
nullable(nxrtimes) = false
nullable(nxrplus) = false
nullable(nxrminus) = false
nullable(nxmutual) = false
nullable(nxltimes) = false
nullable(nxlplus) = false
nullable(nxlor) = false
nullable(nxlminus) = false
nullable(nxlist) = true
nullable(nxlet) = false
nullable(nxland) = false
nullable(nxlambda) = false
nullable(nxif) = false
nullable(nxdec) = true
nullable(nxconcat) = false
nullable(nxcomp) = false
nullable(nxbot) = false
nullable(nxbfr) = false
nullable(nxapp) = false
nullable(narg) = true
nullable(main) = false
nullable(binop) = false
nullable(argvar) = true
first(sxsepsub) = VARINSTR SPACE SEP CTRLSEQ CHAR BREAK
first(sxsep) = VARINSTR SPACE SEP CTRLSEQ CHAR BREAK
first(sxidnm) = IDNAME
first(sxclsnm) = CLASSNAME
first(sxbot) = VARINSTR SPACE CTRLSEQ CHAR BREAK
first(sxblock) = VARINSTR SPACE CTRLSEQ CHAR BREAK
first(sargsub) = OPENQT BGRP
first(sarg) = OPENQT END BGRP
first(nxwhl) = WHILE VAR UNITVALUE TRUE RENEWGLOBALHASH REFNOW REFFINAL OPENSTR OPENQT NUMCONST MINUS LPAREN LNOT LAMBDA IFIDISVALID IFCLASSISVALID IF FINISH FALSE DECGLOBALHASH BLIST
first(nxun) = VAR UNITVALUE TRUE REFNOW REFFINAL OPENSTR OPENQT NUMCONST MINUS LPAREN LNOT FINISH FALSE BLIST
first(nxtoplevel) = MUTUAL LETMUTABLE LET
first(nxrtimes) = VAR UNITVALUE TRUE OPENSTR OPENQT NUMCONST LPAREN FINISH FALSE BLIST
first(nxrplus) = VAR UNITVALUE TRUE OPENSTR OPENQT NUMCONST LPAREN FINISH FALSE BLIST
first(nxrminus) = VAR UNITVALUE TRUE OPENSTR OPENQT NUMCONST LPAREN FINISH FALSE BLIST
first(nxmutual) = LET ENDMUTUAL
first(nxltimes) = VAR UNITVALUE TRUE REFNOW REFFINAL OPENSTR OPENQT NUMCONST MINUS LPAREN LNOT FINISH FALSE BLIST
first(nxlplus) = VAR UNITVALUE TRUE REFNOW REFFINAL OPENSTR OPENQT NUMCONST MINUS LPAREN LNOT FINISH FALSE BLIST
first(nxlor) = VAR UNITVALUE TRUE REFNOW REFFINAL OPENSTR OPENQT NUMCONST MINUS LPAREN LNOT FINISH FALSE BLIST
first(nxlminus) = VAR UNITVALUE TRUE REFNOW REFFINAL OPENSTR OPENQT NUMCONST MINUS LPAREN LNOT FINISH FALSE BLIST
first(nxlist) = LISTPUNCT
first(nxlet) = WHILE VAR UNITVALUE TRUE RENEWGLOBALHASH REFNOW REFFINAL OPENSTR OPENQT NUMCONST MINUS LPAREN LNOT LETMUTABLE LET LAMBDA IFIDISVALID IFCLASSISVALID IF FINISH FALSE DECGLOBALHASH BLIST
first(nxland) = VAR UNITVALUE TRUE REFNOW REFFINAL OPENSTR OPENQT NUMCONST MINUS LPAREN LNOT FINISH FALSE BLIST
first(nxlambda) = VAR UNITVALUE TRUE RENEWGLOBALHASH REFNOW REFFINAL OPENSTR OPENQT NUMCONST MINUS LPAREN LNOT LAMBDA FINISH FALSE DECGLOBALHASH BLIST
first(nxif) = VAR UNITVALUE TRUE RENEWGLOBALHASH REFNOW REFFINAL OPENSTR OPENQT NUMCONST MINUS LPAREN LNOT LAMBDA IFIDISVALID IFCLASSISVALID IF FINISH FALSE DECGLOBALHASH BLIST
first(nxdec) = LETAND
first(nxconcat) = VAR UNITVALUE TRUE REFNOW REFFINAL OPENSTR OPENQT NUMCONST MINUS LPAREN LNOT FINISH FALSE BLIST
first(nxcomp) = VAR UNITVALUE TRUE REFNOW REFFINAL OPENSTR OPENQT NUMCONST MINUS LPAREN LNOT FINISH FALSE BLIST
first(nxbot) = VAR UNITVALUE TRUE OPENSTR OPENQT NUMCONST LPAREN FINISH FALSE BLIST
first(nxbfr) = VAR UNITVALUE TRUE RENEWGLOBALHASH REFNOW REFFINAL OPENSTR OPENQT NUMCONST MINUS LPAREN LNOT LAMBDA FINISH FALSE DECGLOBALHASH BLIST
first(nxapp) = VAR UNITVALUE TRUE OPENSTR OPENQT NUMCONST LPAREN FINISH FALSE BLIST
first(narg) = OPENNUM
first(main) = VARINSTR SPACE MUTUAL LETMUTABLE LET EOI CTRLSEQ CHAR BREAK
first(binop) = TIMES PLUS NEQ MOD MINUS LT LOR LNOT LEQ LAND GT GEQ EQ DIVIDES CONCAT BEFORE
first(argvar) = VAR
minimal(sxsepsub) = (* 0 *) 
minimal(sxsep) = (* 0 *) 
minimal(sxidnm) = (* 0 *) 
minimal(sxclsnm) = (* 0 *) 
minimal(sxbot) = (* 1 *) CHAR
minimal(sxblock) = (* 0 *) 
minimal(sargsub) = (* 0 *) 
minimal(sarg) = (* 1 *) END
minimal(nxwhl) = (* 1 *) VAR
minimal(nxun) = (* 1 *) VAR
minimal(nxtoplevel) = (* 2 *) LET error
minimal(nxrtimes) = (* 1 *) VAR
minimal(nxrplus) = (* 1 *) VAR
minimal(nxrminus) = (* 1 *) VAR
minimal(nxmutual) = (* 1 *) ENDMUTUAL
minimal(nxltimes) = (* 1 *) VAR
minimal(nxlplus) = (* 1 *) VAR
minimal(nxlor) = (* 1 *) VAR
minimal(nxlminus) = (* 1 *) VAR
minimal(nxlist) = (* 0 *) 
minimal(nxlet) = (* 1 *) VAR
minimal(nxland) = (* 1 *) VAR
minimal(nxlambda) = (* 1 *) VAR
minimal(nxif) = (* 1 *) VAR
minimal(nxdec) = (* 0 *) 
minimal(nxconcat) = (* 1 *) VAR
minimal(nxcomp) = (* 1 *) VAR
minimal(nxbot) = (* 1 *) VAR
minimal(nxbfr) = (* 1 *) VAR
minimal(nxapp) = (* 1 *) VAR
minimal(narg) = (* 0 *) 
minimal(main) = (* 1 *) EOI
minimal(binop) = (* 1 *) PLUS
minimal(argvar) = (* 0 *) 
follow(sxsepsub) = EGRP CLOSESTR CLOSEQT
follow(sxsep) = EGRP CLOSESTR CLOSEQT
follow(sxidnm) = OPENQT OPENNUM END BGRP
follow(sxclsnm) = OPENQT OPENNUM IDNAME END BGRP
follow(sxbot) = VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK
follow(sxblock) = SEP EOI EGRP CLOSESTR CLOSEQT
follow(sargsub) = VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK
follow(sarg) = VARINSTR SPACE SEP EOI EGRP CTRLSEQ CLOSESTR CLOSEQT CHAR BREAK
follow(nxwhl) = THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM
follow(nxun) = TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE
follow(nxtoplevel) = EOI
follow(nxrtimes) = THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE
follow(nxrplus) = THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE
follow(nxrminus) = THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE
follow(nxmutual) = MUTUAL LETMUTABLE LET IN EOI
follow(nxltimes) = THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MOD MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BEFORE
follow(nxlplus) = THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE
follow(nxlor) = THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE
follow(nxlminus) = THEN RPAREN PLUS OVERWRITEGLOBALHASH NEQ MUTUAL MINUS LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CONS CONCAT CLOSENUM BEFORE
follow(nxlist) = ELIST
follow(nxlet) = THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM
follow(nxland) = THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE
follow(nxlambda) = THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE
follow(nxif) = THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM
follow(nxdec) = MUTUAL LETMUTABLE LET IN EOI
follow(nxconcat) = THEN RPAREN OVERWRITEGLOBALHASH NEQ MUTUAL LT LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ EQ EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE
follow(nxcomp) = THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LOR LISTPUNCT LETMUTABLE LETAND LET LAND IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM BEFORE
follow(nxbot) = VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE
follow(nxbfr) = THEN RPAREN OVERWRITEGLOBALHASH MUTUAL LISTPUNCT LETMUTABLE LETAND LET IN EOI ENDMUTUAL ELSE ELIST DO CLOSENUM
follow(nxapp) = VAR UNITVALUE TRUE TIMES THEN RPAREN PLUS OVERWRITEGLOBALHASH OPENSTR OPENQT NUMCONST NEQ MUTUAL MOD MINUS LT LPAREN LOR LISTPUNCT LETMUTABLE LETAND LET LEQ LAND IN GT GEQ FINISH FALSE EQ EOI ENDMUTUAL ELSE ELIST DO DIVIDES CONS CONCAT CLOSENUM BLIST BEFORE
follow(narg) = OPENQT END BGRP
follow(main) = #
follow(binop) = RPAREN
follow(argvar) = DEFEQ ARROW
Built an LR(0) automaton with 363 states.
The grammar is not SLR(1) -- 12 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 363 states.
6 shift/reduce conflicts were silently solved.
File "macrodown.mly", line 210, characters 0-5:
Warning: the precedence level assigned to BEFORE is never useful.
File "macrodown.mly", line 207, characters 0-9:
Warning: the precedence level assigned to DEFEQ is never useful.
File "macrodown.mly", line 208, characters 0-9:
Warning: the precedence level assigned to ELSE is never useful.
File "macrodown.mly", line 215, characters 0-5:
Warning: the precedence level assigned to EQ is never useful.
File "macrodown.mly", line 216, characters 0-5:
Warning: the precedence level assigned to GEQ is never useful.
File "macrodown.mly", line 216, characters 0-5:
Warning: the precedence level assigned to GT is never useful.
File "macrodown.mly", line 208, characters 0-9:
Warning: the precedence level assigned to IF is never useful.
File "macrodown.mly", line 207, characters 0-9:
Warning: the precedence level assigned to IN is never useful.
File "macrodown.mly", line 213, characters 0-5:
Warning: the precedence level assigned to LAND is never useful.
File "macrodown.mly", line 216, characters 0-5:
Warning: the precedence level assigned to LEQ is never useful.
File "macrodown.mly", line 207, characters 0-9:
Warning: the precedence level assigned to LET is never useful.
File "macrodown.mly", line 207, characters 0-9:
Warning: the precedence level assigned to LETAND is never useful.
File "macrodown.mly", line 207, characters 0-9:
Warning: the precedence level assigned to LETMUTABLE is never useful.
File "macrodown.mly", line 214, characters 0-9:
Warning: the precedence level assigned to LNOT is never useful.
File "macrodown.mly", line 212, characters 0-5:
Warning: the precedence level assigned to LOR is never useful.
File "macrodown.mly", line 222, characters 0-9:
Warning: the precedence level assigned to LPAREN is never useful.
File "macrodown.mly", line 216, characters 0-5:
Warning: the precedence level assigned to LT is never useful.
File "macrodown.mly", line 215, characters 0-5:
Warning: the precedence level assigned to NEQ is never useful.
File "macrodown.mly", line 207, characters 0-9:
Warning: the precedence level assigned to OVERWRITEEQ is never useful.
File "macrodown.mly", line 209, characters 0-5:
Warning: the precedence level assigned to OVERWRITEGLOBALHASH is never useful.
File "macrodown.mly", line 222, characters 0-9:
Warning: the precedence level assigned to RPAREN is never useful.
File "macrodown.mly", line 208, characters 0-9:
Warning: the precedence level assigned to THEN is never useful.
File "macrodown.mly", line 221, characters 0-9:
Warning: the precedence level assigned to VAR is never useful.
File "macrodown.mly", line 211, characters 0-9:
Warning: the precedence level assigned to WHILE is never useful.
171 out of 363 states have a default reduction.
125 out of 363 states are represented.
0 out of 106 symbols keep track of their start position.
0 out of 106 symbols keep track of their end position.
134 out of 213 productions exploit shiftreduce optimization.
0 out of 363 states can peek at an error.
979 functions before inlining, 93 functions after inlining.
