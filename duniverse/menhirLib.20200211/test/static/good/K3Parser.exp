File "K3Parser.mly", line 128, characters 12-21:
Warning: the token COLONGETS is unused.
File "K3Parser.mly", line 146, characters 7-13:
Warning: the token EFFECT is unused.
File "K3Parser.mly", line 106, characters 7-10:
Warning: the token EOF is unused.
File "K3Parser.mly", line 115, characters 42-46:
Warning: the token HASH is unused.
File "K3Parser.mly", line 121, characters 17-24:
Warning: the token LRARROW is unused.
File "K3Parser.mly", line 146, characters 14-22:
Warning: the token PARALLEL is unused.
File "K3Parser.mly", line 104, characters 7-12:
Warning: the token RANGE is unused.
File "K3Parser.mly", line 134, characters 12-16:
Warning: the token RANK is unused.
File "K3Parser.mly", line 97, characters 20-23:
Warning: the token TOP is unused.
File "K3Parser.mly", line 733, characters 0-15:
Warning: symbol identifier_list is unreachable from any of the start symbol(s).
File "K3Parser.mly", line 728, characters 0-12:
Warning: symbol integer_list is unreachable from any of the start symbol(s).
Grammar has 53 nonterminal symbols, among which 4 start symbols.
Grammar has 120 terminal symbols.
Grammar has 303 productions.
nullable(variable) = false
nullable(value_typed_identifier_list) = false
nullable(value_typed_identifier) = false
nullable(type_expr_tuple) = false
nullable(type_expr_list) = false
nullable(type_expr) = false
nullable(tuple_index) = false
nullable(tuple) = false
nullable(transformers) = false
nullable(stream) = false
nullable(resource_pattern) = false
nullable(resource) = false
nullable(range) = false
nullable(program_test) = false
nullable(program) = false
nullable(predicate) = false
nullable(named_expr_list) = false
nullable(mutation) = false
nullable(letin) = false
nullable(lambda) = false
nullable(int_list_list) = false
nullable(int_list) = false
nullable(instruction) = false
nullable(identifier_stream) = false
nullable(id_unknown) = false
nullable(id_list) = false
nullable(handle) = false
nullable(fn_type_expr_list) = false
nullable(flow_statement) = false
nullable(flow_program) = false
nullable(expression_test_list) = false
nullable(expression_test) = false
nullable(expr_seq) = false
nullable(expr_list) = false
nullable(expr) = false
nullable(declaration) = false
nullable(constant) = false
nullable(conditional) = false
nullable(collection_type) = false
nullable(collection) = false
nullable(check_expr) = false
nullable(case) = false
nullable(block) = false
nullable(bind) = false
nullable(arithmetic) = false
nullable(arg_list) = false
nullable(arg) = false
nullable(annotations) = false
nullable(annotation) = false
nullable(annotated_collection_type) = false
nullable(anno_expr) = false
nullable(address) = false
nullable(access) = false
first(variable) = IDENTIFIER
first(value_typed_identifier_list) = IDENTIFIER
first(value_typed_identifier) = IDENTIFIER
first(type_expr_tuple) = TYPE MUT MAYBE LPAREN LBRACKETLT LBRACKETHASH LBRACKETCOLON LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE INDIRECT
first(type_expr_list) = TYPE MUT MAYBE LPAREN LBRACKETLT LBRACKETHASH LBRACKETCOLON LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE INDIRECT
first(type_expr) = TYPE MUT MAYBE LPAREN LBRACKETLT LBRACKETHASH LBRACKETCOLON LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE INDIRECT
first(tuple_index) = UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT STRING SORT SIZE SEND PEEK_WITH_VID PEEK NOTHING NOT NEG MIN_WITH MAP LPAREN LET LBRACKETLT LBRACKETHASH LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE JUST ITERATE IP INTEGER INSERT INDIRECT IGNORE IF IDENTIFIER GROUPBYAGGREGATE FLOAT FLATTEN FILTERGEQ FILTER DO DELETE_PREFIX DELETE CASE BOOL BIND BACKSLASH AT_WITH AGGREGATEV AGGREGATE
first(tuple) = UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT STRING SORT SIZE SEND PEEK_WITH_VID PEEK NOTHING NOT NEG MIN_WITH MAP LPAREN LET LBRACKETLT LBRACKETHASH LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE JUST ITERATE IP INTEGER INSERT INDIRECT IGNORE IF IDENTIFIER GROUPBYAGGREGATE FLOAT FLATTEN FILTERGEQ FILTER DO DELETE_PREFIX DELETE CASE BOOL BIND BACKSLASH AT_WITH AGGREGATEV AGGREGATE
first(transformers) = UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT STRING SORT SIZE SEND PEEK_WITH_VID PEEK NOTHING NOT NEG MIN_WITH MAP LPAREN LET LBRACKETLT LBRACKETHASH LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE JUST ITERATE IP INTEGER INSERT INDIRECT IGNORE IF IDENTIFIER GROUPBYAGGREGATE FLOAT FLATTEN FILTERGEQ FILTER DO DELETE_PREFIX DELETE CASE BOOL BIND BACKSLASH AT_WITH AGGREGATEV AGGREGATE
first(stream) = STREAM RANDOM
first(resource_pattern) = LPAREN IDENTIFIER
first(resource) = SOURCE SINK
first(range) = LBRACKETHASH LBRACKET LBRACEBAR LBRACE
first(program_test) = TRIGGER SOURCE SINK ROLE FOREIGN DEFAULT DECLARE CONSUME BINDFLOW BIND
first(program) = TRIGGER SOURCE SINK ROLE FOREIGN DEFAULT DECLARE CONSUME BINDFLOW BIND
first(predicate) = UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT STRING SORT SIZE SEND PEEK_WITH_VID PEEK NOTHING NOT NEG MIN_WITH MAP LPAREN LET LBRACKETLT LBRACKETHASH LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE JUST ITERATE IP INTEGER INSERT INDIRECT IGNORE IF IDENTIFIER GROUPBYAGGREGATE FLOAT FLATTEN FILTERGEQ FILTER DO DELETE_PREFIX DELETE CASE BOOL BIND BACKSLASH AT_WITH AGGREGATEV AGGREGATE
first(named_expr_list) = UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT STRING SORT SIZE SEND PEEK_WITH_VID PEEK NOTHING NOT NEG MIN_WITH MAP LPAREN LET LBRACKETLT LBRACKETHASH LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE JUST ITERATE IP INTEGER INSERT INDIRECT IGNORE IF IDENTIFIER GROUPBYAGGREGATE FLOAT FLATTEN FILTERGEQ FILTER DO DELETE_PREFIX DELETE CASE BOOL BIND BACKSLASH AT_WITH AGGREGATEV AGGREGATE
first(mutation) = UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT STRING SORT SIZE SEND PEEK_WITH_VID PEEK NOTHING NOT NEG MIN_WITH MAP LPAREN LET LBRACKETLT LBRACKETHASH LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE JUST ITERATE IP INTEGER INSERT INDIRECT IGNORE IF IDENTIFIER GROUPBYAGGREGATE FLOAT FLATTEN FILTERGEQ FILTER DO DELETE_PREFIX DELETE CASE BOOL BIND BACKSLASH AT_WITH AGGREGATEV AGGREGATE
first(letin) = LET
first(lambda) = BACKSLASH
first(int_list_list) = INTEGER
first(int_list) = INTEGER
first(instruction) = CONSUME
first(identifier_stream) = IDENTIFIER
first(id_unknown) = UNKNOWN IDENTIFIER
first(id_list) = UNKNOWN IDENTIFIER
first(handle) = SOCKET FILE
first(fn_type_expr_list) = TYPE MUT MAYBE LPAREN LBRACKETLT LBRACKETHASH LBRACKETCOLON LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE INDIRECT
first(flow_statement) = TRIGGER SOURCE SINK CONSUME BINDFLOW BIND
first(flow_program) = TRIGGER SOURCE SINK CONSUME BINDFLOW BIND
first(expression_test_list) = UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT TRIGGER STRING SOURCE SORT SIZE SINK SEND ROLE PEEK_WITH_VID PEEK NOTHING NOT NEG MIN_WITH MAP LPAREN LET LBRACKETLT LBRACKETHASH LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE JUST ITERATE IP INTEGER INSERT INDIRECT IGNORE IF IDENTIFIER GROUPBYAGGREGATE FOREIGN FLOAT FLATTEN FILTERGEQ FILTER DO DELETE_PREFIX DELETE DEFAULT DECLARE CONSUME CASE BOOL BINDFLOW BIND BACKSLASH AT_WITH AGGREGATEV AGGREGATE
first(expression_test) = UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT TRIGGER STRING SOURCE SORT SIZE SINK SEND ROLE PEEK_WITH_VID PEEK NOTHING NOT NEG MIN_WITH MAP LPAREN LET LBRACKETLT LBRACKETHASH LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE JUST ITERATE IP INTEGER INSERT INDIRECT IGNORE IF IDENTIFIER GROUPBYAGGREGATE FOREIGN FLOAT FLATTEN FILTERGEQ FILTER DO DELETE_PREFIX DELETE DEFAULT DECLARE CONSUME CASE BOOL BINDFLOW BIND BACKSLASH AT_WITH AGGREGATEV AGGREGATE
first(expr_seq) = UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT STRING SORT SIZE SEND PEEK_WITH_VID PEEK NOTHING NOT NEG MIN_WITH MAP LPAREN LET LBRACKETLT LBRACKETHASH LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE JUST ITERATE IP INTEGER INSERT INDIRECT IGNORE IF IDENTIFIER GROUPBYAGGREGATE FLOAT FLATTEN FILTERGEQ FILTER DO DELETE_PREFIX DELETE CASE BOOL BIND BACKSLASH AT_WITH AGGREGATEV AGGREGATE
first(expr_list) = UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT STRING SORT SIZE SEND PEEK_WITH_VID PEEK NOTHING NOT NEG MIN_WITH MAP LPAREN LET LBRACKETLT LBRACKETHASH LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE JUST ITERATE IP INTEGER INSERT INDIRECT IGNORE IF IDENTIFIER GROUPBYAGGREGATE FLOAT FLATTEN FILTERGEQ FILTER DO DELETE_PREFIX DELETE CASE BOOL BIND BACKSLASH AT_WITH AGGREGATEV AGGREGATE
first(expr) = UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT STRING SORT SIZE SEND PEEK_WITH_VID PEEK NOTHING NOT NEG MIN_WITH MAP LPAREN LET LBRACKETLT LBRACKETHASH LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE JUST ITERATE IP INTEGER INSERT INDIRECT IGNORE IF IDENTIFIER GROUPBYAGGREGATE FLOAT FLATTEN FILTERGEQ FILTER DO DELETE_PREFIX DELETE CASE BOOL BIND BACKSLASH AT_WITH AGGREGATEV AGGREGATE
first(declaration) = TRIGGER SOURCE SINK ROLE FOREIGN DEFAULT DECLARE CONSUME BINDFLOW BIND
first(constant) = UNKNOWN UNIT STRING IP INTEGER IDENTIFIER FLOAT BOOL
first(conditional) = IF
first(collection_type) = LBRACKETLT LBRACKETHASH LBRACKETCOLON LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE
first(collection) = LBRACKETLT LBRACKETHASH LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE
first(check_expr) = IDENTIFIER
first(case) = CASE
first(block) = DO
first(bind) = BIND
first(arithmetic) = UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT STRING SORT SIZE SEND PEEK_WITH_VID PEEK NOTHING NOT NEG MIN_WITH MAP LPAREN LET LBRACKETLT LBRACKETHASH LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE JUST ITERATE IP INTEGER INSERT INDIRECT IGNORE IF IDENTIFIER GROUPBYAGGREGATE FLOAT FLATTEN FILTERGEQ FILTER DO DELETE_PREFIX DELETE CASE BOOL BIND BACKSLASH AT_WITH AGGREGATEV AGGREGATE
first(arg_list) = UNKNOWN LPAREN IDENTIFIER
first(arg) = UNKNOWN LPAREN IDENTIFIER
first(annotations) = IDENTIFIER
first(annotation) = IDENTIFIER
first(annotated_collection_type) = LBRACKETLT LBRACKETHASH LBRACKETCOLON LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE
first(anno_expr) = UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT STRING SORT SIZE SEND PEEK_WITH_VID PEEK NOTHING NOT NEG MIN_WITH MAP LPAREN LET LBRACKETLT LBRACKETHASH LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE JUST ITERATE IP INTEGER INSERT INDIRECT IGNORE IF IDENTIFIER GROUPBYAGGREGATE FLOAT FLATTEN FILTERGEQ FILTER DO DELETE_PREFIX DELETE CASE BOOL BIND BACKSLASH AT_WITH AGGREGATEV AGGREGATE
first(address) = IP IDENTIFIER
first(access) = UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT STRING SORT SIZE SEND PEEK_WITH_VID PEEK NOTHING NOT NEG MIN_WITH MAP LPAREN LET LBRACKETLT LBRACKETHASH LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE JUST ITERATE IP INTEGER INSERT INDIRECT IGNORE IF IDENTIFIER GROUPBYAGGREGATE FLOAT FLATTEN FILTERGEQ FILTER DO DELETE_PREFIX DELETE CASE BOOL BIND BACKSLASH AT_WITH AGGREGATEV AGGREGATE
minimal(variable) = (* 1 *) IDENTIFIER
minimal(value_typed_identifier_list) = (* 3 *) IDENTIFIER COLON TYPE
minimal(value_typed_identifier) = (* 3 *) IDENTIFIER COLON TYPE
minimal(type_expr_tuple) = (* 1 *) TYPE
minimal(type_expr_list) = (* 1 *) TYPE
minimal(type_expr) = (* 1 *) TYPE
minimal(tuple_index) = (* 5 *) UNKNOWN PERIOD LBRACKET INTEGER RBRACKET
minimal(tuple) = (* 1 *) UNKNOWN
minimal(transformers) = (* 2 *) MAP error
minimal(stream) = (* 4 *) STREAM LPAREN UNKNOWN RPAREN
minimal(resource_pattern) = (* 1 *) IDENTIFIER
minimal(resource) = (* 5 *) SOURCE PATTERN IDENTIFIER GETS IDENTIFIER
minimal(range) = (* 9 *) LBRACE UNKNOWN COLON COLON UNKNOWN COLON COLON UNKNOWN RBRACE
minimal(program_test) = (* 3 *) CONSUME IDENTIFIER error
minimal(program) = (* 2 *) CONSUME IDENTIFIER
minimal(predicate) = (* 2 *) NOT UNKNOWN
minimal(named_expr_list) = (* 3 *) UNKNOWN GETS error
minimal(mutation) = (* 3 *) UPSERT_WITH_BEFORE LPAREN error
minimal(letin) = (* 2 *) LET error
minimal(lambda) = (* 2 *) BACKSLASH error
minimal(int_list_list) = (* 1 *) INTEGER
minimal(int_list) = (* 1 *) INTEGER
minimal(instruction) = (* 2 *) CONSUME IDENTIFIER
minimal(identifier_stream) = (* 1 *) IDENTIFIER
minimal(id_unknown) = (* 1 *) UNKNOWN
minimal(id_list) = (* 1 *) UNKNOWN
minimal(handle) = (* 6 *) FILE LPAREN STRING COMMA IDENTIFIER RPAREN
minimal(fn_type_expr_list) = (* 1 *) TYPE
minimal(flow_statement) = (* 2 *) CONSUME IDENTIFIER
minimal(flow_program) = (* 2 *) CONSUME IDENTIFIER
minimal(expression_test_list) = (* 3 *) UNKNOWN EXPECTED error
minimal(expression_test) = (* 3 *) UNKNOWN EXPECTED error
minimal(expr_seq) = (* 1 *) UNKNOWN
minimal(expr_list) = (* 1 *) UNKNOWN
minimal(expr) = (* 1 *) UNKNOWN
minimal(declaration) = (* 2 *) CONSUME IDENTIFIER
minimal(constant) = (* 1 *) UNKNOWN
minimal(conditional) = (* 2 *) IF error
minimal(collection_type) = (* 3 *) LBRACE TYPE RBRACE
minimal(collection) = (* 3 *) LBRACE RBRACE error
minimal(check_expr) = (* 3 *) IDENTIFIER COLON UNKNOWN
minimal(case) = (* 2 *) CASE error
minimal(block) = (* 4 *) DO LBRACE UNKNOWN RBRACE
minimal(bind) = (* 2 *) BIND error
minimal(arithmetic) = (* 2 *) NEG error
minimal(arg_list) = (* 1 *) UNKNOWN
minimal(arg) = (* 1 *) UNKNOWN
minimal(annotations) = (* 1 *) IDENTIFIER
minimal(annotation) = (* 1 *) IDENTIFIER
minimal(annotated_collection_type) = (* 3 *) LBRACE TYPE RBRACE
minimal(anno_expr) = (* 1 *) UNKNOWN
minimal(address) = (* 3 *) IDENTIFIER COLON INTEGER
minimal(access) = (* 4 *) PEEK LPAREN UNKNOWN RPAREN
follow(variable) = error UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT TRIGGER TIMES THEN STRING SOURCE SORT SIZE SINK SEND SEMICOLON RPAREN ROLE RBRACKETLT RBRACKETHASH RBRACKETCOLON RBRACKET RBRACELT RBRACECOLON RBRACEBAR RBRACE PLUS PERIOD PEEK_WITH_VID PEEK OR OF NOTHING NOT NETWORK NEQ NEG MODULO MIN_WITH MAP LT LPAREN LET LEQ LBRACKETLT LBRACKETHASH LBRACKETGEQ LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE LARROW JUST ITERATE IP INTEGER INSERT INDIRECT IN IGNORE IF IDENTIFIER GT GROUPBYAGGREGATE GETS GEQ FOREIGN FLOAT FLATTEN FILTERGEQ FILTER EXPECTED EQ ELSE DO DIVIDE DELETE_PREFIX DELETE DEFAULT DECLARE CONSUME CONCAT COMMA COLON CASE BOOL BINDFLOW BIND BAR BACKSLASH AT_WITH AS ANNOTATE AND AGGREGATEV AGGREGATE #
follow(value_typed_identifier_list) = RBRACE
follow(value_typed_identifier) = RPAREN RBRACE RARROW LBRACE COMMA
follow(type_expr_tuple) = RPAREN RBRACKETLT RBRACKETHASH RBRACKETCOLON RBRACKET RBRACELT RBRACECOLON RBRACEBAR RBRACE BAR
follow(type_expr_list) = RPAREN RBRACKETLT RBRACKETHASH RBRACKETCOLON RBRACKET RBRACELT RBRACECOLON RBRACEBAR RBRACE BAR
follow(type_expr) = error UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT TRIGGER TIMES THEN STRING SOURCE SORT SIZE SINK SEND SEMICOLON RPAREN ROLE RBRACKETLT RBRACKETHASH RBRACKETCOLON RBRACKET RBRACELT RBRACECOLON RBRACEBAR RBRACE RARROW PLUS PERIOD PEEK_WITH_VID PEEK OR OF NOTHING NOT NETWORK NEQ NEG MODULO MIN_WITH MAP LT LPAREN LET LEQ LBRACKETLT LBRACKETHASH LBRACKETGEQ LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE LARROW JUST ITERATE IP INTEGER INSERT INDIRECT IN IGNORE IF IDENTIFIER GT GROUPBYAGGREGATE GETS GEQ FOREIGN FLOAT FLATTEN FILTERGEQ FILTER EXPECTED EQ ELSE DO DIVIDE DELETE_PREFIX DELETE DEFAULT DECLARE CONSUME CONCAT COMMA COLON CASE BOOL BINDFLOW BIND BAR BACKSLASH AT_WITH AS ANNOTATE AND AGGREGATEV AGGREGATE #
follow(tuple_index) = error UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT TRIGGER TIMES THEN STRING SOURCE SORT SIZE SINK SEND SEMICOLON RPAREN ROLE RBRACKETLT RBRACKETHASH RBRACKETCOLON RBRACKET RBRACELT RBRACECOLON RBRACEBAR RBRACE PLUS PERIOD PEEK_WITH_VID PEEK OR OF NOTHING NOT NETWORK NEQ NEG MODULO MIN_WITH MAP LT LPAREN LET LEQ LBRACKETLT LBRACKETHASH LBRACKETGEQ LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE LARROW JUST ITERATE IP INTEGER INSERT INDIRECT IN IGNORE IF IDENTIFIER GT GROUPBYAGGREGATE GETS GEQ FOREIGN FLOAT FLATTEN FILTERGEQ FILTER EXPECTED EQ ELSE DO DIVIDE DELETE_PREFIX DELETE DEFAULT DECLARE CONSUME CONCAT COMMA COLON CASE BOOL BINDFLOW BIND BAR BACKSLASH AT_WITH AS ANNOTATE AND AGGREGATEV AGGREGATE #
follow(tuple) = SEMICOLON RPAREN RBRACKETLT RBRACKETHASH RBRACKETCOLON RBRACKET RBRACELT RBRACECOLON RBRACEBAR RBRACE COMMA BAR
follow(transformers) = error UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT TRIGGER TIMES THEN STRING SOURCE SORT SIZE SINK SEND SEMICOLON RPAREN ROLE RBRACKETLT RBRACKETHASH RBRACKETCOLON RBRACKET RBRACELT RBRACECOLON RBRACEBAR RBRACE PLUS PERIOD PEEK_WITH_VID PEEK OR OF NOTHING NOT NETWORK NEQ NEG MODULO MIN_WITH MAP LT LPAREN LET LEQ LBRACKETLT LBRACKETHASH LBRACKETGEQ LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE LARROW JUST ITERATE IP INTEGER INSERT INDIRECT IN IGNORE IF IDENTIFIER GT GROUPBYAGGREGATE GETS GEQ FOREIGN FLOAT FLATTEN FILTERGEQ FILTER EXPECTED EQ ELSE DO DIVIDE DELETE_PREFIX DELETE DEFAULT DECLARE CONSUME CONCAT COMMA COLON CASE BOOL BINDFLOW BIND BAR BACKSLASH AT_WITH AS ANNOTATE AND AGGREGATEV AGGREGATE #
follow(stream) = error UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT TRIGGER STRING SOURCE SORT SIZE SINK SEND ROLE RBRACE PEEK_WITH_VID PEEK NOTHING NOT NETWORK NEG MIN_WITH MAP LPAREN LET LBRACKETLT LBRACKETHASH LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE JUST ITERATE IP INTEGER INSERT INDIRECT IGNORE IF IDENTIFIER GROUPBYAGGREGATE FOREIGN FLOAT FLATTEN FILTERGEQ FILTER EXPECTED DO DELETE_PREFIX DELETE DEFAULT DECLARE CONSUME CASE BOOL BINDFLOW BIND BACKSLASH AT_WITH AGGREGATEV AGGREGATE #
follow(resource_pattern) = error UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT TRIGGER TIMES STRING SOURCE SORT SIZE SINK SEND RPAREN ROLE RBRACE QUESTION PEEK_WITH_VID PEEK OR NOTHING NOT NETWORK NEG MIN_WITH MAP LPAREN LET LBRACKETLT LBRACKETHASH LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE JUST ITERATE IP INTEGER INSERT INDIRECT IGNORE IF IDENTIFIER GROUPBYAGGREGATE FOREIGN FLOAT FLATTEN FILTERGEQ FILTER EXPECTED DO DELETE_PREFIX DELETE DEFAULT DECLARE CONSUME CASE BOOL BINDFLOW BIND BACKSLASH AT_WITH AGGREGATEV AGGREGATE #
follow(resource) = error UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT TRIGGER STRING SOURCE SORT SIZE SINK SEND ROLE RBRACE PEEK_WITH_VID PEEK NOTHING NOT NETWORK NEG MIN_WITH MAP LPAREN LET LBRACKETLT LBRACKETHASH LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE JUST ITERATE IP INTEGER INSERT INDIRECT IGNORE IF IDENTIFIER GROUPBYAGGREGATE FOREIGN FLOAT FLATTEN FILTERGEQ FILTER EXPECTED DO DELETE_PREFIX DELETE DEFAULT DECLARE CONSUME CASE BOOL BINDFLOW BIND BACKSLASH AT_WITH AGGREGATEV AGGREGATE #
follow(range) = error UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT TRIGGER TIMES THEN STRING SOURCE SORT SIZE SINK SEND SEMICOLON RPAREN ROLE RBRACKETLT RBRACKETHASH RBRACKETCOLON RBRACKET RBRACELT RBRACECOLON RBRACEBAR RBRACE PLUS PERIOD PEEK_WITH_VID PEEK OR OF NOTHING NOT NETWORK NEQ NEG MODULO MIN_WITH MAP LT LPAREN LET LEQ LBRACKETLT LBRACKETHASH LBRACKETGEQ LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE LARROW JUST ITERATE IP INTEGER INSERT INDIRECT IN IGNORE IF IDENTIFIER GT GROUPBYAGGREGATE GETS GEQ FOREIGN FLOAT FLATTEN FILTERGEQ FILTER EXPECTED EQ ELSE DO DIVIDE DELETE_PREFIX DELETE DEFAULT DECLARE CONSUME CONCAT COMMA COLON CASE BOOL BINDFLOW BIND BAR BACKSLASH AT_WITH AS ANNOTATE AND AGGREGATEV AGGREGATE #
follow(program_test) = #
follow(program) = error UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT STRING SORT SIZE SEND PEEK_WITH_VID PEEK NOTHING NOT NETWORK NEG MIN_WITH MAP LPAREN LET LBRACKETLT LBRACKETHASH LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE JUST ITERATE IP INTEGER INSERT INDIRECT IGNORE IF IDENTIFIER GROUPBYAGGREGATE FLOAT FLATTEN FILTERGEQ FILTER EXPECTED DO DELETE_PREFIX DELETE CASE BOOL BIND BACKSLASH AT_WITH AGGREGATEV AGGREGATE #
follow(predicate) = error UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT TRIGGER TIMES THEN STRING SOURCE SORT SIZE SINK SEND SEMICOLON RPAREN ROLE RBRACKETLT RBRACKETHASH RBRACKETCOLON RBRACKET RBRACELT RBRACECOLON RBRACEBAR RBRACE PLUS PERIOD PEEK_WITH_VID PEEK OR OF NOTHING NOT NETWORK NEQ NEG MODULO MIN_WITH MAP LT LPAREN LET LEQ LBRACKETLT LBRACKETHASH LBRACKETGEQ LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE LARROW JUST ITERATE IP INTEGER INSERT INDIRECT IN IGNORE IF IDENTIFIER GT GROUPBYAGGREGATE GETS GEQ FOREIGN FLOAT FLATTEN FILTERGEQ FILTER EXPECTED EQ ELSE DO DIVIDE DELETE_PREFIX DELETE DEFAULT DECLARE CONSUME CONCAT COMMA COLON CASE BOOL BINDFLOW BIND BAR BACKSLASH AT_WITH AS ANNOTATE AND AGGREGATEV AGGREGATE #
follow(named_expr_list) = #
follow(mutation) = error UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT TRIGGER TIMES THEN STRING SOURCE SORT SIZE SINK SEND SEMICOLON RPAREN ROLE RBRACKETLT RBRACKETHASH RBRACKETCOLON RBRACKET RBRACELT RBRACECOLON RBRACEBAR RBRACE PLUS PERIOD PEEK_WITH_VID PEEK OR OF NOTHING NOT NETWORK NEQ NEG MODULO MIN_WITH MAP LT LPAREN LET LEQ LBRACKETLT LBRACKETHASH LBRACKETGEQ LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE LARROW JUST ITERATE IP INTEGER INSERT INDIRECT IN IGNORE IF IDENTIFIER GT GROUPBYAGGREGATE GETS GEQ FOREIGN FLOAT FLATTEN FILTERGEQ FILTER EXPECTED EQ ELSE DO DIVIDE DELETE_PREFIX DELETE DEFAULT DECLARE CONSUME CONCAT COMMA COLON CASE BOOL BINDFLOW BIND BAR BACKSLASH AT_WITH AS ANNOTATE AND AGGREGATEV AGGREGATE #
follow(letin) = error UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT TRIGGER TIMES THEN STRING SOURCE SORT SIZE SINK SEND SEMICOLON RPAREN ROLE RBRACKETLT RBRACKETHASH RBRACKETCOLON RBRACKET RBRACELT RBRACECOLON RBRACEBAR RBRACE PLUS PERIOD PEEK_WITH_VID PEEK OR OF NOTHING NOT NETWORK NEQ NEG MODULO MIN_WITH MAP LT LPAREN LET LEQ LBRACKETLT LBRACKETHASH LBRACKETGEQ LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE LARROW JUST ITERATE IP INTEGER INSERT INDIRECT IN IGNORE IF IDENTIFIER GT GROUPBYAGGREGATE GETS GEQ FOREIGN FLOAT FLATTEN FILTERGEQ FILTER EXPECTED EQ ELSE DO DIVIDE DELETE_PREFIX DELETE DEFAULT DECLARE CONSUME CONCAT COMMA COLON CASE BOOL BINDFLOW BIND BAR BACKSLASH AT_WITH AS ANNOTATE AND AGGREGATEV AGGREGATE #
follow(lambda) = error UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT TRIGGER TIMES THEN STRING SOURCE SORT SIZE SINK SEND SEMICOLON RPAREN ROLE RBRACKETLT RBRACKETHASH RBRACKETCOLON RBRACKET RBRACELT RBRACECOLON RBRACEBAR RBRACE PLUS PERIOD PEEK_WITH_VID PEEK OR OF NOTHING NOT NETWORK NEQ NEG MODULO MIN_WITH MAP LT LPAREN LET LEQ LBRACKETLT LBRACKETHASH LBRACKETGEQ LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE LARROW JUST ITERATE IP INTEGER INSERT INDIRECT IN IGNORE IF IDENTIFIER GT GROUPBYAGGREGATE GETS GEQ FOREIGN FLOAT FLATTEN FILTERGEQ FILTER EXPECTED EQ ELSE DO DIVIDE DELETE_PREFIX DELETE DEFAULT DECLARE CONSUME CONCAT COMMA COLON CASE BOOL BINDFLOW BIND BAR BACKSLASH AT_WITH AS ANNOTATE AND AGGREGATEV AGGREGATE #
follow(int_list_list) = RBRACKETLT
follow(int_list) = SEMICOLON RBRACKETLT
follow(instruction) = error UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT TRIGGER STRING SOURCE SORT SIZE SINK SEND ROLE RBRACE PEEK_WITH_VID PEEK NOTHING NOT NETWORK NEG MIN_WITH MAP LPAREN LET LBRACKETLT LBRACKETHASH LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE JUST ITERATE IP INTEGER INSERT INDIRECT IGNORE IF IDENTIFIER GROUPBYAGGREGATE FOREIGN FLOAT FLATTEN FILTERGEQ FILTER EXPECTED DO DELETE_PREFIX DELETE DEFAULT DECLARE CONSUME CASE BOOL BINDFLOW BIND BACKSLASH AT_WITH AGGREGATEV AGGREGATE #
follow(identifier_stream) = SEMICOLON RBRACE
follow(id_unknown) = RPAREN RARROW COMMA
follow(id_list) = RPAREN
follow(handle) = error UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT TRIGGER STRING SOURCE SORT SIZE SINK SEND ROLE RBRACE PEEK_WITH_VID PEEK NOTHING NOT NETWORK NEG MIN_WITH MAP LPAREN LET LBRACKETLT LBRACKETHASH LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE JUST ITERATE IP INTEGER INSERT INDIRECT IGNORE IF IDENTIFIER GROUPBYAGGREGATE FOREIGN FLOAT FLATTEN FILTERGEQ FILTER EXPECTED DO DELETE_PREFIX DELETE DEFAULT DECLARE CONSUME CASE BOOL BINDFLOW BIND BACKSLASH AT_WITH AGGREGATEV AGGREGATE #
follow(fn_type_expr_list) = error UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT TRIGGER TIMES THEN STRING SOURCE SORT SIZE SINK SEND SEMICOLON RPAREN ROLE RBRACKETLT RBRACKETHASH RBRACKETCOLON RBRACKET RBRACELT RBRACECOLON RBRACEBAR RBRACE RARROW PLUS PERIOD PEEK_WITH_VID PEEK OR OF NOTHING NOT NETWORK NEQ NEG MODULO MIN_WITH MAP LT LPAREN LET LEQ LBRACKETLT LBRACKETHASH LBRACKETGEQ LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE LARROW JUST ITERATE IP INTEGER INSERT INDIRECT IN IGNORE IF IDENTIFIER GT GROUPBYAGGREGATE GETS GEQ FOREIGN FLOAT FLATTEN FILTERGEQ FILTER EXPECTED EQ ELSE DO DIVIDE DELETE_PREFIX DELETE DEFAULT DECLARE CONSUME CONCAT COMMA COLON CASE BOOL BINDFLOW BIND BAR BACKSLASH AT_WITH AS ANNOTATE AND AGGREGATEV AGGREGATE #
follow(flow_statement) = error UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT TRIGGER STRING SOURCE SORT SIZE SINK SEND ROLE RBRACE PEEK_WITH_VID PEEK NOTHING NOT NETWORK NEG MIN_WITH MAP LPAREN LET LBRACKETLT LBRACKETHASH LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE JUST ITERATE IP INTEGER INSERT INDIRECT IGNORE IF IDENTIFIER GROUPBYAGGREGATE FOREIGN FLOAT FLATTEN FILTERGEQ FILTER EXPECTED DO DELETE_PREFIX DELETE DEFAULT DECLARE CONSUME CASE BOOL BINDFLOW BIND BACKSLASH AT_WITH AGGREGATEV AGGREGATE #
follow(flow_program) = error UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT TRIGGER STRING SOURCE SORT SIZE SINK SEND ROLE RBRACE PEEK_WITH_VID PEEK NOTHING NOT NETWORK NEG MIN_WITH MAP LPAREN LET LBRACKETLT LBRACKETHASH LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE JUST ITERATE IP INTEGER INSERT INDIRECT IGNORE IF IDENTIFIER GROUPBYAGGREGATE FOREIGN FLOAT FLATTEN FILTERGEQ FILTER EXPECTED DO DELETE_PREFIX DELETE DEFAULT DECLARE CONSUME CASE BOOL BINDFLOW BIND BACKSLASH AT_WITH AGGREGATEV AGGREGATE #
follow(expression_test_list) = SEMICOLON #
follow(expression_test) = #
follow(expr_seq) = RBRACKETLT RBRACKETHASH RBRACKETCOLON RBRACKET RBRACELT RBRACECOLON RBRACEBAR RBRACE BAR
follow(expr_list) = SEMICOLON RPAREN RBRACKETLT RBRACKETHASH RBRACKETCOLON RBRACKET RBRACELT RBRACECOLON RBRACEBAR RBRACE COMMA BAR
follow(expr) = error UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT TRIGGER TIMES THEN STRING SOURCE SORT SIZE SINK SEND SEMICOLON RPAREN ROLE RBRACKETLT RBRACKETHASH RBRACKETCOLON RBRACKET RBRACELT RBRACECOLON RBRACEBAR RBRACE PLUS PERIOD PEEK_WITH_VID PEEK OR OF NOTHING NOT NETWORK NEQ NEG MODULO MIN_WITH MAP LT LPAREN LET LEQ LBRACKETLT LBRACKETHASH LBRACKETGEQ LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE LARROW JUST ITERATE IP INTEGER INSERT INDIRECT IN IGNORE IF IDENTIFIER GT GROUPBYAGGREGATE GETS GEQ FOREIGN FLOAT FLATTEN FILTERGEQ FILTER EXPECTED EQ ELSE DO DIVIDE DELETE_PREFIX DELETE DEFAULT DECLARE CONSUME CONCAT COMMA COLON CASE BOOL BINDFLOW BIND BAR BACKSLASH AT_WITH AS ANNOTATE AND AGGREGATEV AGGREGATE #
follow(declaration) = error UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT TRIGGER STRING SOURCE SORT SIZE SINK SEND ROLE PEEK_WITH_VID PEEK NOTHING NOT NETWORK NEG MIN_WITH MAP LPAREN LET LBRACKETLT LBRACKETHASH LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE JUST ITERATE IP INTEGER INSERT INDIRECT IGNORE IF IDENTIFIER GROUPBYAGGREGATE FOREIGN FLOAT FLATTEN FILTERGEQ FILTER EXPECTED DO DELETE_PREFIX DELETE DEFAULT DECLARE CONSUME CASE BOOL BINDFLOW BIND BACKSLASH AT_WITH AGGREGATEV AGGREGATE #
follow(constant) = error UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT TRIGGER TIMES THEN STRING SOURCE SORT SIZE SINK SEND SEMICOLON RPAREN ROLE RBRACKETLT RBRACKETHASH RBRACKETCOLON RBRACKET RBRACELT RBRACECOLON RBRACEBAR RBRACE PLUS PERIOD PEEK_WITH_VID PEEK OR OF NOTHING NOT NETWORK NEQ NEG MODULO MIN_WITH MAP LT LPAREN LET LEQ LBRACKETLT LBRACKETHASH LBRACKETGEQ LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE LARROW JUST ITERATE IP INTEGER INSERT INDIRECT IN IGNORE IF IDENTIFIER GT GROUPBYAGGREGATE GETS GEQ FOREIGN FLOAT FLATTEN FILTERGEQ FILTER EXPECTED EQ ELSE DO DIVIDE DELETE_PREFIX DELETE DEFAULT DECLARE CONSUME CONCAT COMMA COLON CASE BOOL BINDFLOW BIND BAR BACKSLASH AT_WITH AS ANNOTATE AND AGGREGATEV AGGREGATE #
follow(conditional) = error UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT TRIGGER TIMES THEN STRING SOURCE SORT SIZE SINK SEND SEMICOLON RPAREN ROLE RBRACKETLT RBRACKETHASH RBRACKETCOLON RBRACKET RBRACELT RBRACECOLON RBRACEBAR RBRACE PLUS PERIOD PEEK_WITH_VID PEEK OR OF NOTHING NOT NETWORK NEQ NEG MODULO MIN_WITH MAP LT LPAREN LET LEQ LBRACKETLT LBRACKETHASH LBRACKETGEQ LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE LARROW JUST ITERATE IP INTEGER INSERT INDIRECT IN IGNORE IF IDENTIFIER GT GROUPBYAGGREGATE GETS GEQ FOREIGN FLOAT FLATTEN FILTERGEQ FILTER EXPECTED EQ ELSE DO DIVIDE DELETE_PREFIX DELETE DEFAULT DECLARE CONSUME CONCAT COMMA COLON CASE BOOL BINDFLOW BIND BAR BACKSLASH AT_WITH AS ANNOTATE AND AGGREGATEV AGGREGATE #
follow(collection_type) = error UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT TRIGGER TIMES THEN STRING SOURCE SORT SIZE SINK SEND SEMICOLON RPAREN ROLE RBRACKETLT RBRACKETHASH RBRACKETCOLON RBRACKET RBRACELT RBRACECOLON RBRACEBAR RBRACE RARROW PLUS PERIOD PEEK_WITH_VID PEEK OR OF NOTHING NOT NETWORK NEQ NEG MODULO MIN_WITH MAP LT LPAREN LET LEQ LBRACKETLT LBRACKETHASH LBRACKETGEQ LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE LARROW JUST ITERATE IP INTEGER INSERT INDIRECT IN IGNORE IF IDENTIFIER GT GROUPBYAGGREGATE GETS GEQ FOREIGN FLOAT FLATTEN FILTERGEQ FILTER EXPECTED EQ ELSE DO DIVIDE DELETE_PREFIX DELETE DEFAULT DECLARE CONSUME CONCAT COMMA COLON CASE BOOL BINDFLOW BIND BAR BACKSLASH AT_WITH AS ANNOTATE AND AGGREGATEV AGGREGATE #
follow(collection) = error UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT TRIGGER TIMES THEN STRING SOURCE SORT SIZE SINK SEND SEMICOLON RPAREN ROLE RBRACKETLT RBRACKETHASH RBRACKETCOLON RBRACKET RBRACELT RBRACECOLON RBRACEBAR RBRACE PLUS PERIOD PEEK_WITH_VID PEEK OR OF NOTHING NOT NETWORK NEQ NEG MODULO MIN_WITH MAP LT LPAREN LET LEQ LBRACKETLT LBRACKETHASH LBRACKETGEQ LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE LARROW JUST ITERATE IP INTEGER INSERT INDIRECT IN IGNORE IF IDENTIFIER GT GROUPBYAGGREGATE GETS GEQ FOREIGN FLOAT FLATTEN FILTERGEQ FILTER EXPECTED EQ ELSE DO DIVIDE DELETE_PREFIX DELETE DEFAULT DECLARE CONSUME CONCAT COMMA COLON CASE BOOL BINDFLOW BIND BAR BACKSLASH AT_WITH AS ANNOTATE AND AGGREGATEV AGGREGATE #
follow(check_expr) = SEMICOLON COMMA #
follow(case) = error UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT TRIGGER TIMES THEN STRING SOURCE SORT SIZE SINK SEND SEMICOLON RPAREN ROLE RBRACKETLT RBRACKETHASH RBRACKETCOLON RBRACKET RBRACELT RBRACECOLON RBRACEBAR RBRACE PLUS PERIOD PEEK_WITH_VID PEEK OR OF NOTHING NOT NETWORK NEQ NEG MODULO MIN_WITH MAP LT LPAREN LET LEQ LBRACKETLT LBRACKETHASH LBRACKETGEQ LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE LARROW JUST ITERATE IP INTEGER INSERT INDIRECT IN IGNORE IF IDENTIFIER GT GROUPBYAGGREGATE GETS GEQ FOREIGN FLOAT FLATTEN FILTERGEQ FILTER EXPECTED EQ ELSE DO DIVIDE DELETE_PREFIX DELETE DEFAULT DECLARE CONSUME CONCAT COMMA COLON CASE BOOL BINDFLOW BIND BAR BACKSLASH AT_WITH AS ANNOTATE AND AGGREGATEV AGGREGATE #
follow(block) = error UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT TRIGGER TIMES THEN STRING SOURCE SORT SIZE SINK SEND SEMICOLON RPAREN ROLE RBRACKETLT RBRACKETHASH RBRACKETCOLON RBRACKET RBRACELT RBRACECOLON RBRACEBAR RBRACE PLUS PERIOD PEEK_WITH_VID PEEK OR OF NOTHING NOT NETWORK NEQ NEG MODULO MIN_WITH MAP LT LPAREN LET LEQ LBRACKETLT LBRACKETHASH LBRACKETGEQ LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE LARROW JUST ITERATE IP INTEGER INSERT INDIRECT IN IGNORE IF IDENTIFIER GT GROUPBYAGGREGATE GETS GEQ FOREIGN FLOAT FLATTEN FILTERGEQ FILTER EXPECTED EQ ELSE DO DIVIDE DELETE_PREFIX DELETE DEFAULT DECLARE CONSUME CONCAT COMMA COLON CASE BOOL BINDFLOW BIND BAR BACKSLASH AT_WITH AS ANNOTATE AND AGGREGATEV AGGREGATE #
follow(bind) = error UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT TRIGGER TIMES THEN STRING SOURCE SORT SIZE SINK SEND SEMICOLON RPAREN ROLE RBRACKETLT RBRACKETHASH RBRACKETCOLON RBRACKET RBRACELT RBRACECOLON RBRACEBAR RBRACE PLUS PERIOD PEEK_WITH_VID PEEK OR OF NOTHING NOT NETWORK NEQ NEG MODULO MIN_WITH MAP LT LPAREN LET LEQ LBRACKETLT LBRACKETHASH LBRACKETGEQ LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE LARROW JUST ITERATE IP INTEGER INSERT INDIRECT IN IGNORE IF IDENTIFIER GT GROUPBYAGGREGATE GETS GEQ FOREIGN FLOAT FLATTEN FILTERGEQ FILTER EXPECTED EQ ELSE DO DIVIDE DELETE_PREFIX DELETE DEFAULT DECLARE CONSUME CONCAT COMMA COLON CASE BOOL BINDFLOW BIND BAR BACKSLASH AT_WITH AS ANNOTATE AND AGGREGATEV AGGREGATE #
follow(arithmetic) = error UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT TRIGGER TIMES THEN STRING SOURCE SORT SIZE SINK SEND SEMICOLON RPAREN ROLE RBRACKETLT RBRACKETHASH RBRACKETCOLON RBRACKET RBRACELT RBRACECOLON RBRACEBAR RBRACE PLUS PERIOD PEEK_WITH_VID PEEK OR OF NOTHING NOT NETWORK NEQ NEG MODULO MIN_WITH MAP LT LPAREN LET LEQ LBRACKETLT LBRACKETHASH LBRACKETGEQ LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE LARROW JUST ITERATE IP INTEGER INSERT INDIRECT IN IGNORE IF IDENTIFIER GT GROUPBYAGGREGATE GETS GEQ FOREIGN FLOAT FLATTEN FILTERGEQ FILTER EXPECTED EQ ELSE DO DIVIDE DELETE_PREFIX DELETE DEFAULT DECLARE CONSUME CONCAT COMMA COLON CASE BOOL BINDFLOW BIND BAR BACKSLASH AT_WITH AS ANNOTATE AND AGGREGATEV AGGREGATE #
follow(arg_list) = RPAREN
follow(arg) = RPAREN RARROW LBRACE COMMA
follow(annotations) = RBRACE
follow(annotation) = SEMICOLON RBRACE
follow(annotated_collection_type) = error UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT TRIGGER TIMES THEN STRING SOURCE SORT SIZE SINK SEND SEMICOLON RPAREN ROLE RBRACKETLT RBRACKETHASH RBRACKETCOLON RBRACKET RBRACELT RBRACECOLON RBRACEBAR RBRACE RARROW PLUS PERIOD PEEK_WITH_VID PEEK OR OF NOTHING NOT NETWORK NEQ NEG MODULO MIN_WITH MAP LT LPAREN LET LEQ LBRACKETLT LBRACKETHASH LBRACKETGEQ LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE LARROW JUST ITERATE IP INTEGER INSERT INDIRECT IN IGNORE IF IDENTIFIER GT GROUPBYAGGREGATE GETS GEQ FOREIGN FLOAT FLATTEN FILTERGEQ FILTER EXPECTED EQ ELSE DO DIVIDE DELETE_PREFIX DELETE DEFAULT DECLARE CONSUME CONCAT COMMA COLON CASE BOOL BINDFLOW BIND BAR BACKSLASH AT_WITH AS ANNOTATE AND AGGREGATEV AGGREGATE #
follow(anno_expr) = error UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT TRIGGER TIMES THEN STRING SOURCE SORT SIZE SINK SEND SEMICOLON RPAREN ROLE RBRACKETLT RBRACKETHASH RBRACKETCOLON RBRACKET RBRACELT RBRACECOLON RBRACEBAR RBRACE PLUS PERIOD PEEK_WITH_VID PEEK OR OF NOTHING NOT NETWORK NEQ NEG MODULO MIN_WITH MAP LT LPAREN LET LEQ LBRACKETLT LBRACKETHASH LBRACKETGEQ LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE LARROW JUST ITERATE IP INTEGER INSERT INDIRECT IN IGNORE IF IDENTIFIER GT GROUPBYAGGREGATE GETS GEQ FOREIGN FLOAT FLATTEN FILTERGEQ FILTER EXPECTED EQ ELSE DO DIVIDE DELETE_PREFIX DELETE DEFAULT DECLARE CONSUME CONCAT COMMA COLON CASE BOOL BINDFLOW BIND BAR BACKSLASH AT_WITH AS ANNOTATE AND AGGREGATEV AGGREGATE #
follow(address) = error UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT TRIGGER TIMES THEN STRING SOURCE SORT SIZE SINK SEND SEMICOLON RPAREN ROLE RBRACKETLT RBRACKETHASH RBRACKETCOLON RBRACKET RBRACELT RBRACECOLON RBRACEBAR RBRACE PLUS PERIOD PEEK_WITH_VID PEEK OR OF NOTHING NOT NETWORK NEQ NEG MODULO MIN_WITH MAP LT LPAREN LET LEQ LBRACKETLT LBRACKETHASH LBRACKETGEQ LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE LARROW JUST ITERATE IP INTEGER INSERT INDIRECT IN IGNORE IF IDENTIFIER GT GROUPBYAGGREGATE GETS GEQ FOREIGN FLOAT FLATTEN FILTERGEQ FILTER EXPECTED EQ ELSE DO DIVIDE DELETE_PREFIX DELETE DEFAULT DECLARE CONSUME CONCAT COMMA COLON CASE BOOL BINDFLOW BIND BAR BACKSLASH AT_WITH AS ANNOTATE AND AGGREGATEV AGGREGATE #
follow(access) = error UPSERT_WITH_BEFORE UPSERT_WITH UPDATE_SUFFIX UPDATE UNKNOWN UNIT TRIGGER TIMES THEN STRING SOURCE SORT SIZE SINK SEND SEMICOLON RPAREN ROLE RBRACKETLT RBRACKETHASH RBRACKETCOLON RBRACKET RBRACELT RBRACECOLON RBRACEBAR RBRACE PLUS PERIOD PEEK_WITH_VID PEEK OR OF NOTHING NOT NETWORK NEQ NEG MODULO MIN_WITH MAP LT LPAREN LET LEQ LBRACKETLT LBRACKETHASH LBRACKETGEQ LBRACKETCOLON LBRACKETBAR LBRACKET LBRACELT LBRACECOLON LBRACEBAR LBRACE LARROW JUST ITERATE IP INTEGER INSERT INDIRECT IN IGNORE IF IDENTIFIER GT GROUPBYAGGREGATE GETS GEQ FOREIGN FLOAT FLATTEN FILTERGEQ FILTER EXPECTED EQ ELSE DO DIVIDE DELETE_PREFIX DELETE DEFAULT DECLARE CONSUME CONCAT COMMA COLON CASE BOOL BINDFLOW BIND BAR BACKSLASH AT_WITH AS ANNOTATE AND AGGREGATEV AGGREGATE #
Built an LR(0) automaton with 762 states.
The grammar is not SLR(1) -- 70 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 1441 states.
565 shift/reduce conflicts were silently solved.
File "K3Parser.mly", line 177, characters 0-5:
Warning: the precedence level assigned to ANNOTATE is never useful.
File "K3Parser.mly", line 165, characters 0-6:
Warning: the precedence level assigned to CASE is never useful.
File "K3Parser.mly", line 163, characters 0-6:
Warning: the precedence level assigned to IF is never useful.
File "K3Parser.mly", line 161, characters 0-6:
Warning: the precedence level assigned to LRARROW is never useful.
File "K3Parser.mly", line 165, characters 0-6:
Warning: the precedence level assigned to OF is never useful.
File "K3Parser.mly", line 163, characters 0-6:
Warning: the precedence level assigned to THEN is never useful.
File "K3Parser.mly", line 183, characters 0-9:
Warning: the precedence level assigned to UMINUS is never useful.
File "K3Parser.mly", line 329, characters 47-53:
Warning: this %prec declaration is never useful.
Warning: 109 states have shift/reduce conflicts.
Warning: 3 states have reduce/reduce conflicts.
3 conflicts could not be explained.
Warning: 576 shift/reduce conflicts were arbitrarily resolved.
Warning: 142 reduce/reduce conflicts were arbitrarily resolved.
Warning: 266 states have an end-of-stream conflict.
File "K3Parser.mly", line 399, characters 0-4:
Warning: symbol expr is never accepted.
File "K3Parser.mly", line 760, characters 6-26:
Warning: production expression_test -> expression_test_list is never reduced.
File "K3Parser.mly", line 755, characters 6-57:
Warning: production expression_test_list -> expression_test_list SEMICOLON expression_test_list is never reduced.
File "K3Parser.mly", line 344, characters 6-40:
Warning: production fn_type_expr_list -> type_expr RARROW fn_type_expr_list is never reduced.
File "K3Parser.mly", line 763, characters 6-31:
Warning: production named_expr_list -> anno_expr GETS check_expr is never reduced.
Warning: in total, 5 productions are never reduced.
445 out of 1441 states have a default reduction.
639 out of 1441 states are represented.
0 out of 179 symbols keep track of their start position.
0 out of 179 symbols keep track of their end position.
220 out of 307 productions exploit shiftreduce optimization.
297 out of 1441 states can peek at an error.
3246 functions before inlining, 579 functions after inlining.
