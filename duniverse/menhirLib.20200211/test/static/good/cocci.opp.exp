File "cocci.mly", line 137, characters 0-6:
Warning: symbol reinit is unreachable from any of the start symbol(s).
%{

(* Not clear how to allow function declarations to specify a return type
and how to allow both to be specified as static, because they are in
different rules.  The rules seem to have to be combined, which would allow
functions to be declared as local variables *)

(* Not clear how to let a function have a parameter of type void.  At the
moment, void is allowed to be the type of a variable, which is wrong, and a
parameter needs both a type and an identifier *)
module Ast0 = Ast0_cocci
module Ast = Ast_cocci
module P = Parse_aux

%}
%start iso_main
%start iso_meta_main
%start meta_main
%start minus_main
%start never_used
%start plus_main
%start rule_name
%token EOF
%token <Data.clt> TAnd
%token <Data.clt> TAndLog
%token TArob
%token TArobArob
%token <Ast_cocci.assignOp * Data.clt> TAssign
%token <Data.clt> TBang
%token TBang0
%token <Data.clt> TBreak
%token <Data.clt> TCBrace
%token <Data.clt> TCCro
%token <Data.clt> TCEllipsis
%token <Data.clt> TCPar
%token <Data.clt> TCPar0
%token <Data.clt> TCase
%token <string * Data.clt> TChar
%token <Data.clt> TComma
%token TConstant
%token TContext
%token <Data.clt> TContinue
%token <Data.clt> TDec
%token TDeclarer
%token <string * Data.clt> TDeclarerId
%token <Data.clt> TDefault
%token <Data.clt * token> TDefine
%token <Data.clt * token * int> TDefineParam
%token TDepends
%token <Data.clt> TDiv
%token <Data.clt> TDo
%token <Data.clt> TDot
%token <Data.clt> TDotDot
%token <Data.clt> TEllipsis
%token <Data.clt> TElse
%token <Data.clt> TEq
%token <Data.clt> TEqEq
%token TError
%token TExpression
%token TExtends
%token <string * Data.clt> TFloat
%token <Data.clt> TFor
%token TFresh
%token <Data.clt> TFunDecl
%token TFunction
%token <string * Data.clt> TIdent
%token TIdentifier
%token <Data.clt> TIf
%token <Data.clt> TInc
%token <string * Data.clt> TIncludeL
%token <string * Data.clt> TIncludeNL
%token <Data.clt> TInf
%token <Data.clt> TInfEq
%token <string * Data.clt> TInt
%token TInvalid
%token TIso
%token TIsoDeclaration
%token TIsoExpression
%token TIsoStatement
%token TIsoTopLevel
%token TIsoType
%token <Data.clt> TLineEnd
%token TLocal
%token TMPtVirg
%token <(string * string) * Ast0_cocci.pure * Type_cocci.typeC list option *
          Data.clt> TMetaConst
%token <(string * string) * Ast0_cocci.pure * Data.clt> TMetaErr
%token <(string * string) * Ast0_cocci.pure * Type_cocci.typeC list option *
          Data.clt> TMetaExp
%token <(string * string) * Ast0_cocci.pure * Data.clt> TMetaExpList
%token <(string * string) * Ast0_cocci.pure * Data.clt> TMetaFunc
%token <(string * string) * Ast0_cocci.pure * Data.clt> TMetaId
%token <(string * string) * Ast0_cocci.pure * Data.clt> TMetaLocalFunc
%token <(string * string) * Ast0_cocci.pure * Data.clt> TMetaParam
%token <(string * string) * Ast0_cocci.pure * Data.clt> TMetaParamList
%token <(string * string) * Ast0_cocci.pure * Data.clt> TMetaStm
%token <(string * string) * Ast0_cocci.pure * Data.clt> TMetaStmList
%token <(string * string) * Ast0_cocci.pure * Data.clt> TMetaType
%token <Data.clt> TMid0
%token <Data.clt> TMinus
%token <string * Data.clt> TMinusFile
%token <Data.clt> TMod
%token <Data.clt> TMul
%token <Data.clt> TNotEq
%token TNothing
%token <Data.clt> TOBrace
%token <Data.clt> TOCro
%token <Data.clt> TOEllipsis
%token <Data.clt> TOPar
%token <Data.clt> TOPar0
%token TOn
%token <Data.clt> TOr
%token <Data.clt> TOrLog
%token TParameter
%token <Data.clt> TPlus
%token TPlus0
%token <string * Data.clt> TPlusFile
%token <string> TPragma
%token <Data.clt> TPtVirg
%token <Data.clt> TPtrOp
%token TPure
%token <Data.clt> TReturn
%token TRightIso
%token <string> TRuleName
%token <Data.clt> TShl
%token <Data.clt> TShr
%token <Data.clt> TSizeof
%token TStatement
%token <string * Data.clt> TString
%token <Data.clt> TSup
%token <Data.clt> TSupEq
%token <Data.clt> TSwitch
%token <Data.clt> TTilde
%token TType
%token <string * Data.clt> TTypeId
%token TTypedef
%token TUsing
%token <Data.clt> TWhen
%token <Data.clt> TWhile
%token <Data.clt> TWhy
%token TWhy0
%token TWords
%token <Data.clt> TXor
%token <string * Data.clt> Tattr
%token <Data.clt> Tauto
%token <Data.clt> Tchar
%token <Data.clt> Tconst
%token <Data.clt> Tdouble
%token <Data.clt> Textern
%token <Data.clt> Tfloat
%token <Data.clt> Tinline
%token <Data.clt> Tint
%token Tlist
%token <Data.clt> Tlong
%token <Data.clt> Tregister
%token <Data.clt> Tshort
%token <Data.clt> Tsigned
%token <Data.clt> Tstatic
%token <Data.clt> Tstruct
%token <Data.clt> Tunion
%token <Data.clt> Tunsigned
%token <Data.clt> Tvoid
%token <Data.clt> Tvolatile
%nonassoc TIf
%nonassoc TElse
%left TOrLog
%left TAndLog
%left TOr
%left TXor
%left TAnd
%left TEqEq TNotEq
%left TInf TInfEq TSup TSupEq
%left TShl TShr
%left TMinus TPlus
%left TDiv TMod TMul
%type <Ast0_cocci.anything list list> iso_main
%type <(Ast_cocci.metavar,Ast_cocci.metavar) Common.either list> iso_meta_main
%type <(Ast_cocci.metavar,Ast_cocci.metavar) Common.either list> meta_main
%type <Ast0_cocci.rule> minus_main
%type <unit> never_used
%type <Ast0_cocci.rule> plus_main
%type <string * Ast_cocci.dependency list * string option> rule_name
%%

option_eexpr_:
  
    {    ( None )}
| x = eexpr
    {    ( Some x )}

option_whenexp_:
  
    {    ( None )}
| x = whenexp
    {    ( Some x )}

option_whenppdecs_:
  
    {    ( None )}
| x = whenppdecs
    {    ( Some x )}

loption_error_words_:
  
    {    ( [] )}
| x = error_words
    {    ( x )}

loption_filespec_:
  
    {    ( [] )}
| x = filespec
    {    ( x )}

loption_fun_exp_decl_statement_list_:
  
    {    ( [] )}
| x = fun_exp_decl_statement_list
    {    ( x )}

loption_minus_function_decl_statement_or_expression_:
  
    {    ( [] )}
| x = minus_function_decl_statement_or_expression
    {    ( x )}

loption_plus_function_decl_statement_or_expression_:
  
    {    ( [] )}
| x = plus_function_decl_statement_or_expression
    {    ( x )}

loption_pure_decl_statement_list_:
  
    {    ( [] )}
| x = pure_decl_statement_list
    {    ( x )}

list_TMul_:
  
    {    ( [] )}
| x = TMul xs = list_TMul_
    {    ( x :: xs )}

list_array_dec_:
  
    {    ( [] )}
| x = array_dec xs = list_array_dec_
    {    ( x :: xs )}

list_case_line_:
  
    {    ( [] )}
| x = case_line xs = list_case_line_
    {    ( x :: xs )}

list_comma_args_edots_when_TEllipsis_eexpr___:
  
    {    ( [] )}
| x = comma_args_edots_when_TEllipsis_eexpr__ xs = list_comma_args_edots_when_TEllipsis_eexpr___
    {    ( x :: xs )}

list_comma_decls_TEllipsis_decl__:
  
    {    ( [] )}
| x = comma_decls_TEllipsis_decl_ xs = list_comma_decls_TEllipsis_decl__
    {    ( x :: xs )}

list_comma_decls_TEllipsis_name_opt_decl__:
  
    {    ( [] )}
| x = comma_decls_TEllipsis_name_opt_decl_ xs = list_comma_decls_TEllipsis_name_opt_decl__
    {    ( x :: xs )}

list_dp_comma_args_TEllipsis__:
  
    {    ( [] )}
| x = dp_comma_args_TEllipsis_ xs = list_dp_comma_args_TEllipsis__
    {    ( x :: xs )}

list_includes_:
  
    {    ( [] )}
| x = includes xs = list_includes_
    {    ( x :: xs )}

list_iso_ctype__:
  
    {    ( [] )}
| x = iso_ctype_ xs = list_iso_ctype__
    {    ( x :: xs )}

list_iso_decl_var__:
  
    {    ( [] )}
| x = iso_decl_var_ xs = list_iso_decl_var__
    {    ( x :: xs )}

list_iso_dexpr__:
  
    {    ( [] )}
| x = iso_dexpr_ xs = list_iso_dexpr__
    {    ( x :: xs )}

list_iso_single_statement__:
  
    {    ( [] )}
| x = iso_single_statement_ xs = list_iso_single_statement__
    {    ( x :: xs )}

list_iso_xstatement_dots_TEllipsis___:
  
    {    ( [] )}
| x = iso_xstatement_dots_TEllipsis__ xs = list_iso_xstatement_dots_TEllipsis___
    {    ( x :: xs )}

list_mzl_ctype__:
  
    {    ( [] )}
| x = mzl_ctype_ xs = list_mzl_ctype__
    {    ( x :: xs )}

list_mzl_eexpr__:
  
    {    ( [] )}
| x = mzl_eexpr_ xs = list_mzl_eexpr__
    {    ( x :: xs )}

list_mzl_expr__:
  
    {    ( [] )}
| x = mzl_expr_ xs = list_mzl_expr__
    {    ( x :: xs )}

list_mzl_rule_elem_statement__:
  
    {    ( [] )}
| x = mzl_rule_elem_statement_ xs = list_mzl_rule_elem_statement__
    {    ( x :: xs )}

list_mzl_statement__:
  
    {    ( [] )}
| x = mzl_statement_ xs = list_mzl_statement__
    {    ( x :: xs )}

list_pair_dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement__exp_decl_statement_list__:
  
    {    ( [] )}
| x = dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement_ y = exp_decl_statement_list xs = list_pair_dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement__exp_decl_statement_list__
    {let x =     ( (x, y) ) in
    ( x :: xs )}

list_pair_edots_when_TEllipsis_eexpr__dexpr__:
  
    {    ( [] )}
| x = edots_when_TEllipsis_eexpr_ y = dexpr xs = list_pair_edots_when_TEllipsis_eexpr__dexpr__
    {let x =     ( (x, y) ) in
    ( x :: xs )}

list_whens_pre_post_decl_statement_or_expression_rule_elem_statement__:
  
    {    ( [] )}
| x = whens_pre_post_decl_statement_or_expression_rule_elem_statement_ xs = list_whens_pre_post_decl_statement_or_expression_rule_elem_statement__
    {    ( x :: xs )}

nonempty_list_TMul_:
  x = TMul
    {    ( [ x ] )}
| x = TMul xs = nonempty_list_TMul_
    {    ( x :: xs )}

nonempty_list_decl_statement_:
  x = decl_statement
    {    ( [ x ] )}
| x = decl_statement xs = nonempty_list_decl_statement_
    {    ( x :: xs )}

nonempty_list_fun_decl_statement_:
  x = fun_decl_statement
    {    ( [ x ] )}
| x = fun_decl_statement xs = nonempty_list_fun_decl_statement_
    {    ( x :: xs )}

separated_nonempty_list_TAndLog_pnrule_:
  x = pnrule
    {    ( [ x ] )}
| x = pnrule _2 = TAndLog xs = separated_nonempty_list_TAndLog_pnrule_
    {    ( x :: xs )}

separated_nonempty_list_TComma_ctype_:
  x = ctype
    {    ( [ x ] )}
| x = ctype _2 = TComma xs = separated_nonempty_list_TComma_ctype_
    {    ( x :: xs )}

separated_nonempty_list_TComma_d_ident_:
  x = d_ident
    {    ( [ x ] )}
| x = d_ident _2 = TComma xs = separated_nonempty_list_TComma_d_ident_
    {    ( x :: xs )}

separated_nonempty_list_TComma_dexpr_:
  x = dexpr
    {    ( [ x ] )}
| x = dexpr _2 = TComma xs = separated_nonempty_list_TComma_dexpr_
    {    ( x :: xs )}

separated_nonempty_list_TComma_pure_ident_or_meta_ident_:
  x = pure_ident_or_meta_ident
    {    ( [ x ] )}
| x = pure_ident_or_meta_ident _2 = TComma xs = separated_nonempty_list_TComma_pure_ident_or_meta_ident_
    {    ( x :: xs )}

minus_main:
  _1 = minus_body _2 = EOF
    {                           ( _1 )}
| m = minus_body _2 = TArobArob
    {                                                           ( m )}
| m = minus_body _2 = TArob
    {                     ( m )}

plus_main:
  _1 = plus_body _2 = EOF
    {                         ( _1 )}
| p = plus_body _2 = TArobArob
    {                                                        ( p )}
| p = plus_body _2 = TArob
    {                    ( p )}

meta_main:
  m = metadec
    {                       ( m (!Ast0.rule_name) )}

iso_meta_main:
  m = metadec
    {                         ( m "" )}

pure:
  _1 = TPure
    {              ( Ast0.Pure )}
| _1 = TContext
    {              ( Ast0.Context )}
| 
    {              ( Ast0.Impure )}

rule_name:
  nm = pure_ident _2 = extends d = depends _5 = TArob
    {let i =     ( None ) in
    ( let n = P.id2name nm in
    (try let _ =  Hashtbl.find Data.all_metadecls n in
    raise (Semantic_cocci.Semantic ("repeated rule name"))
    with Not_found -> ());
    (n,d,i) )}
| nm = pure_ident _2 = extends d = depends x = choose_iso _5 = TArob
    {let i =     ( Some x ) in
    ( let n = P.id2name nm in
    (try let _ =  Hashtbl.find Data.all_metadecls n in
    raise (Semantic_cocci.Semantic ("repeated rule name"))
    with Not_found -> ());
    (n,d,i) )}

extends:
  
    {                                                  ( () )}
| _1 = TExtends parent = TRuleName
    {    ( !Data.install_bindings (parent) )}

depends:
  
    {                                                  ( [] )}
| _1 = TDepends _2 = TOn parents = separated_nonempty_list_TAndLog_pnrule_
    {                                                               ( parents )}

pnrule:
  _1 = TRuleName
    {                  ( Ast.Dep _1 )}
| _1 = TBang _2 = TRuleName
    {                  ( Ast.AntiDep _2 )}

choose_iso:
  _1 = TUsing _2 = TString
    {                     ( P.id2name _2 )}

metadec:
  ar = arity ispure = pure _1 = TIdentifier ids = comma_list_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let kindfn =     ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaIdDecl(arity,name)) in
      !Data.add_id_meta name pure; tok) ) in
    ( function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) )}
| ar = arity ispure = pure _1 = TFresh _2 = TIdentifier ids = comma_list_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let kindfn =     ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaFreshIdDecl(arity,name)) in
      !Data.add_id_meta name pure; tok) ) in
    ( function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) )}
| ar = arity ispure = pure _1 = TType ids = comma_list_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let kindfn =     ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaTypeDecl(arity,name)) in
      !Data.add_type_meta name pure; tok) ) in
    ( function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) )}
| ar = arity ispure = pure _1 = TParameter ids = comma_list_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let kindfn =     ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaParamDecl(arity,name)) in
      !Data.add_param_meta name pure; tok) ) in
    ( function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) )}
| ar = arity ispure = pure _1 = TParameter _2 = Tlist ids = comma_list_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let kindfn =     ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaParamListDecl(arity,name)) in
      !Data.add_paramlist_meta name pure; tok)) in
    ( function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) )}
| ar = arity ispure = pure _1 = TError ids = comma_list_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let kindfn =     ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaErrDecl(arity,name)) in
      !Data.add_err_meta name pure; tok) ) in
    ( function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) )}
| ar = arity ispure = pure _1 = TExpression ids = comma_list_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let kindfn =     ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaExpDecl(arity,name,None)) in
      !Data.add_exp_meta None name pure; tok) ) in
    ( function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) )}
| ar = arity ispure = pure _1 = TExpression _2 = Tlist ids = comma_list_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let kindfn =     ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaExpListDecl(arity,name)) in
      !Data.add_explist_meta name pure; tok) ) in
    ( function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) )}
| ar = arity ispure = pure _1 = TExpression m = nonempty_list_TMul_ ids = comma_list_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let kindfn =     ( (fun arity name pure check_meta ->
      let ty = Some [P.ty_pointerify Type_cocci.Unknown m] in
      let tok = check_meta(Ast.MetaExpDecl(arity,name,ty)) in
      !Data.add_exp_meta ty name pure; tok) ) in
    ( function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) )}
| ar = arity ispure = pure _1 = TStatement ids = comma_list_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let kindfn =     ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaStmDecl(arity,name)) in
      !Data.add_stm_meta name pure; tok) ) in
    ( function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) )}
| ar = arity ispure = pure _1 = TStatement _2 = Tlist ids = comma_list_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let kindfn =     ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaStmListDecl(arity,name)) in
      !Data.add_stmlist_meta name pure; tok) ) in
    ( function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) )}
| ar = arity ispure = pure _1 = TFunction ids = comma_list_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let kindfn =     ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaFuncDecl(arity,name)) in
      !Data.add_func_meta name pure; tok) ) in
    ( function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) )}
| ar = arity ispure = pure _1 = TLocal _2 = TFunction ids = comma_list_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let kindfn =     ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaLocalFuncDecl(arity,name)) in
      !Data.add_local_func_meta name pure;
      tok) ) in
    ( function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) )}
| ar = arity ispure = pure vl = meta_exp_type ids = comma_list_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let kindfn =     ( (fun arity name pure check_meta ->
      let ty = Some vl in
      let tok = check_meta(Ast.MetaExpDecl(arity,name,ty)) in
      !Data.add_exp_meta ty name pure; tok) ) in
    ( function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) )}
| ar = arity ispure = pure vl = meta_exp_type _2 = TOCro _3 = TCCro ids = comma_list_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let kindfn =     ( (fun arity name pure check_meta ->
      let ty = Some (List.map (function x -> Type_cocci.Array x) vl) in
      let tok = check_meta(Ast.MetaExpDecl(arity,name,ty)) in
      !Data.add_exp_meta ty name pure; tok) ) in
    ( function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) )}
| ar = arity ispure = pure _1 = TConstant ids = comma_list_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let kindfn =
  let ty =     ( None ) in
      ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaConstDecl(arity,name,ty)) in
      !Data.add_const_meta ty name pure; tok) )
in
    ( function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) )}
| ar = arity ispure = pure _1 = TConstant x = meta_exp_type ids = comma_list_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let kindfn =
  let ty =     ( Some x ) in
      ( (fun arity name pure check_meta ->
      let tok = check_meta(Ast.MetaConstDecl(arity,name,ty)) in
      !Data.add_const_meta ty name pure; tok) )
in
    ( function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) )}
| ar = arity ispure = pure _1 = TTypedef ids = comma_list_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let kindfn =     ( (fun arity (_,name) pure check_meta ->
      if arity = Ast.NONE && pure = Ast0.Impure
      then (!Data.add_type_name name; [])
      else raise (Semantic_cocci.Semantic "bad typedef")) ) in
    ( function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) )}
| ar = arity ispure = pure _1 = TDeclarer ids = comma_list_pure_ident_or_meta_ident_ _5 = TMPtVirg
    {let kindfn =     ( (fun arity (_,name) pure check_meta ->
      if arity = Ast.NONE && pure = Ast0.Impure
      then (!Data.add_declarer_name name; [])
      else raise (Semantic_cocci.Semantic "bad declarer")) ) in
    ( function current_rule ->
      List.concat
	(List.map
	   (function (rule,nm) ->
	     let (rule,checker) =
	       match rule with
		 None -> ((current_rule,nm),function x -> [Common.Left x])
	       | Some rule ->
		   ((rule,nm),
		    function x -> P.check_meta x; [Common.Right x]) in
	     kindfn ar rule ispure checker)
	   ids) )}

meta_exp_type:
  t = ctype
    {    ( [Ast0_cocci.ast0_type_to_type t] )}
| _1 = TOBrace t = comma_list_ctype_ _3 = TCBrace m = list_TMul_
    {    ( List.map
	(function x -> P.ty_pointerify (Ast0_cocci.ast0_type_to_type x) m)
	t )}

arity:
  _1 = TBang0
    {              ( Ast.UNIQUE )}
| _1 = TWhy0
    {              ( Ast.OPT )}
| _1 = TPlus0
    {              ( Ast.MULTI )}
| 
    {                   ( Ast.NONE )}

generic_ctype:
  q = ctype_qualif
    {         ( Ast0.wrap(Ast0.ImplicitInt(q)) )}
| ty = Tchar
    {let q =     ( None ) in
         ( Ast0.wrap(Ast0.BaseType(P.clt2mcode Ast.CharType ty, q)) )}
| x = ctype_qualif ty = Tchar
    {let q =     ( Some x ) in
         ( Ast0.wrap(Ast0.BaseType(P.clt2mcode Ast.CharType ty, q)) )}
| ty = Tshort
    {let q =     ( None ) in
         ( Ast0.wrap(Ast0.BaseType(P.clt2mcode Ast.ShortType ty, q)) )}
| x = ctype_qualif ty = Tshort
    {let q =     ( Some x ) in
         ( Ast0.wrap(Ast0.BaseType(P.clt2mcode Ast.ShortType ty, q)) )}
| ty = Tint
    {let q =     ( None ) in
         ( Ast0.wrap(Ast0.BaseType(P.clt2mcode Ast.IntType ty, q)) )}
| x = ctype_qualif ty = Tint
    {let q =     ( Some x ) in
         ( Ast0.wrap(Ast0.BaseType(P.clt2mcode Ast.IntType ty, q)) )}
| t = Tdouble
    {         ( Ast0.wrap(Ast0.BaseType(P.clt2mcode Ast.DoubleType t, None)) )}
| t = Tfloat
    {         ( Ast0.wrap(Ast0.BaseType(P.clt2mcode Ast.FloatType t, None)) )}
| ty = Tlong
    {let q =     ( None ) in
         ( Ast0.wrap(Ast0.BaseType(P.clt2mcode Ast.LongType ty, q)) )}
| x = ctype_qualif ty = Tlong
    {let q =     ( Some x ) in
         ( Ast0.wrap(Ast0.BaseType(P.clt2mcode Ast.LongType ty, q)) )}
| s = struct_or_union i = ident
    {  ( Ast0.wrap(Ast0.StructUnionName(s, i)) )}
| s = struct_or_union i = ident l = TOBrace d = struct_decl_list r = TCBrace
    {  ( Ast0.wrap(Ast0.StructUnionDef(Ast0.wrap(Ast0.StructUnionName(s, i)),
					 P.clt2mcode "{" l,
					 d, P.clt2mcode "}" r)) )}
| s = TMetaType l = TOBrace d = struct_decl_list r = TCBrace
    {  ( let (nm,pure,clt) = s in
	 let ty = Ast0.wrap(Ast0.MetaType(P.clt2mcode nm clt,pure)) in
	 Ast0.wrap
	   (Ast0.StructUnionDef(ty,P.clt2mcode "{" l,d,P.clt2mcode "}" r)) )}
| r = TRuleName _2 = TDot p = TIdent
    {  ( let nm = (r,P.id2name p) in
	 (* this is only possible when we are in a metavar decl.  Otherwise,
	    it will be represented already as a MetaType *)
	 let _ = P.check_meta(Ast.MetaTypeDecl(Ast.NONE,nm)) in
	 Ast0.wrap(Ast0.MetaType(P.clt2mcode nm (P.id2clt p),
				 Ast0.Impure (*will be ignored*))) )}
| p = TTypeId
    {  ( Ast0.wrap(Ast0.TypeName(P.id2mcode p)) )}
| p = TMetaType
    {  ( let (nm,pure,clt) = p in
	 Ast0.wrap(Ast0.MetaType(P.clt2mcode nm clt,pure)) )}

struct_or_union:
  s = Tstruct
    {                 ( P.clt2mcode Ast.Struct s )}
| u = Tunion
    {                 ( P.clt2mcode Ast.Union u )}

struct_decl:
  t = ctype d = d_ident pv = TPtVirg
    {  ( let (id,fn) = d in
	 Ast0.wrap(Ast0.UnInit(None,fn t,id,P.clt2mcode ";" pv)) )}
| t = fn_ctype lp1 = TOPar st = TMul d = d_ident rp1 = TCPar lp2 = TOPar p = decl_list_name_opt_decl_ rp2 = TCPar pv = TPtVirg
    {        ( let (id,fn) = d in
        let t =
	  Ast0.wrap
	    (Ast0.FunctionPointer
	       (t,P.clt2mcode "(" lp1,P.clt2mcode "*" st,P.clt2mcode ")" rp1,
		P.clt2mcode "(" lp2,p,P.clt2mcode ")" rp2)) in
        Ast0.wrap(Ast0.UnInit(None,fn t,id,P.clt2mcode ";" pv)) )}
| i = pure_ident d = d_ident pv = TPtVirg
    {let cv =     ( None ) in
  ( let (id,fn) = d in
	 let idtype = P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
	 Ast0.wrap(Ast0.UnInit(None,fn idtype,id,P.clt2mcode ";" pv)) )}
| x = const_vol i = pure_ident d = d_ident pv = TPtVirg
    {let cv =     ( Some x ) in
  ( let (id,fn) = d in
	 let idtype = P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
	 Ast0.wrap(Ast0.UnInit(None,fn idtype,id,P.clt2mcode ";" pv)) )}

struct_decl_list:
  _1 = struct_decl_list_start
    {                          ( Ast0.wrap(Ast0.DOTS(_1)) )}

struct_decl_list_start:
  _1 = struct_decl
    {                                     ( [_1] )}
| _1 = struct_decl _2 = struct_decl_list_start
    {                                     ( _1::_2 )}
| d = edots_when_TEllipsis_struct_decl_ r = continue_struct_decl_list
    {    ( (P.mkddots "..." d)::r )}

continue_struct_decl_list:
  
    {                                     ( [] )}
| _1 = struct_decl _2 = struct_decl_list_start
    {                                     ( _1::_2 )}
| _1 = struct_decl
    {                                     ( [_1] )}

ctype:
  ty = generic_ctype m = list_TMul_
    {let cv =     ( None ) in
  ( P.pointerify (P.make_cv cv ty) m )}
| x = const_vol ty = generic_ctype m = list_TMul_
    {let cv =     ( Some x ) in
  ( P.pointerify (P.make_cv cv ty) m )}
| t = Tvoid m = nonempty_list_TMul_
    {let cv =     ( None ) in
         ( let ty =
	     Ast0.wrap(Ast0.BaseType(P.clt2mcode Ast.VoidType t, None)) in
	   P.pointerify (P.make_cv cv ty) m )}
| x = const_vol t = Tvoid m = nonempty_list_TMul_
    {let cv =     ( Some x ) in
         ( let ty =
	     Ast0.wrap(Ast0.BaseType(P.clt2mcode Ast.VoidType t, None)) in
	   P.pointerify (P.make_cv cv ty) m )}

fn_ctype:
  ty = generic_ctype m = list_TMul_
    {                                     ( P.pointerify ty m )}
| t = Tvoid m = list_TMul_
    {         ( P.pointerify
	     (Ast0.wrap(Ast0.BaseType(P.clt2mcode Ast.VoidType t, None)))
	     m )}

ctype_qualif:
  _1 = Tunsigned
    {                   ( P.clt2mcode Ast.Unsigned _1 )}
| _1 = Tsigned
    {                   ( P.clt2mcode Ast.Signed _1 )}

minus_body:
  f = loption_filespec_ i = list_includes_ b = loption_minus_function_decl_statement_or_expression_ ew = loption_error_words_
    {    ( match f@i@b@ew with
      [] -> raise (Semantic_cocci.Semantic "minus slice can't be empty")
    | code -> Top_level.top_level code )}

plus_body:
  f = loption_filespec_ i = list_includes_ b = loption_plus_function_decl_statement_or_expression_ ew = loption_error_words_
    {    ( Top_level.top_level (f@i@b@ew) )}

filespec:
  _1 = TMinusFile _2 = TPlusFile
    {    ( [Ast0.wrap
	  (Ast0.FILEINFO(P.id2mcode _1,
			 P.id2mcode _2))] )}

includes:
  _1 = TIncludeL
    {    ( Ast0.wrap
	(Ast0.DECL
	   (Ast0.wrap
	      (Ast0.Include(P.clt2mcode "#include" (P.drop_aft (P.id2clt _1)),
			    let (arity,ln,lln,offset,col,strbef,straft) =
			      P.id2clt _1 in
			    let clt = (arity,ln,lln,offset,0,strbef,straft) in
			    P.clt2mcode
			      (Ast.Local (Parse_aux.str2inc (P.id2name _1)))
			      (P.drop_bef clt))))) )}
| _1 = TIncludeNL
    {    ( Ast0.wrap
	(Ast0.DECL
	   (Ast0.wrap
	      (Ast0.Include(P.clt2mcode "#include" (P.drop_aft (P.id2clt _1)),
			    let (arity,ln,lln,offset,col,strbef,straft) =
			      P.id2clt _1 in
			    let clt = (arity,ln,lln,offset,0,strbef,straft) in
			    P.clt2mcode
			      (Ast.NonLocal (Parse_aux.str2inc (P.id2name _1)))
			      (P.drop_bef clt))))) )}
| d = defineop t = ctype
    {    ( let ty = Ast0.wrap(Ast0.Ty(t)) in
      Ast0.wrap(Ast0.DECL(d (Ast0.wrap(Ast0.DOTS([ty]))))) )}
| _1 = defineop b = statement_dots_TEllipsis_
    {    ( Ast0.wrap
	(Ast0.DECL
	   (_1 (Ast0.wrap(Ast0.DOTS(b (P.mkdots "...")))))) )}

defineop:
  _1 = TDefine
    {    ( let (clt,ident) = _1 in
      function body ->
	Ast0.wrap
	  (Ast0.Define(P.clt2mcode "#define" clt,
		       (match ident with
			 TMetaId((nm,pure,clt)) ->
			   Ast0.wrap(Ast0.MetaId(P.clt2mcode nm clt,pure))
		       | TIdent(nm_pure) ->
			   Ast0.wrap(Ast0.Id(P.id2mcode nm_pure))
		       | _ ->
			   raise
			     (Semantic_cocci.Semantic
				"unexpected name for a #define")),
		       Ast0.wrap Ast0.NoParams,
		       body)) )}
| _1 = TDefineParam _2 = define_param_list_option _3 = TCPar
    {    ( let (clt,ident,parenoff) = _1 in
      let (arity,line,lline,offset,col,strbef,straft) = clt in
      let lp = P.clt2mcode "(" (arity,line,lline,parenoff,0,[],[]) in
      function body ->
	Ast0.wrap
	  (Ast0.Define
	     (P.clt2mcode "#define" clt,
	      (match ident with
		TMetaId((nm,pure,clt)) ->
		  Ast0.wrap(Ast0.MetaId(P.clt2mcode nm clt,pure))
	      | TIdent(nm_pure) ->
		  Ast0.wrap(Ast0.Id(P.id2mcode nm_pure))
	      | _ ->
		  raise
		    (Semantic_cocci.Semantic
		       "unexpected name for a #define")),
	      Ast0.wrap (Ast0.DParams (lp,_2,P.clt2mcode ")" _3)),body)) )}

define_param_list:
  _1 = define_param_list_start
    {     (let circle x =
       match Ast0.unwrap x with Ast0.DPcircles(_) -> true | _ -> false in
     if List.exists circle _1
     then Ast0.wrap(Ast0.CIRCLES(_1))
     else Ast0.wrap(Ast0.DOTS(_1)) )}

define_param_list_start:
  _1 = ident
    {          ( [Ast0.wrap(Ast0.DParam _1)] )}
| _1 = ident _2 = TComma _3 = define_param_list_start
    {      ( Ast0.wrap(Ast0.DParam _1)::
	Ast0.wrap(Ast0.DPComma(P.clt2mcode "," _2))::_3 )}
| d = TEllipsis r = list_dp_comma_args_TEllipsis__
    {      ( (P.mkdpdots "..." d)::
	(List.concat (List.map (function x -> x (P.mkdpdots "...")) r)) )}

dp_comma_args_TEllipsis_:
  c = TComma d = TEllipsis
    {    ( function dot_builder ->
      [Ast0.wrap(Ast0.DPComma(P.clt2mcode "," c)); dot_builder d] )}
| _1 = TComma _2 = ident
    {    ( function dot_builder ->
      [Ast0.wrap(Ast0.DPComma(P.clt2mcode "," _1));
	Ast0.wrap(Ast0.DParam _2)] )}

define_param_list_option:
  _1 = define_param_list
    {                                            ( _1 )}
| 
    {                           ( Ast0.wrap(Ast0.DOTS([])) )}

funproto:
  t = ctype id = func_ident lp = TOPar d = decl_list_decl_ rp = TCPar pt = TPtVirg
    {let s =     ( None ) in
      ( Ast0.wrap
	  (Ast0.UnInit
	     (s,
	      Ast0.wrap
		(Ast0.FunctionType(Some t,
				   P.clt2mcode "(" lp, d, P.clt2mcode ")" rp)),
	      id, P.clt2mcode ";" pt)) )}
| x = storage t = ctype id = func_ident lp = TOPar d = decl_list_decl_ rp = TCPar pt = TPtVirg
    {let s =     ( Some x ) in
      ( Ast0.wrap
	  (Ast0.UnInit
	     (s,
	      Ast0.wrap
		(Ast0.FunctionType(Some t,
				   P.clt2mcode "(" lp, d, P.clt2mcode ")" rp)),
	      id, P.clt2mcode ";" pt)) )}
| t = Tvoid id = func_ident lp = TOPar d = decl_list_decl_ rp = TCPar pt = TPtVirg
    {let s =     ( None ) in
    ( let t = Ast0.wrap(Ast0.BaseType(P.clt2mcode Ast.VoidType t, None)) in
      Ast0.wrap
        (Ast0.UnInit
	   (s,
	    Ast0.wrap
	      (Ast0.FunctionType(Some t,
				 P.clt2mcode "(" lp, d, P.clt2mcode ")" rp)),
	    id, P.clt2mcode ";" pt)) )}
| x = storage t = Tvoid id = func_ident lp = TOPar d = decl_list_decl_ rp = TCPar pt = TPtVirg
    {let s =     ( Some x ) in
    ( let t = Ast0.wrap(Ast0.BaseType(P.clt2mcode Ast.VoidType t, None)) in
      Ast0.wrap
        (Ast0.UnInit
	   (s,
	    Ast0.wrap
	      (Ast0.FunctionType(Some t,
				 P.clt2mcode "(" lp, d, P.clt2mcode ")" rp)),
	    id, P.clt2mcode ";" pt)) )}

fundecl:
  f = fninfo _2 = TFunDecl i = func_ident lp = TOPar d = decl_list_decl_ rp = TCPar lb = TOBrace b = pre_post_decl_statement_and_expression_opt rb = TCBrace
    {      ( Ast0.wrap(Ast0.FunDecl((Ast0.default_info(),Ast0.context_befaft()),
			       f, i,
			       P.clt2mcode "(" lp, d,
			       P.clt2mcode ")" rp,
			       P.clt2mcode "{" lb, b,
			       P.clt2mcode "}" rb)) )}

fninfo:
  
    {                ( [] )}
| _1 = storage _2 = fninfo
    {      ( try
	let _ =
	  List.find (function Ast0.FStorage(_) -> true | _ -> false) _2 in
	raise (Semantic_cocci.Semantic "duplicate storage")
      with Not_found -> (Ast0.FStorage(_1))::_2 )}
| t = fn_ctype r = fninfo_nt
    {                           ( (Ast0.FType(t))::r )}
| _1 = Tinline _2 = fninfo
    {      ( try
	let _ = List.find (function Ast0.FInline(_) -> true | _ -> false) _2 in
	raise (Semantic_cocci.Semantic "duplicate inline")
      with Not_found -> (Ast0.FInline(P.clt2mcode "inline" _1))::_2 )}
| _1 = Tattr _2 = fninfo
    {      ( try
	let _ = List.find (function Ast0.FAttr(_) -> true | _ -> false) _2 in
	raise (Semantic_cocci.Semantic "multiple attributes")
      with Not_found -> (Ast0.FAttr(P.id2mcode _1))::_2 )}

fninfo_nt:
  
    {                ( [] )}
| _1 = storage _2 = fninfo_nt
    {      ( try
	let _ =
	  List.find (function Ast0.FStorage(_) -> true | _ -> false) _2 in
	raise (Semantic_cocci.Semantic "duplicate storage")
      with Not_found -> (Ast0.FStorage(_1))::_2 )}
| _1 = Tinline _2 = fninfo_nt
    {      ( try
	let _ = List.find (function Ast0.FInline(_) -> true | _ -> false) _2 in
	raise (Semantic_cocci.Semantic "duplicate inline")
      with Not_found -> (Ast0.FInline(P.clt2mcode "inline" _1))::_2 )}
| _1 = Tattr _2 = fninfo_nt
    {      ( try
	let _ = List.find (function Ast0.FAttr(_) -> true | _ -> false) _2 in
	raise (Semantic_cocci.Semantic "duplicate init")
      with Not_found -> (Ast0.FAttr(P.id2mcode _1))::_2 )}

storage:
  s = Tstatic
    {                        ( P.clt2mcode Ast.Static s )}
| s = Tauto
    {                        ( P.clt2mcode Ast.Auto s )}
| s = Tregister
    {                        ( P.clt2mcode Ast.Register s )}
| s = Textern
    {                        ( P.clt2mcode Ast.Extern s )}

decl:
  t = ctype i = ident
    { ( Ast0.wrap(Ast0.Param(t, Some i)) )}
| t = fn_ctype lp = TOPar s = TMul i = ident rp = TCPar lp1 = TOPar d = decl_list_name_opt_decl_ rp1 = TCPar
    {        ( let fnptr =
	  Ast0.wrap
	    (Ast0.FunctionPointer
	       (t,P.clt2mcode "(" lp,P.clt2mcode "*" s,P.clt2mcode ")" rp,
		P.clt2mcode "(" lp1,d,P.clt2mcode ")" rp1)) in
	Ast0.wrap(Ast0.Param(fnptr, Some i)) )}
| t = Tvoid
    { ( let ty = Ast0.wrap(Ast0.BaseType(P.clt2mcode Ast.VoidType t, None)) in
          Ast0.wrap(Ast0.VoidParam(ty)) )}
| _1 = TMetaParam
    { ( let (nm,pure,clt) = _1 in
	Ast0.wrap(Ast0.MetaParam(P.clt2mcode nm clt,pure)) )}

name_opt_decl:
  _1 = decl
    {            ( _1 )}
| t = ctype
    {              ( Ast0.wrap(Ast0.Param(t, None)) )}
| t = fn_ctype lp = TOPar s = TMul rp = TCPar lp1 = TOPar d = decl_list_name_opt_decl_ rp1 = TCPar
    {        ( let fnptr =
	  Ast0.wrap
	    (Ast0.FunctionPointer
	       (t,P.clt2mcode "(" lp,P.clt2mcode "*" s,P.clt2mcode ")" rp,
		P.clt2mcode "(" lp1,d,P.clt2mcode ")" rp1)) in
	Ast0.wrap(Ast0.Param(fnptr, None)) )}

const_vol:
  _1 = Tconst
    {                   ( P.clt2mcode Ast.Const _1 )}
| _1 = Tvolatile
    {                   ( P.clt2mcode Ast.Volatile _1 )}

statement:
  _1 = TMetaStm
    {    ( P.meta_stm _1 )}
| _1 = expr _2 = TPtVirg
    {    ( P.exp_stm _1 _2 )}
| _1 = TIf _2 = TOPar _3 = eexpr _4 = TCPar _5 = single_statement %prec TIf
    {    ( P.ifthen _1 _2 _3 _4 _5 )}
| _1 = TIf _2 = TOPar _3 = eexpr _4 = TCPar _5 = single_statement _6 = TElse _7 = single_statement
    {    ( P.ifthenelse _1 _2 _3 _4 _5 _6 _7 )}
| _1 = TFor _2 = TOPar _3 = option_eexpr_ _4 = TPtVirg _5 = option_eexpr_ _6 = TPtVirg _7 = option_eexpr_ _8 = TCPar _9 = single_statement
    {    ( P.forloop _1 _2 _3 _4 _5 _6 _7 _8 _9 )}
| _1 = TWhile _2 = TOPar _3 = eexpr _4 = TCPar _5 = single_statement
    {    ( P.whileloop _1 _2 _3 _4 _5 )}
| _1 = TDo _2 = single_statement _3 = TWhile _4 = TOPar _5 = eexpr _6 = TCPar _7 = TPtVirg
    {    ( P.doloop _1 _2 _3 _4 _5 _6 _7 )}
| _1 = TSwitch _2 = TOPar _3 = eexpr _4 = TCPar _5 = TOBrace _6 = list_case_line_ _7 = TCBrace
    {    ( P.switch _1 _2 _3 _4 _5 _6 _7 )}
| _1 = TReturn _2 = eexpr _3 = TPtVirg
    {                        ( P.ret_exp _1 _2 _3 )}
| _1 = TReturn _2 = TPtVirg
    {                  ( P.ret _1 _2 )}
| _1 = TBreak _2 = TPtVirg
    {                 ( P.break _1 _2 )}
| _1 = TContinue _2 = TPtVirg
    {                    ( P.cont _1 _2 )}
| _1 = TOBrace _2 = pre_post_decl_statement_and_expression_opt _3 = TCBrace
    {    ( P.seq _1 _2 _3 )}
| _1 = TOEllipsis w = option_whenppdecs_ b = statement_dots_TEllipsis_ c = TCEllipsis
    {    ( Ast0.wrap(Ast0.Nest(P.clt2mcode "<..." _1,
			  Ast0.wrap(Ast0.DOTS(b (P.mkdots "..."))),
			  P.clt2mcode "...>" c, w)) )}

whenppdecs:
  _1 = TWhen _2 = TNotEq w = pre_post_decl_statement_or_expression _4 = TLineEnd
    {    ( w )}

rule_elem_statement:
  _1 = expr _2 = TPtVirg
    {               ( P.exp_stm _1 _2 )}
| _1 = TReturn _2 = eexpr _3 = TPtVirg
    {                        ( P.ret_exp _1 _2 _3 )}
| _1 = TReturn _2 = TPtVirg
    {                  ( P.ret _1 _2 )}
| _1 = TBreak _2 = TPtVirg
    {                 ( P.break _1 _2 )}
| _1 = TContinue _2 = TPtVirg
    {                    ( P.cont _1 _2 )}
| _1 = TOPar0 _2 = midzero_list_rule_elem_statement_ _3 = TCPar0
    {    ( let (mids,code) = _2 in
    Ast0.wrap
      (Ast0.Disj(P.clt2mcode "(" _1,
		 List.map (function x -> Ast0.wrap(Ast0.DOTS([x]))) code,
		 mids, P.clt2mcode ")" _3)) )}

statement_dots_TEllipsis_:
  r = no_dot_start_end_exp_decl_statement_list_dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement__
    {  ( function dot_builder ->
    List.concat (r (function x -> [dot_builder x])) )}

single_statement:
  _1 = statement
    {                                      ( _1 )}
| _1 = TOPar0 _2 = midzero_list_statement_ _3 = TCPar0
    {      ( let (mids,code) = _2 in
        Ast0.wrap
	  (Ast0.Disj(P.clt2mcode "(" _1,
		     List.map (function x -> Ast0.wrap(Ast0.DOTS([x]))) code,
		     mids, P.clt2mcode ")" _3)) )}

case_line:
  _1 = TDefault _2 = TDotDot _3 = pre_post_decl_statement_and_expression_opt
    {      ( Ast0.wrap(Ast0.Default(P.clt2mcode "default" _1,P.clt2mcode ":" _2,_3)) )}
| _1 = TCase _2 = eexpr _3 = TDotDot _4 = pre_post_decl_statement_and_expression_opt
    {      ( Ast0.wrap(Ast0.Case(P.clt2mcode "case" _1,_2,P.clt2mcode ":" _3,_4)) )}

decl_var:
  t = ctype pv = TPtVirg
    {      ( [Ast0.wrap(Ast0.TyDecl(t,P.clt2mcode ";" pv))] )}
| t = ctype d = comma_list_d_ident_ pv = TPtVirg
    {let s =     ( None ) in
      ( List.map
	  (function (id,fn) ->
	    Ast0.wrap(Ast0.UnInit(s,fn t,id,P.clt2mcode ";" pv)))
	  d )}
| x = storage t = ctype d = comma_list_d_ident_ pv = TPtVirg
    {let s =     ( Some x ) in
      ( List.map
	  (function (id,fn) ->
	    Ast0.wrap(Ast0.UnInit(s,fn t,id,P.clt2mcode ";" pv)))
	  d )}
| f = funproto
    {               ( [f] )}
| t = ctype d = d_ident q = TEq e = initialize pv = TPtVirg
    {let s =     ( None ) in
      ( let (id,fn) = d in
      [Ast0.wrap(Ast0.Init(s,fn t,id,P.clt2mcode "=" q,e,P.clt2mcode ";" pv))] )}
| x = storage t = ctype d = d_ident q = TEq e = initialize pv = TPtVirg
    {let s =     ( Some x ) in
      ( let (id,fn) = d in
      [Ast0.wrap(Ast0.Init(s,fn t,id,P.clt2mcode "=" q,e,P.clt2mcode ";" pv))] )}
| i = pure_ident d = comma_list_d_ident_ pv = TPtVirg
    {let cv =     ( None ) in
let s =     ( None ) in
      ( List.map
	  (function (id,fn) ->
	    let idtype = P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
	    Ast0.wrap(Ast0.UnInit(s,fn idtype,id,P.clt2mcode ";" pv)))
	  d )}
| x = const_vol i = pure_ident d = comma_list_d_ident_ pv = TPtVirg
    {let cv =     ( Some x ) in
let s =     ( None ) in
      ( List.map
	  (function (id,fn) ->
	    let idtype = P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
	    Ast0.wrap(Ast0.UnInit(s,fn idtype,id,P.clt2mcode ";" pv)))
	  d )}
| x = storage i = pure_ident d = comma_list_d_ident_ pv = TPtVirg
    {let cv =     ( None ) in
let s =     ( Some x ) in
      ( List.map
	  (function (id,fn) ->
	    let idtype = P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
	    Ast0.wrap(Ast0.UnInit(s,fn idtype,id,P.clt2mcode ";" pv)))
	  d )}
| x = storage x_inlined1 = const_vol i = pure_ident d = comma_list_d_ident_ pv = TPtVirg
    {let cv =
  let x = x_inlined1 in
      ( Some x )
in
let s =     ( Some x ) in
      ( List.map
	  (function (id,fn) ->
	    let idtype = P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
	    Ast0.wrap(Ast0.UnInit(s,fn idtype,id,P.clt2mcode ";" pv)))
	  d )}
| i = pure_ident d = d_ident q = TEq e = initialize pv = TPtVirg
    {let cv =     ( None ) in
let s =     ( None ) in
      ( let (id,fn) = d in
      !Data.add_type_name (P.id2name i);
      let idtype = P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
      [Ast0.wrap(Ast0.Init(s,fn idtype,id,P.clt2mcode "=" q,e,
			   P.clt2mcode ";" pv))] )}
| x = const_vol i = pure_ident d = d_ident q = TEq e = initialize pv = TPtVirg
    {let cv =     ( Some x ) in
let s =     ( None ) in
      ( let (id,fn) = d in
      !Data.add_type_name (P.id2name i);
      let idtype = P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
      [Ast0.wrap(Ast0.Init(s,fn idtype,id,P.clt2mcode "=" q,e,
			   P.clt2mcode ";" pv))] )}
| x = storage i = pure_ident d = d_ident q = TEq e = initialize pv = TPtVirg
    {let cv =     ( None ) in
let s =     ( Some x ) in
      ( let (id,fn) = d in
      !Data.add_type_name (P.id2name i);
      let idtype = P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
      [Ast0.wrap(Ast0.Init(s,fn idtype,id,P.clt2mcode "=" q,e,
			   P.clt2mcode ";" pv))] )}
| x = storage x_inlined1 = const_vol i = pure_ident d = d_ident q = TEq e = initialize pv = TPtVirg
    {let cv =
  let x = x_inlined1 in
      ( Some x )
in
let s =     ( Some x ) in
      ( let (id,fn) = d in
      !Data.add_type_name (P.id2name i);
      let idtype = P.make_cv cv (Ast0.wrap (Ast0.TypeName(P.id2mcode i))) in
      [Ast0.wrap(Ast0.Init(s,fn idtype,id,P.clt2mcode "=" q,e,
			   P.clt2mcode ";" pv))] )}
| t = fn_ctype lp1 = TOPar st = TMul d = d_ident rp1 = TCPar lp2 = TOPar p = decl_list_name_opt_decl_ rp2 = TCPar pv = TPtVirg
    {let s =     ( None ) in
      ( let (id,fn) = d in
        let t =
	  Ast0.wrap
	    (Ast0.FunctionPointer
	       (t,P.clt2mcode "(" lp1,P.clt2mcode "*" st,P.clt2mcode ")" rp1,
		P.clt2mcode "(" lp2,p,P.clt2mcode ")" rp2)) in
        [Ast0.wrap(Ast0.UnInit(s,fn t,id,P.clt2mcode ";" pv))] )}
| x = storage t = fn_ctype lp1 = TOPar st = TMul d = d_ident rp1 = TCPar lp2 = TOPar p = decl_list_name_opt_decl_ rp2 = TCPar pv = TPtVirg
    {let s =     ( Some x ) in
      ( let (id,fn) = d in
        let t =
	  Ast0.wrap
	    (Ast0.FunctionPointer
	       (t,P.clt2mcode "(" lp1,P.clt2mcode "*" st,P.clt2mcode ")" rp1,
		P.clt2mcode "(" lp2,p,P.clt2mcode ")" rp2)) in
        [Ast0.wrap(Ast0.UnInit(s,fn t,id,P.clt2mcode ";" pv))] )}
| _1 = TDeclarerId _2 = TOPar _3 = eexpr_list_option _4 = TCPar _5 = TPtVirg
    {      ( [Ast0.wrap(Ast0.MacroDecl(P.id2mcode _1,P.clt2mcode "(" _2,_3,
				  P.clt2mcode ")" _4,P.clt2mcode ";" _5))] )}
| t = fn_ctype lp1 = TOPar st = TMul d = d_ident rp1 = TCPar lp2 = TOPar p = decl_list_name_opt_decl_ rp2 = TCPar q = TEq e = initialize pv = TPtVirg
    {let s =     ( None ) in
      ( let (id,fn) = d in
        let t =
	  Ast0.wrap
	    (Ast0.FunctionPointer
	       (t,P.clt2mcode "(" lp1,P.clt2mcode "*" st,P.clt2mcode ")" rp1,
		P.clt2mcode "(" lp2,p,P.clt2mcode ")" rp2)) in
      [Ast0.wrap(Ast0.Init(s,fn t,id,P.clt2mcode "=" q,e,P.clt2mcode ";" pv))] )}
| x = storage t = fn_ctype lp1 = TOPar st = TMul d = d_ident rp1 = TCPar lp2 = TOPar p = decl_list_name_opt_decl_ rp2 = TCPar q = TEq e = initialize pv = TPtVirg
    {let s =     ( Some x ) in
      ( let (id,fn) = d in
        let t =
	  Ast0.wrap
	    (Ast0.FunctionPointer
	       (t,P.clt2mcode "(" lp1,P.clt2mcode "*" st,P.clt2mcode ")" rp1,
		P.clt2mcode "(" lp2,p,P.clt2mcode ")" rp2)) in
      [Ast0.wrap(Ast0.Init(s,fn t,id,P.clt2mcode "=" q,e,P.clt2mcode ";" pv))] )}

d_ident:
  _1 = ident _2 = list_array_dec_
    {      ( (_1,
	 function t ->
	   List.fold_right
	     (function (l,i,r) ->
	       function rest ->
		 Ast0.wrap
		   (Ast0.Array(rest,P.clt2mcode "[" l,i,P.clt2mcode "]" r)))
	     _2 t) )}

array_dec:
  l = TOCro i = option_eexpr_ r = TCCro
    {                                           ( (l,i,r) )}

initialize:
  _1 = eexpr
    {      ( Ast0.wrap(Ast0.InitExpr(_1)) )}
| _1 = TOBrace _2 = initialize_list _3 = TCBrace
    {      ( Ast0.wrap(Ast0.InitList(P.clt2mcode "{" _1,_2,P.clt2mcode "}" _3)) )}
| _1 = TOBrace _2 = TCBrace
    {      ( Ast0.wrap
	  (Ast0.InitList(P.clt2mcode "{" _1,Ast0.wrap(Ast0.DOTS []),
			 P.clt2mcode "}" _2)) )}

initialize2:
  _1 = arith_expr_eexpr_invalid_
    {                            ( Ast0.wrap(Ast0.InitExpr(_1)) )}
| _1 = TOBrace _2 = initialize_list _3 = TCBrace
    {    ( Ast0.wrap(Ast0.InitList(P.clt2mcode "{" _1,_2,P.clt2mcode "}" _3)) )}
| _1 = TOBrace _2 = TCBrace
    {    ( Ast0.wrap
	(Ast0.InitList(P.clt2mcode "{" _1,Ast0.wrap(Ast0.DOTS []),
		       P.clt2mcode "}" _2)) )}
| _1 = TDot _2 = ident _3 = TEq _4 = initialize2
    {    ( Ast0.wrap(Ast0.InitGccDotName(P.clt2mcode "." _1,_2,P.clt2mcode "=" _3,_4)) )}
| _1 = ident _2 = TDotDot _3 = initialize2
    {    ( Ast0.wrap(Ast0.InitGccName(_1,P.clt2mcode ":" _2,_3)) )}
| _1 = TOCro _2 = eexpr _3 = TCCro _4 = TEq _5 = initialize2
    {    ( Ast0.wrap(Ast0.InitGccIndex(P.clt2mcode "[" _1,_2,P.clt2mcode "]" _3,
				  P.clt2mcode "=" _4,_5)) )}
| _1 = TOCro _2 = eexpr _3 = TEllipsis _4 = eexpr _5 = TCCro _6 = TEq _7 = initialize2
    {    ( Ast0.wrap(Ast0.InitGccRange(P.clt2mcode "[" _1,_2,P.clt2mcode "..." _3,
				  _4,P.clt2mcode "]" _5,P.clt2mcode "=" _6,_7)) )}

initialize_list:
  _1 = initialize_list_start
    {                         ( Ast0.wrap(Ast0.DOTS(_1)) )}

initialize_list_start:
  _1 = initialize2 _2 = TComma
    {                     ( [_1;Ast0.wrap(Ast0.IComma(P.clt2mcode "," _2))] )}
| _1 = initialize2 _2 = TComma _3 = initialize_list_start
    {    ( _1::Ast0.wrap(Ast0.IComma(P.clt2mcode "," _2))::_3 )}
| d = edots_when_TEllipsis_initialize_ r = comma_initializers_edots_when_TEllipsis_initialize__
    {    ( (P.mkidots "..." d)::
      (List.concat(List.map (function x -> x (P.mkidots "...")) r)) )}

comma_initializers_edots_when_TEllipsis_initialize__:
  
    {              ( [] )}
| d = edots_when_TEllipsis_initialize_ r = comma_initializers2_edots_when_TEllipsis_initialize__
    {      ( (function dot_builder -> [dot_builder d])::r )}
| i = initialize2 c = TComma r = comma_initializers_edots_when_TEllipsis_initialize__
    {    ( (function dot_builder -> [i; Ast0.wrap(Ast0.IComma(P.clt2mcode "," c))])::
      r )}

comma_initializers2_edots_when_TEllipsis_initialize__:
  
    {              ( [] )}
| i = initialize2 c = TComma r = comma_initializers_edots_when_TEllipsis_initialize__
    {    ( (function dot_builder -> [i; Ast0.wrap(Ast0.IComma(P.clt2mcode "," c))])::
      r )}

decl_statement:
  _1 = TMetaStmList
    {      ( let (nm,pure,clt) = _1 in
      [Ast0.wrap(Ast0.MetaStmt(P.clt2mcode nm clt,pure))] )}
| _1 = decl_var
    {      ( List.map
	  (function x ->
	    Ast0.wrap
	      (Ast0.Decl((Ast0.default_info(),Ast0.context_befaft()),x)))
	  _1 )}
| _1 = statement
    {              ( [_1] )}
| _1 = TOPar0 _2 = pre_post_decl_statement_and_expression_opt_mid _3 = TCPar0
    {      ( let (first,rest) = _2 in
        let (mids,code) = List.split rest in
	let code = first :: code in
	if List.for_all
	    (function x ->
	      match Ast0.unwrap x with Ast0.DOTS([]) -> true | _ -> false)
	    code
      then []
      else [Ast0.wrap(Ast0.Disj(P.clt2mcode "(" _1,
				code, mids,
				P.clt2mcode ")" _3))] )}

expr:
  _1 = basic_expr_expr_invalid_
    {                                ( _1 )}

eexpr:
  _1 = basic_expr_eexpr_dot_expressions_
    {                                         ( _1 )}

dexpr:
  _1 = basic_expr_eexpr_nest_expressions_
    {                                          ( _1 )}

invalid:
  _1 = TInvalid
    {           ( raise (Semantic_cocci.Semantic "not matchable") )}

dot_expressions:
  _1 = TEllipsis
    {            ( Ast0.wrap(Ast0.Edots(P.clt2mcode "..." _1,None)) )}
| _1 = nest_expressions
    {                   ( _1 )}

nest_expressions:
  _1 = TOEllipsis w = option_whenexp_ e = expr_dots_TEllipsis_ c = TCEllipsis
    {    ( Ast0.wrap(Ast0.NestExpr(P.clt2mcode "<..." _1,
			      Ast0.wrap(Ast0.DOTS(e (P.mkedots "..."))),
			      P.clt2mcode "...>" c, w)) )}

whenexp:
  _1 = TWhen _2 = TNotEq w = eexpr _4 = TLineEnd
    {                                       ( w )}

basic_expr_eexpr_dot_expressions_:
  _1 = assign_expr_eexpr_dot_expressions_
    {                                                             ( _1 )}

basic_expr_eexpr_nest_expressions_:
  _1 = assign_expr_eexpr_nest_expressions_
    {                                                             ( _1 )}

basic_expr_expr_invalid_:
  _1 = assign_expr_expr_invalid_
    {                                                             ( _1 )}

assign_expr_eexpr_dot_expressions_:
  _1 = cond_expr_eexpr_dot_expressions_
    {                                           ( _1 )}
| _1 = unary_expr_eexpr_dot_expressions_ _2 = TAssign _3 = assign_expr_eexpr_dot_expressions_
    {      ( let (op,clt) = _2 in
      Ast0.wrap(Ast0.Assignment(_1,P.clt2mcode op clt,_3)) )}
| _1 = unary_expr_eexpr_dot_expressions_ _2 = TEq _3 = assign_expr_eexpr_dot_expressions_
    {      ( Ast0.wrap
	  (Ast0.Assignment
	     (_1,P.clt2mcode Ast.SimpleAssign _2,_3)) )}

assign_expr_eexpr_nest_expressions_:
  _1 = cond_expr_eexpr_nest_expressions_
    {                                           ( _1 )}
| _1 = unary_expr_eexpr_nest_expressions_ _2 = TAssign _3 = assign_expr_eexpr_nest_expressions_
    {      ( let (op,clt) = _2 in
      Ast0.wrap(Ast0.Assignment(_1,P.clt2mcode op clt,_3)) )}
| _1 = unary_expr_eexpr_nest_expressions_ _2 = TEq _3 = assign_expr_eexpr_nest_expressions_
    {      ( Ast0.wrap
	  (Ast0.Assignment
	     (_1,P.clt2mcode Ast.SimpleAssign _2,_3)) )}

assign_expr_expr_invalid_:
  _1 = cond_expr_expr_invalid_
    {                                           ( _1 )}
| _1 = unary_expr_expr_invalid_ _2 = TAssign _3 = assign_expr_expr_invalid_
    {      ( let (op,clt) = _2 in
      Ast0.wrap(Ast0.Assignment(_1,P.clt2mcode op clt,_3)) )}
| _1 = unary_expr_expr_invalid_ _2 = TEq _3 = assign_expr_expr_invalid_
    {      ( Ast0.wrap
	  (Ast0.Assignment
	     (_1,P.clt2mcode Ast.SimpleAssign _2,_3)) )}

cond_expr_eexpr_dot_expressions_:
  _1 = arith_expr_eexpr_dot_expressions_
    {                                             ( _1 )}
| l = arith_expr_eexpr_dot_expressions_ w = TWhy t = option_eexpr_ dd = TDotDot r = cond_expr_eexpr_dot_expressions_
    {      ( Ast0.wrap(Ast0.CondExpr (l, P.clt2mcode "?" w, t,
				 P.clt2mcode ":" dd, r)) )}

cond_expr_eexpr_nest_expressions_:
  _1 = arith_expr_eexpr_nest_expressions_
    {                                             ( _1 )}
| l = arith_expr_eexpr_nest_expressions_ w = TWhy t = option_eexpr_ dd = TDotDot r = cond_expr_eexpr_nest_expressions_
    {      ( Ast0.wrap(Ast0.CondExpr (l, P.clt2mcode "?" w, t,
				 P.clt2mcode ":" dd, r)) )}

cond_expr_expr_invalid_:
  _1 = arith_expr_expr_invalid_
    {                                             ( _1 )}
| l = arith_expr_expr_invalid_ w = TWhy t = option_eexpr_ dd = TDotDot r = cond_expr_expr_invalid_
    {      ( Ast0.wrap(Ast0.CondExpr (l, P.clt2mcode "?" w, t,
				 P.clt2mcode ":" dd, r)) )}

arith_expr_eexpr_dot_expressions_:
  _1 = cast_expr_eexpr_dot_expressions_
    {                                            ( _1 )}
| _1 = arith_expr_eexpr_dot_expressions_ _2 = TMul _3 = arith_expr_eexpr_dot_expressions_
    {      ( P.arith_op Ast.Mul _1 _2 _3 )}
| _1 = arith_expr_eexpr_dot_expressions_ _2 = TDiv _3 = arith_expr_eexpr_dot_expressions_
    {      ( P.arith_op Ast.Div _1 _2 _3 )}
| _1 = arith_expr_eexpr_dot_expressions_ _2 = TMod _3 = arith_expr_eexpr_dot_expressions_
    {      ( P.arith_op Ast.Mod _1 _2 _3 )}
| _1 = arith_expr_eexpr_dot_expressions_ _2 = TPlus _3 = arith_expr_eexpr_dot_expressions_
    {      ( P.arith_op Ast.Plus _1 _2 _3 )}
| _1 = arith_expr_eexpr_dot_expressions_ _2 = TMinus _3 = arith_expr_eexpr_dot_expressions_
    {      ( P.arith_op Ast.Minus _1 _2 _3 )}
| _1 = arith_expr_eexpr_dot_expressions_ _2 = TShl _3 = arith_expr_eexpr_dot_expressions_
    {      ( P.arith_op Ast.DecLeft _1 _2 _3 )}
| _1 = arith_expr_eexpr_dot_expressions_ _2 = TShr _3 = arith_expr_eexpr_dot_expressions_
    {      ( P.arith_op Ast.DecRight _1 _2 _3)}
| _1 = arith_expr_eexpr_dot_expressions_ _2 = TInf _3 = arith_expr_eexpr_dot_expressions_
    {      ( P.logic_op Ast.Inf _1 _2 _3 )}
| _1 = arith_expr_eexpr_dot_expressions_ _2 = TSup _3 = arith_expr_eexpr_dot_expressions_
    {      ( P.logic_op Ast.Sup _1 _2 _3 )}
| _1 = arith_expr_eexpr_dot_expressions_ _2 = TInfEq _3 = arith_expr_eexpr_dot_expressions_
    {      ( P.logic_op Ast.InfEq _1 _2 _3 )}
| _1 = arith_expr_eexpr_dot_expressions_ _2 = TSupEq _3 = arith_expr_eexpr_dot_expressions_
    {      ( P.logic_op Ast.SupEq _1 _2 _3 )}
| _1 = arith_expr_eexpr_dot_expressions_ _2 = TEqEq _3 = arith_expr_eexpr_dot_expressions_
    {      ( P.logic_op Ast.Eq _1 _2 _3 )}
| _1 = arith_expr_eexpr_dot_expressions_ _2 = TNotEq _3 = arith_expr_eexpr_dot_expressions_
    {      ( P.logic_op Ast.NotEq _1 _2 _3 )}
| _1 = arith_expr_eexpr_dot_expressions_ _2 = TAnd _3 = arith_expr_eexpr_dot_expressions_
    {      ( P.arith_op Ast.And _1 _2 _3 )}
| _1 = arith_expr_eexpr_dot_expressions_ _2 = TOr _3 = arith_expr_eexpr_dot_expressions_
    {      ( P.arith_op Ast.Or _1 _2 _3 )}
| _1 = arith_expr_eexpr_dot_expressions_ _2 = TXor _3 = arith_expr_eexpr_dot_expressions_
    {      ( P.arith_op Ast.Xor _1 _2 _3 )}
| _1 = arith_expr_eexpr_dot_expressions_ _2 = TAndLog _3 = arith_expr_eexpr_dot_expressions_
    {      ( P.logic_op Ast.AndLog _1 _2 _3 )}
| _1 = arith_expr_eexpr_dot_expressions_ _2 = TOrLog _3 = arith_expr_eexpr_dot_expressions_
    {      ( P.logic_op Ast.OrLog _1 _2 _3 )}

arith_expr_eexpr_invalid_:
  _1 = cast_expr_eexpr_invalid_
    {                                            ( _1 )}
| _1 = arith_expr_eexpr_invalid_ _2 = TMul _3 = arith_expr_eexpr_invalid_
    {      ( P.arith_op Ast.Mul _1 _2 _3 )}
| _1 = arith_expr_eexpr_invalid_ _2 = TDiv _3 = arith_expr_eexpr_invalid_
    {      ( P.arith_op Ast.Div _1 _2 _3 )}
| _1 = arith_expr_eexpr_invalid_ _2 = TMod _3 = arith_expr_eexpr_invalid_
    {      ( P.arith_op Ast.Mod _1 _2 _3 )}
| _1 = arith_expr_eexpr_invalid_ _2 = TPlus _3 = arith_expr_eexpr_invalid_
    {      ( P.arith_op Ast.Plus _1 _2 _3 )}
| _1 = arith_expr_eexpr_invalid_ _2 = TMinus _3 = arith_expr_eexpr_invalid_
    {      ( P.arith_op Ast.Minus _1 _2 _3 )}
| _1 = arith_expr_eexpr_invalid_ _2 = TShl _3 = arith_expr_eexpr_invalid_
    {      ( P.arith_op Ast.DecLeft _1 _2 _3 )}
| _1 = arith_expr_eexpr_invalid_ _2 = TShr _3 = arith_expr_eexpr_invalid_
    {      ( P.arith_op Ast.DecRight _1 _2 _3)}
| _1 = arith_expr_eexpr_invalid_ _2 = TInf _3 = arith_expr_eexpr_invalid_
    {      ( P.logic_op Ast.Inf _1 _2 _3 )}
| _1 = arith_expr_eexpr_invalid_ _2 = TSup _3 = arith_expr_eexpr_invalid_
    {      ( P.logic_op Ast.Sup _1 _2 _3 )}
| _1 = arith_expr_eexpr_invalid_ _2 = TInfEq _3 = arith_expr_eexpr_invalid_
    {      ( P.logic_op Ast.InfEq _1 _2 _3 )}
| _1 = arith_expr_eexpr_invalid_ _2 = TSupEq _3 = arith_expr_eexpr_invalid_
    {      ( P.logic_op Ast.SupEq _1 _2 _3 )}
| _1 = arith_expr_eexpr_invalid_ _2 = TEqEq _3 = arith_expr_eexpr_invalid_
    {      ( P.logic_op Ast.Eq _1 _2 _3 )}
| _1 = arith_expr_eexpr_invalid_ _2 = TNotEq _3 = arith_expr_eexpr_invalid_
    {      ( P.logic_op Ast.NotEq _1 _2 _3 )}
| _1 = arith_expr_eexpr_invalid_ _2 = TAnd _3 = arith_expr_eexpr_invalid_
    {      ( P.arith_op Ast.And _1 _2 _3 )}
| _1 = arith_expr_eexpr_invalid_ _2 = TOr _3 = arith_expr_eexpr_invalid_
    {      ( P.arith_op Ast.Or _1 _2 _3 )}
| _1 = arith_expr_eexpr_invalid_ _2 = TXor _3 = arith_expr_eexpr_invalid_
    {      ( P.arith_op Ast.Xor _1 _2 _3 )}
| _1 = arith_expr_eexpr_invalid_ _2 = TAndLog _3 = arith_expr_eexpr_invalid_
    {      ( P.logic_op Ast.AndLog _1 _2 _3 )}
| _1 = arith_expr_eexpr_invalid_ _2 = TOrLog _3 = arith_expr_eexpr_invalid_
    {      ( P.logic_op Ast.OrLog _1 _2 _3 )}

arith_expr_eexpr_nest_expressions_:
  _1 = cast_expr_eexpr_nest_expressions_
    {                                            ( _1 )}
| _1 = arith_expr_eexpr_nest_expressions_ _2 = TMul _3 = arith_expr_eexpr_nest_expressions_
    {      ( P.arith_op Ast.Mul _1 _2 _3 )}
| _1 = arith_expr_eexpr_nest_expressions_ _2 = TDiv _3 = arith_expr_eexpr_nest_expressions_
    {      ( P.arith_op Ast.Div _1 _2 _3 )}
| _1 = arith_expr_eexpr_nest_expressions_ _2 = TMod _3 = arith_expr_eexpr_nest_expressions_
    {      ( P.arith_op Ast.Mod _1 _2 _3 )}
| _1 = arith_expr_eexpr_nest_expressions_ _2 = TPlus _3 = arith_expr_eexpr_nest_expressions_
    {      ( P.arith_op Ast.Plus _1 _2 _3 )}
| _1 = arith_expr_eexpr_nest_expressions_ _2 = TMinus _3 = arith_expr_eexpr_nest_expressions_
    {      ( P.arith_op Ast.Minus _1 _2 _3 )}
| _1 = arith_expr_eexpr_nest_expressions_ _2 = TShl _3 = arith_expr_eexpr_nest_expressions_
    {      ( P.arith_op Ast.DecLeft _1 _2 _3 )}
| _1 = arith_expr_eexpr_nest_expressions_ _2 = TShr _3 = arith_expr_eexpr_nest_expressions_
    {      ( P.arith_op Ast.DecRight _1 _2 _3)}
| _1 = arith_expr_eexpr_nest_expressions_ _2 = TInf _3 = arith_expr_eexpr_nest_expressions_
    {      ( P.logic_op Ast.Inf _1 _2 _3 )}
| _1 = arith_expr_eexpr_nest_expressions_ _2 = TSup _3 = arith_expr_eexpr_nest_expressions_
    {      ( P.logic_op Ast.Sup _1 _2 _3 )}
| _1 = arith_expr_eexpr_nest_expressions_ _2 = TInfEq _3 = arith_expr_eexpr_nest_expressions_
    {      ( P.logic_op Ast.InfEq _1 _2 _3 )}
| _1 = arith_expr_eexpr_nest_expressions_ _2 = TSupEq _3 = arith_expr_eexpr_nest_expressions_
    {      ( P.logic_op Ast.SupEq _1 _2 _3 )}
| _1 = arith_expr_eexpr_nest_expressions_ _2 = TEqEq _3 = arith_expr_eexpr_nest_expressions_
    {      ( P.logic_op Ast.Eq _1 _2 _3 )}
| _1 = arith_expr_eexpr_nest_expressions_ _2 = TNotEq _3 = arith_expr_eexpr_nest_expressions_
    {      ( P.logic_op Ast.NotEq _1 _2 _3 )}
| _1 = arith_expr_eexpr_nest_expressions_ _2 = TAnd _3 = arith_expr_eexpr_nest_expressions_
    {      ( P.arith_op Ast.And _1 _2 _3 )}
| _1 = arith_expr_eexpr_nest_expressions_ _2 = TOr _3 = arith_expr_eexpr_nest_expressions_
    {      ( P.arith_op Ast.Or _1 _2 _3 )}
| _1 = arith_expr_eexpr_nest_expressions_ _2 = TXor _3 = arith_expr_eexpr_nest_expressions_
    {      ( P.arith_op Ast.Xor _1 _2 _3 )}
| _1 = arith_expr_eexpr_nest_expressions_ _2 = TAndLog _3 = arith_expr_eexpr_nest_expressions_
    {      ( P.logic_op Ast.AndLog _1 _2 _3 )}
| _1 = arith_expr_eexpr_nest_expressions_ _2 = TOrLog _3 = arith_expr_eexpr_nest_expressions_
    {      ( P.logic_op Ast.OrLog _1 _2 _3 )}

arith_expr_expr_invalid_:
  _1 = cast_expr_expr_invalid_
    {                                            ( _1 )}
| _1 = arith_expr_expr_invalid_ _2 = TMul _3 = arith_expr_expr_invalid_
    {      ( P.arith_op Ast.Mul _1 _2 _3 )}
| _1 = arith_expr_expr_invalid_ _2 = TDiv _3 = arith_expr_expr_invalid_
    {      ( P.arith_op Ast.Div _1 _2 _3 )}
| _1 = arith_expr_expr_invalid_ _2 = TMod _3 = arith_expr_expr_invalid_
    {      ( P.arith_op Ast.Mod _1 _2 _3 )}
| _1 = arith_expr_expr_invalid_ _2 = TPlus _3 = arith_expr_expr_invalid_
    {      ( P.arith_op Ast.Plus _1 _2 _3 )}
| _1 = arith_expr_expr_invalid_ _2 = TMinus _3 = arith_expr_expr_invalid_
    {      ( P.arith_op Ast.Minus _1 _2 _3 )}
| _1 = arith_expr_expr_invalid_ _2 = TShl _3 = arith_expr_expr_invalid_
    {      ( P.arith_op Ast.DecLeft _1 _2 _3 )}
| _1 = arith_expr_expr_invalid_ _2 = TShr _3 = arith_expr_expr_invalid_
    {      ( P.arith_op Ast.DecRight _1 _2 _3)}
| _1 = arith_expr_expr_invalid_ _2 = TInf _3 = arith_expr_expr_invalid_
    {      ( P.logic_op Ast.Inf _1 _2 _3 )}
| _1 = arith_expr_expr_invalid_ _2 = TSup _3 = arith_expr_expr_invalid_
    {      ( P.logic_op Ast.Sup _1 _2 _3 )}
| _1 = arith_expr_expr_invalid_ _2 = TInfEq _3 = arith_expr_expr_invalid_
    {      ( P.logic_op Ast.InfEq _1 _2 _3 )}
| _1 = arith_expr_expr_invalid_ _2 = TSupEq _3 = arith_expr_expr_invalid_
    {      ( P.logic_op Ast.SupEq _1 _2 _3 )}
| _1 = arith_expr_expr_invalid_ _2 = TEqEq _3 = arith_expr_expr_invalid_
    {      ( P.logic_op Ast.Eq _1 _2 _3 )}
| _1 = arith_expr_expr_invalid_ _2 = TNotEq _3 = arith_expr_expr_invalid_
    {      ( P.logic_op Ast.NotEq _1 _2 _3 )}
| _1 = arith_expr_expr_invalid_ _2 = TAnd _3 = arith_expr_expr_invalid_
    {      ( P.arith_op Ast.And _1 _2 _3 )}
| _1 = arith_expr_expr_invalid_ _2 = TOr _3 = arith_expr_expr_invalid_
    {      ( P.arith_op Ast.Or _1 _2 _3 )}
| _1 = arith_expr_expr_invalid_ _2 = TXor _3 = arith_expr_expr_invalid_
    {      ( P.arith_op Ast.Xor _1 _2 _3 )}
| _1 = arith_expr_expr_invalid_ _2 = TAndLog _3 = arith_expr_expr_invalid_
    {      ( P.logic_op Ast.AndLog _1 _2 _3 )}
| _1 = arith_expr_expr_invalid_ _2 = TOrLog _3 = arith_expr_expr_invalid_
    {      ( P.logic_op Ast.OrLog _1 _2 _3 )}

cast_expr_eexpr_dot_expressions_:
  _1 = unary_expr_eexpr_dot_expressions_
    {                                          ( _1 )}
| lp = TOPar t = ctype rp = TCPar e = cast_expr_eexpr_dot_expressions_
    {      ( Ast0.wrap(Ast0.Cast (P.clt2mcode "(" lp, t,
			     P.clt2mcode ")" rp, e)) )}

cast_expr_eexpr_invalid_:
  _1 = unary_expr_eexpr_invalid_
    {                                          ( _1 )}
| lp = TOPar t = ctype rp = TCPar e = cast_expr_eexpr_invalid_
    {      ( Ast0.wrap(Ast0.Cast (P.clt2mcode "(" lp, t,
			     P.clt2mcode ")" rp, e)) )}

cast_expr_eexpr_nest_expressions_:
  _1 = unary_expr_eexpr_nest_expressions_
    {                                          ( _1 )}
| lp = TOPar t = ctype rp = TCPar e = cast_expr_eexpr_nest_expressions_
    {      ( Ast0.wrap(Ast0.Cast (P.clt2mcode "(" lp, t,
			     P.clt2mcode ")" rp, e)) )}

cast_expr_expr_invalid_:
  _1 = unary_expr_expr_invalid_
    {                                          ( _1 )}
| lp = TOPar t = ctype rp = TCPar e = cast_expr_expr_invalid_
    {      ( Ast0.wrap(Ast0.Cast (P.clt2mcode "(" lp, t,
			     P.clt2mcode ")" rp, e)) )}

unary_expr_eexpr_dot_expressions_:
  _1 = postfix_expr_eexpr_dot_expressions_
    {                                         ( _1 )}
| _1 = TInc _2 = unary_expr_eexpr_dot_expressions_
    {      ( Ast0.wrap(Ast0.Infix (_2, P.clt2mcode Ast.Inc _1)) )}
| _1 = TDec _2 = unary_expr_eexpr_dot_expressions_
    {      ( Ast0.wrap(Ast0.Infix (_2, P.clt2mcode Ast.Dec _1)) )}
| _1 = unary_op _2 = unary_expr_eexpr_dot_expressions_
    {      ( let mcode = _1 in Ast0.wrap(Ast0.Unary(_2, mcode)) )}
| _1 = TSizeof _2 = unary_expr_eexpr_dot_expressions_
    {      ( Ast0.wrap(Ast0.SizeOfExpr (P.clt2mcode "sizeof" _1, _2)) )}
| s = TSizeof lp = TOPar t = ctype rp = TCPar
    {      ( Ast0.wrap(Ast0.SizeOfType (P.clt2mcode "sizeof" s,
                                   P.clt2mcode "(" lp,
                                   t,
                                   P.clt2mcode ")" rp)) )}

unary_expr_eexpr_invalid_:
  _1 = postfix_expr_eexpr_invalid_
    {                                         ( _1 )}
| _1 = TInc _2 = unary_expr_eexpr_invalid_
    {      ( Ast0.wrap(Ast0.Infix (_2, P.clt2mcode Ast.Inc _1)) )}
| _1 = TDec _2 = unary_expr_eexpr_invalid_
    {      ( Ast0.wrap(Ast0.Infix (_2, P.clt2mcode Ast.Dec _1)) )}
| _1 = unary_op _2 = unary_expr_eexpr_invalid_
    {      ( let mcode = _1 in Ast0.wrap(Ast0.Unary(_2, mcode)) )}
| _1 = TSizeof _2 = unary_expr_eexpr_invalid_
    {      ( Ast0.wrap(Ast0.SizeOfExpr (P.clt2mcode "sizeof" _1, _2)) )}
| s = TSizeof lp = TOPar t = ctype rp = TCPar
    {      ( Ast0.wrap(Ast0.SizeOfType (P.clt2mcode "sizeof" s,
                                   P.clt2mcode "(" lp,
                                   t,
                                   P.clt2mcode ")" rp)) )}

unary_expr_eexpr_nest_expressions_:
  _1 = postfix_expr_eexpr_nest_expressions_
    {                                         ( _1 )}
| _1 = TInc _2 = unary_expr_eexpr_nest_expressions_
    {      ( Ast0.wrap(Ast0.Infix (_2, P.clt2mcode Ast.Inc _1)) )}
| _1 = TDec _2 = unary_expr_eexpr_nest_expressions_
    {      ( Ast0.wrap(Ast0.Infix (_2, P.clt2mcode Ast.Dec _1)) )}
| _1 = unary_op _2 = unary_expr_eexpr_nest_expressions_
    {      ( let mcode = _1 in Ast0.wrap(Ast0.Unary(_2, mcode)) )}
| _1 = TSizeof _2 = unary_expr_eexpr_nest_expressions_
    {      ( Ast0.wrap(Ast0.SizeOfExpr (P.clt2mcode "sizeof" _1, _2)) )}
| s = TSizeof lp = TOPar t = ctype rp = TCPar
    {      ( Ast0.wrap(Ast0.SizeOfType (P.clt2mcode "sizeof" s,
                                   P.clt2mcode "(" lp,
                                   t,
                                   P.clt2mcode ")" rp)) )}

unary_expr_expr_invalid_:
  _1 = postfix_expr_expr_invalid_
    {                                         ( _1 )}
| _1 = TInc _2 = unary_expr_expr_invalid_
    {      ( Ast0.wrap(Ast0.Infix (_2, P.clt2mcode Ast.Inc _1)) )}
| _1 = TDec _2 = unary_expr_expr_invalid_
    {      ( Ast0.wrap(Ast0.Infix (_2, P.clt2mcode Ast.Dec _1)) )}
| _1 = unary_op _2 = unary_expr_expr_invalid_
    {      ( let mcode = _1 in Ast0.wrap(Ast0.Unary(_2, mcode)) )}
| _1 = TSizeof _2 = unary_expr_expr_invalid_
    {      ( Ast0.wrap(Ast0.SizeOfExpr (P.clt2mcode "sizeof" _1, _2)) )}
| s = TSizeof lp = TOPar t = ctype rp = TCPar
    {      ( Ast0.wrap(Ast0.SizeOfType (P.clt2mcode "sizeof" s,
                                   P.clt2mcode "(" lp,
                                   t,
                                   P.clt2mcode ")" rp)) )}

unary_op:
  _1 = TAnd
    {                  ( P.clt2mcode Ast.GetRef _1 )}
| _1 = TMul
    {           ( P.clt2mcode Ast.DeRef _1 )}
| _1 = TPlus
    {           ( P.clt2mcode Ast.UnPlus _1 )}
| _1 = TMinus
    {           ( P.clt2mcode Ast.UnMinus _1 )}
| _1 = TTilde
    {           ( P.clt2mcode Ast.Tilde _1 )}
| _1 = TBang
    {           ( P.clt2mcode Ast.Not _1 )}

postfix_expr_eexpr_dot_expressions_:
  _1 = primary_expr_eexpr_dot_expressions_
    {                                                 ( _1 )}
| _1 = postfix_expr_eexpr_dot_expressions_ _2 = TOCro _3 = eexpr _4 = TCCro
    {     ( Ast0.wrap(Ast0.ArrayAccess (_1,P.clt2mcode "[" _2,_3,
				       P.clt2mcode "]" _4)) )}
| _1 = postfix_expr_eexpr_dot_expressions_ _2 = TDot _3 = ident
    {     ( Ast0.wrap(Ast0.RecordAccess(_1, P.clt2mcode "." _2, _3)) )}
| _1 = postfix_expr_eexpr_dot_expressions_ _2 = TPtrOp _3 = ident
    {     ( Ast0.wrap(Ast0.RecordPtAccess(_1, P.clt2mcode "->" _2,
				     _3)) )}
| _1 = postfix_expr_eexpr_dot_expressions_ _2 = TInc
    {     ( Ast0.wrap(Ast0.Postfix (_1, P.clt2mcode Ast.Inc _2)) )}
| _1 = postfix_expr_eexpr_dot_expressions_ _2 = TDec
    {     ( Ast0.wrap(Ast0.Postfix (_1, P.clt2mcode Ast.Dec _2)) )}
| _1 = postfix_expr_eexpr_dot_expressions_ _2 = TOPar _3 = eexpr_list_option _4 = TCPar
    {     ( Ast0.wrap(Ast0.FunCall(_1,P.clt2mcode "(" _2,_3,
			      P.clt2mcode ")" _4)) )}

postfix_expr_eexpr_invalid_:
  _1 = primary_expr_eexpr_invalid_
    {                                                 ( _1 )}
| _1 = postfix_expr_eexpr_invalid_ _2 = TOCro _3 = eexpr _4 = TCCro
    {     ( Ast0.wrap(Ast0.ArrayAccess (_1,P.clt2mcode "[" _2,_3,
				       P.clt2mcode "]" _4)) )}
| _1 = postfix_expr_eexpr_invalid_ _2 = TDot _3 = ident
    {     ( Ast0.wrap(Ast0.RecordAccess(_1, P.clt2mcode "." _2, _3)) )}
| _1 = postfix_expr_eexpr_invalid_ _2 = TPtrOp _3 = ident
    {     ( Ast0.wrap(Ast0.RecordPtAccess(_1, P.clt2mcode "->" _2,
				     _3)) )}
| _1 = postfix_expr_eexpr_invalid_ _2 = TInc
    {     ( Ast0.wrap(Ast0.Postfix (_1, P.clt2mcode Ast.Inc _2)) )}
| _1 = postfix_expr_eexpr_invalid_ _2 = TDec
    {     ( Ast0.wrap(Ast0.Postfix (_1, P.clt2mcode Ast.Dec _2)) )}
| _1 = postfix_expr_eexpr_invalid_ _2 = TOPar _3 = eexpr_list_option _4 = TCPar
    {     ( Ast0.wrap(Ast0.FunCall(_1,P.clt2mcode "(" _2,_3,
			      P.clt2mcode ")" _4)) )}

postfix_expr_eexpr_nest_expressions_:
  _1 = primary_expr_eexpr_nest_expressions_
    {                                                 ( _1 )}
| _1 = postfix_expr_eexpr_nest_expressions_ _2 = TOCro _3 = eexpr _4 = TCCro
    {     ( Ast0.wrap(Ast0.ArrayAccess (_1,P.clt2mcode "[" _2,_3,
				       P.clt2mcode "]" _4)) )}
| _1 = postfix_expr_eexpr_nest_expressions_ _2 = TDot _3 = ident
    {     ( Ast0.wrap(Ast0.RecordAccess(_1, P.clt2mcode "." _2, _3)) )}
| _1 = postfix_expr_eexpr_nest_expressions_ _2 = TPtrOp _3 = ident
    {     ( Ast0.wrap(Ast0.RecordPtAccess(_1, P.clt2mcode "->" _2,
				     _3)) )}
| _1 = postfix_expr_eexpr_nest_expressions_ _2 = TInc
    {     ( Ast0.wrap(Ast0.Postfix (_1, P.clt2mcode Ast.Inc _2)) )}
| _1 = postfix_expr_eexpr_nest_expressions_ _2 = TDec
    {     ( Ast0.wrap(Ast0.Postfix (_1, P.clt2mcode Ast.Dec _2)) )}
| _1 = postfix_expr_eexpr_nest_expressions_ _2 = TOPar _3 = eexpr_list_option _4 = TCPar
    {     ( Ast0.wrap(Ast0.FunCall(_1,P.clt2mcode "(" _2,_3,
			      P.clt2mcode ")" _4)) )}

postfix_expr_expr_invalid_:
  _1 = primary_expr_expr_invalid_
    {                                                 ( _1 )}
| _1 = postfix_expr_expr_invalid_ _2 = TOCro _3 = eexpr _4 = TCCro
    {     ( Ast0.wrap(Ast0.ArrayAccess (_1,P.clt2mcode "[" _2,_3,
				       P.clt2mcode "]" _4)) )}
| _1 = postfix_expr_expr_invalid_ _2 = TDot _3 = ident
    {     ( Ast0.wrap(Ast0.RecordAccess(_1, P.clt2mcode "." _2, _3)) )}
| _1 = postfix_expr_expr_invalid_ _2 = TPtrOp _3 = ident
    {     ( Ast0.wrap(Ast0.RecordPtAccess(_1, P.clt2mcode "->" _2,
				     _3)) )}
| _1 = postfix_expr_expr_invalid_ _2 = TInc
    {     ( Ast0.wrap(Ast0.Postfix (_1, P.clt2mcode Ast.Inc _2)) )}
| _1 = postfix_expr_expr_invalid_ _2 = TDec
    {     ( Ast0.wrap(Ast0.Postfix (_1, P.clt2mcode Ast.Dec _2)) )}
| _1 = postfix_expr_expr_invalid_ _2 = TOPar _3 = eexpr_list_option _4 = TCPar
    {     ( Ast0.wrap(Ast0.FunCall(_1,P.clt2mcode "(" _2,_3,
			      P.clt2mcode ")" _4)) )}

primary_expr_eexpr_dot_expressions_:
  _1 = func_ident
    {                ( Ast0.wrap(Ast0.Ident(_1)) )}
| _1 = TInt
    {     ( let (x,clt) = _1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Int x) clt)) )}
| _1 = TFloat
    {     ( let (x,clt) = _1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Float x) clt)) )}
| _1 = TString
    {     ( let (x,clt) = _1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.String x) clt)) )}
| _1 = TChar
    {     ( let (x,clt) = _1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Char x) clt)) )}
| _1 = TMetaConst
    {     ( let (nm,pure,ty,clt) = _1 in
     Ast0.wrap(Ast0.MetaConst(P.clt2mcode nm clt,ty,pure)) )}
| _1 = TMetaErr
    {     ( let (nm,pure,clt) = _1 in
     Ast0.wrap(Ast0.MetaErr(P.clt2mcode nm clt,pure)) )}
| _1 = TMetaExp
    {     ( let (nm,pure,ty,clt) = _1 in
     Ast0.wrap(Ast0.MetaExpr(P.clt2mcode nm clt,ty,pure)) )}
| _1 = TOPar _2 = eexpr _3 = TCPar
    {     ( Ast0.wrap(Ast0.Paren(P.clt2mcode "(" _1,_2,
			    P.clt2mcode ")" _3)) )}
| _1 = TOPar0 _2 = midzero_list_eexpr_ _3 = TCPar0
    {     ( let (mids,code) = _2 in
       Ast0.wrap(Ast0.DisjExpr(P.clt2mcode "(" _1,
			       code, mids,
			       P.clt2mcode ")" _3)) )}
| _1 = dot_expressions
    {                 ( _1 )}

primary_expr_eexpr_invalid_:
  _1 = func_ident
    {                ( Ast0.wrap(Ast0.Ident(_1)) )}
| _1 = TInt
    {     ( let (x,clt) = _1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Int x) clt)) )}
| _1 = TFloat
    {     ( let (x,clt) = _1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Float x) clt)) )}
| _1 = TString
    {     ( let (x,clt) = _1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.String x) clt)) )}
| _1 = TChar
    {     ( let (x,clt) = _1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Char x) clt)) )}
| _1 = TMetaConst
    {     ( let (nm,pure,ty,clt) = _1 in
     Ast0.wrap(Ast0.MetaConst(P.clt2mcode nm clt,ty,pure)) )}
| _1 = TMetaErr
    {     ( let (nm,pure,clt) = _1 in
     Ast0.wrap(Ast0.MetaErr(P.clt2mcode nm clt,pure)) )}
| _1 = TMetaExp
    {     ( let (nm,pure,ty,clt) = _1 in
     Ast0.wrap(Ast0.MetaExpr(P.clt2mcode nm clt,ty,pure)) )}
| _1 = TOPar _2 = eexpr _3 = TCPar
    {     ( Ast0.wrap(Ast0.Paren(P.clt2mcode "(" _1,_2,
			    P.clt2mcode ")" _3)) )}
| _1 = TOPar0 _2 = midzero_list_eexpr_ _3 = TCPar0
    {     ( let (mids,code) = _2 in
       Ast0.wrap(Ast0.DisjExpr(P.clt2mcode "(" _1,
			       code, mids,
			       P.clt2mcode ")" _3)) )}
| _1 = invalid
    {                 ( _1 )}

primary_expr_eexpr_nest_expressions_:
  _1 = func_ident
    {                ( Ast0.wrap(Ast0.Ident(_1)) )}
| _1 = TInt
    {     ( let (x,clt) = _1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Int x) clt)) )}
| _1 = TFloat
    {     ( let (x,clt) = _1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Float x) clt)) )}
| _1 = TString
    {     ( let (x,clt) = _1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.String x) clt)) )}
| _1 = TChar
    {     ( let (x,clt) = _1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Char x) clt)) )}
| _1 = TMetaConst
    {     ( let (nm,pure,ty,clt) = _1 in
     Ast0.wrap(Ast0.MetaConst(P.clt2mcode nm clt,ty,pure)) )}
| _1 = TMetaErr
    {     ( let (nm,pure,clt) = _1 in
     Ast0.wrap(Ast0.MetaErr(P.clt2mcode nm clt,pure)) )}
| _1 = TMetaExp
    {     ( let (nm,pure,ty,clt) = _1 in
     Ast0.wrap(Ast0.MetaExpr(P.clt2mcode nm clt,ty,pure)) )}
| _1 = TOPar _2 = eexpr _3 = TCPar
    {     ( Ast0.wrap(Ast0.Paren(P.clt2mcode "(" _1,_2,
			    P.clt2mcode ")" _3)) )}
| _1 = TOPar0 _2 = midzero_list_eexpr_ _3 = TCPar0
    {     ( let (mids,code) = _2 in
       Ast0.wrap(Ast0.DisjExpr(P.clt2mcode "(" _1,
			       code, mids,
			       P.clt2mcode ")" _3)) )}
| _1 = nest_expressions
    {                 ( _1 )}

primary_expr_expr_invalid_:
  _1 = func_ident
    {                ( Ast0.wrap(Ast0.Ident(_1)) )}
| _1 = TInt
    {     ( let (x,clt) = _1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Int x) clt)) )}
| _1 = TFloat
    {     ( let (x,clt) = _1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Float x) clt)) )}
| _1 = TString
    {     ( let (x,clt) = _1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.String x) clt)) )}
| _1 = TChar
    {     ( let (x,clt) = _1 in
     Ast0.wrap(Ast0.Constant (P.clt2mcode (Ast.Char x) clt)) )}
| _1 = TMetaConst
    {     ( let (nm,pure,ty,clt) = _1 in
     Ast0.wrap(Ast0.MetaConst(P.clt2mcode nm clt,ty,pure)) )}
| _1 = TMetaErr
    {     ( let (nm,pure,clt) = _1 in
     Ast0.wrap(Ast0.MetaErr(P.clt2mcode nm clt,pure)) )}
| _1 = TMetaExp
    {     ( let (nm,pure,ty,clt) = _1 in
     Ast0.wrap(Ast0.MetaExpr(P.clt2mcode nm clt,ty,pure)) )}
| _1 = TOPar _2 = eexpr _3 = TCPar
    {     ( Ast0.wrap(Ast0.Paren(P.clt2mcode "(" _1,_2,
			    P.clt2mcode ")" _3)) )}
| _1 = TOPar0 _2 = midzero_list_expr_ _3 = TCPar0
    {     ( let (mids,code) = _2 in
       Ast0.wrap(Ast0.DisjExpr(P.clt2mcode "(" _1,
			       code, mids,
			       P.clt2mcode ")" _3)) )}
| _1 = invalid
    {                 ( _1 )}

expr_dots_TEllipsis_:
  r = no_dot_start_end_dexpr_edots_when_TEllipsis_eexpr__
    {                                                       ( r )}

pure_ident:
  _1 = TIdent
    {            ( _1 )}

pure_ident_or_meta_ident:
  _1 = pure_ident
    {                                 ( (None,P.id2name _1) )}
| _1 = TRuleName _2 = TDot _3 = pure_ident
    {                                 ( (Some _1,P.id2name _3) )}

func_ident:
  _1 = pure_ident
    {         ( Ast0.wrap(Ast0.Id(P.id2mcode _1)) )}
| _1 = TMetaId
    {         ( let (nm,pure,clt) = _1 in
           Ast0.wrap(Ast0.MetaId(P.clt2mcode nm clt,pure)) )}
| _1 = TMetaFunc
    {         ( let (nm,pure,clt) = _1 in
           Ast0.wrap(Ast0.MetaFunc(P.clt2mcode nm clt,pure)) )}
| _1 = TMetaLocalFunc
    {  ( let (nm,pure,clt) = _1 in
           Ast0.wrap(Ast0.MetaLocalFunc(P.clt2mcode nm clt,pure)) )}

ident:
  _1 = pure_ident
    {         ( Ast0.wrap(Ast0.Id(P.id2mcode _1)) )}
| _1 = TMetaId
    {         ( let (nm,pure,clt) = _1 in
           Ast0.wrap(Ast0.MetaId(P.clt2mcode nm clt,pure)) )}

decl_list_decl_:
  _1 = decl_list_start_decl_
    {     (let circle x =
       match Ast0.unwrap x with Ast0.Pcircles(_) -> true | _ -> false in
     if List.exists circle _1
     then Ast0.wrap(Ast0.CIRCLES(_1))
     else Ast0.wrap(Ast0.DOTS(_1)) )}

decl_list_name_opt_decl_:
  _1 = decl_list_start_name_opt_decl_
    {     (let circle x =
       match Ast0.unwrap x with Ast0.Pcircles(_) -> true | _ -> false in
     if List.exists circle _1
     then Ast0.wrap(Ast0.CIRCLES(_1))
     else Ast0.wrap(Ast0.DOTS(_1)) )}

decl_list_start_decl_:
  _1 = one_dec_decl_
    {                 ( [_1] )}
| _1 = one_dec_decl_ _2 = TComma _3 = decl_list_start_decl_
    {    ( _1::Ast0.wrap(Ast0.PComma(P.clt2mcode "," _2))::_3 )}
| _1 = TEllipsis _2 = list_comma_decls_TEllipsis_decl__
    {    ( Ast0.wrap(Ast0.Pdots(P.clt2mcode "..." _1))::
      (List.concat(List.map (function x -> x (P.mkpdots "...")) _2)) )}

decl_list_start_name_opt_decl_:
  _1 = one_dec_name_opt_decl_
    {                 ( [_1] )}
| _1 = one_dec_name_opt_decl_ _2 = TComma _3 = decl_list_start_name_opt_decl_
    {    ( _1::Ast0.wrap(Ast0.PComma(P.clt2mcode "," _2))::_3 )}
| _1 = TEllipsis _2 = list_comma_decls_TEllipsis_name_opt_decl__
    {    ( Ast0.wrap(Ast0.Pdots(P.clt2mcode "..." _1))::
      (List.concat(List.map (function x -> x (P.mkpdots "...")) _2)) )}

one_dec_decl_:
  _1 = decl
    {        ( _1 )}
| _1 = TMetaParamList
    {    ( let (nm,pure,clt) = _1 in
    Ast0.wrap(Ast0.MetaParamList(P.clt2mcode nm clt,pure)) )}

one_dec_name_opt_decl_:
  _1 = name_opt_decl
    {        ( _1 )}
| _1 = TMetaParamList
    {    ( let (nm,pure,clt) = _1 in
    Ast0.wrap(Ast0.MetaParamList(P.clt2mcode nm clt,pure)) )}

comma_decls_TEllipsis_decl_:
  _1 = TComma _2 = TEllipsis
    {    ( function dot_builder ->
      [Ast0.wrap(Ast0.PComma(P.clt2mcode "," _1));
	dot_builder _2] )}
| _1 = TComma _2 = one_dec_decl_
    {    ( function dot_builder ->
      [Ast0.wrap(Ast0.PComma(P.clt2mcode "," _1)); _2] )}

comma_decls_TEllipsis_name_opt_decl_:
  _1 = TComma _2 = TEllipsis
    {    ( function dot_builder ->
      [Ast0.wrap(Ast0.PComma(P.clt2mcode "," _1));
	dot_builder _2] )}
| _1 = TComma _2 = one_dec_name_opt_decl_
    {    ( function dot_builder ->
      [Ast0.wrap(Ast0.PComma(P.clt2mcode "," _1)); _2] )}

pure_decl_statement_list:
  _1 = nonempty_list_decl_statement_
    {                                            ( List.concat _1 )}

exp_decl_statement_list:
  _1 = TNothing
    {             ( [] )}
| _1 = expr
    {                                            ( [Ast0.wrap(Ast0.Exp(_1))] )}
| _1 = expr _2 = TOEllipsis b = statement_dots_TEllipsis_ _4 = TCEllipsis _5 = exp_decl_statement_list
    {    ( (Ast0.wrap(Ast0.Exp(_1)))::
      (Ast0.wrap(Ast0.Nest(P.clt2mcode "<..." _2,
			  Ast0.wrap(Ast0.DOTS(b (P.mkdots "..."))),
			  P.clt2mcode "...>" _4, None)))::
      _5 )}
| _1 = expr _2 = TOEllipsis b = statement_dots_TEllipsis_ _4 = TCEllipsis
    {    ( [(Ast0.wrap(Ast0.Exp(_1)));
	(Ast0.wrap(Ast0.Nest(P.clt2mcode "<..." _2,
			     Ast0.wrap(Ast0.DOTS(b (P.mkdots "..."))),
			     P.clt2mcode "...>" _4, None)))] )}
| _1 = pure_decl_statement_list
    {                                            ( _1 )}

fun_exp_decl_statement_list:
  _1 = TNothing
    {             ( [] )}
| t = ctype
    {      ( [Ast0.wrap(Ast0.OTHER(Ast0.wrap(Ast0.Ty(t))))] )}
| lp = TOPar0 t = midzero_list_ctype_ rp = TCPar0
    {    ( let (mids,code) = t in
    let s =
      Ast0.wrap(Ast0.DisjType(P.clt2mcode "(" lp,code,mids, P.clt2mcode ")" rp)) in
    [Ast0.wrap(Ast0.OTHER(Ast0.wrap(Ast0.Ty(s))))])}
| _1 = expr
    {                         ( [Ast0.wrap(Ast0.OTHER(Ast0.wrap(Ast0.Exp(_1))))] )}
| _1 = expr _2 = TOEllipsis b = statement_dots_TEllipsis_ _4 = TCEllipsis _5 = fun_exp_decl_statement_list
    {    ( (Ast0.wrap(Ast0.OTHER(Ast0.wrap(Ast0.Exp(_1)))))::
      (Ast0.wrap
	 (Ast0.OTHER
	    (Ast0.wrap
	       (Ast0.Nest(P.clt2mcode "<..." _2,
			  Ast0.wrap(Ast0.DOTS(b (P.mkdots "..."))),
			  P.clt2mcode "...>" _4, None)))))::
      _5 )}
| _1 = expr _2 = TOEllipsis b = statement_dots_TEllipsis_ _4 = TCEllipsis
    {    ( [(Ast0.wrap(Ast0.OTHER(Ast0.wrap(Ast0.Exp(_1)))));
      (Ast0.wrap
	 (Ast0.OTHER
	    (Ast0.wrap
	       (Ast0.Nest(P.clt2mcode "<..." _2,
			  Ast0.wrap(Ast0.DOTS(b (P.mkdots "..."))),
			  P.clt2mcode "...>" _4, None)))))] )}
| f = nonempty_list_fun_decl_statement_
    {                                               ( List.concat f )}

fun_decl_statement:
  d = decl_statement
    {                     ( List.map (function x -> Ast0.wrap(Ast0.OTHER x)) d )}
| f = fundecl
    {                     ( [Ast0.wrap(Ast0.DECL(f))] )}

error_words:
  _1 = TError _2 = TWords _3 = TEq _4 = TOCro cl = comma_list_dexpr_ _6 = TCCro
    {      ( [Ast0.wrap(Ast0.ERRORWORDS(cl))] )}

minus_function_decl_statement_or_expression:
  _1 = opt_dot_start_end_fun_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_fun_exp_decl_statement_list_
    {    ( List.concat
	(_1 (function x -> function y ->
	      [Ast0.wrap(Ast0.OTHER (P.mkdots x y))])) )}

plus_function_decl_statement_or_expression:
  first = fun_exp_decl_statement_list
    {                                      ( first )}
| first = loption_fun_exp_decl_statement_list_ second = required_dot_start_with_ender_fun_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_fun_exp_decl_statement_list_
    {      ( List.concat
	   (first ::
	    (second
	       (function x -> function y ->
		 [Ast0.wrap(Ast0.OTHER (P.mkdots x y))]))) )}

pre_post_decl_statement_or_expression:
  _1 = opt_dot_start_end_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_exp_decl_statement_list_
    {  ( P.top_dots(List.concat (_1 (function x -> function y -> [P.mkdots x y]))) )}

pre_post_decl_statement_and_expression:
  first = pure_decl_statement_list
    {                                   ( P.top_dots first )}
| first = loption_pure_decl_statement_list_ second = required_dot_start_with_ender_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_pure_decl_statement_list_
    {      ( P.top_dots
	  (List.concat
	     (first::(second (function x -> function y -> [P.mkdots x y])))) )}

pre_post_decl_statement_and_expression_opt:
  
    {                                            ( Ast0.wrap(Ast0.DOTS([])) )}
| _1 = pre_post_decl_statement_and_expression
    {                                            ( _1 )}

pre_post_decl_statement_and_expression_opt_mid:
  _1 = pre_post_decl_statement_and_expression
    {                                                 ( (_1,[]) )}
| 
    {                                         ( (Ast0.wrap(Ast0.DOTS([])),[]) )}
| _1 = pre_post_decl_statement_and_expression _2 = TMid0 _3 = pre_post_decl_statement_and_expression_opt_mid
    {      ( let (first,rest) = _3 in
        (_1,(P.clt2mcode "|" _2,first)::rest) )}
| _1 = TMid0 _2 = pre_post_decl_statement_and_expression_opt_mid
    {      ( let (first,rest) = _2 in
        (Ast0.wrap(Ast0.DOTS([])),
	 (P.clt2mcode "|" _1,first)::rest) )}

eexpr_list:
  _1 = eexpr_list_start
    {     (let circle x =
       match Ast0.unwrap x with Ast0.Ecircles(_) -> true | _ -> false in
     let star x =
       match Ast0.unwrap x with Ast0.Estars(_) -> true | _ -> false in
     if List.exists circle _1
     then Ast0.wrap(Ast0.CIRCLES(_1))
     else
       if List.exists star _1
       then Ast0.wrap(Ast0.STARS(_1))
       else Ast0.wrap(Ast0.DOTS(_1)) )}

aexpr:
  _1 = dexpr
    {      ( _1 )}
| _1 = TMetaExpList
    {      ( let (nm,pure,clt) = _1 in
      Ast0.wrap(Ast0.MetaExprList(P.clt2mcode nm clt,pure)) )}
| _1 = generic_ctype
    {      ( Ast0.wrap(Ast0.TypeExp(_1)) )}

eexpr_list_start:
  _1 = aexpr
    {          ( [_1] )}
| _1 = aexpr _2 = TComma _3 = eexpr_list_start
    {      ( _1::Ast0.wrap(Ast0.EComma(P.clt2mcode "," _2))::_3 )}
| d = edots_when_TEllipsis_eexpr_ r = list_comma_args_edots_when_TEllipsis_eexpr___
    {      ( (P.mkedots "..." d)::
	(List.concat (List.map (function x -> x (P.mkedots "...")) r)) )}

comma_args_edots_when_TEllipsis_eexpr__:
  c = TComma d = edots_when_TEllipsis_eexpr_
    {    ( function dot_builder ->
      [Ast0.wrap(Ast0.EComma(P.clt2mcode "," c)); dot_builder d] )}
| _1 = TComma _2 = aexpr
    {    ( function dot_builder ->
      [Ast0.wrap(Ast0.EComma(P.clt2mcode "," _1)); _2] )}

eexpr_list_option:
  _1 = eexpr_list
    {                              ( _1 )}
| 
    {                           ( Ast0.wrap(Ast0.DOTS([])) )}

comma_list_ctype_:
  _1 = separated_nonempty_list_TComma_ctype_
    {                                       ( _1 )}

comma_list_d_ident_:
  _1 = separated_nonempty_list_TComma_d_ident_
    {                                       ( _1 )}

comma_list_dexpr_:
  _1 = separated_nonempty_list_TComma_dexpr_
    {                                       ( _1 )}

comma_list_pure_ident_or_meta_ident_:
  _1 = separated_nonempty_list_TComma_pure_ident_or_meta_ident_
    {                                       ( _1 )}

midzero_list_ctype_:
  a = ctype b = list_mzl_ctype__
    {     ( let (mids,code) = List.split b in (mids,(a::code)) )}

midzero_list_eexpr_:
  a = eexpr b = list_mzl_eexpr__
    {     ( let (mids,code) = List.split b in (mids,(a::code)) )}

midzero_list_expr_:
  a = expr b = list_mzl_expr__
    {     ( let (mids,code) = List.split b in (mids,(a::code)) )}

midzero_list_rule_elem_statement_:
  a = rule_elem_statement b = list_mzl_rule_elem_statement__
    {     ( let (mids,code) = List.split b in (mids,(a::code)) )}

midzero_list_statement_:
  a = statement b = list_mzl_statement__
    {     ( let (mids,code) = List.split b in (mids,(a::code)) )}

mzl_ctype_:
  a = TMid0 b = ctype
    {                 ( (P.clt2mcode "|" a, b) )}

mzl_eexpr_:
  a = TMid0 b = eexpr
    {                 ( (P.clt2mcode "|" a, b) )}

mzl_expr_:
  a = TMid0 b = expr
    {                 ( (P.clt2mcode "|" a, b) )}

mzl_rule_elem_statement_:
  a = TMid0 b = rule_elem_statement
    {                 ( (P.clt2mcode "|" a, b) )}

mzl_statement_:
  a = TMid0 b = statement
    {                 ( (P.clt2mcode "|" a, b) )}

opt_dot_start_end_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_exp_decl_statement_list_:
  start = exp_decl_statement_list
    {               ( function dot_builder -> [start] )}
| r = opt_dot_start_end_pattern_exp_decl_statement_list_dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement__exp_decl_statement_list_opt_dot_end_dots_TEllipsis_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_exp_decl_statement_list__
    {   ( function dot_builder -> r (dot_builder "...") )}

opt_dot_start_end_fun_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_fun_exp_decl_statement_list_:
  start = fun_exp_decl_statement_list
    {               ( function dot_builder -> [start] )}
| r = opt_dot_start_end_pattern_fun_exp_decl_statement_list_dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement__fun_exp_decl_statement_list_opt_dot_end_dots_TEllipsis_fun_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_fun_exp_decl_statement_list__
    {   ( function dot_builder -> r (dot_builder "...") )}

opt_dot_start_end_pattern_exp_decl_statement_list_dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement__exp_decl_statement_list_opt_dot_end_dots_TEllipsis_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_exp_decl_statement_list__:
  g = exp_decl_statement_list d = dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement_
    {     ( function dot_builder -> [g; (dot_builder d)] )}
| g = exp_decl_statement_list d = dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement_ c = opt_dot_end_dots_TEllipsis_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_exp_decl_statement_list_
    {     ( function dot_builder -> g :: (dot_builder d) :: (c dot_builder) )}
| d = dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement_ c = opt_dot_end_dots_TEllipsis_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_exp_decl_statement_list_
    {     ( function dot_builder -> (dot_builder d) :: (c dot_builder) )}

opt_dot_start_end_pattern_fun_exp_decl_statement_list_dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement__fun_exp_decl_statement_list_opt_dot_end_dots_TEllipsis_fun_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_fun_exp_decl_statement_list__:
  g = fun_exp_decl_statement_list d = dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement_
    {     ( function dot_builder -> [g; (dot_builder d)] )}
| g = fun_exp_decl_statement_list d = dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement_ c = opt_dot_end_dots_TEllipsis_fun_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_fun_exp_decl_statement_list_
    {     ( function dot_builder -> g :: (dot_builder d) :: (c dot_builder) )}
| d = dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement_ c = opt_dot_end_dots_TEllipsis_fun_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_fun_exp_decl_statement_list_
    {     ( function dot_builder -> (dot_builder d) :: (c dot_builder) )}

opt_dot_end_dots_TEllipsis_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_exp_decl_statement_list_:
  g = exp_decl_statement_list
    {           ( function dot_builder -> [g] )}
| g = exp_decl_statement_list d = dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement_
    {     ( function dot_builder -> [g ; dot_builder d ] )}
| g = exp_decl_statement_list d = dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement_ r = opt_dot_end_dots_TEllipsis_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_exp_decl_statement_list_
    {     ( function dot_builder -> g :: (dot_builder d) :: (r dot_builder) )}

opt_dot_end_dots_TEllipsis_fun_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_fun_exp_decl_statement_list_:
  g = fun_exp_decl_statement_list
    {           ( function dot_builder -> [g] )}
| g = fun_exp_decl_statement_list d = dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement_
    {     ( function dot_builder -> [g ; dot_builder d ] )}
| g = fun_exp_decl_statement_list d = dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement_ r = opt_dot_end_dots_TEllipsis_fun_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_fun_exp_decl_statement_list_
    {     ( function dot_builder -> g :: (dot_builder d) :: (r dot_builder) )}

required_dot_start_with_ender_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_pure_decl_statement_list_:
  start = dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement_ finish = no_dot_start_dots_TEllipsis_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_pure_decl_statement_list_
    {   ( (function dot_builder ->
       (dot_builder "..." start) :: (finish (dot_builder "..."))) )}

required_dot_start_with_ender_fun_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_fun_exp_decl_statement_list_:
  start = dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement_ finish = no_dot_start_dots_TEllipsis_fun_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_fun_exp_decl_statement_list_
    {   ( (function dot_builder ->
       (dot_builder "..." start) :: (finish (dot_builder "..."))) )}

no_dot_start_dots_TEllipsis_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_pure_decl_statement_list_:
  
    {                  ( function dot_builder -> [] )}
| e = pure_decl_statement_list
    {       ( function dot_builder -> [e] )}
| g = exp_decl_statement_list d = dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement_ r = no_dot_start_dots_TEllipsis_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_pure_decl_statement_list_
    {       ( function dot_builder -> g::(dot_builder d)::(r dot_builder) )}

no_dot_start_dots_TEllipsis_fun_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_fun_exp_decl_statement_list_:
  
    {                  ( function dot_builder -> [] )}
| e = fun_exp_decl_statement_list
    {       ( function dot_builder -> [e] )}
| g = fun_exp_decl_statement_list d = dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement_ r = no_dot_start_dots_TEllipsis_fun_exp_decl_statement_list_pre_post_decl_statement_or_expression_rule_elem_statement_fun_exp_decl_statement_list_
    {       ( function dot_builder -> g::(dot_builder d)::(r dot_builder) )}

edots_when_TEllipsis_eexpr_:
  d = TEllipsis
    {                                                  ( (d,None) )}
| d = TEllipsis _2 = TWhen _3 = TNotEq w = eexpr _5 = TLineEnd
    {                                                  ( (d,Some w) )}

edots_when_TEllipsis_initialize_:
  d = TEllipsis
    {                                                  ( (d,None) )}
| d = TEllipsis _2 = TWhen _3 = TNotEq w = initialize _5 = TLineEnd
    {                                                  ( (d,Some w) )}

edots_when_TEllipsis_struct_decl_:
  d = TEllipsis
    {                                                  ( (d,None) )}
| d = TEllipsis _2 = TWhen _3 = TNotEq w = struct_decl _5 = TLineEnd
    {                                                  ( (d,Some w) )}

dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement_:
  d = TEllipsis w = list_whens_pre_post_decl_statement_or_expression_rule_elem_statement__
    {      ( (d,w) )}

whens_pre_post_decl_statement_or_expression_rule_elem_statement_:
  _1 = TWhen _2 = TNotEq w = pre_post_decl_statement_or_expression _4 = TLineEnd
    {                                         ( Ast0.WhenNot w )}
| _1 = TWhen _2 = TEq w = rule_elem_statement _4 = TLineEnd
    {                                             ( Ast0.WhenAlways w )}

no_dot_start_end_dexpr_edots_when_TEllipsis_eexpr__:
  g = dexpr dg = list_pair_edots_when_TEllipsis_eexpr__dexpr__
    {  ( function dot_builder ->
      g :: (List.concat(List.map (function (d,g) -> [dot_builder d;g]) dg)) )}

no_dot_start_end_exp_decl_statement_list_dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement__:
  g = exp_decl_statement_list dg = list_pair_dots_when_TEllipsis_pre_post_decl_statement_or_expression_rule_elem_statement__exp_decl_statement_list__
    {  ( function dot_builder ->
      g :: (List.concat(List.map (function (d,g) -> [dot_builder d;g]) dg)) )}

iso_main:
  _1 = TIsoExpression e1 = dexpr el = list_iso_dexpr__ _4 = EOF
    {    ( P.iso_adjust (function x -> Ast0.ExprTag x) e1 el )}
| _1 = TIsoStatement s1 = single_statement sl = list_iso_single_statement__ _4 = EOF
    {    ( P.iso_adjust (function x -> Ast0.StmtTag x) s1 sl )}
| _1 = TIsoType t1 = ctype tl = list_iso_ctype__ _4 = EOF
    {    ( P.iso_adjust (function x -> Ast0.TypeCTag x) t1 tl )}
| _1 = TIsoTopLevel e1 = xstatement_dots_TEllipsis_ el = list_iso_xstatement_dots_TEllipsis___ _4 = EOF
    {    ( P.iso_adjust (function x -> Ast0.DotsStmtTag x) e1 el )}
| _1 = TIsoDeclaration d1 = decl_var dl = list_iso_decl_var__ _4 = EOF
    {    ( let check_one = function
	[x] -> x
      | _ ->
	  raise
	    (Semantic_cocci.Semantic
	       "only one variable per declaration in an isomorphism rule") in
    let d1 = check_one d1 in
    let dl =
      List.map
	(function
	    Common.Left x -> Common.Left(check_one x)
	  | Common.Right x -> Common.Right(check_one x))
	dl in
    P.iso_adjust (function x -> Ast0.DeclTag x) d1 dl )}

xstatement_dots_TEllipsis_:
  b = statement_dots_TEllipsis_
    {    ( Ast0.wrap(Ast0.DOTS(b (P.mkdots "..."))) )}

iso_ctype_:
  _1 = TIso t = ctype
    {                ( Common.Left t )}
| _1 = TRightIso t = ctype
    {                     ( Common.Right t )}

iso_decl_var_:
  _1 = TIso t = decl_var
    {                ( Common.Left t )}
| _1 = TRightIso t = decl_var
    {                     ( Common.Right t )}

iso_dexpr_:
  _1 = TIso t = dexpr
    {                ( Common.Left t )}
| _1 = TRightIso t = dexpr
    {                     ( Common.Right t )}

iso_single_statement_:
  _1 = TIso t = single_statement
    {                ( Common.Left t )}
| _1 = TRightIso t = single_statement
    {                     ( Common.Right t )}

iso_xstatement_dots_TEllipsis__:
  _1 = TIso t = xstatement_dots_TEllipsis_
    {                ( Common.Left t )}
| _1 = TRightIso t = xstatement_dots_TEllipsis_
    {                     ( Common.Right t )}

never_used:
  _1 = TPragma
    {                    ( () )}

%%


