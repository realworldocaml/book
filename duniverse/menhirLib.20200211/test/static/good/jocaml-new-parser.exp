Grammar has 126 nonterminal symbols, among which 4 start symbols.
Grammar has 109 terminal symbols.
Grammar has 463 productions.
nullable(with_constraints) = false
nullable(with_constraint) = false
nullable(virtual_method) = false
nullable(virtual_flag) = true
nullable(value_type) = false
nullable(value) = false
nullable(val_longident) = false
nullable(val_ident) = false
nullable(use_file_tail) = false
nullable(use_file) = false
nullable(type_parameters) = true
nullable(type_parameter_list) = false
nullable(type_parameter) = false
nullable(type_longident) = false
nullable(type_list) = false
nullable(type_kind) = true
nullable(type_declarations) = false
nullable(type_declaration) = false
nullable(type_constraint) = false
nullable(toplevel_phrase) = false
nullable(toplevel_directive) = false
nullable(top_structure) = false
nullable(to_ident) = true
nullable(structure_tail) = true
nullable(structure_item) = false
nullable(structure) = true
nullable(stream_pattern_component) = false
nullable(stream_pattern) = false
nullable(stream_expr_component) = false
nullable(stream_expr) = false
nullable(static_semi_list) = false
nullable(static_expr) = false
nullable(static_comma_list) = false
nullable(simple_pattern_list) = false
nullable(simple_pattern) = false
nullable(simple_expr_list) = false
nullable(simple_expr) = false
nullable(simple_core_type) = false
nullable(signed_constant) = false
nullable(signature_item) = false
nullable(signature) = true
nullable(seq_expr) = false
nullable(self_type) = true
nullable(self) = true
nullable(rec_flag) = true
nullable(protected_flag) = true
nullable(process0) = false
nullable(process) = true
nullable(private_flag) = true
nullable(primitive_declaration) = false
nullable(pattern_semi_list) = false
nullable(pattern_comma_list) = false
nullable(pattern) = false
nullable(parser_cases) = false
nullable(parser_case) = false
nullable(opt_semi) = true
nullable(opt_pat) = true
nullable(opt_err) = true
nullable(opt_bar) = true
nullable(operator) = false
nullable(mutable_flag) = true
nullable(mty_longident) = false
nullable(module_type) = false
nullable(module_expr) = false
nullable(module_declaration) = false
nullable(module_binding) = false
nullable(mod_longident) = false
nullable(mod_ext_longident) = false
nullable(method_type) = false
nullable(method_def) = false
nullable(meth_list) = false
nullable(meth_binding) = false
nullable(match_cases) = false
nullable(match_action) = false
nullable(location_tail) = true
nullable(location_item) = false
nullable(location) = true
nullable(list_of_exprs) = false
nullable(let_bindings) = false
nullable(let_binding) = false
nullable(lbl_pattern_list) = false
nullable(lbl_expr_list) = false
nullable(label_longident) = false
nullable(label_expr_list) = false
nullable(label_declarations) = false
nullable(label_declaration) = false
nullable(label) = false
nullable(join_pattern) = false
nullable(join_args) = true
nullable(interface) = false
nullable(implementation) = false
nullable(ident) = false
nullable(fun_def) = false
nullable(fun_binding) = false
nullable(field) = false
nullable(expr_semi_list) = false
nullable(expr_comma_list) = false
nullable(expr) = false
nullable(direction_flag) = false
nullable(def_bindings) = false
nullable(def_binding) = false
nullable(core_type_tuple) = false
nullable(core_type_list) = false
nullable(core_type_comma_list) = false
nullable(core_type) = false
nullable(constructor_declarations) = false
nullable(constructor_declaration) = false
nullable(constructor_arguments) = true
nullable(constraints) = true
nullable(constrain) = false
nullable(constr_longident) = false
nullable(constr_ident) = false
nullable(constant) = false
nullable(closed_flag) = true
nullable(class_type_parameters) = true
nullable(class_type_list) = false
nullable(class_type_fields) = true
nullable(class_type) = false
nullable(class_longident) = false
nullable(class_list) = false
nullable(class_fields) = true
nullable(class_def) = false
nullable(channel_type) = true
nullable(channel_tuple) = false
nullable(ancestor_type) = false
nullable(ancestor) = false
first(with_constraints) = TYPE MODULE
first(with_constraint) = TYPE MODULE
first(virtual_method) = VIRTUAL
first(virtual_flag) = VIRTUAL
first(value_type) = PRIVATE MUTABLE LIDENT
first(value) = PRIVATE MUTABLE LIDENT
first(val_longident) = UIDENT LPAREN LIDENT
first(val_ident) = LPAREN LIDENT
first(use_file_tail) = TYPE SHARP SEMISEMI OPEN MODULE LET EXTERNAL EXCEPTION EOF DEF CLASS
first(use_file) = WHILE UIDENT TYPE TRY TRUE SUBTRACTIVE STRING SHARP SEMISEMI PREFIXOP PARSER OPEN NEW MODULE MATCH LPAREN LOC LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION EOF DEF CLASS CHAR BEGIN ASSERT
first(type_parameters) = QUOTE LPAREN
first(type_parameter_list) = QUOTE
first(type_parameter) = QUOTE
first(type_longident) = UIDENT LIDENT
first(type_list) = LPAREN
first(type_kind) = EQUAL
first(type_declarations) = QUOTE LPAREN LIDENT
first(type_declaration) = QUOTE LPAREN LIDENT
first(type_constraint) = COLONGREATER COLON
first(toplevel_phrase) = WHILE UIDENT TYPE TRY TRUE SUBTRACTIVE STRING SHARP PREFIXOP PARSER OPEN NEW MODULE MATCH LPAREN LOC LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION EOF DEF CLASS CHAR BEGIN ASSERT
first(toplevel_directive) = SHARP
first(top_structure) = TYPE OPEN MODULE LET EXTERNAL EXCEPTION DEF CLASS
first(to_ident) = TO
first(structure_tail) = TYPE SEMISEMI OPEN MODULE LET EXTERNAL EXCEPTION DEF CLASS
first(structure_item) = TYPE OPEN MODULE LET EXTERNAL EXCEPTION DEF CLASS
first(structure) = WHILE UIDENT TYPE TRY TRUE SUBTRACTIVE STRING SEMISEMI PREFIXOP PARSER OPEN NEW MODULE MATCH LPAREN LOC LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION DEF CLASS CHAR BEGIN ASSERT
first(stream_pattern_component) = UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING QUOTE LPAREN LIDENT LBRACKET LBRACE INT FLOAT FALSE CHAR
first(stream_pattern) = UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING QUOTE LPAREN LIDENT LBRACKET LBRACE INT FLOAT FALSE CHAR
first(stream_expr_component) = WHILE UIDENT TRY TRUE SUBTRACTIVE STRING QUOTE PREFIXOP PARSER NEW MATCH LPAREN LOC LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE DEF CHAR BEGIN ASSERT
first(stream_expr) = WHILE UIDENT TRY TRUE SUBTRACTIVE STRING QUOTE PREFIXOP PARSER NEW MATCH LPAREN LOC LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE DEF CHAR BEGIN ASSERT
first(static_semi_list) = UIDENT TRUE STRING LPAREN LIDENT LBRACKETBAR LBRACKET INT FLOAT FALSE CHAR
first(static_expr) = UIDENT TRUE STRING LPAREN LIDENT LBRACKETBAR LBRACKET INT FLOAT FALSE CHAR
first(static_comma_list) = UIDENT TRUE STRING LPAREN LIDENT LBRACKETBAR LBRACKET INT FLOAT FALSE CHAR
first(simple_pattern_list) = UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING LPAREN LIDENT LBRACKET LBRACE INT FLOAT FALSE CHAR
first(simple_pattern) = UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING LPAREN LIDENT LBRACKET LBRACE INT FLOAT FALSE CHAR
first(simple_expr_list) = UIDENT TRUE STRING PREFIXOP NEW LPAREN LOC LIDENT LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE INT FLOAT FALSE CHAR BEGIN
first(simple_expr) = UIDENT TRUE STRING PREFIXOP NEW LPAREN LOC LIDENT LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE INT FLOAT FALSE CHAR BEGIN
first(simple_core_type) = UNDERSCORE UIDENT SHARP QUOTE LPAREN LIDENT LESS
first(signed_constant) = SUBTRACTIVE STRING INT FLOAT CHAR
first(signature_item) = VAL TYPE OPEN MODULE INCLUDE EXTERNAL EXCEPTION CLASS
first(signature) = VAL TYPE OPEN MODULE INCLUDE EXTERNAL EXCEPTION CLASS
first(seq_expr) = WHILE UIDENT TRY TRUE SUBTRACTIVE STRING PREFIXOP PARSER NEW MATCH LPAREN LOC LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE DEF CHAR BEGIN ASSERT
first(self_type) = COLON
first(self) = AS
first(rec_flag) = REC
first(protected_flag) = PROTECTED
first(process0) = UIDENT TRUE STRING REPLY LPAREN LIDENT LBRACKETBAR LBRACKET LBRACEBARBARRBRACE LBRACEBAR INT IF FLOAT FALSE CHAR
first(process) = UIDENT TRUE STRING REPLY LPAREN LIDENT LET LBRACKETBAR LBRACKET LBRACEBARBARRBRACE LBRACEBAR INT IF FLOAT FALSE DEF CHAR BEGIN
first(private_flag) = PRIVATE
first(primitive_declaration) = STRING
first(pattern_semi_list) = UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING LPAREN LIDENT LBRACKET LBRACE INT FLOAT FALSE CHAR
first(pattern_comma_list) = UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING LPAREN LIDENT LBRACKET LBRACE INT FLOAT FALSE CHAR
first(pattern) = UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING LPAREN LIDENT LBRACKET LBRACE INT FLOAT FALSE CHAR
first(parser_cases) = LBRACKETLESS
first(parser_case) = LBRACKETLESS
first(opt_semi) = SEMI
first(opt_pat) = UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING LPAREN LIDENT LBRACKET LBRACE INT FLOAT FALSE CHAR
first(opt_err) = QUESTION
first(opt_bar) = BAR
first(operator) = SUBTRACTIVE STAR PREFIXOP OR LESSGREATER LESS INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 GREATER EQUAL COLONEQUAL BARBAR AMPERSAND AMPERAMPER
first(mutable_flag) = MUTABLE
first(mty_longident) = UIDENT LIDENT
first(module_type) = UIDENT SIG LPAREN LIDENT FUNCTOR
first(module_expr) = UIDENT STRUCT LPAREN FUNCTOR
first(module_declaration) = LPAREN COLON
first(module_binding) = LPAREN EQUAL COLON
first(mod_longident) = UIDENT
first(mod_ext_longident) = UIDENT
first(method_type) = METHOD
first(method_def) = METHOD
first(meth_list) = LIDENT DOTDOT
first(meth_binding) = UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING LPAREN LIDENT LBRACKET LBRACE INT FLOAT FALSE EQUAL COLONGREATER COLON CHAR
first(match_cases) = UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING LPAREN LIDENT LBRACKET LBRACE INT FLOAT FALSE CHAR
first(match_action) = WHEN MINUSGREATER
first(location_tail) = WHILE UIDENT TRY TRUE SUBTRACTIVE STRING SEMISEMI PREFIXOP PARSER NEW MATCH LPAREN LOC LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE DEF CHAR BEGIN ASSERT
first(location_item) = WHILE UIDENT TRY TRUE SUBTRACTIVE STRING PREFIXOP PARSER NEW MATCH LPAREN LOC LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE DEF CHAR BEGIN ASSERT
first(location) = WHILE UIDENT TRY TRUE SUBTRACTIVE STRING SEMISEMI PREFIXOP PARSER NEW MATCH LPAREN LOC LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE DEF CHAR BEGIN ASSERT
first(list_of_exprs) = WHILE UIDENT TRY TRUE SUBTRACTIVE STRING PREFIXOP PARSER NEW MATCH LPAREN LOC LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE DEF CHAR BEGIN ASSERT
first(let_bindings) = UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING LPAREN LIDENT LBRACKET LBRACE INT FLOAT FALSE CHAR
first(let_binding) = UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING LPAREN LIDENT LBRACKET LBRACE INT FLOAT FALSE CHAR
first(lbl_pattern_list) = UIDENT LIDENT
first(lbl_expr_list) = UIDENT LIDENT
first(label_longident) = UIDENT LIDENT
first(label_expr_list) = LIDENT
first(label_declarations) = MUTABLE LIDENT
first(label_declaration) = MUTABLE LIDENT
first(label) = LIDENT
first(join_pattern) = LIDENT
first(join_args) = UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING LPAREN LIDENT LBRACKET LBRACE INT FLOAT FALSE CHAR
first(interface) = VAL TYPE OPEN MODULE INCLUDE EXTERNAL EXCEPTION EOF CLASS
first(implementation) = WHILE UIDENT TYPE TRY TRUE SUBTRACTIVE STRING SEMISEMI PREFIXOP PARSER OPEN NEW MODULE MATCH LPAREN LOC LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION EOF DEF CLASS CHAR BEGIN ASSERT
first(ident) = UIDENT LIDENT
first(fun_def) = WHEN UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING MINUSGREATER LPAREN LIDENT LBRACKET LBRACE INT FLOAT FALSE CHAR
first(fun_binding) = UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING LPAREN LIDENT LBRACKET LBRACE INT FLOAT FALSE EQUAL COLONGREATER COLON CHAR
first(field) = LIDENT
first(expr_semi_list) = WHILE UIDENT TRY TRUE SUBTRACTIVE STRING PREFIXOP PARSER NEW MATCH LPAREN LOC LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE DEF CHAR BEGIN ASSERT
first(expr_comma_list) = WHILE UIDENT TRY TRUE SUBTRACTIVE STRING PREFIXOP PARSER NEW MATCH LPAREN LOC LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE DEF CHAR BEGIN ASSERT
first(expr) = WHILE UIDENT TRY TRUE SUBTRACTIVE STRING PREFIXOP PARSER NEW MATCH LPAREN LOC LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE DEF CHAR BEGIN ASSERT
first(direction_flag) = TO DOWNTO
first(def_bindings) = LIDENT
first(def_binding) = LIDENT
first(core_type_tuple) = UNDERSCORE UIDENT SHARP QUOTE LPAREN LIDENT LESS
first(core_type_list) = UNDERSCORE UIDENT SHARP QUOTE LPAREN LIDENT LESS
first(core_type_comma_list) = UNDERSCORE UIDENT SHARP QUOTE LPAREN LIDENT LESSLESS LESS
first(core_type) = UNDERSCORE UIDENT SHARP QUOTE LPAREN LIDENT LESSLESS LESS
first(constructor_declarations) = UIDENT TRUE LPAREN LBRACKET FALSE COLONCOLON
first(constructor_declaration) = UIDENT TRUE LPAREN LBRACKET FALSE COLONCOLON
first(constructor_arguments) = OF
first(constraints) = CONSTRAINT
first(constrain) = QUOTE
first(constr_longident) = UIDENT TRUE LPAREN LBRACKET FALSE
first(constr_ident) = UIDENT TRUE LPAREN LBRACKET FALSE COLONCOLON
first(constant) = STRING INT FLOAT CHAR
first(closed_flag) = CLOSED
first(class_type_parameters) = QUOTE LPAREN
first(class_type_list) = VIRTUAL QUOTE LPAREN LIDENT CLOSED
first(class_type_fields) = VIRTUAL VAL METHOD INHERIT
first(class_type) = VIRTUAL QUOTE LPAREN LIDENT CLOSED
first(class_longident) = UIDENT LIDENT
first(class_list) = VIRTUAL QUOTE LPAREN LIDENT CLOSED
first(class_fields) = VIRTUAL VAL METHOD INHERIT
first(class_def) = VIRTUAL QUOTE LPAREN LIDENT CLOSED
first(channel_type) = UNDERSCORE UIDENT SHARP QUOTE LPAREN LIDENT LESSLESS LESS
first(channel_tuple) = UNDERSCORE UIDENT SHARP QUOTE LPAREN LIDENT LESSLESS LESS
first(ancestor_type) = UIDENT LPAREN LIDENT
first(ancestor) = UIDENT LPAREN LIDENT
minimal(with_constraints) = (* 4 *) TYPE LIDENT EQUAL UNDERSCORE
minimal(with_constraint) = (* 4 *) TYPE LIDENT EQUAL UNDERSCORE
minimal(virtual_method) = (* 4 *) VIRTUAL LIDENT COLON UNDERSCORE
minimal(virtual_flag) = (* 0 *) 
minimal(value_type) = (* 1 *) LIDENT
minimal(value) = (* 1 *) LIDENT
minimal(val_longident) = (* 1 *) LIDENT
minimal(val_ident) = (* 1 *) LIDENT
minimal(use_file_tail) = (* 1 *) EOF
minimal(use_file) = (* 1 *) EOF
minimal(type_parameters) = (* 0 *) 
minimal(type_parameter_list) = (* 2 *) QUOTE UIDENT
minimal(type_parameter) = (* 2 *) QUOTE UIDENT
minimal(type_longident) = (* 1 *) LIDENT
minimal(type_list) = (* 3 *) LPAREN UNDERSCORE RPAREN
minimal(type_kind) = (* 0 *) 
minimal(type_declarations) = (* 1 *) LIDENT
minimal(type_declaration) = (* 1 *) LIDENT
minimal(type_constraint) = (* 2 *) COLON UNDERSCORE
minimal(toplevel_phrase) = (* 1 *) EOF
minimal(toplevel_directive) = (* 2 *) SHARP UIDENT
minimal(top_structure) = (* 2 *) TYPE LIDENT
minimal(to_ident) = (* 0 *) 
minimal(structure_tail) = (* 0 *) 
minimal(structure_item) = (* 2 *) TYPE LIDENT
minimal(structure) = (* 0 *) 
minimal(stream_pattern_component) = (* 1 *) LIDENT
minimal(stream_pattern) = (* 1 *) LIDENT
minimal(stream_expr_component) = (* 1 *) LIDENT
minimal(stream_expr) = (* 1 *) LIDENT
minimal(static_semi_list) = (* 1 *) LIDENT
minimal(static_expr) = (* 1 *) LIDENT
minimal(static_comma_list) = (* 1 *) LIDENT
minimal(simple_pattern_list) = (* 1 *) LIDENT
minimal(simple_pattern) = (* 1 *) LIDENT
minimal(simple_expr_list) = (* 1 *) LIDENT
minimal(simple_expr) = (* 1 *) LIDENT
minimal(simple_core_type) = (* 1 *) UNDERSCORE
minimal(signed_constant) = (* 1 *) INT
minimal(signature_item) = (* 2 *) TYPE LIDENT
minimal(signature) = (* 0 *) 
minimal(seq_expr) = (* 1 *) LIDENT
minimal(self_type) = (* 0 *) 
minimal(self) = (* 0 *) 
minimal(rec_flag) = (* 0 *) 
minimal(protected_flag) = (* 0 *) 
minimal(process0) = (* 1 *) LBRACEBARBARRBRACE
minimal(process) = (* 0 *) 
minimal(private_flag) = (* 0 *) 
minimal(primitive_declaration) = (* 1 *) STRING
minimal(pattern_semi_list) = (* 1 *) LIDENT
minimal(pattern_comma_list) = (* 3 *) LIDENT COMMA LIDENT
minimal(pattern) = (* 1 *) LIDENT
minimal(parser_cases) = (* 3 *) LBRACKETLESS LIDENT error
minimal(parser_case) = (* 3 *) LBRACKETLESS LIDENT error
minimal(opt_semi) = (* 0 *) 
minimal(opt_pat) = (* 0 *) 
minimal(opt_err) = (* 0 *) 
minimal(opt_bar) = (* 0 *) 
minimal(operator) = (* 1 *) PREFIXOP
minimal(mutable_flag) = (* 0 *) 
minimal(mty_longident) = (* 1 *) UIDENT
minimal(module_type) = (* 1 *) UIDENT
minimal(module_expr) = (* 1 *) UIDENT
minimal(module_declaration) = (* 2 *) COLON UIDENT
minimal(module_binding) = (* 2 *) EQUAL UIDENT
minimal(mod_longident) = (* 1 *) UIDENT
minimal(mod_ext_longident) = (* 1 *) UIDENT
minimal(method_type) = (* 2 *) METHOD LIDENT
minimal(method_def) = (* 4 *) METHOD LIDENT EQUAL LIDENT
minimal(meth_list) = (* 1 *) DOTDOT
minimal(meth_binding) = (* 2 *) EQUAL LIDENT
minimal(match_cases) = (* 3 *) LIDENT MINUSGREATER LIDENT
minimal(match_action) = (* 2 *) MINUSGREATER LIDENT
minimal(location_tail) = (* 0 *) 
minimal(location_item) = (* 1 *) LIDENT
minimal(location) = (* 0 *) 
minimal(list_of_exprs) = (* 1 *) LIDENT
minimal(let_bindings) = (* 3 *) LIDENT EQUAL LIDENT
minimal(let_binding) = (* 3 *) LIDENT EQUAL LIDENT
minimal(lbl_pattern_list) = (* 3 *) LIDENT EQUAL LIDENT
minimal(lbl_expr_list) = (* 3 *) LIDENT EQUAL LIDENT
minimal(label_longident) = (* 1 *) LIDENT
minimal(label_expr_list) = (* 3 *) LIDENT EQUAL LIDENT
minimal(label_declarations) = (* 3 *) LIDENT COLON UNDERSCORE
minimal(label_declaration) = (* 3 *) LIDENT COLON UNDERSCORE
minimal(label) = (* 1 *) LIDENT
minimal(join_pattern) = (* 2 *) LIDENT LESSGREATER
minimal(join_args) = (* 0 *) 
minimal(interface) = (* 1 *) EOF
minimal(implementation) = (* 1 *) EOF
minimal(ident) = (* 1 *) UIDENT
minimal(fun_def) = (* 2 *) MINUSGREATER LIDENT
minimal(fun_binding) = (* 2 *) EQUAL LIDENT
minimal(field) = (* 3 *) LIDENT COLON UNDERSCORE
minimal(expr_semi_list) = (* 1 *) LIDENT
minimal(expr_comma_list) = (* 3 *) LIDENT COMMA LIDENT
minimal(expr) = (* 1 *) LIDENT
minimal(direction_flag) = (* 1 *) TO
minimal(def_bindings) = (* 3 *) LIDENT LESSGREATER EQUAL
minimal(def_binding) = (* 3 *) LIDENT LESSGREATER EQUAL
minimal(core_type_tuple) = (* 3 *) UNDERSCORE STAR UNDERSCORE
minimal(core_type_list) = (* 1 *) UNDERSCORE
minimal(core_type_comma_list) = (* 3 *) UNDERSCORE COMMA UNDERSCORE
minimal(core_type) = (* 1 *) UNDERSCORE
minimal(constructor_declarations) = (* 1 *) UIDENT
minimal(constructor_declaration) = (* 1 *) UIDENT
minimal(constructor_arguments) = (* 0 *) 
minimal(constraints) = (* 0 *) 
minimal(constrain) = (* 4 *) QUOTE UIDENT EQUAL UNDERSCORE
minimal(constr_longident) = (* 1 *) UIDENT
minimal(constr_ident) = (* 1 *) UIDENT
minimal(constant) = (* 1 *) INT
minimal(closed_flag) = (* 0 *) 
minimal(class_type_parameters) = (* 0 *) 
minimal(class_type_list) = (* 5 *) LIDENT LPAREN UNDERSCORE RPAREN EQUAL
minimal(class_type_fields) = (* 0 *) 
minimal(class_type) = (* 5 *) LIDENT LPAREN UNDERSCORE RPAREN EQUAL
minimal(class_longident) = (* 1 *) LIDENT
minimal(class_list) = (* 3 *) LIDENT LIDENT EQUAL
minimal(class_fields) = (* 0 *) 
minimal(class_def) = (* 3 *) LIDENT LIDENT EQUAL
minimal(channel_type) = (* 0 *) 
minimal(channel_tuple) = (* 1 *) UNDERSCORE
minimal(ancestor_type) = (* 1 *) LIDENT
minimal(ancestor) = (* 2 *) LIDENT LIDENT
follow(with_constraints) = error WITH VAL TYPE SHARP SEMISEMI RPAREN OPEN MODULE LET INCLUDE EXTERNAL EXCEPTION EQUAL EOF END DEF CLASS AND
follow(with_constraint) = error WITH VAL TYPE SHARP SEMISEMI RPAREN OPEN MODULE LET INCLUDE EXTERNAL EXCEPTION EQUAL EOF END DEF CLASS AND
follow(virtual_method) = error VIRTUAL VAL METHOD INHERIT END AND
follow(virtual_flag) = QUOTE LPAREN LIDENT CLOSED
follow(value_type) = VIRTUAL VAL METHOD INHERIT END AND
follow(value) = error VIRTUAL VAL METHOD INHERIT END AND
follow(val_longident) = error WITH WHILE VIRTUAL VAL UIDENT TYPE TRY TRUE TO THEN SUBTRACTIVE STRING STAR SHARP SEMISEMI SEMI RPAREN RBRACKET RBRACE QUESTION PREFIXOP PARSER OR OPEN NEW MODULE MINUSGREATER METHOD MATCH LPAREN LOC LIDENT LET LESSLESSGREATERGREATER LESSLESS LESSGREATER LESS LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN IF GREATERRBRACKET GREATERRBRACE GREATERGREATER GREATER FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DOT DONE DO DEF COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS CHAR BEGIN BARRBRACKET BARRBRACE BARBAR BAR ASSERT AS AND AMPERSAND AMPERAMPER
follow(val_ident) = error WITH WHILE WHEN VIRTUAL VAL UNDERSCORE UIDENT TYPE TRY TRUE TO THEN SUBTRACTIVE STRING STAR SHARP SEMISEMI SEMI RPAREN RBRACKET RBRACE QUESTION PREFIXOP PARSER OR OPEN NEW MODULE MINUSGREATER METHOD MATCH LPAREN LOC LIDENT LET LESSLESSGREATERGREATER LESSLESS LESSGREATER LESS LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN IF GREATERRBRACKET GREATERRBRACE GREATERGREATER GREATER FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DOT DONE DO DEF COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS CHAR BEGIN BARRBRACKET BARRBRACE BARBAR BAR ASSERT AS AND AMPERSAND AMPERAMPER
follow(use_file_tail) = #
follow(use_file) = #
follow(type_parameters) = UIDENT LIDENT
follow(type_parameter_list) = RPAREN COMMA
follow(type_parameter) = error WITH VIRTUAL VAL UIDENT TYPE SHARP SEMISEMI SEMI RPAREN RBRACE OPEN MODULE MINUSGREATER METHOD LIDENT LET INHERIT INCLUDE GREATERGREATER GREATER EXTERNAL EXCEPTION EQUALGREATER EQUAL EOF END DEF CONSTRAINT COMMA COLONGREATER CLASS AS AND
follow(type_longident) = error WITH VIRTUAL VAL UIDENT TYPE STAR SHARP SEMISEMI SEMI RPAREN RBRACE OPEN MODULE MINUSGREATER METHOD LIDENT LET INHERIT INCLUDE GREATERGREATER GREATER EXTERNAL EXCEPTION EQUALGREATER EQUAL EOF END DEF CONSTRAINT COMMA COLONGREATER CLASS BAR AS AND
follow(type_list) = EQUAL COLON
follow(type_kind) = error VAL TYPE SHARP SEMISEMI OPEN MODULE LET INCLUDE EXTERNAL EXCEPTION EOF END DEF CONSTRAINT CLASS AND
follow(type_declarations) = error VAL TYPE SHARP SEMISEMI OPEN MODULE LET INCLUDE EXTERNAL EXCEPTION EOF END DEF CLASS AND
follow(type_declaration) = error VAL TYPE SHARP SEMISEMI OPEN MODULE LET INCLUDE EXTERNAL EXCEPTION EOF END DEF CLASS AND
follow(type_constraint) = RPAREN EQUAL
follow(toplevel_phrase) = #
follow(toplevel_directive) = TYPE SHARP SEMISEMI OPEN MODULE LET EXTERNAL EXCEPTION EOF DEF CLASS
follow(top_structure) = SEMISEMI
follow(to_ident) = error WHILE UIDENT TYPE TRY TRUE SUBTRACTIVE STRING SHARP SEMISEMI PREFIXOP PARSER OPEN NEW MODULE MATCH LPAREN LOC LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT IN IF FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION EOF END ELSE DEF CLASS CHAR BEGIN BARRBRACE BAR ASSERT AND
follow(structure_tail) = error EOF END
follow(structure_item) = error TYPE SHARP SEMISEMI OPEN MODULE LET EXTERNAL EXCEPTION EOF END DEF CLASS
follow(structure) = error EOF END
follow(stream_pattern_component) = error SEMI QUESTION GREATERRBRACKET
follow(stream_pattern) = error SEMI GREATERRBRACKET
follow(stream_expr_component) = error SEMI GREATERRBRACKET
follow(stream_expr) = error SEMI GREATERRBRACKET
follow(static_semi_list) = error SEMI RBRACKET BARRBRACKET
follow(static_expr) = error WHILE UIDENT TYPE TRY TRUE TO SUBTRACTIVE STRING SHARP SEMISEMI SEMI RPAREN RBRACKET PREFIXOP PARSER OPEN NEW MODULE MATCH LPAREN LOC LIDENT LET LESSLESSGREATERGREATER LESSLESS LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT IN IF GREATERGREATER FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION EOF END ELSE DOT DEF COMMA COLONGREATER COLON CLASS CHAR BEGIN BARRBRACKET BARRBRACE BAR ASSERT AND
follow(static_comma_list) = error RPAREN GREATERGREATER COMMA
follow(simple_pattern_list) = UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING LPAREN LIDENT LBRACKET LBRACE INT FLOAT FALSE EQUAL COLON CHAR AS
follow(simple_pattern) = error WHEN UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING SEMI RPAREN RBRACKET RBRACE QUESTION MINUSGREATER LPAREN LIDENT LBRACKETLESS LBRACKET LBRACE INT GREATERRBRACKET GREATERGREATER GREATER FLOAT FALSE EQUAL COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CHAR BAR AS
follow(simple_expr_list) = error WITH WHILE VIRTUAL VAL UIDENT TYPE TRY TRUE TO THEN SUBTRACTIVE STRING STAR SHARP SEMISEMI SEMI RPAREN RBRACKET RBRACE QUESTION PREFIXOP PARSER OR OPEN NEW MODULE MINUSGREATER METHOD MATCH LPAREN LOC LIDENT LET LESSGREATER LESS LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN IF GREATERRBRACKET GREATERRBRACE GREATERGREATER GREATER FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DONE DO DEF COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS CHAR BEGIN BARRBRACKET BARBAR BAR ASSERT AS AND AMPERSAND AMPERAMPER
follow(simple_expr) = error WITH WHILE VIRTUAL VAL UIDENT TYPE TRY TRUE TO THEN SUBTRACTIVE STRING STAR SHARP SEMISEMI SEMI RPAREN RBRACKET RBRACE QUESTION PREFIXOP PARSER OR OPEN NEW MODULE MINUSGREATER METHOD MATCH LPAREN LOC LIDENT LET LESSLESSGREATERGREATER LESSLESS LESSGREATER LESS LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN IF GREATERRBRACKET GREATERRBRACE GREATERGREATER GREATER FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DOT DONE DO DEF COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS CHAR BEGIN BARRBRACKET BARBAR BAR ASSERT AS AND AMPERSAND AMPERAMPER
follow(simple_core_type) = error WITH VIRTUAL VAL UIDENT TYPE STAR SHARP SEMISEMI SEMI RPAREN RBRACE OPEN MODULE MINUSGREATER METHOD LIDENT LET INHERIT INCLUDE GREATERGREATER GREATER EXTERNAL EXCEPTION EQUALGREATER EQUAL EOF END DEF CONSTRAINT COMMA COLONGREATER CLASS BAR AS AND
follow(signed_constant) = error WHEN UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING SEMI RPAREN RBRACKET RBRACE QUESTION MINUSGREATER LPAREN LIDENT LBRACKETLESS LBRACKET LBRACE INT GREATERRBRACKET GREATERGREATER GREATER FLOAT FALSE EQUAL COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CHAR BAR AS
follow(signature_item) = error VAL TYPE SEMISEMI OPEN MODULE INCLUDE EXTERNAL EXCEPTION EOF END CLASS
follow(signature) = error VAL TYPE OPEN MODULE INCLUDE EXTERNAL EXCEPTION EOF END CLASS
follow(seq_expr) = error WITH WHILE VIRTUAL VAL UIDENT TYPE TRY TRUE TO THEN SUBTRACTIVE STRING STAR SHARP SEMISEMI SEMI RPAREN RBRACKET RBRACE QUESTION PREFIXOP PARSER OR OPEN NEW MODULE MINUSGREATER METHOD MATCH LPAREN LOC LIDENT LET LESSGREATER LESS LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN IF GREATERRBRACKET GREATERRBRACE GREATERGREATER GREATER FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DONE DO DEF COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS CHAR BEGIN BARRBRACKET BARBAR BAR ASSERT AND AMPERSAND AMPERAMPER
follow(self_type) = EQUAL
follow(self) = error VIRTUAL VAL METHOD INHERIT EQUAL END COLON AND
follow(rec_flag) = UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING LPAREN LIDENT LBRACKET LBRACE INT FLOAT FALSE CHAR
follow(protected_flag) = LIDENT
follow(process0) = error WHILE UIDENT TYPE TRY TRUE SUBTRACTIVE STRING SHARP SEMISEMI PREFIXOP PARSER OPEN NEW MODULE MATCH LPAREN LOC LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT IN IF FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION EOF END ELSE DEF CLASS CHAR BEGIN BARRBRACE BAR ASSERT AND
follow(process) = error WHILE UIDENT TYPE TRY TRUE SUBTRACTIVE STRING SHARP SEMISEMI PREFIXOP PARSER OPEN NEW MODULE MATCH LPAREN LOC LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT IN IF FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION EOF END DEF CLASS CHAR BEGIN BARRBRACE ASSERT AND
follow(private_flag) = MUTABLE LIDENT
follow(primitive_declaration) = error VAL TYPE SHARP SEMISEMI OPEN MODULE LET INCLUDE EXTERNAL EXCEPTION EOF END DEF CLASS
follow(pattern_semi_list) = error SEMI RBRACKET
follow(pattern_comma_list) = error WHEN SEMI RPAREN RBRACKET RBRACE QUESTION MINUSGREATER GREATERRBRACKET GREATERGREATER GREATER EQUAL COMMA COLONEQUAL COLONCOLON COLON BAR AS
follow(pattern) = error WHEN SEMI RPAREN RBRACKET RBRACE QUESTION MINUSGREATER GREATERRBRACKET GREATERGREATER GREATER EQUAL COMMA COLONEQUAL COLONCOLON COLON BAR AS
follow(parser_cases) = error WITH WHILE VIRTUAL VAL UIDENT TYPE TRY TRUE TO THEN SUBTRACTIVE STRING STAR SHARP SEMISEMI SEMI RPAREN RBRACKET RBRACE QUESTION PREFIXOP PARSER OR OPEN NEW MODULE MINUSGREATER METHOD MATCH LPAREN LOC LIDENT LET LESSGREATER LESS LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN IF GREATERRBRACKET GREATERRBRACE GREATERGREATER GREATER FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DONE DO DEF COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS CHAR BEGIN BARRBRACKET BARBAR BAR ASSERT AND AMPERSAND AMPERAMPER
follow(parser_case) = error WITH WHILE VIRTUAL VAL UIDENT TYPE TRY TRUE TO THEN SUBTRACTIVE STRING STAR SHARP SEMISEMI SEMI RPAREN RBRACKET RBRACE QUESTION PREFIXOP PARSER OR OPEN NEW MODULE MINUSGREATER METHOD MATCH LPAREN LOC LIDENT LET LESSGREATER LESS LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN IF GREATERRBRACKET GREATERRBRACE GREATERGREATER GREATER FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DONE DO DEF COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS CHAR BEGIN BARRBRACKET BARBAR BAR ASSERT AND AMPERSAND AMPERAMPER
follow(opt_semi) = error RBRACKET RBRACE GREATERRBRACKET GREATERRBRACE GREATER BARRBRACKET
follow(opt_pat) = MINUSGREATER LBRACKETLESS BAR
follow(opt_err) = error SEMI GREATERRBRACKET
follow(opt_bar) = UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING LPAREN LIDENT LBRACKETLESS LBRACKET LBRACE INT FLOAT FALSE COLONCOLON CHAR
follow(operator) = RPAREN
follow(mutable_flag) = LIDENT
follow(mty_longident) = error WITH VAL TYPE SHARP SEMISEMI RPAREN OPEN MODULE LET INCLUDE EXTERNAL EXCEPTION EQUAL EOF END DEF CLASS
follow(module_type) = error WITH VAL TYPE SHARP SEMISEMI RPAREN OPEN MODULE LET INCLUDE EXTERNAL EXCEPTION EQUAL EOF END DEF CLASS
follow(module_expr) = error TYPE SHARP SEMISEMI RPAREN OPEN MODULE LPAREN LET EXTERNAL EXCEPTION EOF END DEF COLON CLASS
follow(module_declaration) = error VAL TYPE SEMISEMI OPEN MODULE INCLUDE EXTERNAL EXCEPTION EOF END CLASS
follow(module_binding) = error TYPE SHARP SEMISEMI OPEN MODULE LET EXTERNAL EXCEPTION EOF END DEF CLASS
follow(mod_longident) = error WITH WHILE WHEN VIRTUAL VAL UNDERSCORE UIDENT TYPE TRY TRUE TO THEN SUBTRACTIVE STRING STAR SHARP SEMISEMI SEMI RPAREN RBRACKET RBRACE QUESTION PREFIXOP PARSER OR OPEN NEW MODULE MINUSGREATER METHOD MATCH LPAREN LOC LIDENT LET LESSLESSGREATERGREATER LESSLESS LESSGREATER LESS LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 INCLUDE IN IF GREATERRBRACKET GREATERRBRACE GREATERGREATER GREATER FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DOT DONE DO DEF COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS CHAR BEGIN BARRBRACKET BARRBRACE BARBAR BAR ASSERT AS AND AMPERSAND AMPERAMPER
follow(mod_ext_longident) = error WITH VAL TYPE SHARP SEMISEMI RPAREN OPEN MODULE LPAREN LET INCLUDE EXTERNAL EXCEPTION EQUAL EOF END DOT DEF CLASS AND
follow(method_type) = VIRTUAL VAL METHOD INHERIT END AND
follow(method_def) = error VIRTUAL VAL METHOD INHERIT END AND
follow(meth_list) = GREATER
follow(meth_binding) = error VIRTUAL VAL METHOD INHERIT END AND
follow(match_cases) = error WITH WHILE VIRTUAL VAL UIDENT TYPE TRY TRUE TO THEN SUBTRACTIVE STRING STAR SHARP SEMISEMI SEMI RPAREN RBRACKET RBRACE QUESTION PREFIXOP PARSER OR OPEN NEW MODULE MINUSGREATER METHOD MATCH LPAREN LOC LIDENT LET LESSGREATER LESS LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN IF GREATERRBRACKET GREATERRBRACE GREATERGREATER GREATER FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DONE DO DEF COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS CHAR BEGIN BARRBRACKET BARBAR BAR ASSERT AND AMPERSAND AMPERAMPER
follow(match_action) = error WITH WHILE VIRTUAL VAL UIDENT TYPE TRY TRUE TO THEN SUBTRACTIVE STRING STAR SHARP SEMISEMI SEMI RPAREN RBRACKET RBRACE QUESTION PREFIXOP PARSER OR OPEN NEW MODULE MINUSGREATER METHOD MATCH LPAREN LOC LIDENT LET LESSGREATER LESS LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN IF GREATERRBRACKET GREATERRBRACE GREATERGREATER GREATER FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DONE DO DEF COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS CHAR BEGIN BARRBRACKET BARBAR BAR ASSERT AND AMPERSAND AMPERAMPER
follow(location_tail) = WHILE UIDENT TRY TRUE SUBTRACTIVE STRING SEMISEMI PREFIXOP PARSER NEW MATCH LPAREN LOC LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE END DEF CHAR BEGIN ASSERT
follow(location_item) = WHILE UIDENT TRY TRUE SUBTRACTIVE STRING SEMISEMI PREFIXOP PARSER NEW MATCH LPAREN LOC LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE END DEF CHAR BEGIN ASSERT
follow(location) = END
follow(list_of_exprs) = error GREATERGREATER
follow(let_bindings) = error WHILE UIDENT TYPE TRY TRUE SUBTRACTIVE STRING SHARP SEMISEMI PREFIXOP PARSER OPEN NEW MODULE MATCH LPAREN LOC LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT IN IF FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION EOF END DEF CLASS CHAR BEGIN ASSERT AND
follow(let_binding) = error WHILE UIDENT TYPE TRY TRUE SUBTRACTIVE STRING SHARP SEMISEMI PREFIXOP PARSER OPEN NEW MODULE MATCH LPAREN LOC LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT IN IF FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION EOF END DEF CLASS CHAR BEGIN ASSERT AND
follow(lbl_pattern_list) = error SEMI RBRACE
follow(lbl_expr_list) = error SEMI RBRACE
follow(label_longident) = error WITH WHILE VIRTUAL VAL UIDENT TYPE TRY TRUE TO THEN SUBTRACTIVE STRING STAR SHARP SEMISEMI SEMI RPAREN RBRACKET RBRACE QUESTION PREFIXOP PARSER OR OPEN NEW MODULE MINUSGREATER METHOD MATCH LPAREN LOC LIDENT LET LESSMINUS LESSLESSGREATERGREATER LESSLESS LESSGREATER LESS LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN IF GREATERRBRACKET GREATERRBRACE GREATERGREATER GREATER FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DOT DONE DO DEF COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS CHAR BEGIN BARRBRACKET BARRBRACE BARBAR BAR ASSERT AS AND AMPERSAND AMPERAMPER
follow(label_expr_list) = error SEMI GREATERRBRACE
follow(label_declarations) = SEMI RBRACE
follow(label_declaration) = SEMI RBRACE
follow(label) = error WITH WHILE VIRTUAL VAL UNDERSCORE UIDENT TYPE TRY TRUE TO THEN SUBTRACTIVE STRING STAR SHARP SEMISEMI SEMI RPAREN RBRACKET RBRACE QUESTION PREFIXOP PARSER OR OPEN NEW MODULE MINUSGREATER METHOD MATCH LPAREN LOC LIDENT LET LESSMINUS LESSLESSGREATERGREATER LESSLESS LESSGREATER LESS LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN IF GREATERRBRACKET GREATERRBRACE GREATERGREATER GREATER FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DOT DONE DO DEF COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS CHAR BEGIN BARRBRACKET BARBAR BAR ASSERT AS AND AMPERSAND AMPERAMPER
follow(join_pattern) = EQUAL BAR
follow(join_args) = GREATERGREATER GREATER
follow(interface) = #
follow(implementation) = #
follow(ident) = error WITH VIRTUAL VAL UIDENT TYPE STRING STAR SHARP SEMISEMI SEMI RPAREN RBRACE OPEN MODULE MINUSGREATER METHOD LPAREN LIDENT LET INT INHERIT INCLUDE GREATERGREATER GREATER EXTERNAL EXCEPTION EQUALGREATER EQUAL EOF END DEF CONSTRAINT COMMA COLONGREATER CLASS BAR AS AND
follow(fun_def) = error WITH WHILE VIRTUAL VAL UIDENT TYPE TRY TRUE TO THEN SUBTRACTIVE STRING STAR SHARP SEMISEMI SEMI RPAREN RBRACKET RBRACE QUESTION PREFIXOP PARSER OR OPEN NEW MODULE MINUSGREATER METHOD MATCH LPAREN LOC LIDENT LET LESSGREATER LESS LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN IF GREATERRBRACKET GREATERRBRACE GREATERGREATER GREATER FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DONE DO DEF COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS CHAR BEGIN BARRBRACKET BARBAR BAR ASSERT AND AMPERSAND AMPERAMPER
follow(fun_binding) = error WHILE UIDENT TYPE TRY TRUE SUBTRACTIVE STRING SHARP SEMISEMI PREFIXOP PARSER OPEN NEW MODULE MATCH LPAREN LOC LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT IN IF FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION EOF END DEF CLASS CHAR BEGIN ASSERT AND
follow(field) = SEMI GREATER
follow(expr_semi_list) = error SEMI RBRACKET BARRBRACKET
follow(expr_comma_list) = error WITH WHILE VIRTUAL VAL UIDENT TYPE TRY TRUE TO THEN SUBTRACTIVE STRING STAR SHARP SEMISEMI SEMI RPAREN RBRACKET RBRACE QUESTION PREFIXOP PARSER OR OPEN NEW MODULE MINUSGREATER METHOD MATCH LPAREN LOC LIDENT LET LESSGREATER LESS LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN IF GREATERRBRACKET GREATERRBRACE GREATERGREATER GREATER FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DONE DO DEF COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS CHAR BEGIN BARRBRACKET BARBAR BAR ASSERT AND AMPERSAND AMPERAMPER
follow(expr) = error WITH WHILE VIRTUAL VAL UIDENT TYPE TRY TRUE TO THEN SUBTRACTIVE STRING STAR SHARP SEMISEMI SEMI RPAREN RBRACKET RBRACE QUESTION PREFIXOP PARSER OR OPEN NEW MODULE MINUSGREATER METHOD MATCH LPAREN LOC LIDENT LET LESSGREATER LESS LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN IF GREATERRBRACKET GREATERRBRACE GREATERGREATER GREATER FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DONE DO DEF COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS CHAR BEGIN BARRBRACKET BARBAR BAR ASSERT AND AMPERSAND AMPERAMPER
follow(direction_flag) = WHILE UIDENT TRY TRUE SUBTRACTIVE STRING PREFIXOP PARSER NEW MATCH LPAREN LOC LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE DEF CHAR BEGIN ASSERT
follow(def_bindings) = error WHILE UIDENT TYPE TRY TRUE SUBTRACTIVE STRING SHARP SEMISEMI PREFIXOP PARSER OPEN NEW MODULE MATCH LPAREN LOC LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT IN IF FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION EOF END DEF CLASS CHAR BEGIN ASSERT AND
follow(def_binding) = error WHILE UIDENT TYPE TRY TRUE SUBTRACTIVE STRING SHARP SEMISEMI PREFIXOP PARSER OPEN NEW MODULE MATCH LPAREN LOC LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT IN IF FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION EOF END DEF CLASS CHAR BEGIN ASSERT AND
follow(core_type_tuple) = error WITH VIRTUAL VAL TYPE STAR SHARP SEMISEMI SEMI RPAREN RBRACE OPEN MODULE MINUSGREATER METHOD LET INHERIT INCLUDE GREATERGREATER GREATER EXTERNAL EXCEPTION EQUALGREATER EQUAL EOF END DEF CONSTRAINT COMMA COLONGREATER CLASS AS AND
follow(core_type_list) = error VAL TYPE STAR SHARP SEMISEMI OPEN MODULE LET INCLUDE EXTERNAL EXCEPTION EOF END DEF CONSTRAINT CLASS BAR AND
follow(core_type_comma_list) = RPAREN COMMA
follow(core_type) = error WITH VIRTUAL VAL TYPE SHARP SEMISEMI SEMI RPAREN RBRACE OPEN MODULE MINUSGREATER METHOD LET INHERIT INCLUDE GREATERGREATER GREATER EXTERNAL EXCEPTION EQUALGREATER EQUAL EOF END DEF CONSTRAINT COMMA COLONGREATER CLASS AS AND
follow(constructor_declarations) = error VAL TYPE SHARP SEMISEMI OPEN MODULE LET INCLUDE EXTERNAL EXCEPTION EOF END DEF CONSTRAINT CLASS BAR AND
follow(constructor_declaration) = error VAL TYPE SHARP SEMISEMI OPEN MODULE LET INCLUDE EXTERNAL EXCEPTION EOF END DEF CONSTRAINT CLASS BAR AND
follow(constructor_arguments) = error VAL TYPE SHARP SEMISEMI OPEN MODULE LET INCLUDE EXTERNAL EXCEPTION EOF END DEF CONSTRAINT CLASS BAR AND
follow(constraints) = error WITH VIRTUAL VAL TYPE SHARP SEMISEMI RPAREN OPEN MODULE METHOD LET INHERIT INCLUDE EXTERNAL EXCEPTION EQUAL EOF END DEF CONSTRAINT CLASS AND
follow(constrain) = error WITH VIRTUAL VAL TYPE SHARP SEMISEMI RPAREN OPEN MODULE METHOD LET INHERIT INCLUDE EXTERNAL EXCEPTION EQUAL EOF END DEF CONSTRAINT CLASS AND
follow(constr_longident) = error WITH WHILE WHEN VIRTUAL VAL UNDERSCORE UIDENT TYPE TRY TRUE TO THEN SUBTRACTIVE STRING STAR SHARP SEMISEMI SEMI RPAREN RBRACKET RBRACE QUESTION PREFIXOP PARSER OR OPEN NEW MODULE MINUSGREATER METHOD MATCH LPAREN LOC LIDENT LET LESSLESSGREATERGREATER LESSLESS LESSGREATER LESS LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN IF GREATERRBRACKET GREATERRBRACE GREATERGREATER GREATER FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DOT DONE DO DEF COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS CHAR BEGIN BARRBRACKET BARRBRACE BARBAR BAR ASSERT AS AND AMPERSAND AMPERAMPER
follow(constr_ident) = error VAL TYPE SHARP SEMISEMI OPEN OF MODULE LET INCLUDE EXTERNAL EXCEPTION EOF END DEF CONSTRAINT CLASS BAR AND
follow(constant) = error WITH WHILE WHEN VIRTUAL VAL UNDERSCORE UIDENT TYPE TRY TRUE TO THEN SUBTRACTIVE STRING STAR SHARP SEMISEMI SEMI RPAREN RBRACKET RBRACE QUESTION PREFIXOP PARSER OR OPEN NEW MODULE MINUSGREATER METHOD MATCH LPAREN LOC LIDENT LET LESSLESSGREATERGREATER LESSLESS LESSGREATER LESS LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN IF GREATERRBRACKET GREATERRBRACE GREATERGREATER GREATER FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DOT DONE DO DEF COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS CHAR BEGIN BARRBRACKET BARRBRACE BARBAR BAR ASSERT AS AND AMPERSAND AMPERAMPER
follow(closed_flag) = QUOTE LPAREN LIDENT
follow(class_type_parameters) = LIDENT
follow(class_type_list) = END AND
follow(class_type_fields) = VIRTUAL VAL METHOD INHERIT END AND
follow(class_type) = END AND
follow(class_longident) = error WITH WHILE VIRTUAL VAL UIDENT TYPE TRY TRUE TO THEN SUBTRACTIVE STRING STAR SHARP SEMISEMI SEMI RPAREN RBRACKET RBRACE QUESTION PREFIXOP PARSER OR OPEN NEW MODULE MINUSGREATER METHOD MATCH LPAREN LOC LIDENT LET LESSLESSGREATERGREATER LESSLESS LESSGREATER LESS LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACEBAR LBRACE LAZY INT INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 INCLUDE IN IF GREATERRBRACKET GREATERRBRACE GREATERGREATER GREATER FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION EQUALGREATER EQUAL EOF END ELSE DOWNTO DOT DONE DO DEF CONSTRAINT COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS CHAR BEGIN BARRBRACKET BARBAR BAR ASSERT AS AND AMPERSAND AMPERAMPER
follow(class_list) = error END AND
follow(class_fields) = error VIRTUAL VAL METHOD INHERIT END AND
follow(class_def) = error END AND
follow(channel_type) = GREATERGREATER EQUALGREATER
follow(channel_tuple) = GREATERGREATER EQUALGREATER COMMA
follow(ancestor_type) = VIRTUAL VAL METHOD INHERIT END AND
follow(ancestor) = error VIRTUAL VAL METHOD INHERIT END AND
Built an LR(0) automaton with 948 states.
The grammar is not SLR(1) -- 85 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 1607 states.
1008 shift/reduce conflicts were silently solved.
File "jocaml-new-parser.mly", line 244, characters 0-6:
Warning: the precedence level assigned to prec_let is never useful.
File "jocaml-new-parser.mly", line 248, characters 0-6:
Warning: the precedence level assigned to prec_list is never useful.
File "jocaml-new-parser.mly", line 245, characters 0-6:
Warning: the precedence level assigned to prec_type_def is never useful.
File "jocaml-new-parser.mly", line 640, characters 37-45:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 453, characters 39-47:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 455, characters 48-56:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 457, characters 45-53:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 459, characters 42-50:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 473, characters 37-45:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 481, characters 34-42:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 483, characters 29-37:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 856, characters 15-24:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 857, characters 35-44:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 774, characters 25-33:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 776, characters 41-49:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 850, characters 27-36:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 852, characters 48-57:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 844, characters 37-46:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 846, characters 56-65:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 761, characters 33-41:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 763, characters 38-46:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 987, characters 26-34:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 989, characters 42-50:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 325, characters 10-18:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 396, characters 10-18:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 817, characters 24-33:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 684, characters 38-46:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 686, characters 47-55:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 692, characters 34-41:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 710, characters 47-54:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 1182, characters 42-58:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 1185, characters 12-28:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 1195, characters 49-65:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 1198, characters 12-28:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 717, characters 22-31:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 718, characters 44-53:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 824, characters 21-30:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 825, characters 15-24:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 804, characters 34-43:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 1082, characters 26-39:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 1090, characters 65-78:
Warning: this %prec declaration is never useful.
File "jocaml-new-parser.mly", line 1093, characters 10-23:
Warning: this %prec declaration is never useful.
Warning: 52 states have shift/reduce conflicts.
Warning: 487 shift/reduce conflicts were arbitrarily resolved.
521 out of 1607 states have a default reduction.
880 out of 1607 states are represented.
0 out of 241 symbols keep track of their start position.
0 out of 241 symbols keep track of their end position.
236 out of 467 productions exploit shiftreduce optimization.
456 out of 1607 states can peek at an error.
3816 functions before inlining, 954 functions after inlining.
