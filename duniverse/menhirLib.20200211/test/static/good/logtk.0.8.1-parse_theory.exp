Grammar has 56 nonterminal symbols, among which 2 start symbols.
Grammar has 44 terminal symbols.
Grammar has 117 productions.
nullable(variables) = false
nullable(variable) = false
nullable(type_const) = false
nullable(theory) = false
nullable(tff_type) = false
nullable(tff_ty_var) = false
nullable(tff_ty_args) = false
nullable(tff_atom_type) = false
nullable(term) = false
nullable(system_term) = false
nullable(system_functor) = false
nullable(system_constant) = false
nullable(statements) = false
nullable(statement) = false
nullable(separated_nonempty_list(COMMA,variable)) = false
nullable(separated_nonempty_list(COMMA,tff_type)) = false
nullable(separated_nonempty_list(COMMA,term)) = false
nullable(separated_nonempty_list(COMMA,fof_logic_formula)) = false
nullable(separated_nonempty_list(COMMA,datalog_term)) = false
nullable(separated_nonempty_list(COMMA,datalog_lit)) = false
nullable(separated_nonempty_list(COMMA,atomic_word)) = false
nullable(separated_nonempty_list(AND_ALSO,premise)) = false
nullable(premises) = false
nullable(premise) = false
nullable(plain_term) = false
nullable(parse_statements) = false
nullable(parse_statement) = false
nullable(loption(separated_nonempty_list(COMMA,fof_logic_formula))) = true
nullable(lemma) = false
nullable(include_) = false
nullable(functor_) = false
nullable(function_term) = false
nullable(fof_unitary_formula) = false
nullable(fof_unary_formula) = false
nullable(fof_tuple) = false
nullable(fof_sequent) = false
nullable(fof_quantified_formula) = false
nullable(fof_logic_formula) = false
nullable(fof_formula) = false
nullable(defined_term) = false
nullable(defined_plain_term) = false
nullable(defined_functor) = false
nullable(defined_constant) = false
nullable(defined_atomic_term) = false
nullable(defined_atom) = false
nullable(datalog_term) = false
nullable(datalog_lit) = false
nullable(datalog_atom) = false
nullable(constant) = false
nullable(clause) = false
nullable(axiom) = false
nullable(atomic_word) = false
nullable(atomic_system_word) = false
nullable(atomic_formula) = false
nullable(atomic_defined_word) = false
nullable(arguments) = false
first(variables) = UPPER_WORD
first(variable) = UPPER_WORD
first(type_const) = LOWER_WORD DOLLAR_WORD
first(theory) = THEORY
first(tff_type) = UPPER_WORD TYPE_TY LOWER_WORD LEFT_PAREN DOLLAR_WORD
first(tff_ty_var) = UPPER_WORD
first(tff_ty_args) = UPPER_WORD TYPE_TY LOWER_WORD LEFT_PAREN DOLLAR_WORD
first(tff_atom_type) = UPPER_WORD TYPE_TY LOWER_WORD LEFT_PAREN DOLLAR_WORD
first(term) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(system_term) = DOLLAR_DOLLAR_WORD
first(system_functor) = DOLLAR_DOLLAR_WORD
first(system_constant) = DOLLAR_DOLLAR_WORD
first(statements) = error THEORY RAW LEMMA INCLUDE EOI AXIOM
first(statement) = THEORY RAW LEMMA INCLUDE AXIOM
first(separated_nonempty_list(COMMA,variable)) = UPPER_WORD
first(separated_nonempty_list(COMMA,tff_type)) = UPPER_WORD TYPE_TY LOWER_WORD LEFT_PAREN DOLLAR_WORD
first(separated_nonempty_list(COMMA,term)) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(separated_nonempty_list(COMMA,fof_logic_formula)) = UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LEFT_PAREN INTEGER FORALL FALSE EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(separated_nonempty_list(COMMA,datalog_term)) = UPPER_WORD SINGLE_QUOTED LOWER_WORD
first(separated_nonempty_list(COMMA,datalog_lit)) = SINGLE_QUOTED LOWER_WORD
first(separated_nonempty_list(COMMA,atomic_word)) = SINGLE_QUOTED LOWER_WORD
first(separated_nonempty_list(AND_ALSO,premise)) = UPPER_WORD TRUE THEORY SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LEFT_PAREN LEFT_BRACKET INTEGER FORALL FALSE EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT AXIOM
first(premises) = UPPER_WORD TRUE THEORY SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LEFT_PAREN LEFT_BRACKET INTEGER FORALL FALSE EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT AXIOM
first(premise) = UPPER_WORD TRUE THEORY SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LEFT_PAREN LEFT_BRACKET INTEGER FORALL FALSE EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT AXIOM
first(plain_term) = SINGLE_QUOTED LOWER_WORD DOLLAR_WORD
first(parse_statements) = error THEORY RAW LEMMA INCLUDE EOI AXIOM
first(parse_statement) = THEORY RAW LEMMA INCLUDE AXIOM
first(loption(separated_nonempty_list(COMMA,fof_logic_formula))) = UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LEFT_PAREN INTEGER FORALL FALSE EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(lemma) = LEMMA
first(include_) = INCLUDE
first(functor_) = SINGLE_QUOTED LOWER_WORD
first(function_term) = SINGLE_QUOTED REAL RATIONAL LOWER_WORD INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(fof_unitary_formula) = UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LEFT_PAREN INTEGER FORALL FALSE EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(fof_unary_formula) = NOT
first(fof_tuple) = LEFT_BRACKET
first(fof_sequent) = LEFT_PAREN LEFT_BRACKET
first(fof_quantified_formula) = FORALL EXISTS
first(fof_logic_formula) = UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LEFT_PAREN INTEGER FORALL FALSE EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(fof_formula) = UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LEFT_PAREN LEFT_BRACKET INTEGER FORALL FALSE EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(defined_term) = REAL RATIONAL INTEGER DOLLAR_WORD DISTINCT_OBJECT
first(defined_plain_term) = DOLLAR_WORD
first(defined_functor) = DOLLAR_WORD
first(defined_constant) = DOLLAR_WORD
first(defined_atomic_term) = DOLLAR_WORD
first(defined_atom) = REAL RATIONAL INTEGER DISTINCT_OBJECT
first(datalog_term) = UPPER_WORD SINGLE_QUOTED LOWER_WORD
first(datalog_lit) = SINGLE_QUOTED LOWER_WORD
first(datalog_atom) = LOWER_WORD
first(constant) = SINGLE_QUOTED LOWER_WORD DOLLAR_WORD
first(clause) = RAW
first(axiom) = AXIOM
first(atomic_word) = SINGLE_QUOTED LOWER_WORD
first(atomic_system_word) = DOLLAR_DOLLAR_WORD
first(atomic_formula) = UPPER_WORD TRUE SINGLE_QUOTED REAL RATIONAL LOWER_WORD INTEGER FALSE DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(atomic_defined_word) = DOLLAR_WORD
first(arguments) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
minimal(variables) = (* 1 *) UPPER_WORD
minimal(variable) = (* 1 *) UPPER_WORD
minimal(type_const) = (* 1 *) LOWER_WORD
minimal(theory) = (* 5 *) THEORY LOWER_WORD IS TRUE DOT
minimal(tff_type) = (* 1 *) UPPER_WORD
minimal(tff_ty_var) = (* 1 *) UPPER_WORD
minimal(tff_ty_args) = (* 1 *) UPPER_WORD
minimal(tff_atom_type) = (* 1 *) UPPER_WORD
minimal(term) = (* 1 *) SINGLE_QUOTED
minimal(system_term) = (* 1 *) DOLLAR_DOLLAR_WORD
minimal(system_functor) = (* 1 *) DOLLAR_DOLLAR_WORD
minimal(system_constant) = (* 1 *) DOLLAR_DOLLAR_WORD
minimal(statements) = (* 1 *) EOI
minimal(statement) = (* 3 *) RAW SINGLE_QUOTED DOT
minimal(separated_nonempty_list(COMMA,variable)) = (* 1 *) UPPER_WORD
minimal(separated_nonempty_list(COMMA,tff_type)) = (* 1 *) UPPER_WORD
minimal(separated_nonempty_list(COMMA,term)) = (* 1 *) SINGLE_QUOTED
minimal(separated_nonempty_list(COMMA,fof_logic_formula)) = (* 1 *) TRUE
minimal(separated_nonempty_list(COMMA,datalog_term)) = (* 1 *) SINGLE_QUOTED
minimal(separated_nonempty_list(COMMA,datalog_lit)) = (* 1 *) SINGLE_QUOTED
minimal(separated_nonempty_list(COMMA,atomic_word)) = (* 1 *) SINGLE_QUOTED
minimal(separated_nonempty_list(AND_ALSO,premise)) = (* 1 *) TRUE
minimal(premises) = (* 1 *) TRUE
minimal(premise) = (* 1 *) TRUE
minimal(plain_term) = (* 1 *) SINGLE_QUOTED
minimal(parse_statements) = (* 2 *) EOI EOI
minimal(parse_statement) = (* 4 *) RAW SINGLE_QUOTED DOT EOI
minimal(loption(separated_nonempty_list(COMMA,fof_logic_formula))) = (* 0 *) 
minimal(lemma) = (* 5 *) LEMMA TRUE IF TRUE DOT
minimal(include_) = (* 3 *) INCLUDE SINGLE_QUOTED DOT
minimal(functor_) = (* 1 *) SINGLE_QUOTED
minimal(function_term) = (* 1 *) SINGLE_QUOTED
minimal(fof_unitary_formula) = (* 1 *) TRUE
minimal(fof_unary_formula) = (* 2 *) NOT TRUE
minimal(fof_tuple) = (* 2 *) LEFT_BRACKET RIGHT_BRACKET
minimal(fof_sequent) = (* 5 *) LEFT_BRACKET RIGHT_BRACKET GENTZEN_ARROW LEFT_BRACKET RIGHT_BRACKET
minimal(fof_quantified_formula) = (* 6 *) FORALL LEFT_BRACKET UPPER_WORD RIGHT_BRACKET COLUMN TRUE
minimal(fof_logic_formula) = (* 1 *) TRUE
minimal(fof_formula) = (* 1 *) TRUE
minimal(defined_term) = (* 1 *) INTEGER
minimal(defined_plain_term) = (* 1 *) DOLLAR_WORD
minimal(defined_functor) = (* 1 *) DOLLAR_WORD
minimal(defined_constant) = (* 1 *) DOLLAR_WORD
minimal(defined_atomic_term) = (* 1 *) DOLLAR_WORD
minimal(defined_atom) = (* 1 *) INTEGER
minimal(datalog_term) = (* 1 *) SINGLE_QUOTED
minimal(datalog_lit) = (* 1 *) SINGLE_QUOTED
minimal(datalog_atom) = (* 1 *) LOWER_WORD
minimal(constant) = (* 1 *) SINGLE_QUOTED
minimal(clause) = (* 3 *) RAW SINGLE_QUOTED DOT
minimal(axiom) = (* 5 *) AXIOM LOWER_WORD IS TRUE DOT
minimal(atomic_word) = (* 1 *) SINGLE_QUOTED
minimal(atomic_system_word) = (* 1 *) DOLLAR_DOLLAR_WORD
minimal(atomic_formula) = (* 1 *) TRUE
minimal(atomic_defined_word) = (* 1 *) DOLLAR_WORD
minimal(arguments) = (* 1 *) SINGLE_QUOTED
follow(variables) = RIGHT_BRACKET
follow(variable) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND
follow(type_const) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA ARROW AND_ALSO AND
follow(theory) = error THEORY RAW LEMMA INCLUDE EOI AXIOM
follow(tff_type) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND
follow(tff_ty_var) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA ARROW AND_ALSO AND
follow(tff_ty_args) = RIGHT_PAREN
follow(tff_atom_type) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA ARROW AND_ALSO AND
follow(term) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND
follow(system_term) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND
follow(system_functor) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND
follow(system_constant) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND
follow(statements) = EOI
follow(statement) = error THEORY RAW LEMMA INCLUDE EOI AXIOM
follow(separated_nonempty_list(COMMA,variable)) = RIGHT_BRACKET
follow(separated_nonempty_list(COMMA,tff_type)) = RIGHT_PAREN
follow(separated_nonempty_list(COMMA,term)) = RIGHT_PAREN
follow(separated_nonempty_list(COMMA,fof_logic_formula)) = RIGHT_BRACKET
follow(separated_nonempty_list(COMMA,datalog_term)) = RIGHT_PAREN
follow(separated_nonempty_list(COMMA,datalog_lit)) = DOT
follow(separated_nonempty_list(COMMA,atomic_word)) = RIGHT_PAREN
follow(separated_nonempty_list(AND_ALSO,premise)) = DOT
follow(premises) = DOT
follow(premise) = DOT AND_ALSO
follow(plain_term) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND
follow(parse_statements) = #
follow(parse_statement) = #
follow(loption(separated_nonempty_list(COMMA,fof_logic_formula))) = RIGHT_BRACKET
follow(lemma) = error THEORY RAW LEMMA INCLUDE EOI AXIOM
follow(include_) = error THEORY RAW LEMMA INCLUDE EOI AXIOM
follow(functor_) = LEFT_PAREN
follow(function_term) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND
follow(fof_unitary_formula) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND
follow(fof_unary_formula) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND
follow(fof_tuple) = RIGHT_PAREN IF GENTZEN_ARROW DOT AND_ALSO
follow(fof_sequent) = RIGHT_PAREN IF DOT AND_ALSO
follow(fof_quantified_formula) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND
follow(fof_logic_formula) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND
follow(fof_formula) = IF DOT AND_ALSO
follow(defined_term) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND
follow(defined_plain_term) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND
follow(defined_functor) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND
follow(defined_constant) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND
follow(defined_atomic_term) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND
follow(defined_atom) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND
follow(datalog_term) = RIGHT_PAREN COMMA
follow(datalog_lit) = IF DOT COMMA
follow(datalog_atom) = IS IF DOT AND_ALSO
follow(constant) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND
follow(clause) = error THEORY RAW LEMMA INCLUDE EOI AXIOM
follow(axiom) = error THEORY RAW LEMMA INCLUDE EOI AXIOM
follow(atomic_word) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND
follow(atomic_system_word) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND
follow(atomic_formula) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY IF EQUIV DOT COMMA AND_ALSO AND
follow(atomic_defined_word) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY IF EQUIV EQUAL DOT COMMA AND_ALSO AND
follow(arguments) = RIGHT_PAREN
Built an LR(0) automaton with 207 states.
The grammar is not SLR(1) -- 11 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 241 states.
64 shift/reduce conflicts were silently solved.
Warning: 2 states have reduce/reduce conflicts.
Warning: 17 reduce/reduce conflicts were arbitrarily resolved.
100 out of 241 states have a default reduction.
67 out of 241 states are represented.
41 out of 104 symbols keep track of their start position.
43 out of 104 symbols keep track of their end position.
68 out of 119 productions exploit shiftreduce optimization.
2 out of 241 states can peek at an error.
664 functions before inlining, 102 functions after inlining.
