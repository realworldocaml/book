%{
module Pervasives = Stdlib
(* In 4.08+dev, 'Pervasives' is deprecated in favor of Stdlib. We need
   to disable the deprecation warning not because of any OCaml code
   below, but because Menhir generates code using Pervasives (in the
   interpretation of $symbolstartpos). Yes, this is ugly, but right now
   we don't see an easier way.  *)

open Asttypes
open Longident
open Parsetree
open Ast_helper
open Docstrings
open Docstrings.WithMenhir

let mkloc = Location.mkloc
let mknoloc = Location.mknoloc

let make_loc (startpos, endpos) = {
  Location.loc_start = startpos;
  Location.loc_end = endpos;
  Location.loc_ghost = false;
}

let ghost_loc (startpos, endpos) = {
  Location.loc_start = startpos;
  Location.loc_end = endpos;
  Location.loc_ghost = true;
}

let mktyp ~loc d = Typ.mk ~loc:(make_loc loc) d
let mkpat ~loc d = Pat.mk ~loc:(make_loc loc) d
let mkexp ~loc d = Exp.mk ~loc:(make_loc loc) d
let mkmty ~loc ?attrs d = Mty.mk ~loc:(make_loc loc) ?attrs d
let mksig ~loc d = Sig.mk ~loc:(make_loc loc) d
let mkmod ~loc ?attrs d = Mod.mk ~loc:(make_loc loc) ?attrs d
let mkstr ~loc d = Str.mk ~loc:(make_loc loc) d
let mkclass ~loc ?attrs d = Cl.mk ~loc:(make_loc loc) ?attrs d
let mkcty ~loc ?attrs d = Cty.mk ~loc:(make_loc loc) ?attrs d

let mkctf ~loc ?attrs ?docs d =
  Ctf.mk ~loc:(make_loc loc) ?attrs ?docs d
let mkcf ~loc ?attrs ?docs d =
  Cf.mk ~loc:(make_loc loc) ?attrs ?docs d

let mkrhs rhs loc = mkloc rhs (make_loc loc)
let ghrhs rhs loc = mkloc rhs (ghost_loc loc)

let reloc_pat ~loc x = { x with ppat_loc = make_loc loc };;
let reloc_exp ~loc x = { x with pexp_loc = make_loc loc };;
let reloc_typ ~loc x = { x with ptyp_loc = make_loc loc };;

let mkoperator ~loc name =
  mkexp ~loc (Pexp_ident(mkrhs (Lident name) loc))

let mkpatvar ~loc name =
  mkpat ~loc (Ppat_var (mkrhs name loc))

(*
  Ghost expressions and patterns:
  expressions and patterns that do not appear explicitly in the
  source file they have the loc_ghost flag set to true.
  Then the profiler will not try to instrument them and the
  -annot option will not try to display their type.

  Every grammar rule that generates an element with a location must
  make at most one non-ghost element, the topmost one.

  How to tell whether your location must be ghost:
  A location corresponds to a range of characters in the source file.
  If the location contains a piece of code that is syntactically
  valid (according to the documentation), and corresponds to the
  AST node, then the location must be real; in all other cases,
  it must be ghost.
*)
let ghexp ~loc d = Exp.mk ~loc:(ghost_loc loc) d
let ghpat ~loc d = Pat.mk ~loc:(ghost_loc loc) d
let ghtyp ~loc d = Typ.mk ~loc:(ghost_loc loc) d
let ghloc ~loc d = { txt = d; loc = ghost_loc loc }
let ghstr ~loc d = Str.mk ~loc:(ghost_loc loc) d
let ghsig ~loc d = Sig.mk ~loc:(ghost_loc loc) d

let mkinfix arg1 op arg2 =
  Pexp_apply(op, [Nolabel, arg1; Nolabel, arg2])

let neg_string f =
  if String.length f > 0 && f.[0] = '-'
  then String.sub f 1 (String.length f - 1)
  else "-" ^ f

let mkuminus ~oploc name arg =
  match name, arg.pexp_desc with
  | "-", Pexp_constant(Pconst_integer (n,m)) ->
      Pexp_constant(Pconst_integer(neg_string n,m))
  | ("-" | "-."), Pexp_constant(Pconst_float (f, m)) ->
      Pexp_constant(Pconst_float(neg_string f, m))
  | _ ->
      Pexp_apply(mkoperator ~loc:oploc ("~" ^ name), [Nolabel, arg])

let mkuplus ~oploc name arg =
  let desc = arg.pexp_desc in
  match name, desc with
  | "+", Pexp_constant(Pconst_integer _)
  | ("+" | "+."), Pexp_constant(Pconst_float _) -> desc
  | _ ->
      Pexp_apply(mkoperator ~loc:oploc ("~" ^ name), [Nolabel, arg])

(* TODO define an abstraction boundary between locations-as-pairs
   and locations-as-Location.t; it should be clear when we move from
   one world to the other *)

let mkexp_cons_desc consloc args =
  Pexp_construct(mkrhs (Lident "::") consloc, Some args)
let mkexp_cons ~loc consloc args =
  mkexp ~loc (mkexp_cons_desc consloc args)

let mkpat_cons_desc consloc args =
  Ppat_construct(mkrhs (Lident "::") consloc, Some args)
let mkpat_cons ~loc consloc args =
  mkpat ~loc (mkpat_cons_desc consloc args)

let ghexp_cons_desc consloc args =
  Pexp_construct(ghrhs (Lident "::") consloc, Some args)
let ghpat_cons_desc consloc args =
  Ppat_construct(ghrhs (Lident "::") consloc, Some args)

let rec mktailexp nilloc = let open Location in function
    [] ->
      let nil = ghloc ~loc:nilloc (Lident "[]") in
      Pexp_construct (nil, None), nilloc
  | e1 :: el ->
      let exp_el, el_loc = mktailexp nilloc el in
      let loc = (e1.pexp_loc.loc_start, snd el_loc) in
      let arg = ghexp ~loc (Pexp_tuple [e1; ghexp ~loc:el_loc exp_el]) in
      ghexp_cons_desc loc arg, loc

let rec mktailpat nilloc = let open Location in function
    [] ->
      let nil = ghloc ~loc:nilloc (Lident "[]") in
      Ppat_construct (nil, None), nilloc
  | p1 :: pl ->
      let pat_pl, el_loc = mktailpat nilloc pl in
      let loc = (p1.ppat_loc.loc_start, snd el_loc) in
      let arg = ghpat ~loc (Ppat_tuple [p1; ghpat ~loc:el_loc pat_pl]) in
      ghpat_cons_desc loc arg, loc

let mkstrexp e attrs =
  { pstr_desc = Pstr_eval (e, attrs); pstr_loc = e.pexp_loc }

let mkexp_constraint ~loc e (t1, t2) =
  match t1, t2 with
  | Some t, None -> ghexp ~loc (Pexp_constraint(e, t))
  | _, Some t -> ghexp ~loc (Pexp_coerce(e, t1, t))
  | None, None -> assert false

let mkexp_opt_constraint ~loc e = function
  | None -> e
  | Some constraint_ -> mkexp_constraint ~loc e constraint_

let mkpat_opt_constraint ~loc p = function
  | None -> p
  | Some typ -> mkpat ~loc (Ppat_constraint(p, typ))

let syntax_error () =
  raise Syntaxerr.Escape_error

let unclosed opening_name opening_loc closing_name closing_loc =
  raise(Syntaxerr.Error(Syntaxerr.Unclosed(make_loc opening_loc, opening_name,
                                           make_loc closing_loc, closing_name)))

let expecting loc nonterm =
    raise Syntaxerr.(Error(Expecting(make_loc loc, nonterm)))

let not_expecting loc nonterm =
    raise Syntaxerr.(Error(Not_expecting(make_loc loc, nonterm)))

let dotop_fun ~loc dotop =
  (* We could use ghexp here, but sticking to mkexp for parser.mly
     compatibility. TODO improve parser.mly *)
  mkexp ~loc (Pexp_ident (ghloc ~loc dotop))

let array_function ~loc str name =
  ghloc ~loc (Ldot(Lident str,
                   (if !Clflags.unsafe then "unsafe_" ^ name else name)))

let array_get_fun ~loc =
  ghexp ~loc (Pexp_ident(array_function ~loc "Array" "get"))
let string_get_fun ~loc =
  ghexp ~loc (Pexp_ident(array_function ~loc "String" "get"))

let array_set_fun ~loc =
  ghexp ~loc (Pexp_ident(array_function ~loc "Array" "set"))
let string_set_fun ~loc =
  ghexp ~loc (Pexp_ident(array_function ~loc "String" "set"))

let index_get ~loc get_fun array index =
  let args = [Nolabel, array; Nolabel, index] in
   mkexp ~loc (Pexp_apply(get_fun, args))

let index_set ~loc set_fun array index value =
  let args = [Nolabel, array; Nolabel, index; Nolabel, value] in
   mkexp ~loc (Pexp_apply(set_fun, args))

let array_get ~loc = index_get ~loc (array_get_fun ~loc)
let string_get ~loc = index_get ~loc (string_get_fun ~loc)
let dotop_get ~loc dotop = index_get ~loc (dotop_fun ~loc dotop)

let array_set ~loc = index_set ~loc (array_set_fun ~loc)
let string_set ~loc = index_set ~loc (string_set_fun ~loc)
let dotop_set ~loc dotop = index_set ~loc (dotop_fun ~loc dotop)

let bigarray_function ~loc str name =
  ghloc ~loc (Ldot(Ldot(Lident "Bigarray", str), name))

let bigarray_untuplify = function
    { pexp_desc = Pexp_tuple explist; pexp_loc = _ } -> explist
  | exp -> [exp]

let bigarray_get ~loc arr arg =
  let mkexp, ghexp = mkexp ~loc, ghexp ~loc in
  let bigarray_function = bigarray_function ~loc in
  let get = if !Clflags.unsafe then "unsafe_get" else "get" in
  match bigarray_untuplify arg with
    [c1] ->
      mkexp(Pexp_apply(ghexp(Pexp_ident(bigarray_function "Array1" get)),
                       [Nolabel, arr; Nolabel, c1]))
  | [c1;c2] ->
      mkexp(Pexp_apply(ghexp(Pexp_ident(bigarray_function "Array2" get)),
                       [Nolabel, arr; Nolabel, c1; Nolabel, c2]))
  | [c1;c2;c3] ->
      mkexp(Pexp_apply(ghexp(Pexp_ident(bigarray_function "Array3" get)),
                       [Nolabel, arr; Nolabel, c1; Nolabel, c2; Nolabel, c3]))
  | coords ->
      mkexp(Pexp_apply(ghexp(Pexp_ident(bigarray_function "Genarray" "get")),
                       [Nolabel, arr; Nolabel, ghexp(Pexp_array coords)]))

let bigarray_set ~loc arr arg newval =
  let mkexp, ghexp = mkexp ~loc, ghexp ~loc in
  let bigarray_function = bigarray_function ~loc in
  let set = if !Clflags.unsafe then "unsafe_set" else "set" in
  match bigarray_untuplify arg with
    [c1] ->
      mkexp(Pexp_apply(ghexp(Pexp_ident(bigarray_function "Array1" set)),
                       [Nolabel, arr; Nolabel, c1; Nolabel, newval]))
  | [c1;c2] ->
      mkexp(Pexp_apply(ghexp(Pexp_ident(bigarray_function "Array2" set)),
                       [Nolabel, arr; Nolabel, c1;
                        Nolabel, c2; Nolabel, newval]))
  | [c1;c2;c3] ->
      mkexp(Pexp_apply(ghexp(Pexp_ident(bigarray_function "Array3" set)),
                       [Nolabel, arr; Nolabel, c1;
                        Nolabel, c2; Nolabel, c3; Nolabel, newval]))
  | coords ->
      mkexp(Pexp_apply(ghexp(Pexp_ident(bigarray_function "Genarray" "set")),
                       [Nolabel, arr;
                        Nolabel, ghexp(Pexp_array coords);
                        Nolabel, newval]))

let lapply ~loc p1 p2 =
  if !Clflags.applicative_functors
  then Lapply(p1, p2)
  else raise (Syntaxerr.Error(
                  Syntaxerr.Applicative_path (make_loc loc)))

let exp_of_longident ~loc lid =
  mkexp ~loc (Pexp_ident {lid with txt = Lident(Longident.last lid.txt)})

let exp_of_label ~loc lbl =
  mkexp ~loc (Pexp_ident lbl)

let pat_of_label ~loc lbl =
  mkpat ~loc (Ppat_var lbl)

let mk_newtypes ~loc newtypes exp =
  let mkexp = mkexp ~loc in
  List.fold_right (fun newtype exp -> mkexp (Pexp_newtype (newtype, exp)))
    newtypes exp

let wrap_type_annotation ~loc newtypes core_type body =
  let mkexp, ghtyp = mkexp ~loc, ghtyp ~loc in
  let mk_newtypes = mk_newtypes ~loc in
  let exp = mkexp(Pexp_constraint(body,core_type)) in
  let exp = mk_newtypes newtypes exp in
  (exp, ghtyp(Ptyp_poly(newtypes, Typ.varify_constructors newtypes core_type)))

let wrap_exp_attrs ~loc body (ext, attrs) =
  let ghexp = ghexp ~loc in
  (* todo: keep exact location for the entire attribute *)
  let body = {body with pexp_attributes = attrs @ body.pexp_attributes} in
  match ext with
  | None -> body
  | Some id -> ghexp(Pexp_extension (id, PStr [mkstrexp body []]))

let mkexp_attrs ~loc d attrs =
  wrap_exp_attrs ~loc (mkexp ~loc d) attrs

let wrap_typ_attrs ~loc typ (ext, attrs) =
  (* todo: keep exact location for the entire attribute *)
  let typ = {typ with ptyp_attributes = attrs @ typ.ptyp_attributes} in
  match ext with
  | None -> typ
  | Some id -> ghtyp ~loc (Ptyp_extension (id, PTyp typ))

let wrap_pat_attrs ~loc pat (ext, attrs) =
  (* todo: keep exact location for the entire attribute *)
  let pat = {pat with ppat_attributes = attrs @ pat.ppat_attributes} in
  match ext with
  | None -> pat
  | Some id -> ghpat ~loc (Ppat_extension (id, PPat (pat, None)))

let mkpat_attrs ~loc d attrs =
  wrap_pat_attrs ~loc (mkpat ~loc d) attrs

let wrap_class_attrs ~loc:_ body attrs =
  {body with pcl_attributes = attrs @ body.pcl_attributes}
let wrap_mod_attrs ~loc:_ body attrs =
  {body with pmod_attributes = attrs @ body.pmod_attributes}
let wrap_mty_attrs ~loc:_ body attrs =
  {body with pmty_attributes = attrs @ body.pmty_attributes}

let wrap_str_ext ~loc body ext =
  match ext with
  | None -> body
  | Some id -> ghstr ~loc (Pstr_extension ((id, PStr [body]), []))

let wrap_sig_ext ~loc body ext =
  match ext with
  | None -> body
  | Some id -> ghsig ~loc (Psig_extension ((id, PSig [body]), []))

let text_str pos = Str.text (rhs_text pos)
let text_sig pos = Sig.text (rhs_text pos)
let text_cstr pos = Cf.text (rhs_text pos)
let text_csig pos = Ctf.text (rhs_text pos)
let text_def pos = [Ptop_def (Str.text (rhs_text pos))]

let extra_text startpos endpos text items =
  match items with
  | [] ->
      let post = rhs_post_text endpos in
      let post_extras = rhs_post_extra_text endpos in
      text post @ text post_extras
  | _ :: _ ->
      let pre_extras = rhs_pre_extra_text startpos in
      let post_extras = rhs_post_extra_text endpos in
        text pre_extras @ items @ text post_extras

let extra_str p1 p2 items = extra_text p1 p2 Str.text items
let extra_sig p1 p2 items = extra_text p1 p2 Sig.text items
let extra_cstr p1 p2 items = extra_text p1 p2 Cf.text items
let extra_csig p1 p2 items = extra_text p1 p2 Ctf.text  items
let extra_def p1 p2 items =
  extra_text p1 p2 (fun txt -> [Ptop_def (Str.text txt)]) items

let extra_rhs_core_type ct ~pos =
  let docs = rhs_info pos in
  { ct with ptyp_attributes = add_info_attrs docs ct.ptyp_attributes }

type let_binding =
  { lb_pattern: pattern;
    lb_expression: expression;
    lb_attributes: attributes;
    lb_docs: docs Lazy.t;
    lb_text: text Lazy.t;
    lb_loc: Location.t; }

type let_bindings =
  { lbs_bindings: let_binding list;
    lbs_rec: rec_flag;
    lbs_extension: string Asttypes.loc option;
    lbs_loc: Location.t }

let mklb first ~loc (p, e) attrs =
  {
    lb_pattern = p;
    lb_expression = e;
    lb_attributes = attrs;
    lb_docs = symbol_docs_lazy loc;
    lb_text = (if first then empty_text_lazy
               else symbol_text_lazy (fst loc));
    lb_loc = make_loc loc;
  }

let mklbs ~loc ext rf lb =
  {
    lbs_bindings = [lb];
    lbs_rec = rf;
    lbs_extension = ext ;
    lbs_loc = make_loc loc;
  }

let addlb lbs lb =
  { lbs with lbs_bindings = lb :: lbs.lbs_bindings }

let val_of_let_bindings ~loc lbs =
  let bindings =
    List.map
      (fun lb ->
         Vb.mk ~loc:lb.lb_loc ~attrs:lb.lb_attributes
           ~docs:(Lazy.force lb.lb_docs)
           ~text:(Lazy.force lb.lb_text)
           lb.lb_pattern lb.lb_expression)
      lbs.lbs_bindings
  in
  let str = mkstr ~loc (Pstr_value(lbs.lbs_rec, List.rev bindings)) in
  match lbs.lbs_extension with
  | None -> str
  | Some id -> ghstr ~loc (Pstr_extension((id, PStr [str]), []))

let expr_of_let_bindings ~loc lbs body =
  let bindings =
    List.map
      (fun lb ->
         Vb.mk ~loc:lb.lb_loc ~attrs:lb.lb_attributes
           lb.lb_pattern lb.lb_expression)
      lbs.lbs_bindings
  in
    mkexp_attrs ~loc (Pexp_let(lbs.lbs_rec, List.rev bindings, body))
      (lbs.lbs_extension, [])

let class_of_let_bindings ~loc lbs body =
  let bindings =
    List.map
      (fun lb ->
         Vb.mk ~loc:lb.lb_loc ~attrs:lb.lb_attributes
           lb.lb_pattern lb.lb_expression)
      lbs.lbs_bindings
  in
    if lbs.lbs_extension <> None then
      raise Syntaxerr.(Error(Not_expecting(lbs.lbs_loc, "extension")));
    mkclass ~loc (Pcl_let (lbs.lbs_rec, List.rev bindings, body))

(* Alternatively, we could keep the generic module type in the Parsetree
   and extract the package type during type-checking. In that case,
   the assertions below should be turned into explicit checks. *)
let package_type_of_module_type pmty =
  let err loc s =
    raise (Syntaxerr.Error (Syntaxerr.Invalid_package_type (loc, s)))
  in
  let map_cstr = function
    | Pwith_type (lid, ptyp) ->
        let loc = ptyp.ptype_loc in
        if ptyp.ptype_params <> [] then
          err loc "parametrized types are not supported";
        if ptyp.ptype_cstrs <> [] then
          err loc "constrained types are not supported";
        if ptyp.ptype_private <> Public then
          err loc "private types are not supported";

        (* restrictions below are checked by the 'with_constraint' rule *)
        assert (ptyp.ptype_kind = Ptype_abstract);
        assert (ptyp.ptype_attributes = []);
        let ty =
          match ptyp.ptype_manifest with
          | Some ty -> ty
          | None -> assert false
        in
        (lid, ty)
    | _ ->
        err pmty.pmty_loc "only 'with type t =' constraints are supported"
  in
  match pmty with
  | {pmty_desc = Pmty_ident lid} -> (lid, [])
  | {pmty_desc = Pmty_with({pmty_desc = Pmty_ident lid}, cstrs)} ->
      (lid, List.map map_cstr cstrs)
  | _ ->
      err pmty.pmty_loc
        "only module type identifier and 'with type' constraints are supported"

let mk_directive_arg ~loc k =
  { pdira_desc = k;
    pdira_loc = make_loc loc;
  }

let mk_directive ~loc name arg =
  Ptop_dir {
      pdir_name = name;
      pdir_arg = arg;
      pdir_loc = make_loc loc;
    }

%}
%start implementation
%start interface
%start parse_core_type
%start parse_expression
%start parse_pattern
%start toplevel_phrase
%start use_file
%token AMPERAMPER
%token AMPERSAND
%token AND
%token AS
%token ASSERT
%token BACKQUOTE
%token BANG
%token BAR
%token BARBAR
%token BARRBRACKET
%token BEGIN
%token <char> CHAR
%token CLASS
%token COLON
%token COLONCOLON
%token COLONEQUAL
%token COLONGREATER
%token COMMA
%token <string * Location.t> COMMENT
%token CONSTRAINT
%token DO
%token <Docstrings.docstring> DOCSTRING
%token DONE
%token DOT
%token DOTDOT
%token <string> DOTOP
%token DOWNTO
%token ELSE
%token END
%token EOF
%token EOL
%token EQUAL
%token EXCEPTION
%token EXTERNAL
%token FALSE
%token <string * char option> FLOAT
%token FOR
%token FUN
%token FUNCTION
%token FUNCTOR
%token GREATER
%token GREATERRBRACE
%token GREATERRBRACKET
%token HASH
%token <string> HASHOP
%token IF
%token IN
%token INCLUDE
%token <string> INFIXOP0
%token <string> INFIXOP1
%token <string> INFIXOP2
%token <string> INFIXOP3
%token <string> INFIXOP4
%token INHERIT
%token INITIALIZER
%token <string * char option> INT
%token <string> LABEL
%token LAZY
%token LBRACE
%token LBRACELESS
%token LBRACKET
%token LBRACKETAT
%token LBRACKETATAT
%token LBRACKETATATAT
%token LBRACKETBAR
%token LBRACKETGREATER
%token LBRACKETLESS
%token LBRACKETPERCENT
%token LBRACKETPERCENTPERCENT
%token LESS
%token LESSMINUS
%token LET
%token <string> LIDENT
%token LPAREN
%token MATCH
%token METHOD
%token MINUS
%token MINUSDOT
%token MINUSGREATER
%token MODULE
%token MUTABLE
%token NEW
%token NONREC
%token OBJECT
%token OF
%token OPEN
%token <string> OPTLABEL
%token OR
%token PERCENT
%token PLUS
%token PLUSDOT
%token PLUSEQ
%token <string> PREFIXOP
%token PRIVATE
%token QUESTION
%token QUOTE
%token RBRACE
%token RBRACKET
%token REC
%token RPAREN
%token SEMI
%token SEMISEMI
%token SIG
%token STAR
%token <string * string option> STRING
%token STRUCT
%token THEN
%token TILDE
%token TO
%token TRUE
%token TRY
%token TYPE
%token <string> UIDENT
%token UNDERSCORE
%token VAL
%token VIRTUAL
%token WHEN
%token WHILE
%token WITH
%nonassoc IN
%nonassoc below_SEMI
%nonassoc SEMI
%nonassoc LET
%nonassoc below_WITH
%nonassoc FUNCTION WITH
%nonassoc AND
%nonassoc THEN
%nonassoc ELSE
%nonassoc LESSMINUS
%right COLONEQUAL
%nonassoc AS
%left BAR
%nonassoc below_COMMA
%left COMMA
%right MINUSGREATER
%right BARBAR OR
%right AMPERAMPER AMPERSAND
%nonassoc below_EQUAL
%left EQUAL GREATER INFIXOP0 LESS
%right INFIXOP1
%nonassoc below_LBRACKETAT
%nonassoc LBRACKETAT
%right COLONCOLON
%left INFIXOP2 MINUS MINUSDOT PLUS PLUSDOT PLUSEQ
%left INFIXOP3 PERCENT STAR
%right INFIXOP4
%nonassoc prec_unary_minus prec_unary_plus
%nonassoc prec_constant_constructor
%nonassoc prec_constr_appl
%nonassoc below_HASH
%nonassoc HASH
%left HASHOP
%nonassoc below_DOT
%nonassoc DOT DOTOP
%nonassoc BACKQUOTE BANG BEGIN CHAR FALSE FLOAT INT LBRACE LBRACELESS LBRACKET LBRACKETBAR LBRACKETPERCENT LIDENT LPAREN NEW PREFIXOP STRING TRUE UIDENT
%type <Parsetree.structure> implementation
%type <Parsetree.signature> interface
%type <Parsetree.core_type> parse_core_type
%type <Parsetree.expression> parse_expression
%type <Parsetree.pattern> parse_pattern
%type <Parsetree.toplevel_phrase> toplevel_phrase
%type <Parsetree.toplevel_phrase list> use_file
%%

reversed_separated_nonempty_list_COMMA_core_type_:
  x = core_type
    {let xs =     ( [ x ] ) in
    ( xs )}
| xs = reversed_separated_nonempty_list_COMMA_core_type_ _2 = COMMA x = core_type
    {let xs =     ( x :: xs ) in
    ( xs )}

implementation:
  _1 = structure _2 = EOF
    {                                         ( _1 )}

interface:
  _1 = signature _2 = EOF
    {                                         ( _1 )}

toplevel_phrase:
  _1 = top_structure _2 = SEMISEMI
    {                                         ( Ptop_def (_1) )}
| _1 = toplevel_directive _2 = SEMISEMI
    {                                         ( _1 )}
| _1 = EOF
    {                                         ( raise End_of_file )}

top_structure:
  _1 = top_structure_nodoc
    {let _1 =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                                ( extra_str _startpos _endpos _1 )
in
                                              ( _1 )}

top_structure_nodoc:
  _1 = seq_expr _2 = post_item_attributes
    {      ( text_str _startpos__1_ @ [mkstrexp _1 _2] )}
| _1 = top_structure_tail_nodoc
    {      ( _1 )}

top_structure_tail_nodoc:
  
    {      ( [] )}
| _1 = structure_item _2 = top_structure_tail_nodoc
    {      ( text_str _startpos__1_ @ _1 :: _2 )}

use_file:
  _1 = use_file_body _2 = EOF
    {let _1 =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                                ( extra_def _startpos _endpos _1 )
in
                                         ( _1 )}

use_file_body:
  _1 = use_file_tail
    {                                         ( _1 )}
| _1 = seq_expr _2 = post_item_attributes _3 = use_file_tail
    {      ( text_def _startpos__1_ @ Ptop_def[mkstrexp _1 _2] :: _3 )}

use_file_tail:
  
    {      ( [] )}
| _1 = SEMISEMI _2 = use_file_body
    {      ( _2 )}
| _1 = structure_item _2 = use_file_tail
    {      ( text_def _startpos__1_ @ Ptop_def[_1] :: _2 )}
| _1 = toplevel_directive _2 = use_file_tail
    {      ( mark_rhs_docs _startpos__1_ _endpos__1_;
        text_def _startpos__1_ @ _1 :: _2 )}

parse_core_type:
  _1 = core_type _2 = EOF
    {                  ( _1 )}

parse_expression:
  _1 = seq_expr _2 = EOF
    {                 ( _1 )}

parse_pattern:
  _1 = pattern _2 = EOF
    {                ( _1 )}

functor_arg:
  _1 = LPAREN _2 = RPAREN
    {let _1 =
  let _1 =                         ("*") in
  let _endpos__1_ = _endpos__2_ in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
      ( _1, None )}
| _1 = LPAREN _1_inlined1 = functor_arg_name _3 = COLON _4 = module_type _5 = RPAREN
    {let _2 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
      ( _2, Some _4 )}

functor_arg_name:
  _1 = UIDENT
    {               ( _1 )}
| _1 = UNDERSCORE
    {               ( "_" )}

functor_args:
  _1 = functor_args _2 = functor_arg
    {      ( _2 :: _1 )}
| _1 = functor_arg
    {      ( [ _1 ] )}

module_expr:
  _1 = STRUCT _2 = attributes _3 = structure _4 = END
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( mkmod ~loc:_sloc ~attrs:_2 (Pmod_structure(_3)) )}
| _1 = STRUCT _2 = attributes _3 = structure _4 = error
    {let _loc__4_ = (_startpos__4_, _endpos__4_) in
let _loc__1_ = (_startpos__1_, _endpos__1_) in
      ( unclosed "struct" _loc__1_ "end" _loc__4_ )}
| _1 = FUNCTOR _2 = attributes _3 = functor_args _4 = MINUSGREATER _5 = module_expr
    {let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let modexp =
          List.fold_left
            (fun acc (n, t) -> mkmod ~loc:_sloc (Pmod_functor(n, t, acc)))
            _5 _3
        in wrap_mod_attrs ~loc:_sloc modexp _2 )}
| _1 = paren_module_expr
    {      ( _1 )}
| _1 = module_expr _2 = attribute
    {      ( Mod.attr _1 _2 )}
| _1 = mod_longident
    {let _1 =
  let _1 =
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
          (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
    in
        ( Pmod_ident _1 )
  in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkmod ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = module_expr _2 = paren_module_expr
    {let _1 =
  let _1 =     ( Pmod_apply(_1, _2) ) in
  let _endpos__1_ = _endpos__2_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkmod ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = module_expr _2 = LPAREN _3 = RPAREN
    {let _1 =
  let _1 =
    let _endpos = _endpos__3_ in
    let _symbolstartpos = _startpos__1_ in
    let _sloc = (_symbolstartpos, _endpos) in
        ( (* TODO review mkmod location *)
      Pmod_apply(_1, mkmod ~loc:_sloc (Pmod_structure [])) )
  in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkmod ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = extension
    {let _1 =
  let _1 =     ( Pmod_extension _1 ) in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkmod ~loc:_sloc _1 )
in
      ( _1 )}

paren_module_expr:
  _1 = LPAREN _2 = module_expr _3 = COLON _4 = module_type _5 = RPAREN
    {let _1 =
  let _1 =       ( Pmod_constraint(_2, _4) ) in
  let _endpos__1_ = _endpos__5_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkmod ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = LPAREN _2 = module_expr _3 = COLON _4 = module_type _5 = error
    {let _loc__5_ = (_startpos__5_, _endpos__5_) in
let _loc__1_ = (_startpos__1_, _endpos__1_) in
      ( unclosed "(" _loc__1_ ")" _loc__5_ )}
| _1 = LPAREN _2 = module_expr _3 = RPAREN
    {      ( _2 (* TODO consider reloc *) )}
| _1 = LPAREN _2 = module_expr _3 = error
    {let _loc__3_ = (_startpos__3_, _endpos__3_) in
let _loc__1_ = (_startpos__1_, _endpos__1_) in
      ( unclosed "(" _loc__1_ ")" _loc__3_ )}
| _1 = LPAREN _2 = VAL _3 = attributes _4 = expr _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( mkmod ~loc:_sloc ~attrs:_3 (Pmod_unpack _4))}
| _1 = LPAREN _2 = VAL _3 = attributes _4 = expr _5 = COLON _6 = package_type _7 = RPAREN
    {let _endpos = _endpos__7_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let constr_loc = (_startpos__4_, _endpos__6_) in
        mkmod ~loc:_sloc ~attrs:_3
          (Pmod_unpack(
               ghexp ~loc:constr_loc (Pexp_constraint(_4, _6)))) )}
| _1 = LPAREN _2 = VAL _3 = attributes _4 = expr _5 = COLON _6 = package_type _7 = COLONGREATER _8 = package_type _9 = RPAREN
    {let _endpos = _endpos__9_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let constr_loc = (_startpos__4_, _endpos__8_) in
        mkmod ~loc:_sloc ~attrs:_3
          (Pmod_unpack(
               ghexp ~loc:constr_loc (Pexp_coerce(_4, Some _6, _8)))) )}
| _1 = LPAREN _2 = VAL _3 = attributes _4 = expr _5 = COLONGREATER _6 = package_type _7 = RPAREN
    {let _endpos = _endpos__7_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let constr_loc = (_startpos__4_, _endpos__6_) in
        mkmod ~loc:_sloc ~attrs:_3
          (Pmod_unpack(
               ghexp ~loc:constr_loc (Pexp_coerce(_4, None, _6)))) )}
| _1 = LPAREN _2 = VAL _3 = attributes _4 = expr _5 = COLON _6 = error
    {let _loc__6_ = (_startpos__6_, _endpos__6_) in
let _loc__1_ = (_startpos__1_, _endpos__1_) in
      ( unclosed "(" _loc__1_ ")" _loc__6_ )}
| _1 = LPAREN _2 = VAL _3 = attributes _4 = expr _5 = COLONGREATER _6 = error
    {let _loc__6_ = (_startpos__6_, _endpos__6_) in
let _loc__1_ = (_startpos__1_, _endpos__1_) in
      ( unclosed "(" _loc__1_ ")" _loc__6_ )}
| _1 = LPAREN _2 = VAL _3 = attributes _4 = expr _5 = error
    {let _loc__5_ = (_startpos__5_, _endpos__5_) in
let _loc__1_ = (_startpos__1_, _endpos__1_) in
      ( unclosed "(" _loc__1_ ")" _loc__5_ )}

structure:
  _1 = structure_nodoc
    {let _1 =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                                ( extra_str _startpos _endpos _1 )
in
                                      ( _1 )}

structure_nodoc:
  _1 = seq_expr _2 = post_item_attributes _3 = structure_tail_nodoc
    {      ( mark_rhs_docs _startpos__1_ _endpos__2_;
        text_str _startpos__1_ @ mkstrexp _1 _2 :: _3 )}
| _1 = structure_tail_nodoc
    {                         ( _1 )}

structure_tail_nodoc:
  
    {                                        ( [] )}
| _1 = SEMISEMI _2 = structure_nodoc
    {                                        ( text_str _startpos__1_ @ _2 )}
| _1 = structure_item _2 = structure_tail_nodoc
    {                                        ( text_str _startpos__1_ @ _1 :: _2 )}

structure_item:
  _1 = let_bindings
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( val_of_let_bindings ~loc:_sloc _1 )}
| _1 = structure_item_with_ext
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
      ( let item, ext = _1 in
        wrap_str_ext ~loc:_loc (mkstr ~loc:_loc item) ext )}
| _1 = item_extension _2 = post_item_attributes
    {let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let docs = symbol_docs _sloc in
        mkstr ~loc:_sloc (Pstr_extension (_1, (add_docs_attrs docs _2))) )}
| _1 = floating_attribute
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( mkstr ~loc:_sloc (Pstr_attribute _1) )}

structure_item_with_ext:
  _1 = primitive_declaration
    {      ( let (body, ext) = _1 in (Pstr_primitive body, ext) )}
| _1 = value_description
    {      ( let (body, ext) = _1 in (Pstr_primitive body, ext) )}
| _1 = type_declarations
    {      ( let (nr, l, ext ) = _1 in (Pstr_type (nr, List.rev l), ext) )}
| _1 = str_type_extension
    {      ( let (l, ext) = _1 in (Pstr_typext l, ext) )}
| _1 = str_exception_declaration
    {      ( let (l, ext) = _1 in (Pstr_exception l, ext) )}
| _1 = module_binding
    {      ( let (body, ext) = _1 in (Pstr_module body, ext) )}
| _1 = rec_module_bindings
    {      ( let (l, ext) = _1 in (Pstr_recmodule (List.rev l), ext) )}
| _1 = module_type_declaration
    {      ( let (body, ext) = _1 in (Pstr_modtype body, ext) )}
| _1 = open_statement
    {      ( let (body, ext) = _1 in (Pstr_open body, ext) )}
| _1 = class_declarations
    {      ( let (l, ext) = _1 in (Pstr_class (List.rev l), ext) )}
| _1 = class_type_declarations
    {      ( let (l, ext) = _1 in (Pstr_class_type (List.rev l), ext) )}
| _1 = str_include_statement
    {      ( let (body, ext) = _1 in (Pstr_include body, ext) )}

str_include_statement:
  _1 = INCLUDE _2 = ext_attributes _3 = module_expr _4 = post_item_attributes
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let (ext, attrs) = _2 in
        let docs = symbol_docs _sloc in
        Incl.mk _3 ~attrs:(attrs@_4) ~loc:(make_loc _sloc) ~docs, ext )}

module_binding_body:
  _1 = EQUAL _2 = module_expr
    {      ( _2 )}
| _1 = COLON _2 = module_type _3 = EQUAL _4 = module_expr
    {let _1 =
  let _1 =         ( Pmod_constraint(_4, _2) ) in
  let _endpos__1_ = _endpos__4_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkmod ~loc:_sloc _1 )
in
    ( _1 )}
| _1 = functor_arg _2 = module_binding_body
    {let _1 =
  let _1 =         ( Pmod_functor(fst _1, snd _1, _2) ) in
  let _endpos__1_ = _endpos__2_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkmod ~loc:_sloc _1 )
in
    ( _1 )}

module_binding:
  _1 = MODULE _2 = ext_attributes _1_inlined1 = UIDENT _4 = module_binding_body _5 = post_item_attributes
    {let _3 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let (ext, attrs) = _2 in
        let docs = symbol_docs _sloc in
        Mb.mk _3 _4 ~attrs:(attrs@_5) ~loc:(make_loc _sloc) ~docs, ext )}

rec_module_bindings:
  _1 = rec_module_binding
    {      ( let (b, ext) = _1 in ([b], ext) )}
| _1 = rec_module_bindings _2 = and_module_binding
    {      ( let (l, ext) = _1 in (_2 :: l, ext) )}

rec_module_binding:
  _1 = MODULE _2 = ext_attributes _3 = REC _1_inlined1 = UIDENT _5 = module_binding_body _6 = post_item_attributes
    {let _4 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__6_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let (ext, attrs) = _2 in
        let docs = symbol_docs _sloc in
        Mb.mk _4 _5 ~attrs:(attrs@_6) ~loc:(make_loc _sloc) ~docs, ext )}

and_module_binding:
  _1 = AND _2 = attributes _1_inlined1 = UIDENT _4 = module_binding_body _5 = post_item_attributes
    {let _3 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let docs = symbol_docs _sloc in
        let text = symbol_text _symbolstartpos in
        Mb.mk _3 _4 ~attrs:(_2@_5) ~loc:(make_loc _sloc) ~text ~docs )}

module_type:
  _1 = SIG _2 = attributes _3 = signature _4 = END
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( mkmty ~loc:_sloc ~attrs:_2 (Pmty_signature (_3)) )}
| _1 = SIG _2 = attributes _3 = signature _4 = error
    {let _loc__4_ = (_startpos__4_, _endpos__4_) in
let _loc__1_ = (_startpos__1_, _endpos__1_) in
      ( unclosed "sig" _loc__1_ "end" _loc__4_ )}
| _1 = FUNCTOR _2 = attributes _3 = functor_args _4 = MINUSGREATER _5 = module_type %prec below_WITH
    {let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let mty =
          List.fold_left
            (fun acc (n, t) -> mkmty ~loc:_sloc (Pmty_functor(n, t, acc)))
            _5 _3
        in wrap_mty_attrs ~loc:_sloc mty _2 )}
| _1 = MODULE _2 = TYPE _3 = OF _4 = attributes _5 = module_expr %prec below_LBRACKETAT
    {let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( mkmty ~loc:_sloc ~attrs:_4 (Pmty_typeof _5) )}
| _1 = LPAREN _2 = module_type _3 = RPAREN
    {      ( _2 )}
| _1 = LPAREN _2 = module_type _3 = error
    {let _loc__3_ = (_startpos__3_, _endpos__3_) in
let _loc__1_ = (_startpos__1_, _endpos__1_) in
      ( unclosed "(" _loc__1_ ")" _loc__3_ )}
| _1 = module_type _2 = attribute
    {      ( Mty.attr _1 _2 )}
| _1 = mty_longident
    {let _1 =
  let _1 =
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
          (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
    in
          ( Pmty_ident _1 )
  in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkmty ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = module_type _2 = MINUSGREATER _3 = module_type %prec below_WITH
    {let _1 =
  let _1 =       ( Pmty_functor(mknoloc "_", Some _1, _3) ) in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkmty ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = module_type _2 = WITH _3 = with_constraints
    {let _1 =
  let _1 =       ( Pmty_with(_1, List.rev _3) ) in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkmty ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = extension
    {let _1 =
  let _1 =       ( Pmty_extension _1 ) in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkmty ~loc:_sloc _1 )
in
      ( _1 )}

signature:
  _1 = signature_nodoc
    {let _1 =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                                ( extra_sig _startpos _endpos _1 )
in
                                      ( _1 )}

signature_nodoc:
  
    {                                   ( [] )}
| _1 = SEMISEMI _2 = signature_nodoc
    {                                   ( text_sig _startpos__1_ @ _2 )}
| _1 = signature_item _2 = signature_nodoc
    {                                   ( text_sig _startpos__1_ @ _1 :: _2 )}

signature_item:
  _1 = signature_item_with_ext
    {let _endpos = _endpos__1_ in
let _startpos = _startpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _loc = (_startpos, _endpos) in
let _sloc = (_symbolstartpos, _endpos) in
      ( let item, ext = _1 in
        wrap_sig_ext ~loc:_loc (mksig ~loc:_sloc item) ext )}
| _1 = item_extension _2 = post_item_attributes
    {let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let docs = symbol_docs _sloc in
        mksig ~loc:_sloc (Psig_extension (_1, (add_docs_attrs docs _2))) )}
| _1 = floating_attribute
    {let _1 =
  let _1 =       ( Psig_attribute _1 ) in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mksig ~loc:_sloc _1 )
in
      ( _1 )}

signature_item_with_ext:
  _1 = value_description
    {      ( let (body, ext) = _1 in (Psig_value body, ext) )}
| _1 = primitive_declaration
    {      ( let (body, ext) = _1 in (Psig_value body, ext) )}
| _1 = type_declarations
    {      ( let (nr, l, ext) = _1 in (Psig_type (nr, List.rev l), ext) )}
| _1 = sig_type_extension
    {      ( let (l, ext) = _1 in (Psig_typext l, ext) )}
| _1 = sig_exception_declaration
    {      ( let (l, ext) = _1 in (Psig_exception l, ext) )}
| _1 = module_declaration
    {      ( let (body, ext) = _1 in (Psig_module body, ext) )}
| _1 = module_alias
    {      ( let (body, ext) = _1 in (Psig_module body, ext) )}
| _1 = rec_module_declarations
    {      ( let (l, ext) = _1 in (Psig_recmodule (List.rev l), ext) )}
| _1 = module_type_declaration
    {      ( let (body, ext) = _1 in (Psig_modtype body, ext) )}
| _1 = open_statement
    {      ( let (body, ext) = _1 in (Psig_open body, ext) )}
| _1 = sig_include_statement
    {      ( let (body, ext) = _1 in (Psig_include body, ext) )}
| _1 = class_descriptions
    {      ( let (l, ext) = _1 in (Psig_class (List.rev l), ext) )}
| _1 = class_type_declarations
    {      ( let (l, ext) = _1 in (Psig_class_type (List.rev l), ext) )}

open_statement:
  _1 = OPEN _2 = override_flag _3 = ext_attributes _1_inlined1 = mod_longident _5 = post_item_attributes
    {let _4 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let (ext, attrs) = _3 in
        let docs = symbol_docs _sloc in
        Opn.mk _4 ~override:_2 ~attrs:(attrs@_5) ~loc:(make_loc _sloc) ~docs
        , ext )}

sig_include_statement:
  _1 = INCLUDE _2 = ext_attributes _3 = module_type _4 = post_item_attributes
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let (ext, attrs) = _2 in
        let docs = symbol_docs _sloc in
        Incl.mk _3 ~attrs:(attrs@_4) ~loc:(make_loc _sloc) ~docs, ext )}

module_declaration_body:
  _1 = COLON _2 = module_type
    {      ( _2 )}
| _1 = functor_arg _2 = module_declaration_body
    {let _1 =
  let _1 =       ( let (name,typ) = _1 in
        Pmty_functor(name, typ, _2) ) in
  let _endpos__1_ = _endpos__2_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkmty ~loc:_sloc _1 )
in
      ( _1 )}

module_declaration:
  _1 = MODULE _2 = ext_attributes _1_inlined1 = UIDENT _4 = module_declaration_body _5 = post_item_attributes
    {let _3 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let (ext, attrs) = _2 in
        let docs = symbol_docs _sloc in
        Md.mk _3 _4 ~attrs:(attrs@_5) ~loc:(make_loc _sloc) ~docs, ext )}

module_alias:
  _1 = MODULE _2 = ext_attributes _1_inlined1 = UIDENT _4 = EQUAL _1_inlined2 = mod_longident _6 = post_item_attributes
    {let _5 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined2_, _startpos__1_inlined2_, _1_inlined2) in
  let _1 =
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
    let _loc = (_startpos, _endpos) in
        (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
  in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
    ( Mty.alias ~loc:(make_loc _sloc) _1 )
in
let _3 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__6_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let (ext, attrs) = _2 in
        let docs = symbol_docs _sloc in
        Md.mk _3 _5 ~attrs:(attrs@_6) ~loc:(make_loc _sloc) ~docs, ext )}

rec_module_declarations:
  _1 = rec_module_declaration
    {      ( let (body, ext) = _1 in ([body], ext) )}
| _1 = rec_module_declarations _2 = and_module_declaration
    {      ( let (l, ext) = _1 in (_2 :: l, ext) )}

rec_module_declaration:
  _1 = MODULE _2 = ext_attributes _3 = REC _1_inlined1 = UIDENT _5 = COLON _6 = module_type _7 = post_item_attributes
    {let _4 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__7_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let (ext, attrs) = _2 in
        let docs = symbol_docs _sloc in
        Md.mk _4 _6 ~attrs:(attrs@_7) ~loc:(make_loc _sloc) ~docs, ext )}

and_module_declaration:
  _1 = AND _2 = attributes _1_inlined1 = UIDENT _4 = COLON _5 = module_type _6 = post_item_attributes
    {let _3 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__6_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let docs = symbol_docs _sloc in
        let text = symbol_text _symbolstartpos in
        Md.mk _3 _5 ~attrs:(_2@_6) ~loc:(make_loc _sloc) ~text ~docs )}

module_type_declaration_body:
  
    {                              ( None )}
| _1 = EQUAL _2 = module_type
    {                              ( Some _2 )}

module_type_declaration:
  _1 = MODULE _2 = TYPE _3 = ext_attributes _1_inlined1 = ident _5 = module_type_declaration_body _6 = post_item_attributes
    {let _4 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__6_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let (ext, attrs) = _3 in
        let docs = symbol_docs _sloc in
        Mtd.mk _4 ?typ:_5 ~attrs:(attrs@_6) ~loc:(make_loc _sloc) ~docs, ext )}

class_declarations:
  _1 = class_declaration
    {      ( let (body, ext) = _1 in ([body], ext) )}
| _1 = class_declarations _2 = and_class_declaration
    {      ( let (l, ext) = _1 in (_2 :: l, ext) )}

class_declaration:
  _1 = CLASS _2 = ext_attributes _3 = virtual_flag _4 = class_type_parameters _1_inlined1 = LIDENT _6 = class_fun_binding _7 = post_item_attributes
    {let _5 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__7_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let (ext, attrs) = _2 in
        let docs = symbol_docs _sloc in
        Ci.mk _5 _6 ~virt:_3 ~params:_4
                    ~attrs:(attrs@_7) ~loc:(make_loc _sloc) ~docs
        , ext )}

and_class_declaration:
  _1 = AND _2 = attributes _3 = virtual_flag _4 = class_type_parameters _1_inlined1 = LIDENT _6 = class_fun_binding _7 = post_item_attributes
    {let _5 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__7_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let docs = symbol_docs _sloc in
        let text = symbol_text _symbolstartpos in
        Ci.mk _5 _6 ~virt:_3 ~params:_4
                    ~attrs:(_2@_7) ~loc:(make_loc _sloc) ~text ~docs )}

class_fun_binding:
  _1 = EQUAL _2 = class_expr
    {      ( _2 )}
| _1 = COLON _2 = class_type _3 = EQUAL _4 = class_expr
    {let _1 =
  let _1 =         ( Pcl_constraint(_4, _2) ) in
  let _endpos__1_ = _endpos__4_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkclass ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = labeled_simple_pattern _2 = class_fun_binding
    {let _1 =
  let _1 =       ( let (l,o,p) = _1 in Pcl_fun(l, o, p, _2) ) in
  let _endpos__1_ = _endpos__2_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkclass ~loc:_sloc _1 )
in
      ( _1 )}

class_type_parameters:
  
    {                                                ( [] )}
| _1 = LBRACKET _2 = type_parameter_list _3 = RBRACKET
    {                                                ( List.rev _2 )}

class_fun_def:
  _1 = class_fun_def_desc
    {let _1 =
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkclass ~loc:_sloc _1 )
in
                                           ( _1 )}

class_fun_def_desc:
  _1 = labeled_simple_pattern _2 = MINUSGREATER _3 = class_expr
    {      ( let (l,o,p) = _1 in Pcl_fun(l, o, p, _3) )}
| _1 = labeled_simple_pattern _2 = class_fun_def
    {      ( let (l,o,p) = _1 in Pcl_fun(l, o, p, _2) )}

class_expr:
  _1 = class_simple_expr
    {      ( _1 )}
| _1 = FUN _2 = attributes _3 = class_fun_def
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( wrap_class_attrs ~loc:_sloc _3 _2 )}
| _1 = let_bindings _2 = IN _3 = class_expr
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( class_of_let_bindings ~loc:_sloc _1 _3 )}
| _1 = LET _2 = OPEN _3 = override_flag _4 = attributes _1_inlined1 = mod_longident _6 = IN _7 = class_expr
    {let _5 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__7_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( mkclass ~loc:_sloc ~attrs:_4 (Pcl_open(_3, _5, _7)) )}
| _1 = class_expr _2 = attribute
    {      ( Cl.attr _1 _2 )}
| _1 = class_simple_expr _2 = simple_labeled_expr_list
    {let _1 =
  let _1 =         ( Pcl_apply(_1, List.rev _2) ) in
  let _endpos__1_ = _endpos__2_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkclass ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = extension
    {let _1 =
  let _1 =         ( Pcl_extension _1 ) in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkclass ~loc:_sloc _1 )
in
      ( _1 )}

class_simple_expr:
  _1 = LPAREN _2 = class_expr _3 = RPAREN
    {      ( _2 )}
| _1 = LPAREN _2 = class_expr _3 = error
    {let _loc__3_ = (_startpos__3_, _endpos__3_) in
let _loc__1_ = (_startpos__1_, _endpos__1_) in
      ( unclosed "(" _loc__1_ ")" _loc__3_ )}
| _1 = LBRACKET tys = reversed_separated_nonempty_list_COMMA_core_type_ _3 = RBRACKET _1_inlined1 = class_longident
    {let _1 =
  let _1 =
    let _4 =
      let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
          (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
    in
    let _2 =     ( tys ) in
            ( Pcl_constr(_4, List.rev _2) )
  in
  let _endpos__1_ = _endpos__1_inlined1_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkclass ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = class_longident
    {let _1 =
  let _1 =
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
          (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
    in
            ( Pcl_constr(_1, []) )
  in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkclass ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = OBJECT _2 = attributes _3 = class_structure _4 = error
    {let _1 =
  let _1 =
    let _loc__4_ = (_startpos__4_, _endpos__4_) in
    let _loc__1_ = (_startpos__1_, _endpos__1_) in
            ( unclosed "object" _loc__1_ "end" _loc__4_ )
  in
  let _endpos__1_ = _endpos__4_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkclass ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = LPAREN _2 = class_expr _3 = COLON _4 = class_type _5 = RPAREN
    {let _1 =
  let _1 =         ( Pcl_constraint(_2, _4) ) in
  let _endpos__1_ = _endpos__5_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkclass ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = LPAREN _2 = class_expr _3 = COLON _4 = class_type _5 = error
    {let _1 =
  let _1 =
    let _loc__5_ = (_startpos__5_, _endpos__5_) in
    let _loc__1_ = (_startpos__1_, _endpos__1_) in
            ( unclosed "(" _loc__1_ ")" _loc__5_ )
  in
  let _endpos__1_ = _endpos__5_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkclass ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = OBJECT _2 = attributes _3 = class_structure _4 = END
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( mkclass ~loc:_sloc ~attrs:_2 (Pcl_structure _3) )}

class_structure:
  _1 = class_self_pattern _1_inlined1 = class_fields
    {let _2 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                                 ( extra_cstr _startpos _endpos _1 )
in
       ( Cstr.mk _1 (List.rev _2) )}

class_self_pattern:
  _1 = LPAREN _2 = pattern _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( reloc_pat ~loc:_sloc _2 )}
| _1 = LPAREN _2 = pattern _3 = COLON _4 = core_type _5 = RPAREN
    {let _1 =
  let _1 =       ( Ppat_constraint(_2, _4) ) in
  let _endpos__1_ = _endpos__5_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}
| 
    {let _endpos = _endpos__0_ in
let _symbolstartpos = _endpos in
let _sloc = (_symbolstartpos, _endpos) in
      ( ghpat ~loc:_sloc Ppat_any )}

class_fields:
  
    {      ( [] )}
| _1 = class_fields _2 = class_field
    {      ( _2 :: List.rev (text_cstr _startpos__2_) @ _1 )}

class_field:
  _1 = INHERIT _2 = override_flag _3 = attributes _4 = class_expr _5 = parent_binder _6 = post_item_attributes
    {let _endpos = _endpos__6_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let docs = symbol_docs _sloc in
        mkcf ~loc:_sloc (Pcf_inherit (_2, _4, _5)) ~attrs:(_3@_6) ~docs )}
| _1 = VAL _2 = value _3 = post_item_attributes
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let v, attrs = _2 in
        let docs = symbol_docs _sloc in
        mkcf ~loc:_sloc (Pcf_val v) ~attrs:(attrs@_3) ~docs )}
| _1 = METHOD _2 = method_ _3 = post_item_attributes
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let meth, attrs = _2 in
        let docs = symbol_docs _sloc in
        mkcf ~loc:_sloc (Pcf_method meth) ~attrs:(attrs@_3) ~docs )}
| _1 = CONSTRAINT _2 = attributes _3 = constrain_field _4 = post_item_attributes
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let docs = symbol_docs _sloc in
        mkcf ~loc:_sloc (Pcf_constraint _3) ~attrs:(_2@_4) ~docs )}
| _1 = INITIALIZER _2 = attributes _3 = seq_expr _4 = post_item_attributes
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let docs = symbol_docs _sloc in
        mkcf ~loc:_sloc (Pcf_initializer _3) ~attrs:(_2@_4) ~docs )}
| _1 = item_extension _2 = post_item_attributes
    {let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let docs = symbol_docs _sloc in
        mkcf ~loc:_sloc (Pcf_extension _1) ~attrs:_2 ~docs )}
| _1 = floating_attribute
    {let _1 =
  let _1 =       ( Pcf_attribute _1 ) in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkcf ~loc:_sloc _1 )
in
      ( _1 )}

parent_binder:
  _1 = AS _1_inlined1 = LIDENT
    {let _2 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
          ( Some _2 )}
| 
    {          ( None )}

value:
  _1 = override_flag _2 = attributes _3 = MUTABLE _4 = VIRTUAL _1_inlined1 = label _6 = COLON _7 = core_type
    {let _5 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
      ( if _1 = Override then syntax_error ();
        (_5, Mutable, Cfk_virtual _7), _2 )}
| _1 = override_flag _2 = attributes _3 = VIRTUAL _4 = mutable_flag _1_inlined1 = label _6 = COLON _7 = core_type
    {let _5 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
      ( if _1 = Override then syntax_error ();
        (_5, _4, Cfk_virtual _7), _2 )}
| _1 = override_flag _2 = attributes _3 = mutable_flag _1_inlined1 = label _5 = EQUAL _6 = seq_expr
    {let _4 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
      ( (_4, _3, Cfk_concrete (_1, _6)), _2 )}
| _1 = override_flag _2 = attributes _3 = mutable_flag _1_inlined1 = label _5 = type_constraint _6 = EQUAL _7 = seq_expr
    {let _4 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _startpos__4_ = _startpos__1_inlined1_ in
let _endpos = _endpos__7_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  if _startpos__2_ != _endpos__2_ then
    _startpos__2_
  else
    if _startpos__3_ != _endpos__3_ then
      _startpos__3_
    else
      _startpos__4_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let e = mkexp_constraint ~loc:_sloc _7 _5 in
        (_4, _3, Cfk_concrete (_1, e)), _2
      )}

method_:
  _1 = override_flag _2 = attributes _3 = PRIVATE _4 = VIRTUAL _1_inlined1 = label _6 = COLON _7 = poly_type
    {let _5 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
      ( if _1 = Override then syntax_error ();
        (_5, Private, Cfk_virtual _7), _2 )}
| _1 = override_flag _2 = attributes _3 = VIRTUAL _4 = private_flag _1_inlined1 = label _6 = COLON _7 = poly_type
    {let _5 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
      ( if _1 = Override then syntax_error ();
        (_5, _4, Cfk_virtual _7), _2 )}
| _1 = override_flag _2 = attributes _3 = private_flag _1_inlined1 = label _5 = strict_binding
    {let _4 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
      ( let e = _5 in
        let loc = Location.(e.pexp_loc.loc_start, e.pexp_loc.loc_end) in
        (_4, _3,
        Cfk_concrete (_1, ghexp ~loc (Pexp_poly (e, None)))), _2 )}
| _1 = override_flag _2 = attributes _3 = private_flag _1_inlined1 = label _5 = COLON _6 = poly_type _7 = EQUAL _8 = seq_expr
    {let _4 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
      ( let poly_exp =
          let loc = (_startpos__6_, _endpos__8_) in
          ghexp ~loc (Pexp_poly(_8, Some _6)) in
        (_4, _3, Cfk_concrete (_1, poly_exp)), _2 )}
| _1 = override_flag _2 = attributes _3 = private_flag _1_inlined1 = label _5 = COLON _6 = TYPE _7 = lident_list _8 = DOT _9 = core_type _10 = EQUAL _11 = seq_expr
    {let _4 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _startpos__4_ = _startpos__1_inlined1_ in
let _endpos = _endpos__11_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  if _startpos__2_ != _endpos__2_ then
    _startpos__2_
  else
    if _startpos__3_ != _endpos__3_ then
      _startpos__3_
    else
      _startpos__4_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let poly_exp_loc = (_startpos__7_, _endpos__11_) in
        let poly_exp =
          let exp, poly =
            (* it seems odd to use the global ~loc here while poly_exp_loc
               is tighter, but this is what ocamlyacc does;
               TODO improve parser.mly *)
            wrap_type_annotation ~loc:_sloc _7 _9 _11 in
          ghexp ~loc:poly_exp_loc (Pexp_poly(exp, Some poly)) in
        (_4, _3,
        Cfk_concrete (_1, poly_exp)), _2 )}

class_type:
  _1 = class_signature
    {      ( _1 )}
| _1 = QUESTION _2 = LIDENT _3 = COLON _4 = simple_core_type_or_tuple _5 = MINUSGREATER _6 = class_type
    {let _1 =
  let _1 =         ( Pcty_arrow(Optional _2 , _4, _6) ) in
  let _endpos__1_ = _endpos__6_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkcty ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = OPTLABEL _2 = simple_core_type_or_tuple _3 = MINUSGREATER _4 = class_type
    {let _1 =
  let _1 =         ( Pcty_arrow(Optional _1, _2, _4) ) in
  let _endpos__1_ = _endpos__4_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkcty ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = LIDENT _2 = COLON _3 = simple_core_type_or_tuple _4 = MINUSGREATER _5 = class_type
    {let _1 =
  let _1 =         ( Pcty_arrow(Labelled _1, _3, _5) ) in
  let _endpos__1_ = _endpos__5_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkcty ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = simple_core_type_or_tuple _2 = MINUSGREATER _3 = class_type
    {let _1 =
  let _1 =         ( Pcty_arrow(Nolabel, _1, _3) ) in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkcty ~loc:_sloc _1 )
in
      ( _1 )}

class_signature:
  _1 = LBRACKET tys = reversed_separated_nonempty_list_COMMA_core_type_ _3 = RBRACKET _1_inlined1 = clty_longident
    {let _1 =
  let _1 =
    let _4 =
      let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
          (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
    in
    let _2 =     ( tys ) in
            ( Pcty_constr (_4, List.rev _2) )
  in
  let _endpos__1_ = _endpos__1_inlined1_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkcty ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = clty_longident
    {let _1 =
  let _1 =
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
          (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
    in
            ( Pcty_constr (_1, []) )
  in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkcty ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = extension
    {let _1 =
  let _1 =         ( Pcty_extension _1 ) in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkcty ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = OBJECT _2 = attributes _3 = class_sig_body _4 = END
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( mkcty ~loc:_sloc ~attrs:_2 (Pcty_signature _3) )}
| _1 = OBJECT _2 = attributes _3 = class_sig_body _4 = error
    {let _loc__4_ = (_startpos__4_, _endpos__4_) in
let _loc__1_ = (_startpos__1_, _endpos__1_) in
      ( unclosed "object" _loc__1_ "end" _loc__4_ )}
| _1 = class_signature _2 = attribute
    {      ( Cty.attr _1 _2 )}
| _1 = LET _2 = OPEN _3 = override_flag _4 = attributes _1_inlined1 = mod_longident _6 = IN _7 = class_signature
    {let _5 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__7_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( mkcty ~loc:_sloc ~attrs:_4 (Pcty_open(_3, _5, _7)) )}

class_sig_body:
  _1 = class_self_type _1_inlined1 = class_sig_fields
    {let _2 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
                                 ( extra_csig _startpos _endpos _1 )
in
      ( Csig.mk _1 (List.rev _2) )}

class_self_type:
  _1 = LPAREN _2 = core_type _3 = RPAREN
    {      ( _2 )}
| 
    {let _1 =
  let _1 =                       ( Ptyp_any ) in
  let _endpos__1_ = _endpos__0_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _endpos in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mktyp ~loc:_sloc _1 )
in
      ( _1 )}

class_sig_fields:
  
    {    ( [] )}
| _1 = class_sig_fields _2 = class_sig_field
    {    ( _2 :: List.rev (text_csig _startpos__2_) @ _1 )}

class_sig_field:
  _1 = INHERIT _2 = attributes _3 = class_signature _4 = post_item_attributes
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let docs = symbol_docs _sloc in
        mkctf ~loc:_sloc (Pctf_inherit _3) ~attrs:(_2@_4) ~docs )}
| _1 = VAL _2 = attributes _3 = value_type _4 = post_item_attributes
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let docs = symbol_docs _sloc in
        mkctf ~loc:_sloc (Pctf_val _3) ~attrs:(_2@_4) ~docs )}
| _1 = METHOD _2 = attributes _3 = private_virtual_flags _1_inlined1 = label _5 = COLON _6 = poly_type _7 = post_item_attributes
    {let _4 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__7_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let (p, v) = _3 in
        let docs = symbol_docs _sloc in
        mkctf ~loc:_sloc (Pctf_method (_4, p, v, _6)) ~attrs:(_2@_7) ~docs )}
| _1 = CONSTRAINT _2 = attributes _3 = constrain_field _4 = post_item_attributes
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let docs = symbol_docs _sloc in
        mkctf ~loc:_sloc (Pctf_constraint _3) ~attrs:(_2@_4) ~docs )}
| _1 = item_extension _2 = post_item_attributes
    {let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let docs = symbol_docs _sloc in
        mkctf ~loc:_sloc (Pctf_extension _1) ~attrs:_2 ~docs )}
| _1 = floating_attribute
    {let _1 =
  let _1 =       ( Pctf_attribute _1 ) in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkctf ~loc:_sloc _1 )
in
      ( _1 )}

value_type:
  _1 = VIRTUAL _2 = mutable_flag _1_inlined1 = label _4 = COLON _5 = core_type
    {let _3 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
      ( _3, _2, Virtual, _5 )}
| _1 = MUTABLE _2 = virtual_flag _1_inlined1 = label _4 = COLON _5 = core_type
    {let _3 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
      ( _3, Mutable, _2, _5 )}
| _1 = label _2 = COLON _3 = core_type
    {let _1 =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
      ( _1, Immutable, Concrete, _3 )}

constrain:
  _1 = core_type _2 = EQUAL _3 = core_type
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( _1, _3, make_loc _sloc )}

constrain_field:
  _1 = core_type _2 = EQUAL _3 = core_type
    {    ( _1, _3 )}

class_descriptions:
  _1 = class_description
    {      ( let (body, ext) = _1 in ([body],ext) )}
| _1 = class_descriptions _2 = and_class_description
    {      ( let (l, ext) = _1 in (_2 :: l, ext) )}

class_description:
  _1 = CLASS _2 = ext_attributes _3 = virtual_flag _4 = class_type_parameters _1_inlined1 = LIDENT _6 = COLON _7 = class_type _8 = post_item_attributes
    {let _5 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__8_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let (ext, attrs) = _2 in
        let docs = symbol_docs _sloc in
        Ci.mk _5 _7 ~virt:_3 ~params:_4
                    ~attrs:(attrs @ _8) ~loc:(make_loc _sloc) ~docs
        , ext )}

and_class_description:
  _1 = AND _2 = attributes _3 = virtual_flag _4 = class_type_parameters _1_inlined1 = LIDENT _6 = COLON _7 = class_type _8 = post_item_attributes
    {let _5 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__8_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let docs = symbol_docs _sloc in
        let text = symbol_text _symbolstartpos in
        Ci.mk _5 _7 ~virt:_3 ~params:_4
                    ~attrs:(_2@_8) ~loc:(make_loc _sloc) ~text ~docs )}

class_type_declarations:
  _1 = class_type_declaration
    {      ( let (body, ext) = _1 in ([body],ext) )}
| _1 = class_type_declarations _2 = and_class_type_declaration
    {      ( let (l, ext) = _1 in (_2 :: l, ext) )}

class_type_declaration:
  _1 = CLASS _2 = TYPE _3 = ext_attributes _4 = virtual_flag _5 = class_type_parameters _1_inlined1 = LIDENT _7 = EQUAL _8 = class_signature _9 = post_item_attributes
    {let _6 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__9_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let (ext, attrs) = _3 in
        let docs = symbol_docs _sloc in
        Ci.mk _6 _8 ~virt:_4 ~params:_5
                    ~attrs:(attrs@_9) ~loc:(make_loc _sloc) ~docs
        , ext )}

and_class_type_declaration:
  _1 = AND _2 = attributes _3 = virtual_flag _4 = class_type_parameters _1_inlined1 = LIDENT _6 = EQUAL _7 = class_signature _8 = post_item_attributes
    {let _5 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__8_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let docs = symbol_docs _sloc in
        let text = symbol_text _symbolstartpos in
        Ci.mk _5 _7 ~virt:_3 ~params:_4
                    ~attrs:(_2@_8) ~loc:(make_loc _sloc) ~text ~docs )}

seq_expr:
  _1 = expr %prec below_SEMI
    {                                  ( _1 )}
| _1 = expr _2 = SEMI
    {                                  ( _1 )}
| _1 = expr _2 = SEMI _3 = seq_expr
    {let _1 =
  let _1 =     ( Pexp_sequence(_1, _3) ) in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
    ( _1 )}
| _1 = expr _2 = SEMI _3 = PERCENT _4 = attr_id _5 = seq_expr
    {let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( let seq = mkexp ~loc:_sloc (Pexp_sequence (_1, _5)) in
      let payload = PStr [mkstrexp seq []] in
      mkexp ~loc:_sloc (Pexp_extension (_4, payload)) )}

labeled_simple_pattern:
  _1 = QUESTION _2 = LPAREN _3 = label_let_pattern _4 = opt_default _5 = RPAREN
    {      ( (Optional (fst _3), _4, snd _3) )}
| _1 = QUESTION _2 = label_var
    {      ( (Optional (fst _2), None, snd _2) )}
| _1 = OPTLABEL _2 = LPAREN _3 = let_pattern _4 = opt_default _5 = RPAREN
    {      ( (Optional _1, _4, _3) )}
| _1 = OPTLABEL _2 = pattern_var
    {      ( (Optional _1, None, _2) )}
| _1 = TILDE _2 = LPAREN _3 = label_let_pattern _4 = RPAREN
    {      ( (Labelled (fst _3), None, snd _3) )}
| _1 = TILDE _2 = label_var
    {      ( (Labelled (fst _2), None, snd _2) )}
| _1 = LABEL _2 = simple_pattern
    {      ( (Labelled _1, None, _2) )}
| _1 = simple_pattern
    {      ( (Nolabel, None, _1) )}

pattern_var:
  _1 = pattern_var_
    {let _1 =
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}

pattern_var_:
  _1 = LIDENT
    {let _1 =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
                      ( Ppat_var _1 )}
| _1 = UNDERSCORE
    {                      ( Ppat_any )}

opt_default:
  
    {                                        ( None )}
| _1 = EQUAL _2 = seq_expr
    {                                        ( Some _2 )}

label_let_pattern:
  _1 = label_var
    {      ( _1 )}
| _1 = label_var _2 = COLON _3 = core_type
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let (lab, pat) = _1 in
        (lab, mkpat ~loc:_sloc (Ppat_constraint(pat, _3))) )}

label_var:
  _1 = LIDENT
    {let _1 =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( (_1.Location.txt, mkpat ~loc:_sloc (Ppat_var _1)) )}

let_pattern:
  _1 = pattern
    {      ( _1 )}
| _1 = pattern _2 = COLON _3 = core_type
    {let _1 =
  let _1 =       ( Ppat_constraint(_1, _3) ) in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}

expr:
  _1 = simple_expr %prec below_HASH
    {      ( _1 )}
| _1 = LET _2 = MODULE _3 = ext_attributes _1_inlined1 = UIDENT _5 = module_binding_body _6 = IN _7 = seq_expr
    {let _1 =
  let _4 =
    let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
    let _loc = (_startpos, _endpos) in
        (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
  in
        ( Pexp_letmodule(_4, _5, _7), _3 )
in
let _endpos__1_ = _endpos__7_ in
let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( let desc, attrs = _1 in
      mkexp_attrs ~loc:_sloc desc attrs )}
| _1 = LET _2 = EXCEPTION _3 = ext_attributes _4 = let_exception_declaration _5 = IN _6 = seq_expr
    {let _1 =       ( Pexp_letexception(_4, _6), _3 ) in
let _endpos__1_ = _endpos__6_ in
let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( let desc, attrs = _1 in
      mkexp_attrs ~loc:_sloc desc attrs )}
| _1 = LET _2 = OPEN _3 = override_flag _4 = ext_attributes _1_inlined1 = mod_longident _6 = IN _7 = seq_expr
    {let _1 =
  let _5 =
    let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
    let _loc = (_startpos, _endpos) in
        (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
  in
        ( Pexp_open(_3, _5, _7), _4 )
in
let _endpos__1_ = _endpos__7_ in
let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( let desc, attrs = _1 in
      mkexp_attrs ~loc:_sloc desc attrs )}
| _1 = FUNCTION _2 = ext_attributes _3 = opt_bar _4 = match_cases
    {let _1 =       ( Pexp_function(List.rev _4), _2 ) in
let _endpos__1_ = _endpos__4_ in
let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( let desc, attrs = _1 in
      mkexp_attrs ~loc:_sloc desc attrs )}
| _1 = FUN _2 = ext_attributes _3 = labeled_simple_pattern _4 = fun_def
    {let _1 =       ( let (l,o,p) = _3 in
        Pexp_fun(l, o, p, _4), _2 ) in
let _endpos__1_ = _endpos__4_ in
let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( let desc, attrs = _1 in
      mkexp_attrs ~loc:_sloc desc attrs )}
| _1 = FUN _2 = ext_attributes _3 = LPAREN _4 = TYPE _5 = lident_list _6 = RPAREN _7 = fun_def
    {let _1 =
  let _endpos = _endpos__7_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
        ( (mk_newtypes ~loc:_sloc _5 _7).pexp_desc, _2 )
in
let _endpos__1_ = _endpos__7_ in
let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( let desc, attrs = _1 in
      mkexp_attrs ~loc:_sloc desc attrs )}
| _1 = MATCH _2 = ext_attributes _3 = seq_expr _4 = WITH _5 = opt_bar _6 = match_cases
    {let _1 =       ( Pexp_match(_3, List.rev _6), _2 ) in
let _endpos__1_ = _endpos__6_ in
let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( let desc, attrs = _1 in
      mkexp_attrs ~loc:_sloc desc attrs )}
| _1 = TRY _2 = ext_attributes _3 = seq_expr _4 = WITH _5 = opt_bar _6 = match_cases
    {let _1 =       ( Pexp_try(_3, List.rev _6), _2 ) in
let _endpos__1_ = _endpos__6_ in
let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( let desc, attrs = _1 in
      mkexp_attrs ~loc:_sloc desc attrs )}
| _1 = TRY _2 = ext_attributes _3 = seq_expr _4 = WITH _5 = error
    {let _1 =       ( syntax_error() ) in
let _endpos__1_ = _endpos__5_ in
let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( let desc, attrs = _1 in
      mkexp_attrs ~loc:_sloc desc attrs )}
| _1 = IF _2 = ext_attributes _3 = seq_expr _4 = THEN _5 = expr _6 = ELSE _7 = expr
    {let _1 =       ( Pexp_ifthenelse(_3, _5, Some _7), _2 ) in
let _endpos__1_ = _endpos__7_ in
let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( let desc, attrs = _1 in
      mkexp_attrs ~loc:_sloc desc attrs )}
| _1 = IF _2 = ext_attributes _3 = seq_expr _4 = THEN _5 = expr
    {let _1 =       ( Pexp_ifthenelse(_3, _5, None), _2 ) in
let _endpos__1_ = _endpos__5_ in
let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( let desc, attrs = _1 in
      mkexp_attrs ~loc:_sloc desc attrs )}
| _1 = WHILE _2 = ext_attributes _3 = seq_expr _4 = DO _5 = seq_expr _6 = DONE
    {let _1 =       ( Pexp_while(_3, _5), _2 ) in
let _endpos__1_ = _endpos__6_ in
let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( let desc, attrs = _1 in
      mkexp_attrs ~loc:_sloc desc attrs )}
| _1 = FOR _2 = ext_attributes _3 = pattern _4 = EQUAL _5 = seq_expr _6 = direction_flag _7 = seq_expr _8 = DO _9 = seq_expr _10 = DONE
    {let _1 =       ( Pexp_for(_3, _5, _7, _6, _9), _2 ) in
let _endpos__1_ = _endpos__10_ in
let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( let desc, attrs = _1 in
      mkexp_attrs ~loc:_sloc desc attrs )}
| _1 = ASSERT _2 = ext_attributes _3 = simple_expr %prec below_HASH
    {let _1 =       ( Pexp_assert _3, _2 ) in
let _endpos__1_ = _endpos__3_ in
let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( let desc, attrs = _1 in
      mkexp_attrs ~loc:_sloc desc attrs )}
| _1 = LAZY _2 = ext_attributes _3 = simple_expr %prec below_HASH
    {let _1 =       ( Pexp_lazy _3, _2 ) in
let _endpos__1_ = _endpos__3_ in
let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( let desc, attrs = _1 in
      mkexp_attrs ~loc:_sloc desc attrs )}
| _1 = OBJECT _2 = ext_attributes _3 = class_structure _4 = END
    {let _1 =       ( Pexp_object _3, _2 ) in
let _endpos__1_ = _endpos__4_ in
let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( let desc, attrs = _1 in
      mkexp_attrs ~loc:_sloc desc attrs )}
| _1 = OBJECT _2 = ext_attributes _3 = class_structure _4 = error
    {let _1 =
  let _loc__4_ = (_startpos__4_, _endpos__4_) in
  let _loc__1_ = (_startpos__1_, _endpos__1_) in
        ( unclosed "object" _loc__1_ "end" _loc__4_ )
in
let _endpos__1_ = _endpos__4_ in
let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( let desc, attrs = _1 in
      mkexp_attrs ~loc:_sloc desc attrs )}
| _1 = expr _1_inlined1 = INFIXOP0 _3 = expr
    {let _1 =
  let _1 =
    let _1 =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
        let _loc = (_startpos, _endpos) in
           ( (* see the mkrhs comment above
        for the choice of $startpos over $symbolstartpos *)
     mkoperator ~loc:_loc _1 )
      in
            ( mkinfix _1 _2 _3 )
    in
                ( _1 )
  in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
    ( _1 )}
| _1 = expr _1_inlined1 = INFIXOP1 _3 = expr
    {let _1 =
  let _1 =
    let _1 =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
        let _loc = (_startpos, _endpos) in
           ( (* see the mkrhs comment above
        for the choice of $startpos over $symbolstartpos *)
     mkoperator ~loc:_loc _1 )
      in
            ( mkinfix _1 _2 _3 )
    in
                ( _1 )
  in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
    ( _1 )}
| _1 = expr _1_inlined1 = INFIXOP2 _3 = expr
    {let _1 =
  let _1 =
    let _1 =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
        let _loc = (_startpos, _endpos) in
           ( (* see the mkrhs comment above
        for the choice of $startpos over $symbolstartpos *)
     mkoperator ~loc:_loc _1 )
      in
            ( mkinfix _1 _2 _3 )
    in
                ( _1 )
  in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
    ( _1 )}
| _1 = expr _1_inlined1 = INFIXOP3 _3 = expr
    {let _1 =
  let _1 =
    let _1 =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
        let _loc = (_startpos, _endpos) in
           ( (* see the mkrhs comment above
        for the choice of $startpos over $symbolstartpos *)
     mkoperator ~loc:_loc _1 )
      in
            ( mkinfix _1 _2 _3 )
    in
                ( _1 )
  in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
    ( _1 )}
| _1 = expr _1_inlined1 = INFIXOP4 _3 = expr
    {let _1 =
  let _1 =
    let _1 =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
        let _loc = (_startpos, _endpos) in
           ( (* see the mkrhs comment above
        for the choice of $startpos over $symbolstartpos *)
     mkoperator ~loc:_loc _1 )
      in
            ( mkinfix _1 _2 _3 )
    in
                ( _1 )
  in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
    ( _1 )}
| _1 = expr _1_inlined1 = PLUS _3 = expr
    {let _1 =
  let _1 =
    let _1 =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let _1 =                  ("+") in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
        let _loc = (_startpos, _endpos) in
           ( (* see the mkrhs comment above
        for the choice of $startpos over $symbolstartpos *)
     mkoperator ~loc:_loc _1 )
      in
            ( mkinfix _1 _2 _3 )
    in
                ( _1 )
  in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
    ( _1 )}
| _1 = expr _1_inlined1 = PLUSDOT _3 = expr
    {let _1 =
  let _1 =
    let _1 =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let _1 =                     ("+.") in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
        let _loc = (_startpos, _endpos) in
           ( (* see the mkrhs comment above
        for the choice of $startpos over $symbolstartpos *)
     mkoperator ~loc:_loc _1 )
      in
            ( mkinfix _1 _2 _3 )
    in
                ( _1 )
  in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
    ( _1 )}
| _1 = expr _1_inlined1 = PLUSEQ _3 = expr
    {let _1 =
  let _1 =
    let _1 =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let _1 =                    ("+=") in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
        let _loc = (_startpos, _endpos) in
           ( (* see the mkrhs comment above
        for the choice of $startpos over $symbolstartpos *)
     mkoperator ~loc:_loc _1 )
      in
            ( mkinfix _1 _2 _3 )
    in
                ( _1 )
  in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
    ( _1 )}
| _1 = expr _1_inlined1 = MINUS _3 = expr
    {let _1 =
  let _1 =
    let _1 =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let _1 =                   ("-") in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
        let _loc = (_startpos, _endpos) in
           ( (* see the mkrhs comment above
        for the choice of $startpos over $symbolstartpos *)
     mkoperator ~loc:_loc _1 )
      in
            ( mkinfix _1 _2 _3 )
    in
                ( _1 )
  in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
    ( _1 )}
| _1 = expr _1_inlined1 = MINUSDOT _3 = expr
    {let _1 =
  let _1 =
    let _1 =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let _1 =                      ("-.") in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
        let _loc = (_startpos, _endpos) in
           ( (* see the mkrhs comment above
        for the choice of $startpos over $symbolstartpos *)
     mkoperator ~loc:_loc _1 )
      in
            ( mkinfix _1 _2 _3 )
    in
                ( _1 )
  in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
    ( _1 )}
| _1 = expr _1_inlined1 = STAR _3 = expr
    {let _1 =
  let _1 =
    let _1 =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let _1 =                  ("*") in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
        let _loc = (_startpos, _endpos) in
           ( (* see the mkrhs comment above
        for the choice of $startpos over $symbolstartpos *)
     mkoperator ~loc:_loc _1 )
      in
            ( mkinfix _1 _2 _3 )
    in
                ( _1 )
  in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
    ( _1 )}
| _1 = expr _1_inlined1 = PERCENT _3 = expr
    {let _1 =
  let _1 =
    let _1 =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let _1 =                     ("%") in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
        let _loc = (_startpos, _endpos) in
           ( (* see the mkrhs comment above
        for the choice of $startpos over $symbolstartpos *)
     mkoperator ~loc:_loc _1 )
      in
            ( mkinfix _1 _2 _3 )
    in
                ( _1 )
  in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
    ( _1 )}
| _1 = expr _1_inlined1 = EQUAL _3 = expr
    {let _1 =
  let _1 =
    let _1 =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let _1 =                   ("=") in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
        let _loc = (_startpos, _endpos) in
           ( (* see the mkrhs comment above
        for the choice of $startpos over $symbolstartpos *)
     mkoperator ~loc:_loc _1 )
      in
            ( mkinfix _1 _2 _3 )
    in
                ( _1 )
  in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
    ( _1 )}
| _1 = expr _1_inlined1 = LESS _3 = expr
    {let _1 =
  let _1 =
    let _1 =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let _1 =                  ("<") in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
        let _loc = (_startpos, _endpos) in
           ( (* see the mkrhs comment above
        for the choice of $startpos over $symbolstartpos *)
     mkoperator ~loc:_loc _1 )
      in
          ( mkinfix _1 _2 _3 )
    in
                ( _1 )
  in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
    ( _1 )}
| _1 = expr _1_inlined1 = GREATER _3 = expr
    {let _1 =
  let _1 =
    let _1 =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let _1 =                     (">") in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
        let _loc = (_startpos, _endpos) in
           ( (* see the mkrhs comment above
        for the choice of $startpos over $symbolstartpos *)
     mkoperator ~loc:_loc _1 )
      in
            ( mkinfix _1 _2 _3 )
    in
                ( _1 )
  in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
    ( _1 )}
| _1 = expr _1_inlined1 = OR _3 = expr
    {let _1 =
  let _1 =
    let _1 =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let _1 =                ("or") in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
        let _loc = (_startpos, _endpos) in
           ( (* see the mkrhs comment above
        for the choice of $startpos over $symbolstartpos *)
     mkoperator ~loc:_loc _1 )
      in
            ( mkinfix _1 _2 _3 )
    in
                ( _1 )
  in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
    ( _1 )}
| _1 = expr _1_inlined1 = BARBAR _3 = expr
    {let _1 =
  let _1 =
    let _1 =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let _1 =                    ("||") in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
        let _loc = (_startpos, _endpos) in
           ( (* see the mkrhs comment above
        for the choice of $startpos over $symbolstartpos *)
     mkoperator ~loc:_loc _1 )
      in
            ( mkinfix _1 _2 _3 )
    in
                ( _1 )
  in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
    ( _1 )}
| _1 = expr _1_inlined1 = AMPERSAND _3 = expr
    {let _1 =
  let _1 =
    let _1 =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let _1 =                       ("&") in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
        let _loc = (_startpos, _endpos) in
           ( (* see the mkrhs comment above
        for the choice of $startpos over $symbolstartpos *)
     mkoperator ~loc:_loc _1 )
      in
            ( mkinfix _1 _2 _3 )
    in
                ( _1 )
  in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
    ( _1 )}
| _1 = expr _1_inlined1 = AMPERAMPER _3 = expr
    {let _1 =
  let _1 =
    let _1 =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let _1 =                        ("&&") in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
        let _loc = (_startpos, _endpos) in
           ( (* see the mkrhs comment above
        for the choice of $startpos over $symbolstartpos *)
     mkoperator ~loc:_loc _1 )
      in
            ( mkinfix _1 _2 _3 )
    in
                ( _1 )
  in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
    ( _1 )}
| _1 = expr _1_inlined1 = COLONEQUAL _3 = expr
    {let _1 =
  let _1 =
    let _1 =
      let _2 =
        let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
        let _1 =                        (":=") in
        let _endpos = _endpos__1_ in
        let _startpos = _startpos__1_ in
        let _loc = (_startpos, _endpos) in
           ( (* see the mkrhs comment above
        for the choice of $startpos over $symbolstartpos *)
     mkoperator ~loc:_loc _1 )
      in
            ( mkinfix _1 _2 _3 )
    in
                ( _1 )
  in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
    ( _1 )}
| _1 = subtractive _2 = expr %prec prec_unary_minus
    {let _1 =
  let _1 =
    let _1 =
      let _loc__1_ = (_startpos__1_, _endpos__1_) in
            ( mkuminus ~oploc:_loc__1_ _1 _2 )
    in
                ( _1 )
  in
  let _endpos__1_ = _endpos__2_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
    ( _1 )}
| _1 = additive _2 = expr %prec prec_unary_plus
    {let _1 =
  let _1 =
    let _1 =
      let _loc__1_ = (_startpos__1_, _endpos__1_) in
            ( mkuplus ~oploc:_loc__1_ _1 _2 )
    in
                ( _1 )
  in
  let _endpos__1_ = _endpos__2_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
    ( _1 )}
| _1 = simple_expr _2 = simple_labeled_expr_list
    {let _1 =
  let _1 =     ( Pexp_apply(_1, List.rev _2) ) in
  let _endpos__1_ = _endpos__2_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
    ( _1 )}
| _1 = expr_comma_list %prec below_COMMA
    {let _1 =
  let _1 =     ( Pexp_tuple(List.rev _1) ) in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
    ( _1 )}
| _1 = constr_longident _2 = simple_expr %prec below_HASH
    {let _1 =
  let _1 =
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
          (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
    in
        ( Pexp_construct(_1, Some _2) )
  in
  let _endpos__1_ = _endpos__2_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
    ( _1 )}
| _1 = name_tag _2 = simple_expr %prec below_HASH
    {let _1 =
  let _1 =     ( Pexp_variant(_1, Some _2) ) in
  let _endpos__1_ = _endpos__2_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
    ( _1 )}
| _1 = let_bindings _2 = IN _3 = seq_expr
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( expr_of_let_bindings ~loc:_sloc _1 _3 )}
| _1 = expr _2 = COLONCOLON _3 = expr
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
let _loc__2_ = (_startpos__2_, _endpos__2_) in
let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp_cons ~loc:_sloc _loc__2_ (ghexp ~loc:_sloc (Pexp_tuple[_1;_3])) )}
| _1 = label _2 = LESSMINUS _3 = expr
    {let _1 =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc (Pexp_setinstvar(_1, _3)) )}
| _1 = simple_expr _2 = DOT _1_inlined1 = label_longident _4 = LESSMINUS _5 = expr
    {let _3 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc (Pexp_setfield(_1, _3, _5)) )}
| _1 = simple_expr _2 = DOT _3 = LPAREN _4 = seq_expr _5 = RPAREN _6 = LESSMINUS _7 = expr
    {let _endpos = _endpos__7_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( array_set ~loc:_sloc _1 _4 _7 )}
| _1 = simple_expr _2 = DOT _3 = LBRACKET _4 = seq_expr _5 = RBRACKET _6 = LESSMINUS _7 = expr
    {let _endpos = _endpos__7_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( string_set ~loc:_sloc _1 _4 _7 )}
| _1 = simple_expr _2 = DOT _3 = LBRACE _4 = expr _5 = RBRACE _6 = LESSMINUS _7 = expr
    {let _endpos = _endpos__7_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( bigarray_set ~loc:_sloc _1 _4 _7 )}
| _1 = simple_expr _2 = DOTOP _3 = LBRACKET _4 = expr _5 = RBRACKET _6 = LESSMINUS _7 = expr
    {let _endpos = _endpos__7_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( dotop_set ~loc:_sloc (Lident ("." ^ _2 ^ "[]<-")) _1 _4 _7 )}
| _1 = simple_expr _2 = DOTOP _3 = LPAREN _4 = expr _5 = RPAREN _6 = LESSMINUS _7 = expr
    {let _endpos = _endpos__7_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( dotop_set ~loc:_sloc (Lident ("." ^ _2 ^ "()<-")) _1 _4 _7 )}
| _1 = simple_expr _2 = DOTOP _3 = LBRACE _4 = expr _5 = RBRACE _6 = LESSMINUS _7 = expr
    {let _endpos = _endpos__7_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( dotop_set ~loc:_sloc (Lident ("." ^ _2 ^ "{}<-")) _1 _4 _7 )}
| _1 = simple_expr _2 = DOT _3 = mod_longident _4 = DOTOP _5 = LBRACKET _6 = expr _7 = RBRACKET _8 = LESSMINUS _9 = expr
    {let _endpos = _endpos__9_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( dotop_set ~loc:_sloc (Ldot(_3,"." ^ _4 ^ "[]<-")) _1 _6 _9 )}
| _1 = simple_expr _2 = DOT _3 = mod_longident _4 = DOTOP _5 = LPAREN _6 = expr _7 = RPAREN _8 = LESSMINUS _9 = expr
    {let _endpos = _endpos__9_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( dotop_set ~loc:_sloc (Ldot(_3, "." ^ _4 ^ "()<-")) _1 _6 _9 )}
| _1 = simple_expr _2 = DOT _3 = mod_longident _4 = DOTOP _5 = LBRACE _6 = expr _7 = RBRACE _8 = LESSMINUS _9 = expr
    {let _endpos = _endpos__9_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( dotop_set ~loc:_sloc (Ldot(_3, "." ^ _4 ^ "{}<-")) _1 _6 _9 )}
| _1 = expr _2 = attribute
    {      ( Exp.attr _1 _2 )}
| _1 = UNDERSCORE
    {let _loc__1_ = (_startpos__1_, _endpos__1_) in
     ( not_expecting _loc__1_ "wildcard \"_\"" )}

simple_expr:
  _1 = LPAREN _2 = seq_expr _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( reloc_exp ~loc:_sloc _2 )}
| _1 = LPAREN _2 = seq_expr _3 = error
    {let _loc__3_ = (_startpos__3_, _endpos__3_) in
let _loc__1_ = (_startpos__1_, _endpos__1_) in
      ( unclosed "(" _loc__1_ ")" _loc__3_ )}
| _1 = LPAREN _2 = seq_expr _3 = type_constraint _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp_constraint ~loc:_sloc _2 _3 )}
| _1 = simple_expr _2 = DOT _3 = LPAREN _4 = seq_expr _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( array_get ~loc:_sloc _1 _4 )}
| _1 = simple_expr _2 = DOT _3 = LPAREN _4 = seq_expr _5 = error
    {let _loc__5_ = (_startpos__5_, _endpos__5_) in
let _loc__3_ = (_startpos__3_, _endpos__3_) in
      ( unclosed "(" _loc__3_ ")" _loc__5_ )}
| _1 = simple_expr _2 = DOT _3 = LBRACKET _4 = seq_expr _5 = RBRACKET
    {let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( string_get ~loc:_sloc _1 _4 )}
| _1 = simple_expr _2 = DOT _3 = LBRACKET _4 = seq_expr _5 = error
    {let _loc__5_ = (_startpos__5_, _endpos__5_) in
let _loc__3_ = (_startpos__3_, _endpos__3_) in
      ( unclosed "[" _loc__3_ "]" _loc__5_ )}
| _1 = simple_expr _2 = DOTOP _3 = LBRACKET _4 = expr _5 = RBRACKET
    {let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( dotop_get ~loc:_sloc (Lident ("." ^ _2 ^ "[]")) _1 _4 )}
| _1 = simple_expr _2 = DOTOP _3 = LBRACKET _4 = expr _5 = error
    {let _loc__5_ = (_startpos__5_, _endpos__5_) in
let _loc__3_ = (_startpos__3_, _endpos__3_) in
      ( unclosed "[" _loc__3_ "]" _loc__5_ )}
| _1 = simple_expr _2 = DOTOP _3 = LPAREN _4 = expr _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( dotop_get ~loc:_sloc (Lident ("." ^ _2 ^ "()")) _1 _4  )}
| _1 = simple_expr _2 = DOTOP _3 = LPAREN _4 = expr _5 = error
    {let _loc__5_ = (_startpos__5_, _endpos__5_) in
let _loc__3_ = (_startpos__3_, _endpos__3_) in
      ( unclosed "(" _loc__3_ ")" _loc__5_ )}
| _1 = simple_expr _2 = DOTOP _3 = LBRACE _4 = expr _5 = RBRACE
    {let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( dotop_get ~loc:_sloc (Lident ("." ^ _2 ^ "{}")) _1 _4 )}
| _1 = simple_expr _2 = DOTOP _3 = LBRACE _4 = expr _5 = error
    {let _loc__5_ = (_startpos__5_, _endpos__5_) in
let _loc__3_ = (_startpos__3_, _endpos__3_) in
      ( unclosed "{" _loc__3_ "}" _loc__5_ )}
| _1 = simple_expr _2 = DOT _3 = mod_longident _4 = DOTOP _5 = LBRACKET _6 = expr _7 = RBRACKET
    {let _endpos = _endpos__7_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( dotop_get ~loc:_sloc (Ldot(_3, "." ^ _4 ^ "[]")) _1 _6  )}
| _1 = simple_expr _2 = DOT _3 = mod_longident _4 = DOTOP _5 = LBRACKET _6 = expr _7 = error
    {let _loc__7_ = (_startpos__7_, _endpos__7_) in
let _loc__5_ = (_startpos__5_, _endpos__5_) in
      ( unclosed "[" _loc__5_ "]" _loc__7_ )}
| _1 = simple_expr _2 = DOT _3 = mod_longident _4 = DOTOP _5 = LPAREN _6 = expr _7 = RPAREN
    {let _endpos = _endpos__7_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( dotop_get ~loc:_sloc (Ldot(_3, "." ^ _4 ^ "()")) _1 _6 )}
| _1 = simple_expr _2 = DOT _3 = mod_longident _4 = DOTOP _5 = LPAREN _6 = expr _7 = error
    {let _loc__7_ = (_startpos__7_, _endpos__7_) in
let _loc__5_ = (_startpos__5_, _endpos__5_) in
      ( unclosed "(" _loc__5_ ")" _loc__7_ )}
| _1 = simple_expr _2 = DOT _3 = mod_longident _4 = DOTOP _5 = LBRACE _6 = expr _7 = RBRACE
    {let _endpos = _endpos__7_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( dotop_get ~loc:_sloc (Ldot(_3, "." ^ _4 ^ "{}")) _1 _6  )}
| _1 = simple_expr _2 = DOT _3 = mod_longident _4 = DOTOP _5 = LBRACE _6 = expr _7 = error
    {let _loc__7_ = (_startpos__7_, _endpos__7_) in
let _loc__5_ = (_startpos__5_, _endpos__5_) in
      ( unclosed "{" _loc__5_ "}" _loc__7_ )}
| _1 = simple_expr _2 = DOT _3 = LBRACE _4 = expr _5 = RBRACE
    {let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( bigarray_get ~loc:_sloc _1 _4 )}
| _1 = simple_expr _2 = DOT _3 = LBRACE _4 = expr_comma_list _5 = error
    {let _loc__5_ = (_startpos__5_, _endpos__5_) in
let _loc__3_ = (_startpos__3_, _endpos__3_) in
      ( unclosed "{" _loc__3_ "}" _loc__5_ )}
| _1 = BEGIN _2 = ext_attributes _3 = seq_expr _4 = END
    {let _1 =       ( let (ext, attrs) = _2 in
        _3.pexp_desc, (ext, attrs @ _3.pexp_attributes) ) in
let _endpos__1_ = _endpos__4_ in
let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( let desc, attrs = _1 in
      mkexp_attrs ~loc:_sloc desc attrs )}
| _1 = BEGIN _2 = ext_attributes _3 = END
    {let _1 =
  let _endpos = _endpos__3_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
        ( Pexp_construct (mkloc (Lident "()") (make_loc _sloc), None), _2 )
in
let _endpos__1_ = _endpos__3_ in
let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( let desc, attrs = _1 in
      mkexp_attrs ~loc:_sloc desc attrs )}
| _1 = BEGIN _2 = ext_attributes _3 = seq_expr _4 = error
    {let _1 =
  let _loc__4_ = (_startpos__4_, _endpos__4_) in
  let _loc__1_ = (_startpos__1_, _endpos__1_) in
        ( unclosed "begin" _loc__1_ "end" _loc__4_ )
in
let _endpos__1_ = _endpos__4_ in
let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( let desc, attrs = _1 in
      mkexp_attrs ~loc:_sloc desc attrs )}
| _1 = NEW _2 = ext_attributes _1_inlined1 = class_longident
    {let _1 =
  let _3 =
    let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
    let _endpos = _endpos__1_ in
    let _startpos = _startpos__1_ in
    let _loc = (_startpos, _endpos) in
        (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
  in
        ( Pexp_new(_3), _2 )
in
let _endpos__1_ = _endpos__1_inlined1_ in
let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( let desc, attrs = _1 in
      mkexp_attrs ~loc:_sloc desc attrs )}
| _1 = LPAREN _2 = MODULE _3 = ext_attributes _4 = module_expr _5 = RPAREN
    {let _1 =       ( Pexp_pack _4, _3 ) in
let _endpos__1_ = _endpos__5_ in
let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( let desc, attrs = _1 in
      mkexp_attrs ~loc:_sloc desc attrs )}
| _1 = LPAREN _2 = MODULE _3 = ext_attributes _4 = module_expr _5 = COLON _6 = package_type _7 = RPAREN
    {let _1 =
  let _endpos = _endpos__7_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
        ( Pexp_constraint (ghexp ~loc:_sloc (Pexp_pack _4), _6), _3 )
in
let _endpos__1_ = _endpos__7_ in
let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( let desc, attrs = _1 in
      mkexp_attrs ~loc:_sloc desc attrs )}
| _1 = LPAREN _2 = MODULE _3 = ext_attributes _4 = module_expr _5 = COLON _6 = error
    {let _1 =
  let _loc__6_ = (_startpos__6_, _endpos__6_) in
  let _loc__1_ = (_startpos__1_, _endpos__1_) in
        ( unclosed "(" _loc__1_ ")" _loc__6_ )
in
let _endpos__1_ = _endpos__6_ in
let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( let desc, attrs = _1 in
      mkexp_attrs ~loc:_sloc desc attrs )}
| _1 = val_longident
    {let _1 =
  let _1 =
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
          (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
    in
          ( Pexp_ident (_1) )
  in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = constant
    {let _1 =
  let _1 =       ( Pexp_constant _1 ) in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = constr_longident %prec prec_constant_constructor
    {let _1 =
  let _1 =
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
          (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
    in
          ( Pexp_construct(_1, None) )
  in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = name_tag %prec prec_constant_constructor
    {let _1 =
  let _1 =       ( Pexp_variant(_1, None) ) in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = PREFIXOP _2 = simple_expr
    {let _1 =
  let _1 =
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
         ( (* see the mkrhs comment above
        for the choice of $startpos over $symbolstartpos *)
     mkoperator ~loc:_loc _1 )
    in
          ( Pexp_apply(_1, [Nolabel,_2]) )
  in
  let _endpos__1_ = _endpos__2_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = BANG _2 = simple_expr
    {let _1 =
  let _1 =
    let _1 =
      let _1 =             ("!") in
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
         ( (* see the mkrhs comment above
        for the choice of $startpos over $symbolstartpos *)
     mkoperator ~loc:_loc _1 )
    in
          ( Pexp_apply(_1, [Nolabel,_2]) )
  in
  let _endpos__1_ = _endpos__2_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = LBRACELESS _2 = field_expr_list _3 = GREATERRBRACE
    {let _1 =
  let _1 =       ( Pexp_override _2 ) in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = LBRACELESS _2 = field_expr_list _3 = error
    {let _1 =
  let _1 =
    let _loc__3_ = (_startpos__3_, _endpos__3_) in
    let _loc__1_ = (_startpos__1_, _endpos__1_) in
          ( unclosed "{<" _loc__1_ ">}" _loc__3_ )
  in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = LBRACELESS _2 = GREATERRBRACE
    {let _1 =
  let _1 =       ( Pexp_override [] ) in
  let _endpos__1_ = _endpos__2_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = simple_expr _2 = DOT _1_inlined1 = label_longident
    {let _1 =
  let _1 =
    let _3 =
      let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
          (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
    in
          ( Pexp_field(_1, _3) )
  in
  let _endpos__1_ = _endpos__1_inlined1_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = mod_longident _2 = DOT _3 = LPAREN _4 = seq_expr _5 = RPAREN
    {let _1 =
  let _1 =
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
          (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
    in
          ( Pexp_open(Fresh, _1, _4) )
  in
  let _endpos__1_ = _endpos__5_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = mod_longident _2 = DOT _3 = LBRACELESS _4 = field_expr_list _5 = GREATERRBRACE
    {let _1 =
  let _1 =
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
          (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
    in
    let _endpos = _endpos__5_ in
    let _symbolstartpos = _startpos__1_ in
    let _sloc = (_symbolstartpos, _endpos) in
          ( (* TODO: review the location of Pexp_override *)
        Pexp_open(Fresh, _1, mkexp ~loc:_sloc (Pexp_override _4)) )
  in
  let _endpos__1_ = _endpos__5_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = mod_longident _2 = DOT _3 = LBRACELESS _4 = field_expr_list _5 = error
    {let _1 =
  let _1 =
    let _loc__5_ = (_startpos__5_, _endpos__5_) in
    let _loc__3_ = (_startpos__3_, _endpos__3_) in
          ( unclosed "{<" _loc__3_ ">}" _loc__5_ )
  in
  let _endpos__1_ = _endpos__5_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = simple_expr _2 = HASH _1_inlined1 = label
    {let _1 =
  let _1 =
    let _3 =
      let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
          (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
    in
          ( Pexp_send(_1, _3) )
  in
  let _endpos__1_ = _endpos__1_inlined1_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = simple_expr _1_inlined1 = HASHOP _3 = simple_expr
    {let _1 =
  let _1 =
    let _2 =
      let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
         ( (* see the mkrhs comment above
        for the choice of $startpos over $symbolstartpos *)
     mkoperator ~loc:_loc _1 )
    in
          ( mkinfix _1 _2 _3 )
  in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = extension
    {let _1 =
  let _1 =       ( Pexp_extension _1 ) in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = mod_longident _2 = DOT _1_inlined1 = LPAREN _2_inlined1 = RPAREN
    {let _1 =
  let _1 =
    let _3 =
      let (_endpos__2_, _startpos__1_, _2, _1) = (_endpos__2_inlined1_, _startpos__1_inlined1_, _2_inlined1, _1_inlined1) in
      let _1 =                                                  (Lident "()") in
      let _endpos__1_ = _endpos__2_ in
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
          (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
    in
    let _endpos__3_ = _endpos__2_inlined1_ in
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
          (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
    in
    let _endpos = _endpos__3_ in
    let _symbolstartpos = _startpos__1_ in
    let _sloc = (_symbolstartpos, _endpos) in
          ( (* TODO: review the location of Pexp_construct *)
        Pexp_open(Fresh, _1, mkexp ~loc:_sloc (Pexp_construct(_3, None))) )
  in
  let _endpos__1_ = _endpos__2_inlined1_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = mod_longident _2 = DOT _3 = LPAREN _4 = seq_expr _5 = error
    {let _1 =
  let _1 =
    let _loc__5_ = (_startpos__5_, _endpos__5_) in
    let _loc__3_ = (_startpos__3_, _endpos__3_) in
          ( unclosed "(" _loc__3_ ")" _loc__5_ )
  in
  let _endpos__1_ = _endpos__5_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = LBRACE _2 = record_expr _3 = RBRACE
    {let _1 =
  let _1 =       ( let (exten, fields) = _2 in
        Pexp_record(fields, exten) ) in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = LBRACE _2 = record_expr _3 = error
    {let _1 =
  let _1 =
    let _loc__3_ = (_startpos__3_, _endpos__3_) in
    let _loc__1_ = (_startpos__1_, _endpos__1_) in
          ( unclosed "{" _loc__1_ "}" _loc__3_ )
  in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = mod_longident _2 = DOT _3 = LBRACE _4 = record_expr _5 = RBRACE
    {let _1 =
  let _1 =
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
          (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
    in
    let _endpos = _endpos__5_ in
    let _symbolstartpos = _startpos__1_ in
    let _sloc = (_symbolstartpos, _endpos) in
          ( let (exten, fields) = _4 in
        (* TODO: review the location of Pexp_construct *)
        Pexp_open(Fresh, _1, mkexp ~loc:_sloc (Pexp_record(fields, exten))) )
  in
  let _endpos__1_ = _endpos__5_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = mod_longident _2 = DOT _3 = LBRACE _4 = record_expr _5 = error
    {let _1 =
  let _1 =
    let _loc__5_ = (_startpos__5_, _endpos__5_) in
    let _loc__3_ = (_startpos__3_, _endpos__3_) in
          ( unclosed "{" _loc__3_ "}" _loc__5_ )
  in
  let _endpos__1_ = _endpos__5_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = LBRACKETBAR _2 = expr_semi_list _3 = opt_semi _4 = BARRBRACKET
    {let _1 =
  let _1 =       ( Pexp_array(List.rev _2) ) in
  let _endpos__1_ = _endpos__4_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = LBRACKETBAR _2 = expr_semi_list _3 = opt_semi _4 = error
    {let _1 =
  let _1 =
    let _loc__4_ = (_startpos__4_, _endpos__4_) in
    let _loc__1_ = (_startpos__1_, _endpos__1_) in
          ( unclosed "[|" _loc__1_ "|]" _loc__4_ )
  in
  let _endpos__1_ = _endpos__4_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = LBRACKETBAR _2 = BARRBRACKET
    {let _1 =
  let _1 =       ( Pexp_array [] ) in
  let _endpos__1_ = _endpos__2_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = mod_longident _2 = DOT _3 = LBRACKETBAR _4 = expr_semi_list _5 = opt_semi _6 = BARRBRACKET
    {let _1 =
  let _1 =
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
          (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
    in
    let _endpos = _endpos__6_ in
    let _symbolstartpos = _startpos__1_ in
    let _sloc = (_symbolstartpos, _endpos) in
          ( (* TODO: review the location of Pexp_array *)
        Pexp_open(Fresh, _1, mkexp ~loc:_sloc (Pexp_array(List.rev _4))) )
  in
  let _endpos__1_ = _endpos__6_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = mod_longident _2 = DOT _3 = LBRACKETBAR _4 = BARRBRACKET
    {let _1 =
  let _1 =
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
          (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
    in
    let _endpos = _endpos__4_ in
    let _symbolstartpos = _startpos__1_ in
    let _sloc = (_symbolstartpos, _endpos) in
          ( (* TODO: review the location of Pexp_array *)
        Pexp_open(Fresh, _1, mkexp ~loc:_sloc (Pexp_array [])) )
  in
  let _endpos__1_ = _endpos__4_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = mod_longident _2 = DOT _3 = LBRACKETBAR _4 = expr_semi_list _5 = opt_semi _6 = error
    {let _1 =
  let _1 =
    let _loc__6_ = (_startpos__6_, _endpos__6_) in
    let _loc__3_ = (_startpos__3_, _endpos__3_) in
          ( unclosed "[|" _loc__3_ "|]" _loc__6_ )
  in
  let _endpos__1_ = _endpos__6_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = LBRACKET _2 = expr_semi_list _3 = opt_semi _4 = RBRACKET
    {let _1 =
  let _1 =
    let _loc__4_ = (_startpos__4_, _endpos__4_) in
          ( fst (mktailexp _loc__4_ (List.rev _2)) )
  in
  let _endpos__1_ = _endpos__4_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = LBRACKET _2 = expr_semi_list _3 = opt_semi _4 = error
    {let _1 =
  let _1 =
    let _loc__4_ = (_startpos__4_, _endpos__4_) in
    let _loc__1_ = (_startpos__1_, _endpos__1_) in
          ( unclosed "[" _loc__1_ "]" _loc__4_ )
  in
  let _endpos__1_ = _endpos__4_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = mod_longident _2 = DOT _3 = LBRACKET _4 = expr_semi_list _5 = opt_semi _6 = RBRACKET
    {let _1 =
  let _1 =
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
          (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
    in
    let _endpos = _endpos__6_ in
    let _symbolstartpos = _startpos__1_ in
    let _loc__6_ = (_startpos__6_, _endpos__6_) in
    let _sloc = (_symbolstartpos, _endpos) in
          ( let list_exp =
          (* TODO: review the location of list_exp *)
          let tail_exp, _tail_loc = mktailexp _loc__6_ (List.rev _4) in
          mkexp ~loc:_sloc tail_exp in
        Pexp_open(Fresh, _1, list_exp) )
  in
  let _endpos__1_ = _endpos__6_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = mod_longident _2 = DOT _1_inlined1 = LBRACKET _2_inlined1 = RBRACKET
    {let _1 =
  let _1 =
    let _3 =
      let (_endpos__2_, _startpos__1_, _2, _1) = (_endpos__2_inlined1_, _startpos__1_inlined1_, _2_inlined1, _1_inlined1) in
      let _1 =                                                      (Lident "[]") in
      let _endpos__1_ = _endpos__2_ in
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
          (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
    in
    let _endpos__3_ = _endpos__2_inlined1_ in
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
          (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
    in
    let _endpos = _endpos__3_ in
    let _symbolstartpos = _startpos__1_ in
    let _sloc = (_symbolstartpos, _endpos) in
          ( (* TODO: review the location of Pexp_construct *)
        Pexp_open(Fresh, _1, mkexp ~loc:_sloc (Pexp_construct(_3, None))) )
  in
  let _endpos__1_ = _endpos__2_inlined1_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = mod_longident _2 = DOT _3 = LBRACKET _4 = expr_semi_list _5 = opt_semi _6 = error
    {let _1 =
  let _1 =
    let _loc__6_ = (_startpos__6_, _endpos__6_) in
    let _loc__3_ = (_startpos__3_, _endpos__3_) in
          ( unclosed "[" _loc__3_ "]" _loc__6_ )
  in
  let _endpos__1_ = _endpos__6_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = mod_longident _2 = DOT _3 = LPAREN _4 = MODULE _5 = ext_attributes _6 = module_expr _7 = COLON _8 = package_type _9 = RPAREN
    {let _1 =
  let _1 =
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
          (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
    in
    let _endpos = _endpos__9_ in
    let _symbolstartpos = _startpos__1_ in
    let _sloc = (_symbolstartpos, _endpos) in
          ( (* TODO: review the location of Pexp_constraint *)
        let modexp =
          mkexp_attrs ~loc:_sloc
            (Pexp_constraint (ghexp ~loc:_sloc (Pexp_pack _6), _8)) _5 in
        Pexp_open(Fresh, _1, modexp) )
  in
  let _endpos__1_ = _endpos__9_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = mod_longident _2 = DOT _3 = LPAREN _4 = MODULE _5 = ext_attributes _6 = module_expr _7 = COLON _8 = error
    {let _1 =
  let _1 =
    let _loc__8_ = (_startpos__8_, _endpos__8_) in
    let _loc__3_ = (_startpos__3_, _endpos__3_) in
          ( unclosed "(" _loc__3_ ")" _loc__8_ )
  in
  let _endpos__1_ = _endpos__8_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}

simple_labeled_expr_list:
  _1 = labeled_simple_expr
    {      ( [_1] )}
| _1 = simple_labeled_expr_list _2 = labeled_simple_expr
    {      ( _2 :: _1 )}

labeled_simple_expr:
  _1 = simple_expr %prec below_HASH
    {      ( (Nolabel, _1) )}
| _1 = label_expr
    {      ( _1 )}

label_expr:
  _1 = LABEL _2 = simple_expr %prec below_HASH
    {      ( (Labelled _1, _2) )}
| _1 = TILDE _2 = label_ident
    {      ( (Labelled (fst _2), snd _2) )}
| _1 = QUESTION _2 = label_ident
    {      ( (Optional (fst _2), snd _2) )}
| _1 = OPTLABEL _2 = simple_expr %prec below_HASH
    {      ( (Optional _1, _2) )}

label_ident:
  _1 = LIDENT
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( (_1, mkexp ~loc:_sloc (Pexp_ident(mkrhs (Lident _1) _sloc))) )}

lident_list:
  _1 = LIDENT
    {let _1 =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
                                      ( [_1] )}
| _1 = LIDENT _2 = lident_list
    {let _1 =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
                                      ( _1 :: _2 )}

let_binding_body:
  _1 = val_ident _2 = strict_binding
    {let _1 =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
                ( mkpatvar ~loc:_loc _1 )
in
      ( (_1, _2) )}
| _1 = val_ident _2 = type_constraint _3 = EQUAL _4 = seq_expr
    {let _1 =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
                ( mkpatvar ~loc:_loc _1 )
in
let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let v = _1 in (* PR#7344 *)
        let t =
          match _2 with
            Some t, None -> t
          | _, Some t -> t
          | _ -> assert false
        in
        let loc = Location.(t.ptyp_loc.loc_start, t.ptyp_loc.loc_end) in
        let typ = ghtyp ~loc (Ptyp_poly([],t)) in
        let patloc = (_startpos__1_, _endpos__2_) in
        (ghpat ~loc:patloc (Ppat_constraint(v, typ)),
         mkexp_constraint ~loc:_sloc _4 _2) )}
| _1 = val_ident _2 = COLON _3 = typevar_list _4 = DOT _5 = core_type _6 = EQUAL _7 = seq_expr
    {let _1 =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
                ( mkpatvar ~loc:_loc _1 )
in
      ( let typloc = (_startpos__3_, _endpos__5_) in
        let patloc = (_startpos__1_, _endpos__5_) in
        (ghpat ~loc:patloc
           (Ppat_constraint(_1, ghtyp ~loc:typloc (Ptyp_poly(List.rev _3,_5)))),
         _7) )}
| _1 = val_ident _2 = COLON _3 = TYPE _4 = lident_list _5 = DOT _6 = core_type _7 = EQUAL _8 = seq_expr
    {let _1 =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
                ( mkpatvar ~loc:_loc _1 )
in
let _endpos = _endpos__8_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let exp, poly =
          wrap_type_annotation ~loc:_sloc _4 _6 _8 in
        let loc = (_startpos__1_, _endpos__6_) in
        (ghpat ~loc (Ppat_constraint(_1, poly)), exp) )}
| _1 = pattern_no_exn _2 = EQUAL _3 = seq_expr
    {      ( (_1, _3) )}
| _1 = simple_pattern_not_ident _2 = COLON _3 = core_type _4 = EQUAL _5 = seq_expr
    {      ( let loc = (_startpos__1_, _endpos__3_) in
        (ghpat ~loc (Ppat_constraint(_1, _3)), _5) )}

let_bindings:
  _1 = let_binding
    {                                                ( _1 )}
| _1 = let_bindings _2 = and_let_binding
    {                                                ( addlb _1 _2 )}

let_binding:
  _1 = LET _2 = ext_attributes _3 = rec_flag _4 = let_binding_body _5 = post_item_attributes
    {let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let (ext, attr) = _2 in
        mklbs ~loc:_sloc ext _3 (mklb ~loc:_sloc true _4 (attr@_5)) )}

and_let_binding:
  _1 = AND _2 = attributes _3 = let_binding_body _4 = post_item_attributes
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( mklb ~loc:_sloc false _3 (_2@_4) )}

fun_binding:
  _1 = strict_binding
    {      ( _1 )}
| _1 = type_constraint _2 = EQUAL _3 = seq_expr
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp_constraint ~loc:_sloc _3 _1 )}

strict_binding:
  _1 = EQUAL _2 = seq_expr
    {      ( _2 )}
| _1 = labeled_simple_pattern _2 = fun_binding
    {let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let (l, o, p) = _1 in ghexp ~loc:_sloc (Pexp_fun(l, o, p, _2)) )}
| _1 = LPAREN _2 = TYPE _3 = lident_list _4 = RPAREN _5 = fun_binding
    {let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( mk_newtypes ~loc:_sloc _3 _5 )}

match_cases:
  _1 = match_case
    {               ( [_1] )}
| _1 = match_cases _2 = BAR _3 = match_case
    {                               ( _3 :: _1 )}

match_case:
  _1 = pattern _2 = MINUSGREATER _3 = seq_expr
    {      ( Exp.case _1 _3 )}
| _1 = pattern _2 = WHEN _3 = seq_expr _4 = MINUSGREATER _5 = seq_expr
    {      ( Exp.case _1 ~guard:_3 _5 )}
| _1 = pattern _2 = MINUSGREATER _3 = DOT
    {let _loc__3_ = (_startpos__3_, _endpos__3_) in
      ( Exp.case _1 (Exp.unreachable ~loc:(make_loc _loc__3_) ()) )}

fun_def:
  _1 = MINUSGREATER _2 = seq_expr
    {      ( _2 )}
| _1 = COLON _2 = simple_core_type _3 = MINUSGREATER _4 = seq_expr
    {let _1 =
  let _1 =       ( Pexp_constraint (_4, _2) ) in
  let _endpos__1_ = _endpos__4_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkexp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = labeled_simple_pattern _2 = fun_def
    {let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      (
       let (l,o,p) = _1 in
       ghexp ~loc:_sloc (Pexp_fun(l, o, p, _2))
      )}
| _1 = LPAREN _2 = TYPE _3 = lident_list _4 = RPAREN _5 = fun_def
    {let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( mk_newtypes ~loc:_sloc _3 _5 )}

expr_comma_list:
  _1 = expr_comma_list _2 = COMMA _3 = expr
    {                                                ( _3 :: _1 )}
| _1 = expr _2 = COMMA _3 = expr
    {                                                ( [_3; _1] )}

record_expr:
  _1 = simple_expr _2 = WITH _3 = lbl_expr_list
    {                                                ( (Some _1, _3) )}
| _1 = lbl_expr_list
    {                                                ( (None, _1) )}

lbl_expr_list:
  _1 = lbl_expr
    {              ( [_1] )}
| _1 = lbl_expr _2 = SEMI _3 = lbl_expr_list
    {                                 ( _1 :: _3 )}
| _1 = lbl_expr _2 = SEMI
    {                   ( [_1] )}

lbl_expr:
  _1 = label_longident _2 = opt_type_constraint _3 = EQUAL _4 = expr
    {let _1 =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( (_1, mkexp_opt_constraint ~loc:_sloc _4 _2) )}
| _1 = label_longident _2 = opt_type_constraint
    {let _1 =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( (_1,
         mkexp_opt_constraint ~loc:_sloc
           (exp_of_longident ~loc:_sloc _1) _2) )}

field_expr_list:
  _1 = field_expr _2 = opt_semi
    {                        ( [_1] )}
| _1 = field_expr _2 = SEMI _3 = field_expr_list
    {                                    ( _1 :: _3 )}

field_expr:
  _1 = label _2 = EQUAL _3 = expr
    {let _1 =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
      ( (_1, _3) )}
| _1 = label
    {let _1 =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( (_1, exp_of_label ~loc:_sloc {_1 with txt = Lident _1.txt}) )}

expr_semi_list:
  _1 = expr
    {                                                ( [_1] )}
| _1 = expr_semi_list _2 = SEMI _3 = expr
    {                                                ( _3 :: _1 )}

type_constraint:
  _1 = COLON _2 = core_type
    {                                                ( (Some _2, None) )}
| _1 = COLON _2 = core_type _3 = COLONGREATER _4 = core_type
    {                                                ( (Some _2, Some _4) )}
| _1 = COLONGREATER _2 = core_type
    {                                                ( (None, Some _2) )}
| _1 = COLON _2 = error
    {                                                ( syntax_error() )}
| _1 = COLONGREATER _2 = error
    {                                                ( syntax_error() )}

opt_type_constraint:
  _1 = type_constraint
    {                    ( Some _1 )}
| 
    {                ( None )}

pattern:
  _1 = pattern _2 = COLONCOLON _3 = pattern
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
let _loc__2_ = (_startpos__2_, _endpos__2_) in
let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat_cons ~loc:_sloc _loc__2_ (ghpat ~loc:_sloc (Ppat_tuple[_1;_3])) )}
| _1 = EXCEPTION _2 = ext_attributes _3 = pattern %prec prec_constr_appl
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat_attrs ~loc:_sloc (Ppat_exception _3) _2)}
| _1 = pattern _2 = attribute
    {      ( Pat.attr _1 _2 )}
| _1 = pattern_gen
    {      ( _1 )}
| _1 = pattern _2 = AS _1_inlined1 = val_ident
    {let _1 =
  let _1 =
    let _3 =
      let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
          (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
    in
          ( Ppat_alias(_1, _3) )
  in
  let _endpos__1_ = _endpos__1_inlined1_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = pattern _2 = AS _3 = error
    {let _1 =
  let _1 =
    let _loc__3_ = (_startpos__3_, _endpos__3_) in
          ( expecting _loc__3_ "identifier" )
  in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = pattern_comma_list %prec below_COMMA
    {let _1 =
  let _1 =       ( Ppat_tuple(List.rev _1) ) in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = pattern _2 = COLONCOLON _3 = error
    {let _1 =
  let _1 =
    let _loc__3_ = (_startpos__3_, _endpos__3_) in
          ( expecting _loc__3_ "pattern" )
  in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = pattern _2 = BAR _3 = pattern
    {let _1 =
  let _1 =       ( Ppat_or(_1, _3) ) in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = pattern _2 = BAR _3 = error
    {let _1 =
  let _1 =
    let _loc__3_ = (_startpos__3_, _endpos__3_) in
          ( expecting _loc__3_ "pattern" )
  in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}

pattern_no_exn:
  _1 = pattern_no_exn _2 = COLONCOLON _3 = pattern
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
let _loc__2_ = (_startpos__2_, _endpos__2_) in
let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat_cons ~loc:_sloc _loc__2_ (ghpat ~loc:_sloc (Ppat_tuple[_1;_3])) )}
| _1 = pattern_no_exn _2 = attribute
    {      ( Pat.attr _1 _2 )}
| _1 = pattern_gen
    {      ( _1 )}
| _1 = pattern_no_exn _2 = AS _1_inlined1 = val_ident
    {let _1 =
  let _1 =
    let _3 =
      let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
          (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
    in
          ( Ppat_alias(_1, _3) )
  in
  let _endpos__1_ = _endpos__1_inlined1_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = pattern_no_exn _2 = AS _3 = error
    {let _1 =
  let _1 =
    let _loc__3_ = (_startpos__3_, _endpos__3_) in
          ( expecting _loc__3_ "identifier" )
  in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = pattern_no_exn_comma_list %prec below_COMMA
    {let _1 =
  let _1 =       ( Ppat_tuple(List.rev _1) ) in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = pattern_no_exn _2 = COLONCOLON _3 = error
    {let _1 =
  let _1 =
    let _loc__3_ = (_startpos__3_, _endpos__3_) in
          ( expecting _loc__3_ "pattern" )
  in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = pattern_no_exn _2 = BAR _3 = pattern
    {let _1 =
  let _1 =       ( Ppat_or(_1, _3) ) in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = pattern_no_exn _2 = BAR _3 = error
    {let _1 =
  let _1 =
    let _loc__3_ = (_startpos__3_, _endpos__3_) in
          ( expecting _loc__3_ "pattern" )
  in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}

pattern_gen:
  _1 = simple_pattern
    {      ( _1 )}
| _1 = constr_longident _2 = pattern %prec prec_constr_appl
    {let _1 =
  let _1 =
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
          (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
    in
            ( Ppat_construct(_1, Some _2) )
  in
  let _endpos__1_ = _endpos__2_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = name_tag _2 = pattern %prec prec_constr_appl
    {let _1 =
  let _1 =         ( Ppat_variant(_1, Some _2) ) in
  let _endpos__1_ = _endpos__2_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = LAZY _2 = ext_attributes _3 = simple_pattern
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat_attrs ~loc:_sloc (Ppat_lazy _3) _2)}

simple_pattern:
  _1 = val_ident %prec below_EQUAL
    {let _1 =
  let _1 =
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
          (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
    in
          ( Ppat_var (_1) )
  in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = simple_pattern_not_ident
    {                             ( _1 )}

simple_pattern_not_ident:
  _1 = LPAREN _2 = pattern _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( reloc_pat ~loc:_sloc _2 )}
| _1 = simple_delimited_pattern
    {      ( _1 )}
| _1 = LPAREN _2 = MODULE _3 = ext_attributes _1_inlined1 = UIDENT _5 = RPAREN
    {let _4 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat_attrs ~loc:_sloc (Ppat_unpack _4) _3 )}
| _1 = LPAREN _2 = MODULE _3 = ext_attributes _1_inlined1 = UIDENT _5 = COLON _6 = package_type _7 = RPAREN
    {let _4 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__7_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat_attrs ~loc:_sloc
          (Ppat_constraint(mkpat ~loc:_sloc (Ppat_unpack _4), _6))
          _3 )}
| _1 = UNDERSCORE
    {let _1 =
  let _1 =       ( Ppat_any ) in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = signed_constant
    {let _1 =
  let _1 =       ( Ppat_constant _1 ) in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = signed_constant _2 = DOTDOT _3 = signed_constant
    {let _1 =
  let _1 =       ( Ppat_interval (_1, _3) ) in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = constr_longident
    {let _1 =
  let _1 =
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
          (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
    in
          ( Ppat_construct(_1, None) )
  in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = name_tag
    {let _1 =
  let _1 =       ( Ppat_variant(_1, None) ) in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = HASH _1_inlined1 = type_longident
    {let _1 =
  let _1 =
    let _2 =
      let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
          (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
    in
          ( Ppat_type (_2) )
  in
  let _endpos__1_ = _endpos__1_inlined1_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = mod_longident _2 = DOT _3 = simple_delimited_pattern
    {let _1 =
  let _1 =
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
          (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
    in
          ( Ppat_open(_1, _3) )
  in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = mod_longident _2 = DOT _1_inlined1 = LBRACKET _2_inlined1 = RBRACKET
    {let _1 =
  let _1 =
    let _3 =
      let (_endpos__2_, _startpos__1_, _2, _1) = (_endpos__2_inlined1_, _startpos__1_inlined1_, _2_inlined1, _1_inlined1) in
      let _1 =                                                      (Lident "[]") in
      let _endpos__1_ = _endpos__2_ in
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
          (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
    in
    let _endpos__3_ = _endpos__2_inlined1_ in
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
          (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
    in
    let _endpos = _endpos__3_ in
    let _symbolstartpos = _startpos__1_ in
    let _sloc = (_symbolstartpos, _endpos) in
        ( Ppat_open(_1, mkpat ~loc:_sloc (Ppat_construct(_3, None))) )
  in
  let _endpos__1_ = _endpos__2_inlined1_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = mod_longident _2 = DOT _1_inlined1 = LPAREN _2_inlined1 = RPAREN
    {let _1 =
  let _1 =
    let _3 =
      let (_endpos__2_, _startpos__1_, _2, _1) = (_endpos__2_inlined1_, _startpos__1_inlined1_, _2_inlined1, _1_inlined1) in
      let _1 =                                                  (Lident "()") in
      let _endpos__1_ = _endpos__2_ in
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
          (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
    in
    let _endpos__3_ = _endpos__2_inlined1_ in
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
          (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
    in
    let _endpos = _endpos__3_ in
    let _symbolstartpos = _startpos__1_ in
    let _sloc = (_symbolstartpos, _endpos) in
        ( Ppat_open(_1, mkpat ~loc:_sloc (Ppat_construct(_3, None))) )
  in
  let _endpos__1_ = _endpos__2_inlined1_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = mod_longident _2 = DOT _3 = LPAREN _4 = pattern _5 = RPAREN
    {let _1 =
  let _1 =
    let _1 =
      let _endpos = _endpos__1_ in
      let _startpos = _startpos__1_ in
      let _loc = (_startpos, _endpos) in
          (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
    in
          ( Ppat_open (_1, _4) )
  in
  let _endpos__1_ = _endpos__5_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = mod_longident _2 = DOT _3 = LPAREN _4 = pattern _5 = error
    {let _1 =
  let _1 =
    let _loc__5_ = (_startpos__5_, _endpos__5_) in
    let _loc__3_ = (_startpos__3_, _endpos__3_) in
          ( unclosed "(" _loc__3_ ")" _loc__5_  )
  in
  let _endpos__1_ = _endpos__5_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = mod_longident _2 = DOT _3 = LPAREN _4 = error
    {let _1 =
  let _1 =
    let _loc__4_ = (_startpos__4_, _endpos__4_) in
          ( expecting _loc__4_ "pattern" )
  in
  let _endpos__1_ = _endpos__4_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = LPAREN _2 = pattern _3 = error
    {let _1 =
  let _1 =
    let _loc__3_ = (_startpos__3_, _endpos__3_) in
    let _loc__1_ = (_startpos__1_, _endpos__1_) in
          ( unclosed "(" _loc__1_ ")" _loc__3_ )
  in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = LPAREN _2 = pattern _3 = COLON _4 = core_type _5 = RPAREN
    {let _1 =
  let _1 =       ( Ppat_constraint(_2, _4) ) in
  let _endpos__1_ = _endpos__5_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = LPAREN _2 = pattern _3 = COLON _4 = core_type _5 = error
    {let _1 =
  let _1 =
    let _loc__5_ = (_startpos__5_, _endpos__5_) in
    let _loc__1_ = (_startpos__1_, _endpos__1_) in
          ( unclosed "(" _loc__1_ ")" _loc__5_ )
  in
  let _endpos__1_ = _endpos__5_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = LPAREN _2 = pattern _3 = COLON _4 = error
    {let _1 =
  let _1 =
    let _loc__4_ = (_startpos__4_, _endpos__4_) in
          ( expecting _loc__4_ "type" )
  in
  let _endpos__1_ = _endpos__4_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = LPAREN _2 = MODULE _3 = ext_attributes _4 = UIDENT _5 = COLON _6 = package_type _7 = error
    {let _1 =
  let _1 =
    let _loc__7_ = (_startpos__7_, _endpos__7_) in
    let _loc__1_ = (_startpos__1_, _endpos__1_) in
          ( unclosed "(" _loc__1_ ")" _loc__7_ )
  in
  let _endpos__1_ = _endpos__7_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = extension
    {let _1 =
  let _1 =       ( Ppat_extension _1 ) in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
      ( _1 )}

simple_delimited_pattern:
  _1 = LBRACE _2 = lbl_pattern_list _3 = RBRACE
    {let _1 =
  let _1 =       ( let (fields, closed) = _2 in
        Ppat_record(fields, closed) ) in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
    ( _1 )}
| _1 = LBRACE _2 = lbl_pattern_list _3 = error
    {let _1 =
  let _1 =
    let _loc__3_ = (_startpos__3_, _endpos__3_) in
    let _loc__1_ = (_startpos__1_, _endpos__1_) in
          ( unclosed "{" _loc__1_ "}" _loc__3_ )
  in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
    ( _1 )}
| _1 = LBRACKET _2 = pattern_semi_list _3 = opt_semi _4 = RBRACKET
    {let _1 =
  let _1 =
    let _loc__4_ = (_startpos__4_, _endpos__4_) in
          ( fst (mktailpat _loc__4_ (List.rev _2)) )
  in
  let _endpos__1_ = _endpos__4_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
    ( _1 )}
| _1 = LBRACKET _2 = pattern_semi_list _3 = opt_semi _4 = error
    {let _1 =
  let _1 =
    let _loc__4_ = (_startpos__4_, _endpos__4_) in
    let _loc__1_ = (_startpos__1_, _endpos__1_) in
          ( unclosed "[" _loc__1_ "]" _loc__4_ )
  in
  let _endpos__1_ = _endpos__4_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
    ( _1 )}
| _1 = LBRACKETBAR _2 = pattern_semi_list _3 = opt_semi _4 = BARRBRACKET
    {let _1 =
  let _1 =       ( Ppat_array(List.rev _2) ) in
  let _endpos__1_ = _endpos__4_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
    ( _1 )}
| _1 = LBRACKETBAR _2 = BARRBRACKET
    {let _1 =
  let _1 =       ( Ppat_array [] ) in
  let _endpos__1_ = _endpos__2_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
    ( _1 )}
| _1 = LBRACKETBAR _2 = pattern_semi_list _3 = opt_semi _4 = error
    {let _1 =
  let _1 =
    let _loc__4_ = (_startpos__4_, _endpos__4_) in
    let _loc__1_ = (_startpos__1_, _endpos__1_) in
          ( unclosed "[|" _loc__1_ "|]" _loc__4_ )
  in
  let _endpos__1_ = _endpos__4_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkpat ~loc:_sloc _1 )
in
    ( _1 )}

pattern_comma_list:
  _1 = pattern_comma_list _2 = COMMA _3 = pattern
    {                                                ( _3 :: _1 )}
| _1 = pattern _2 = COMMA _3 = pattern
    {                                                ( [_3; _1] )}
| _1 = pattern _2 = COMMA _3 = error
    {let _loc__3_ = (_startpos__3_, _endpos__3_) in
                                                ( expecting _loc__3_ "pattern" )}

pattern_no_exn_comma_list:
  _1 = pattern_no_exn_comma_list _2 = COMMA _3 = pattern
    {                                                ( _3 :: _1 )}
| _1 = pattern_no_exn _2 = COMMA _3 = pattern
    {                                                ( [_3; _1] )}
| _1 = pattern_no_exn _2 = COMMA _3 = error
    {let _loc__3_ = (_startpos__3_, _endpos__3_) in
                                                ( expecting _loc__3_ "pattern" )}

pattern_semi_list:
  _1 = pattern
    {                                                ( [_1] )}
| _1 = pattern_semi_list _2 = SEMI _3 = pattern
    {                                                ( _3 :: _1 )}

lbl_pattern_list:
  _1 = lbl_pattern
    {                ( [_1], Closed )}
| _1 = lbl_pattern _2 = SEMI
    {                     ( [_1], Closed )}
| _1 = lbl_pattern _2 = SEMI _3 = UNDERSCORE _4 = opt_semi
    {                                         ( [_1], Open )}
| _1 = lbl_pattern _2 = SEMI _3 = lbl_pattern_list
    {      ( let (fields, closed) = _3 in _1 :: fields, closed )}

lbl_pattern:
  _1 = label_longident _2 = opt_pattern_type_constraint _3 = EQUAL _4 = pattern
    {let _1 =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
     ( (_1, mkpat_opt_constraint ~loc:_sloc _4 _2) )}
| _1 = label_longident _2 = opt_pattern_type_constraint
    {let _1 =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
     ( let label = {_1 with txt = Longident.last _1.txt} in
       (_1, mkpat_opt_constraint ~loc:_sloc
              (pat_of_label ~loc:_sloc label) _2) )}

opt_pattern_type_constraint:
  _1 = COLON _2 = core_type
    {                    ( Some _2 )}
| 
    {                ( None )}

value_description:
  _1 = VAL _2 = ext_attributes _1_inlined1 = val_ident _4 = COLON _5 = core_type _6 = post_item_attributes
    {let _3 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__6_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let (ext, attrs) = _2 in
        let docs = symbol_docs _sloc in
        Val.mk _3 _5 ~attrs:(attrs@_6) ~loc:(make_loc _sloc) ~docs, ext )}

primitive_declaration_body:
  _1 = STRING
    {                                                ( [fst _1] )}
| _1 = STRING _2 = primitive_declaration_body
    {                                                ( fst _1 :: _2 )}

primitive_declaration:
  _1 = EXTERNAL _2 = ext_attributes _1_inlined1 = val_ident _4 = COLON _5 = core_type _6 = EQUAL _7 = primitive_declaration_body _8 = post_item_attributes
    {let _3 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__8_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let (ext, attrs) = _2 in
        let docs = symbol_docs _sloc in
        Val.mk _3 _5 ~prim:_7 ~attrs:(attrs@_8) ~loc:(make_loc _sloc) ~docs
        , ext )}

type_declarations:
  _1 = type_declaration
    {      ( let (nonrec_flag, ty, ext) = _1 in (nonrec_flag, [ty], ext) )}
| _1 = type_declarations _2 = and_type_declaration
    {      ( let (nonrec_flag, tys, ext) = _1 in (nonrec_flag, _2 :: tys, ext) )}

type_declaration:
  _1 = TYPE _2 = ext_attributes _3 = nonrec_flag _4 = optional_type_parameters _1_inlined1 = LIDENT _6 = type_kind _7 = constraints _8 = post_item_attributes
    {let _5 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__8_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let (kind, priv, manifest) = _6 in
        let (ext, attrs) = _2 in
        let docs = symbol_docs _sloc in
        let ty =
          Type.mk _5 ~params:_4 ~cstrs:(List.rev _7) ~kind
            ~priv ?manifest ~attrs:(attrs@_8) ~loc:(make_loc _sloc) ~docs
        in
        (_3, ty, ext) )}

and_type_declaration:
  _1 = AND _2 = attributes _3 = optional_type_parameters _1_inlined1 = LIDENT _5 = type_kind _6 = constraints _7 = post_item_attributes
    {let _4 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__7_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let (kind, priv, manifest) = _5 in
        let docs = symbol_docs _sloc in
        let text = symbol_text _symbolstartpos in
        Type.mk _4 ~params:_3 ~cstrs:(List.rev _6)
          ~kind ~priv ?manifest
          ~attrs:(_2@_7) ~loc:(make_loc _sloc) ~docs ~text )}

constraints:
  _1 = constraints _2 = CONSTRAINT _3 = constrain
    {                                                ( _3 :: _1 )}
| 
    {                                                ( [] )}

type_kind:
  
    {      ( (Ptype_abstract, Public, None) )}
| _1 = EQUAL _2 = core_type
    {      ( (Ptype_abstract, Public, Some _2) )}
| _1 = EQUAL _2 = PRIVATE _3 = core_type
    {      ( (Ptype_abstract, Private, Some _3) )}
| _1 = EQUAL _2 = constructor_declarations
    {      ( (Ptype_variant(List.rev _2), Public, None) )}
| _1 = EQUAL _2 = PRIVATE _3 = constructor_declarations
    {      ( (Ptype_variant(List.rev _3), Private, None) )}
| _1 = EQUAL _2 = DOTDOT
    {      ( (Ptype_open, Public, None) )}
| _1 = EQUAL _2 = PRIVATE _3 = DOTDOT
    {      ( (Ptype_open, Private, None) )}
| _1 = EQUAL _2 = private_flag _3 = LBRACE _4 = label_declarations _5 = RBRACE
    {      ( (Ptype_record _4, _2, None) )}
| _1 = EQUAL _2 = core_type _3 = EQUAL _4 = private_flag _5 = constructor_declarations
    {      ( (Ptype_variant(List.rev _5), _4, Some _2) )}
| _1 = EQUAL _2 = core_type _3 = EQUAL _4 = private_flag _5 = DOTDOT
    {      ( (Ptype_open, _4, Some _2) )}
| _1 = EQUAL _2 = core_type _3 = EQUAL _4 = private_flag _5 = LBRACE _6 = label_declarations _7 = RBRACE
    {      ( (Ptype_record _6, _4, Some _2) )}

optional_type_parameters:
  
    {                                                ( [] )}
| _1 = optional_type_parameter
    {                                                ( [_1] )}
| _1 = LPAREN _2 = optional_type_parameter_list _3 = RPAREN
    {                                                ( List.rev _2 )}

optional_type_parameter:
  _1 = type_variance _2 = optional_type_variable
    {                                                ( _2, _1 )}

optional_type_parameter_list:
  _1 = optional_type_parameter
    {                                                         ( [_1] )}
| _1 = optional_type_parameter_list _2 = COMMA _3 = optional_type_parameter
    {                                                                  ( _3 :: _1 )}

optional_type_variable:
  _1 = QUOTE _2 = ident
    {let _1 =
  let _1 =                     ( Ptyp_var _2 ) in
  let _endpos__1_ = _endpos__2_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mktyp ~loc:_sloc _1 )
in
      ( _1 )}
| _1 = UNDERSCORE
    {let _1 =
  let _1 =                     ( Ptyp_any ) in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mktyp ~loc:_sloc _1 )
in
      ( _1 )}

type_parameter:
  _1 = type_variance _2 = type_variable
    {                                                  ( _2, _1 )}

type_variance:
  
    {                                                ( Invariant )}
| _1 = PLUS
    {                                                ( Covariant )}
| _1 = MINUS
    {                                                ( Contravariant )}

type_variable:
  _1 = QUOTE _2 = ident
    {let _1 =
  let _1 =                       ( Ptyp_var _2 ) in
  let _endpos__1_ = _endpos__2_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mktyp ~loc:_sloc _1 )
in
                                       ( _1 )}

type_parameter_list:
  _1 = type_parameter
    {                                                ( [_1] )}
| _1 = type_parameter_list _2 = COMMA _3 = type_parameter
    {                                                ( _3 :: _1 )}

constructor_declarations:
  _1 = BAR
    {                                                         ( [  ] )}
| _1 = constructor_declaration
    {                                                         ( [_1] )}
| _1 = bar_constructor_declaration
    {                                                         ( [_1] )}
| _1 = constructor_declarations _2 = bar_constructor_declaration
    {                                                         ( _2 :: _1 )}

constructor_declaration:
  _1 = constr_ident _2 = generalized_constructor_arguments _3 = attributes
    {let _1 =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( let args,res = _2 in
      let info = symbol_info _endpos in
      Type.constructor _1 ~args ?res ~attrs:_3 ~loc:(make_loc _sloc) ~info )}

bar_constructor_declaration:
  _1 = BAR _1_inlined1 = constr_ident _3 = generalized_constructor_arguments _4 = attributes
    {let _2 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( let args,res = _3 in
      let info = symbol_info _endpos in
      Type.constructor _2 ~args ?res ~attrs:_4 ~loc:(make_loc _sloc) ~info )}

str_exception_declaration:
  _1 = sig_exception_declaration
    {                                                 ( _1 )}
| _1 = EXCEPTION _2 = ext_attributes _1_inlined1 = constr_ident _4 = EQUAL _1_inlined2 = constr_longident _6 = attributes _7 = post_item_attributes
    {let _5 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined2_, _startpos__1_inlined2_, _1_inlined2) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _3 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__7_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( let (ext,attrs) = _2 in
      let docs = symbol_docs _sloc in
      Te.mk_exception ~attrs:_7
        (Te.rebind _3 _5 ~attrs:(attrs @ _6) ~loc:(make_loc _sloc) ~docs)
      , ext )}

sig_exception_declaration:
  _1 = EXCEPTION _2 = ext_attributes _1_inlined1 = constr_ident _4 = generalized_constructor_arguments _5 = attributes _6 = post_item_attributes
    {let _3 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__6_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let args, res = _4 in
        let (ext,attrs) = _2 in
        let docs = symbol_docs _sloc in
        Te.mk_exception ~attrs:_6
          (Te.decl _3 ~args ?res
                      ~attrs:(attrs @ _5) ~loc:(make_loc _sloc) ~docs)
        , ext )}

let_exception_declaration:
  _1 = constr_ident _2 = generalized_constructor_arguments _3 = attributes
    {let _1 =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let args, res = _2 in
        Te.decl _1 ~args ?res ~attrs:_3 ~loc:(make_loc _sloc) )}

generalized_constructor_arguments:
  
    {                                  ( (Pcstr_tuple [],None) )}
| _1 = OF _2 = constructor_arguments
    {                                  ( (_2,None) )}
| _1 = COLON _2 = constructor_arguments _3 = MINUSGREATER _4 = simple_core_type
    {                                  ( (_2,Some _4) )}
| _1 = COLON _2 = simple_core_type
    {                                  ( (Pcstr_tuple [],Some _2) )}

constructor_arguments:
  _1 = core_type_list
    {                                     ( Pcstr_tuple (List.rev _1) )}
| _1 = LBRACE _2 = label_declarations _3 = RBRACE
    {                                     ( Pcstr_record _2 )}

label_declarations:
  _1 = label_declaration
    {                                                ( [_1] )}
| _1 = label_declaration_semi
    {                                                ( [_1] )}
| _1 = label_declaration_semi _2 = label_declarations
    {                                                ( _1 :: _2 )}

label_declaration:
  _1 = mutable_flag _1_inlined1 = label _3 = COLON _4 = poly_type_no_attr _5 = attributes
    {let _2 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _startpos__2_ = _startpos__1_inlined1_ in
let _endpos = _endpos__5_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let info = symbol_info _endpos in
        Type.field _2 _4 ~mut:_1 ~attrs:_5 ~loc:(make_loc _sloc) ~info )}

label_declaration_semi:
  _1 = mutable_flag _1_inlined1 = label _3 = COLON _4 = poly_type_no_attr _5 = attributes _6 = SEMI _7 = attributes
    {let _2 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _startpos__2_ = _startpos__1_inlined1_ in
let _endpos = _endpos__7_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let info =
          match rhs_info _endpos__5_ with
          | Some _ as info_before_semi -> info_before_semi
          | None -> symbol_info _endpos
       in
       Type.field _2 _4 ~mut:_1 ~attrs:(_5 @ _7) ~loc:(make_loc _sloc) ~info )}

str_type_extension:
  _1 = TYPE _2 = ext_attributes _3 = nonrec_flag _4 = optional_type_parameters _1_inlined1 = type_longident _6 = PLUSEQ _7 = private_flag _8 = str_extension_constructors _9 = post_item_attributes
    {let _5 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__9_ in
let _symbolstartpos = _startpos__1_ in
let _loc__3_ = (_startpos__3_, _endpos__3_) in
let _sloc = (_symbolstartpos, _endpos) in
      ( let (ext, attrs) = _2 in
        if _3 <> Recursive then not_expecting _loc__3_ "nonrec flag";
        let docs = symbol_docs _sloc in
        Te.mk _5 (List.rev _8) ~params:_4 ~priv:_7 ~attrs:(attrs@_9) ~docs
        , ext )}

sig_type_extension:
  _1 = TYPE _2 = ext_attributes _3 = nonrec_flag _4 = optional_type_parameters _1_inlined1 = type_longident _6 = PLUSEQ _7 = private_flag _8 = sig_extension_constructors _9 = post_item_attributes
    {let _5 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__9_ in
let _symbolstartpos = _startpos__1_ in
let _loc__3_ = (_startpos__3_, _endpos__3_) in
let _sloc = (_symbolstartpos, _endpos) in
      ( let (ext, attrs) = _2 in
        if _3 <> Recursive then not_expecting _loc__3_ "nonrec flag";
        let docs = symbol_docs _sloc in
        Te.mk _5 (List.rev _8) ~params:_4 ~priv:_7 ~attrs:(attrs@_9) ~docs
        , ext )}

str_extension_constructors:
  _1 = extension_constructor_declaration
    {                                                          ( [_1] )}
| _1 = bar_extension_constructor_declaration
    {                                                          ( [_1] )}
| _1 = extension_constructor_rebind
    {                                                          ( [_1] )}
| _1 = bar_extension_constructor_rebind
    {                                                          ( [_1] )}
| _1 = str_extension_constructors _2 = bar_extension_constructor_declaration
    {      ( _2 :: _1 )}
| _1 = str_extension_constructors _2 = bar_extension_constructor_rebind
    {      ( _2 :: _1 )}

sig_extension_constructors:
  _1 = extension_constructor_declaration
    {                                                          ( [_1] )}
| _1 = bar_extension_constructor_declaration
    {                                                          ( [_1] )}
| _1 = sig_extension_constructors _2 = bar_extension_constructor_declaration
    {      ( _2 :: _1 )}

extension_constructor_declaration:
  _1 = constr_ident _2 = generalized_constructor_arguments _3 = attributes
    {let _1 =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let args, res = _2 in
        let info = symbol_info _endpos in
        Te.decl _1 ~args ?res ~attrs:_3 ~loc:(make_loc _sloc) ~info )}

bar_extension_constructor_declaration:
  _1 = BAR _1_inlined1 = constr_ident _3 = generalized_constructor_arguments _4 = attributes
    {let _2 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let args, res = _3 in
        let info = symbol_info _endpos in
        Te.decl _2 ~args ?res ~attrs:_4 ~loc:(make_loc _sloc) ~info )}

extension_constructor_rebind:
  _1 = constr_ident _2 = EQUAL _1_inlined1 = constr_longident _4 = attributes
    {let _3 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _1 =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let info = symbol_info _endpos in
        Te.rebind _1 _3 ~attrs:_4 ~loc:(make_loc _sloc) ~info )}

bar_extension_constructor_rebind:
  _1 = BAR _1_inlined1 = constr_ident _3 = EQUAL _1_inlined2 = constr_longident _5 = attributes
    {let _4 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined2_, _startpos__1_inlined2_, _1_inlined2) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _2 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let info = symbol_info _endpos in
        Te.rebind _2 _4 ~attrs:_5 ~loc:(make_loc _sloc) ~info )}

with_constraints:
  _1 = with_constraint
    {                                                ( [_1] )}
| _1 = with_constraints _2 = AND _3 = with_constraint
    {                                                ( _3 :: _1 )}

with_constraint:
  _1 = TYPE _2 = optional_type_parameters _1_inlined1 = label_longident _4 = with_type_binder _5 = core_type_no_attr _6 = constraints
    {let _3 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__6_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let lident = Location.{ _3 with txt = Longident.last _3.txt } in
        Pwith_type
          (_3,
           (Type.mk lident
              ~params:_2
              ~cstrs:(List.rev _6)
              ~manifest:_5
              ~priv:_4
              ~loc:(make_loc _sloc))) )}
| _1 = TYPE _2 = optional_type_parameters _1_inlined1 = label_longident _4 = COLONEQUAL _5 = core_type_no_attr
    {let _3 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let lident = Location.{ _3 with txt = Longident.last _3.txt } in
        Pwith_typesubst
         (_3,
           (Type.mk lident
              ~params:_2
              ~manifest:_5
              ~loc:(make_loc _sloc))) )}
| _1 = MODULE _1_inlined1 = mod_longident _3 = EQUAL _1_inlined2 = mod_ext_longident
    {let _4 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined2_, _startpos__1_inlined2_, _1_inlined2) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _2 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
      ( Pwith_module (_2, _4) )}
| _1 = MODULE _1_inlined1 = mod_longident _3 = COLONEQUAL _1_inlined2 = mod_ext_longident
    {let _4 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined2_, _startpos__1_inlined2_, _1_inlined2) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _2 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
      ( Pwith_modsubst (_2, _4) )}

with_type_binder:
  _1 = EQUAL
    {                   ( Public )}
| _1 = EQUAL _2 = PRIVATE
    {                   ( Private )}

typevar_list:
  _1 = QUOTE _1_inlined1 = ident
    {let _2 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
                                                ( [_2] )}
| _1 = typevar_list _2 = QUOTE _1_inlined1 = ident
    {let _3 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
                                                ( _3 :: _1 )}

poly_type:
  _1 = core_type
    {          ( _1 )}
| _1 = typevar_list _2 = DOT _3 = core_type
    {let _1 =
  let _1 =           ( Ptyp_poly(List.rev _1, _3) ) in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mktyp ~loc:_sloc _1 )
in
          ( _1 )}

poly_type_no_attr:
  _1 = core_type_no_attr
    {          ( _1 )}
| _1 = typevar_list _2 = DOT _3 = core_type_no_attr
    {let _1 =
  let _1 =           ( Ptyp_poly(List.rev _1, _3) ) in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mktyp ~loc:_sloc _1 )
in
          ( _1 )}

core_type:
  _1 = core_type_no_attr
    {      ( _1 )}
| _1 = core_type _2 = attribute
    {      ( Typ.attr _1 _2 )}

core_type_no_attr:
  _1 = core_type2 %prec MINUSGREATER
    {      ( _1 )}
| _1 = core_type2 _2 = AS _3 = QUOTE _4 = ident
    {let _1 =
  let _1 =       ( Ptyp_alias(_1, _4) ) in
  let _endpos__1_ = _endpos__4_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mktyp ~loc:_sloc _1 )
in
      ( _1 )}

core_type2:
  _1 = simple_core_type_or_tuple
    {      ( _1 )}
| _1 = core_type2_
    {let _1 =
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mktyp ~loc:_sloc _1 )
in
      ( _1 )}

core_type2_:
  _1 = QUESTION _2 = LIDENT _3 = COLON _1_inlined1 = core_type2 _5 = MINUSGREATER _6 = core_type2
    {let _4 =
  let (_endpos__1_, _1) = (_endpos__1_inlined1_, _1_inlined1) in
    ( extra_rhs_core_type _1 ~pos:_endpos__1_ )
in
      ( Ptyp_arrow(Optional _2, _4, _6) )}
| _1 = OPTLABEL _1_inlined1 = core_type2 _3 = MINUSGREATER _4 = core_type2
    {let _2 =
  let (_endpos__1_, _1) = (_endpos__1_inlined1_, _1_inlined1) in
    ( extra_rhs_core_type _1 ~pos:_endpos__1_ )
in
      ( Ptyp_arrow(Optional _1 , _2, _4) )}
| _1 = LIDENT _2 = COLON _1_inlined1 = core_type2 _4 = MINUSGREATER _5 = core_type2
    {let _3 =
  let (_endpos__1_, _1) = (_endpos__1_inlined1_, _1_inlined1) in
    ( extra_rhs_core_type _1 ~pos:_endpos__1_ )
in
      ( Ptyp_arrow(Labelled _1, _3, _5) )}
| _1 = core_type2 _2 = MINUSGREATER _3 = core_type2
    {let _1 =   ( extra_rhs_core_type _1 ~pos:_endpos__1_ ) in
      ( Ptyp_arrow(Nolabel, _1, _3) )}

simple_core_type:
  _1 = simple_core_type2 %prec below_HASH
    {      ( _1 )}
| _1 = LPAREN _2 = core_type _3 = RPAREN %prec below_HASH
    {      ( _2 )}

simple_core_type2:
  _1 = LPAREN _2 = MODULE _3 = ext_attributes _4 = package_type _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( wrap_typ_attrs ~loc:_sloc (reloc_typ ~loc:_sloc _4) _3 )}
| _1 = simple_core_type2_
    {let _1 =
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mktyp ~loc:_sloc _1 )
in
      ( _1 )}

simple_core_type2_:
  _1 = QUOTE _2 = ident
    {      ( Ptyp_var _2 )}
| _1 = UNDERSCORE
    {      ( Ptyp_any )}
| _1 = type_longident
    {let _1 =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
      ( Ptyp_constr(_1, []) )}
| _1 = simple_core_type2 _1_inlined1 = type_longident
    {let _2 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
      ( Ptyp_constr(_2, [_1]) )}
| _1 = LPAREN x = core_type _3 = RPAREN _1_inlined1 = type_longident
    {let _4 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _2 =
  let tys =     ( [ x ] ) in
      ( tys )
in
      ( Ptyp_constr(_4, List.rev _2) )}
| _1 = LPAREN xs = reversed_separated_nonempty_list_COMMA_core_type_ _2 = COMMA x = core_type _3 = RPAREN _1_inlined1 = type_longident
    {let _4 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _2 =
  let tys =     ( x :: xs ) in
      ( tys )
in
      ( Ptyp_constr(_4, List.rev _2) )}
| _1 = LESS _2 = meth_list _3 = GREATER
    {      ( let (f, c) = _2 in Ptyp_object (f, c) )}
| _1 = LESS _2 = GREATER
    {      ( Ptyp_object ([], Closed) )}
| _1 = HASH _1_inlined1 = class_longident
    {let _2 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
      ( Ptyp_class(_2, []) )}
| _1 = simple_core_type2 _2 = HASH _1_inlined1 = class_longident
    {let _3 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
      ( Ptyp_class(_3, [_1]) )}
| _1 = LPAREN x = core_type _3 = RPAREN _4 = HASH _1_inlined1 = class_longident
    {let _5 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _2 =
  let tys =     ( [ x ] ) in
      ( tys )
in
      ( Ptyp_class(_5, List.rev _2) )}
| _1 = LPAREN xs = reversed_separated_nonempty_list_COMMA_core_type_ _2 = COMMA x = core_type _3 = RPAREN _4 = HASH _1_inlined1 = class_longident
    {let _5 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _2 =
  let tys =     ( x :: xs ) in
      ( tys )
in
      ( Ptyp_class(_5, List.rev _2) )}
| _1 = LBRACKET _2 = tag_field _3 = RBRACKET
    {      ( Ptyp_variant([_2], Closed, None) )}
| _1 = LBRACKET _2 = BAR _3 = row_field_list _4 = RBRACKET
    {      ( Ptyp_variant(List.rev _3, Closed, None) )}
| _1 = LBRACKET _2 = row_field _3 = BAR _4 = row_field_list _5 = RBRACKET
    {      ( Ptyp_variant(_2 :: List.rev _4, Closed, None) )}
| _1 = LBRACKETGREATER _2 = opt_bar _3 = row_field_list _4 = RBRACKET
    {      ( Ptyp_variant(List.rev _3, Open, None) )}
| _1 = LBRACKETGREATER _2 = RBRACKET
    {      ( Ptyp_variant([], Open, None) )}
| _1 = LBRACKETLESS _2 = opt_bar _3 = row_field_list _4 = RBRACKET
    {      ( Ptyp_variant(List.rev _3, Closed, Some []) )}
| _1 = LBRACKETLESS _2 = opt_bar _3 = row_field_list _4 = GREATER _5 = name_tag_list _6 = RBRACKET
    {      ( Ptyp_variant(List.rev _3, Closed, Some (List.rev _5)) )}
| _1 = extension
    {      ( Ptyp_extension _1 )}

package_type:
  _1 = module_type
    {let _1 =
  let _1 =       ( Ptyp_package (package_type_of_module_type _1) ) in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mktyp ~loc:_sloc _1 )
in
      ( _1 )}

row_field_list:
  _1 = row_field
    {                                                ( [_1] )}
| _1 = row_field_list _2 = BAR _3 = row_field
    {                                                ( _3 :: _1 )}

row_field:
  _1 = tag_field
    {                       ( _1 )}
| _1 = simple_core_type
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                       ( Rf.inherit_ ~loc:(make_loc _sloc) _1 )}

tag_field:
  _1 = name_tag _2 = OF _3 = opt_ampersand _4 = amper_type_list _5 = attributes
    {let _1 =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let info = symbol_info _endpos in
        let attrs = add_info_attrs info _5 in
        Rf.tag ~loc:(make_loc _sloc) ~attrs _1 _3 (List.rev _4) )}
| _1 = name_tag _2 = attributes
    {let _1 =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( let info = symbol_info _endpos in
        let attrs = add_info_attrs info _2 in
        Rf.tag ~loc:(make_loc _sloc) ~attrs _1 true [] )}

opt_ampersand:
  _1 = AMPERSAND
    {                                                ( true )}
| 
    {                                                ( false )}

amper_type_list:
  _1 = core_type_no_attr
    {                                                ( [_1] )}
| _1 = amper_type_list _2 = AMPERSAND _3 = core_type_no_attr
    {                                                ( _3 :: _1 )}

name_tag_list:
  _1 = name_tag
    {                                                ( [_1] )}
| _1 = name_tag_list _2 = name_tag
    {                                                ( _2 :: _1 )}

simple_core_type_or_tuple:
  _1 = simple_core_type
    {                     ( _1 )}
| _1 = simple_core_type _2 = STAR _3 = core_type_list
    {let _1 =
  let _1 =       ( Ptyp_tuple(_1 :: List.rev _3) ) in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mktyp ~loc:_sloc _1 )
in
      ( _1 )}

core_type_list:
  _1 = simple_core_type
    {                                           ( [_1] )}
| _1 = core_type_list _2 = STAR _3 = simple_core_type
    {                                           ( _3 :: _1 )}

meth_list:
  _1 = field_semi _2 = meth_list
    {      ( let (f, c) = _2 in (_1 :: f, c) )}
| _1 = inherit_field_semi _2 = meth_list
    {      ( let (f, c) = _2 in (_1 :: f, c) )}
| _1 = field_semi
    {                         ( [_1], Closed )}
| _1 = field
    {                         ( [_1], Closed )}
| _1 = inherit_field_semi
    {                         ( [_1], Closed )}
| _1 = simple_core_type
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
                         ( [Of.inherit_ ~loc:(make_loc _sloc) _1], Closed )}
| _1 = DOTDOT
    {                         ( [], Open )}

field:
  _1 = label _2 = COLON _3 = poly_type_no_attr _4 = attributes
    {let _1 =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( let info = symbol_info _endpos in
      let attrs = add_info_attrs info _4 in
      Of.tag ~loc:(make_loc _sloc) ~attrs _1 _3 )}

field_semi:
  _1 = label _2 = COLON _3 = poly_type_no_attr _4 = attributes _5 = SEMI _6 = attributes
    {let _1 =
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
let _endpos = _endpos__6_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( let info =
        match rhs_info _endpos__4_ with
        | Some _ as info_before_semi -> info_before_semi
        | None -> symbol_info _endpos
      in
      let attrs = add_info_attrs info (_4 @ _6) in
      Of.tag ~loc:(make_loc _sloc) ~attrs _1 _3 )}

inherit_field_semi:
  _1 = simple_core_type _2 = SEMI
    {let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( Of.inherit_ ~loc:(make_loc _sloc) _1 )}

label:
  _1 = LIDENT
    {                                                ( _1 )}

constant:
  _1 = INT
    {                 ( let (n, m) = _1 in Pconst_integer (n, m) )}
| _1 = CHAR
    {                 ( Pconst_char _1 )}
| _1 = STRING
    {                 ( let (s, d) = _1 in Pconst_string (s, d) )}
| _1 = FLOAT
    {                 ( let (f, m) = _1 in Pconst_float (f, m) )}

signed_constant:
  _1 = constant
    {                 ( _1 )}
| _1 = MINUS _2 = INT
    {                 ( let (n, m) = _2 in Pconst_integer("-" ^ n, m) )}
| _1 = MINUS _2 = FLOAT
    {                 ( let (f, m) = _2 in Pconst_float("-" ^ f, m) )}
| _1 = PLUS _2 = INT
    {                 ( let (n, m) = _2 in Pconst_integer (n, m) )}
| _1 = PLUS _2 = FLOAT
    {                 ( let (f, m) = _2 in Pconst_float(f, m) )}

ident:
  _1 = UIDENT
    {                              ( _1 )}
| _1 = LIDENT
    {                              ( _1 )}

val_ident:
  _1 = LIDENT
    {                              ( _1 )}
| _1 = LPAREN _2 = operator _3 = RPAREN
    {                              ( _2 )}
| _1 = LPAREN _2 = operator _3 = error
    {let _loc__3_ = (_startpos__3_, _endpos__3_) in
let _loc__1_ = (_startpos__1_, _endpos__1_) in
                              ( unclosed "(" _loc__1_ ")" _loc__3_ )}
| _1 = LPAREN _2 = error
    {let _loc__2_ = (_startpos__2_, _endpos__2_) in
                              ( expecting _loc__2_ "operator" )}
| _1 = LPAREN _2 = MODULE _3 = error
    {let _loc__3_ = (_startpos__3_, _endpos__3_) in
                              ( expecting _loc__3_ "module-expr" )}

operator:
  _1 = PREFIXOP
    {                                                ( _1 )}
| _1 = INFIXOP0
    {                                                ( _1 )}
| _1 = INFIXOP1
    {                                                ( _1 )}
| _1 = INFIXOP2
    {                                                ( _1 )}
| _1 = INFIXOP3
    {                                                ( _1 )}
| _1 = INFIXOP4
    {                                                ( _1 )}
| _1 = DOTOP _2 = LPAREN _3 = RPAREN
    {                                                ( "."^ _1 ^"()" )}
| _1 = DOTOP _2 = LPAREN _3 = RPAREN _4 = LESSMINUS
    {                                                ( "."^ _1 ^ "()<-" )}
| _1 = DOTOP _2 = LBRACKET _3 = RBRACKET
    {                                                ( "."^ _1 ^"[]" )}
| _1 = DOTOP _2 = LBRACKET _3 = RBRACKET _4 = LESSMINUS
    {                                                ( "."^ _1 ^ "[]<-" )}
| _1 = DOTOP _2 = LBRACE _3 = RBRACE
    {                                                ( "."^ _1 ^"{}" )}
| _1 = DOTOP _2 = LBRACE _3 = RBRACE _4 = LESSMINUS
    {                                                ( "."^ _1 ^ "{}<-" )}
| _1 = HASHOP
    {                                                ( _1 )}
| _1 = BANG
    {                                                ( "!" )}
| _1 = PLUS
    {                                                ( "+" )}
| _1 = PLUSDOT
    {                                                ( "+." )}
| _1 = MINUS
    {                                                ( "-" )}
| _1 = MINUSDOT
    {                                                ( "-." )}
| _1 = STAR
    {                                                ( "*" )}
| _1 = EQUAL
    {                                                ( "=" )}
| _1 = LESS
    {                                                ( "<" )}
| _1 = GREATER
    {                                                ( ">" )}
| _1 = OR
    {                                                ( "or" )}
| _1 = BARBAR
    {                                                ( "||" )}
| _1 = AMPERSAND
    {                                                ( "&" )}
| _1 = AMPERAMPER
    {                                                ( "&&" )}
| _1 = COLONEQUAL
    {                                                ( ":=" )}
| _1 = PLUSEQ
    {                                                ( "+=" )}
| _1 = PERCENT
    {                                                ( "%" )}

constr_ident:
  _1 = UIDENT
    {                                                ( _1 )}
| _1 = LBRACKET _2 = RBRACKET
    {                                                ( "[]" )}
| _1 = LPAREN _2 = RPAREN
    {                                                ( "()" )}
| _1 = LPAREN _2 = COLONCOLON _3 = RPAREN
    {                                                ( "::" )}
| _1 = FALSE
    {                                                ( "false" )}
| _1 = TRUE
    {                                                ( "true" )}

val_longident:
  _1 = val_ident
    {                                                ( Lident _1 )}
| _1 = mod_longident _2 = DOT _3 = val_ident
    {                                                ( Ldot(_1, _3) )}

constr_longident:
  _1 = mod_longident %prec below_DOT
    {                                                ( _1 )}
| _1 = mod_longident _2 = DOT _3 = LPAREN _4 = COLONCOLON _5 = RPAREN
    {                                                ( Ldot(_1,"::") )}
| _1 = LBRACKET _2 = RBRACKET
    {                                                ( Lident "[]" )}
| _1 = LPAREN _2 = RPAREN
    {                                                ( Lident "()" )}
| _1 = LPAREN _2 = COLONCOLON _3 = RPAREN
    {                                                ( Lident "::" )}
| _1 = FALSE
    {                                                ( Lident "false" )}
| _1 = TRUE
    {                                                ( Lident "true" )}

label_longident:
  _1 = LIDENT
    {                                                ( Lident _1 )}
| _1 = mod_longident _2 = DOT _3 = LIDENT
    {                                                ( Ldot(_1, _3) )}

type_longident:
  _1 = LIDENT
    {                                                ( Lident _1 )}
| _1 = mod_ext_longident _2 = DOT _3 = LIDENT
    {                                                ( Ldot(_1, _3) )}

mod_longident:
  _1 = UIDENT
    {                                                ( Lident _1 )}
| _1 = mod_longident _2 = DOT _3 = UIDENT
    {                                                ( Ldot(_1, _3) )}

mod_ext_longident:
  _1 = UIDENT
    {                                                ( Lident _1 )}
| _1 = mod_ext_longident _2 = DOT _3 = UIDENT
    {                                                ( Ldot(_1, _3) )}
| _1 = mod_ext_longident _2 = LPAREN _3 = mod_ext_longident _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
      ( lapply ~loc:_sloc _1 _3 )}

mty_longident:
  _1 = ident
    {                                                ( Lident _1 )}
| _1 = mod_ext_longident _2 = DOT _3 = ident
    {                                                ( Ldot(_1, _3) )}

clty_longident:
  _1 = LIDENT
    {                                                ( Lident _1 )}
| _1 = mod_ext_longident _2 = DOT _3 = LIDENT
    {                                                ( Ldot(_1, _3) )}

class_longident:
  _1 = LIDENT
    {                                                ( Lident _1 )}
| _1 = mod_longident _2 = DOT _3 = LIDENT
    {                                                ( Ldot(_1, _3) )}

toplevel_directive:
  _1 = toplevel_directive_
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( let (dir, arg) = _1 in
      mk_directive ~loc:_sloc dir arg )}

toplevel_directive_:
  _1 = HASH _1_inlined1 = ident
    {let _2 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
    ( _2, None )}
| _1 = HASH _1_inlined1 = ident _3 = toplevel_directive_argument
    {let _2 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let _endpos = _endpos__1_ in
  let _startpos = _startpos__1_ in
  let _loc = (_startpos, _endpos) in
      (
      (* Semantically we could use $symbolstartpos instead of $startpos
         here, but the code comes from calls to (Parsing.rhs_loc p) for
         some position p, which rather corresponds to
         $startpos, so we kept it for compatibility.

         I do not know if mkrhs is ever used in a situation where $startpos
         and $symbolpos do not coincide.  *)
      mkrhs _1 _loc )
in
    ( _2, Some _3 )}

toplevel_directive_argument:
  _1 = toplevel_directive_argument_
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( mk_directive_arg ~loc:_sloc _1 )}

toplevel_directive_argument_:
  _1 = STRING
    {                  ( let (s, _) = _1 in Pdir_string s )}
| _1 = INT
    {                  ( let (n, m) = _1 in Pdir_int (n ,m) )}
| _1 = val_longident
    {                  ( Pdir_ident _1 )}
| _1 = mod_longident
    {                  ( Pdir_ident _1 )}
| _1 = FALSE
    {                  ( Pdir_bool false )}
| _1 = TRUE
    {                  ( Pdir_bool true )}

name_tag:
  _1 = BACKQUOTE _2 = ident
    {                                                ( _2 )}

rec_flag:
  
    {                                                ( Nonrecursive )}
| _1 = REC
    {                                                ( Recursive )}

nonrec_flag:
  
    {                                                ( Recursive )}
| _1 = NONREC
    {                                                ( Nonrecursive )}

direction_flag:
  _1 = TO
    {                                                ( Upto )}
| _1 = DOWNTO
    {                                                ( Downto )}

private_flag:
  
    {                                                ( Public )}
| _1 = PRIVATE
    {                                                ( Private )}

mutable_flag:
  
    {                                                ( Immutable )}
| _1 = MUTABLE
    {                                                ( Mutable )}

virtual_flag:
  
    {                                                ( Concrete )}
| _1 = VIRTUAL
    {                                                ( Virtual )}

private_virtual_flags:
  
    {                 ( Public, Concrete )}
| _1 = PRIVATE
    {            ( Private, Concrete )}
| _1 = VIRTUAL
    {            ( Public, Virtual )}
| _1 = PRIVATE _2 = VIRTUAL
    {                    ( Private, Virtual )}
| _1 = VIRTUAL _2 = PRIVATE
    {                    ( Private, Virtual )}

override_flag:
  
    {                                                ( Fresh )}
| _1 = BANG
    {                                                ( Override )}

opt_bar:
  
    {                                                ( () )}
| _1 = BAR
    {                                                ( () )}

opt_semi:
  
    {                                                ( () )}
| _1 = SEMI
    {                                                ( () )}

subtractive:
  _1 = MINUS
    {                                                ( "-" )}
| _1 = MINUSDOT
    {                                                ( "-." )}

additive:
  _1 = PLUS
    {                                                ( "+" )}
| _1 = PLUSDOT
    {                                                ( "+." )}

single_attr_id:
  _1 = LIDENT
    {           ( _1 )}
| _1 = UIDENT
    {           ( _1 )}
| _1 = AND
    {        ( "and" )}
| _1 = AS
    {       ( "as" )}
| _1 = ASSERT
    {           ( "assert" )}
| _1 = BEGIN
    {          ( "begin" )}
| _1 = CLASS
    {          ( "class" )}
| _1 = CONSTRAINT
    {               ( "constraint" )}
| _1 = DO
    {       ( "do" )}
| _1 = DONE
    {         ( "done" )}
| _1 = DOWNTO
    {           ( "downto" )}
| _1 = ELSE
    {         ( "else" )}
| _1 = END
    {        ( "end" )}
| _1 = EXCEPTION
    {              ( "exception" )}
| _1 = EXTERNAL
    {             ( "external" )}
| _1 = FALSE
    {          ( "false" )}
| _1 = FOR
    {        ( "for" )}
| _1 = FUN
    {        ( "fun" )}
| _1 = FUNCTION
    {             ( "function" )}
| _1 = FUNCTOR
    {            ( "functor" )}
| _1 = IF
    {       ( "if" )}
| _1 = IN
    {       ( "in" )}
| _1 = INCLUDE
    {            ( "include" )}
| _1 = INHERIT
    {            ( "inherit" )}
| _1 = INITIALIZER
    {                ( "initializer" )}
| _1 = LAZY
    {         ( "lazy" )}
| _1 = LET
    {        ( "let" )}
| _1 = MATCH
    {          ( "match" )}
| _1 = METHOD
    {           ( "method" )}
| _1 = MODULE
    {           ( "module" )}
| _1 = MUTABLE
    {            ( "mutable" )}
| _1 = NEW
    {        ( "new" )}
| _1 = NONREC
    {           ( "nonrec" )}
| _1 = OBJECT
    {           ( "object" )}
| _1 = OF
    {       ( "of" )}
| _1 = OPEN
    {         ( "open" )}
| _1 = OR
    {       ( "or" )}
| _1 = PRIVATE
    {            ( "private" )}
| _1 = REC
    {        ( "rec" )}
| _1 = SIG
    {        ( "sig" )}
| _1 = STRUCT
    {           ( "struct" )}
| _1 = THEN
    {         ( "then" )}
| _1 = TO
    {       ( "to" )}
| _1 = TRUE
    {         ( "true" )}
| _1 = TRY
    {        ( "try" )}
| _1 = TYPE
    {         ( "type" )}
| _1 = VAL
    {        ( "val" )}
| _1 = VIRTUAL
    {            ( "virtual" )}
| _1 = WHEN
    {         ( "when" )}
| _1 = WHILE
    {          ( "while" )}
| _1 = WITH
    {         ( "with" )}

attr_id:
  _1 = single_attr_id
    {let _1 =
  let _1 =                      ( _1 ) in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkloc _1 (make_loc _sloc) )
in
    ( _1 )}
| _1 = single_attr_id _2 = DOT _3 = attr_id
    {let _1 =
  let _1 =                                  ( _1 ^ "." ^ _3.txt ) in
  let _endpos__1_ = _endpos__3_ in
  let _endpos = _endpos__1_ in
  let _symbolstartpos = _startpos__1_ in
  let _sloc = (_symbolstartpos, _endpos) in
      ( mkloc _1 (make_loc _sloc) )
in
    ( _1 )}

attribute:
  _1 = LBRACKETAT _2 = attr_id _3 = payload _4 = RBRACKET
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( Attr.mk ~loc:(make_loc _sloc) _2 _3 )}

post_item_attribute:
  _1 = LBRACKETATAT _2 = attr_id _3 = payload _4 = RBRACKET
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( Attr.mk ~loc:(make_loc _sloc) _2 _3 )}

floating_attribute:
  _1 = LBRACKETATATAT _2 = attr_id _3 = payload _4 = RBRACKET
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
let _sloc = (_symbolstartpos, _endpos) in
    ( mark_symbol_docs _sloc;
      Attr.mk ~loc:(make_loc _sloc) _2 _3 )}

post_item_attributes:
  
    {                 ( [] )}
| _1 = post_item_attribute _2 = post_item_attributes
    {                                             ( _1 :: _2 )}

attributes:
  
    {               ( [] )}
| _1 = attribute _2 = attributes
    {                         ( _1 :: _2 )}

ext_attributes:
  
    {                 ( None, [] )}
| _1 = attribute _2 = attributes
    {                         ( None, _1 :: _2 )}
| _1 = PERCENT _2 = attr_id _3 = attributes
    {                               ( Some _2, _3 )}

extension:
  _1 = LBRACKETPERCENT _2 = attr_id _3 = payload _4 = RBRACKET
    {                                           ( (_2, _3) )}

item_extension:
  _1 = LBRACKETPERCENTPERCENT _2 = attr_id _3 = payload _4 = RBRACKET
    {                                                  ( (_2, _3) )}

payload:
  _1 = structure
    {              ( PStr _1 )}
| _1 = COLON _2 = signature
    {                    ( PSig _2 )}
| _1 = COLON _2 = core_type
    {                    ( PTyp _2 )}
| _1 = QUESTION _2 = pattern
    {                     ( PPat (_2, None) )}
| _1 = QUESTION _2 = pattern _3 = WHEN _4 = seq_expr
    {                                   ( PPat (_2, Some _4) )}

%%


