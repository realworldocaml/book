File "scilabParser.mly", line 32, characters 36-42:
Warning: the token ANDAND is unused.
File "scilabParser.mly", line 43, characters 7-10:
Warning: the token EOF is unused.
File "scilabParser.mly", line 67, characters 10-22:
Warning: the token FUNCTIONCALL is unused.
File "scilabParser.mly", line 34, characters 37-46:
Warning: the token LINEBREAK is unused.
File "scilabParser.mly", line 33, characters 41-45:
Warning: the token OROR is unused.
File "scilabParser.mly", line 26, characters 7-10:
Warning: the token SOF is unused.
File "scilabParser.mly", line 27, characters 56-62:
Warning: the token SPACES is unused.
File "scilabParser.mly", line 36, characters 7-14:
Warning: the token WIERDOP is unused.
Grammar has 68 nonterminal symbols, among which 1 start symbols.
Grammar has 76 terminal symbols.
Grammar has 424 productions.
nullable(whileControl) = false
nullable(whileConditionBreak) = false
nullable(whileBody) = true
nullable(variableFields) = true
nullable(variableField) = false
nullable(variableDeclaration) = false
nullable(variable) = false
nullable(tryTok) = false
nullable(tryControl) = false
nullable(thenTok) = true
nullable(thenBody) = true
nullable(specificFunctionCall) = false
nullable(simpleFunctionCall) = false
nullable(selectable) = false
nullable(selectControl) = false
nullable(selectConditionBreak) = false
nullable(select) = false
nullable(returnControl) = false
nullable(recursiveExpression) = false
nullable(program) = true
nullable(operation) = false
nullable(multipleResults) = false
nullable(matrixOrCellLines) = false
nullable(matrixOrCellLineBreak) = false
nullable(matrixOrCellLine) = false
nullable(matrixOrCellColumnsBreak) = false
nullable(matrixOrCellColumns) = false
nullable(matrix) = false
nullable(listableEnd) = false
nullable(listableBegin) = false
nullable(lineEnd) = false
nullable(keywords) = false
nullable(implicitFunctionCall) = false
nullable(implicitCallable) = false
nullable(ifControl) = false
nullable(ifConditionBreak) = false
nullable(idList) = false
nullable(hiddenFun) = false
nullable(functionDelimiter) = false
nullable(functionDeclarationReturns) = false
nullable(functionDeclarationBreak) = false
nullable(functionDeclarationArguments) = true
nullable(functionDeclaration) = false
nullable(functionCall) = false
nullable(functionBody) = true
nullable(functionArgs) = true
nullable(forIterator) = false
nullable(forControl) = false
nullable(forConditionBreak) = true
nullable(forBody) = true
nullable(expressions) = false
nullable(expressionLineBreak) = false
nullable(expression) = false
nullable(elseWhileBody) = true
nullable(elseTok) = false
nullable(elseIfControl) = false
nullable(elseBody) = true
nullable(defaultCase) = false
nullable(condition) = false
nullable(comparison) = false
nullable(comments) = false
nullable(cell) = false
nullable(catchTok) = false
nullable(catchBody) = true
nullable(casesControl) = false
nullable(caseControlBreak) = true
nullable(caseBody) = true
nullable(assignable) = false
first(whileControl) = WHILE
first(whileConditionBreak) = THEN SEMI EOL DO COMMENT COMMA
first(whileBody) = WHILE VARINT TRY SWITCH STR SELECT RETURN PLUS NUM NOT MINUS LPAREN LBRACK LBRACE IF ID HIDDENFUNCTION HIDDEN FUNCTION FOR DOLLAR CONTINUE COMMENT COLON BREAK BOOLTRUE BOOLFALSE
first(variableFields) = VARINT STR PLUS NUM NOT MINUS LPAREN LBRACK LBRACE ID DOLLAR COMMA COLON BOOLTRUE BOOLFALSE
first(variableField) = VARINT STR PLUS NUM NOT MINUS LPAREN LBRACK LBRACE ID DOLLAR COLON BOOLTRUE BOOLFALSE
first(variableDeclaration) = VARINT STR PLUS NUM NOT MINUS LPAREN LBRACK LBRACE ID DOLLAR COLON BOOLTRUE BOOLFALSE
first(variable) = VARINT STR PLUS NUM NOT MINUS LPAREN LBRACK LBRACE ID DOLLAR COLON BOOLTRUE BOOLFALSE
first(tryTok) = TRY
first(tryControl) = TRY
first(thenTok) = THEN SEMI EOL COMMA
first(thenBody) = WHILE VARINT TRY SWITCH STR SELECT RETURN PLUS NUM NOT MINUS LPAREN LBRACK LBRACE IF ID HIDDENFUNCTION HIDDEN FUNCTION FOR DOLLAR CONTINUE COMMENT COLON BREAK BOOLTRUE BOOLFALSE
first(specificFunctionCall) = BOOLTRUE BOOLFALSE
first(simpleFunctionCall) = ID
first(selectable) = VARINT STR PLUS NUM NOT MINUS LPAREN LBRACK LBRACE ID DOLLAR COLON BOOLTRUE BOOLFALSE
first(selectControl) = SWITCH SELECT
first(selectConditionBreak) = SEMI EOL COMMA
first(select) = SWITCH SELECT
first(returnControl) = RETURN
first(recursiveExpression) = WHILE VARINT TRY SWITCH STR SELECT RETURN PLUS NUM NOT MINUS LPAREN LBRACK LBRACE IF ID HIDDENFUNCTION HIDDEN FUNCTION FOR DOLLAR CONTINUE COMMENT COLON BREAK BOOLTRUE BOOLFALSE
first(program) = WHILE VARINT TRY SWITCH STR SEMI SELECT RETURN PLUS NUM NOT MINUS LPAREN LBRACK LBRACE IF ID HIDDENFUNCTION HIDDEN FUNCTION FOR EOL DOLLAR CONTINUE COMMENT COMMA COLON BREAK BOOLTRUE BOOLFALSE
first(operation) = VARINT STR PLUS NUM NOT MINUS LPAREN LBRACK LBRACE ID DOLLAR COLON BOOLTRUE BOOLFALSE
first(multipleResults) = LBRACK
first(matrixOrCellLines) = VARINT STR PLUS NUM NOT MINUS LPAREN LBRACK LBRACE ID DOLLAR COMMENT COLON BOOLTRUE BOOLFALSE
first(matrixOrCellLineBreak) = SEMI EOL
first(matrixOrCellLine) = VARINT STR PLUS NUM NOT MINUS LPAREN LBRACK LBRACE ID DOLLAR COMMENT COLON BOOLTRUE BOOLFALSE
first(matrixOrCellColumnsBreak) = COMMA
first(matrixOrCellColumns) = VARINT STR PLUS NUM NOT MINUS LPAREN LBRACK LBRACE ID DOLLAR COMMENT COLON BOOLTRUE BOOLFALSE
first(matrix) = LBRACK
first(listableEnd) = COLON
first(listableBegin) = COLON
first(lineEnd) = EOL COMMENT
first(keywords) = WHILE TRY THEN SWITCH SELECT RETURN OTHERWISE IF HIDDENFUNCTION HIDDEN FUNCTION FOR ENDFUNCTION END ELSEIF ELSE DO CATCH CASE BREAK
first(implicitFunctionCall) = ID
first(implicitCallable) = VARINT VARFLOAT STR NUM ID DOLLAR BOOLTRUE BOOLFALSE
first(ifControl) = IF
first(ifConditionBreak) = SEMI EOL COMMA
first(idList) = ID
first(hiddenFun) = HIDDENFUNCTION HIDDEN
first(functionDelimiter) = ENDFUNCTION END
first(functionDeclarationReturns) = ID
first(functionDeclarationBreak) = SEMI EOL COMMENT COMMA
first(functionDeclarationArguments) = LPAREN
first(functionDeclaration) = HIDDENFUNCTION HIDDEN FUNCTION
first(functionCall) = ID BOOLTRUE BOOLFALSE
first(functionBody) = WHILE VARINT TRY SWITCH STR SELECT RETURN PLUS NUM NOT MINUS LPAREN LBRACK LBRACE IF ID HIDDENFUNCTION HIDDEN FUNCTION FOR DOLLAR CONTINUE COMMENT COLON BREAK BOOLTRUE BOOLFALSE
first(functionArgs) = VARINT STR PLUS NUM NOT MINUS LPAREN LBRACK LBRACE ID DOLLAR COMMA COLON BOOLTRUE BOOLFALSE
first(forIterator) = VARINT STR PLUS NUM NOT MINUS LPAREN LBRACK LBRACE ID DOLLAR COLON BOOLTRUE BOOLFALSE
first(forControl) = FOR
first(forConditionBreak) = SEMI EOL DO COMMA
first(forBody) = WHILE VARINT TRY SWITCH STR SELECT RETURN PLUS NUM NOT MINUS LPAREN LBRACK LBRACE IF ID HIDDENFUNCTION HIDDEN FUNCTION FOR DOLLAR CONTINUE COMMENT COLON BREAK BOOLTRUE BOOLFALSE
first(expressions) = WHILE VARINT TRY SWITCH STR SELECT RETURN PLUS NUM NOT MINUS LPAREN LBRACK LBRACE IF ID HIDDENFUNCTION HIDDEN FUNCTION FOR DOLLAR CONTINUE COMMENT COLON BREAK BOOLTRUE BOOLFALSE
first(expressionLineBreak) = SEMI EOL COMMA
first(expression) = WHILE VARINT TRY SWITCH STR SELECT RETURN PLUS NUM NOT MINUS LPAREN LBRACK LBRACE IF ID HIDDENFUNCTION HIDDEN FUNCTION FOR DOLLAR CONTINUE COMMENT COLON BREAK BOOLTRUE BOOLFALSE
first(elseWhileBody) = WHILE VARINT TRY SWITCH STR SELECT RETURN PLUS NUM NOT MINUS LPAREN LBRACK LBRACE IF ID HIDDENFUNCTION HIDDEN FUNCTION FOR DOLLAR CONTINUE COMMENT COLON BREAK BOOLTRUE BOOLFALSE
first(elseTok) = ELSE
first(elseIfControl) = ELSEIF
first(elseBody) = WHILE VARINT TRY SWITCH STR SELECT RETURN PLUS NUM NOT MINUS LPAREN LBRACK LBRACE IF ID HIDDENFUNCTION HIDDEN FUNCTION FOR DOLLAR CONTINUE COMMENT COLON BREAK BOOLTRUE BOOLFALSE
first(defaultCase) = OTHERWISE ELSE
first(condition) = VARINT STR PLUS NUM NOT MINUS LPAREN LBRACK LBRACE ID DOLLAR COLON BOOLTRUE BOOLFALSE
first(comparison) = VARINT STR PLUS NUM NOT MINUS LPAREN LBRACK LBRACE ID DOLLAR COLON BOOLTRUE BOOLFALSE
first(comments) = COMMENT
first(cell) = LBRACE
first(catchTok) = CATCH
first(catchBody) = WHILE VARINT TRY SWITCH STR SELECT RETURN PLUS NUM NOT MINUS LPAREN LBRACK LBRACE IF ID HIDDENFUNCTION HIDDEN FUNCTION FOR DOLLAR CONTINUE COMMENT COLON BREAK BOOLTRUE BOOLFALSE
first(casesControl) = COMMENT CASE
first(caseControlBreak) = THEN SEMI EOL COMMA
first(caseBody) = WHILE VARINT TRY SWITCH STR SELECT RETURN PLUS NUM NOT MINUS LPAREN LBRACK LBRACE IF ID HIDDENFUNCTION HIDDEN FUNCTION FOR DOLLAR CONTINUE COMMENT COLON BREAK BOOLTRUE BOOLFALSE
first(assignable) = VARINT STR PLUS NUM NOT MINUS LPAREN LBRACK LBRACE ID DOLLAR COLON BOOLTRUE BOOLFALSE
minimal(whileControl) = (* 4 *) WHILE ID COMMA END
minimal(whileConditionBreak) = (* 1 *) COMMA
minimal(whileBody) = (* 0 *) 
minimal(variableFields) = (* 0 *) 
minimal(variableField) = (* 1 *) ID
minimal(variableDeclaration) = (* 3 *) ID ASSIGN ID
minimal(variable) = (* 1 *) ID
minimal(tryTok) = (* 1 *) TRY
minimal(tryControl) = (* 2 *) TRY END
minimal(thenTok) = (* 0 *) 
minimal(thenBody) = (* 0 *) 
minimal(specificFunctionCall) = (* 3 *) BOOLTRUE LPAREN RPAREN
minimal(simpleFunctionCall) = (* 3 *) ID LPAREN RPAREN
minimal(selectable) = (* 1 *) ID
minimal(selectControl) = (* 6 *) SELECT ID EOL CASE ID END
minimal(selectConditionBreak) = (* 1 *) EOL
minimal(select) = (* 1 *) SELECT
minimal(returnControl) = (* 1 *) RETURN
minimal(recursiveExpression) = (* 2 *) ID SEMI
minimal(program) = (* 0 *) 
minimal(operation) = (* 2 *) MINUS ID
minimal(multipleResults) = (* 3 *) LBRACK COMMENT RBRACK
minimal(matrixOrCellLines) = (* 2 *) COMMENT SEMI
minimal(matrixOrCellLineBreak) = (* 1 *) SEMI
minimal(matrixOrCellLine) = (* 2 *) COMMENT SEMI
minimal(matrixOrCellColumnsBreak) = (* 1 *) COMMA
minimal(matrixOrCellColumns) = (* 1 *) COMMENT
minimal(matrix) = (* 2 *) LBRACK RBRACK
minimal(listableEnd) = (* 2 *) COLON ID
minimal(listableBegin) = (* 2 *) COLON ID
minimal(lineEnd) = (* 1 *) EOL
minimal(keywords) = (* 1 *) IF
minimal(implicitFunctionCall) = (* 2 *) ID ID
minimal(implicitCallable) = (* 1 *) ID
minimal(ifControl) = (* 3 *) IF ID END
minimal(ifConditionBreak) = (* 1 *) SEMI
minimal(idList) = (* 1 *) ID
minimal(hiddenFun) = (* 1 *) HIDDENFUNCTION
minimal(functionDelimiter) = (* 1 *) END
minimal(functionDeclarationReturns) = (* 1 *) ID
minimal(functionDeclarationBreak) = (* 1 *) EOL
minimal(functionDeclarationArguments) = (* 0 *) 
minimal(functionDeclaration) = (* 4 *) FUNCTION ID EOL END
minimal(functionCall) = (* 3 *) ID LPAREN RPAREN
minimal(functionBody) = (* 0 *) 
minimal(functionArgs) = (* 0 *) 
minimal(forIterator) = (* 1 *) ID
minimal(forControl) = (* 5 *) FOR ID ASSIGN ID END
minimal(forConditionBreak) = (* 0 *) 
minimal(forBody) = (* 0 *) 
minimal(expressions) = (* 1 *) ID
minimal(expressionLineBreak) = (* 1 *) SEMI
minimal(expression) = (* 1 *) ID
minimal(elseWhileBody) = (* 0 *) 
minimal(elseTok) = (* 1 *) ELSE
minimal(elseIfControl) = (* 2 *) ELSEIF ID
minimal(elseBody) = (* 0 *) 
minimal(defaultCase) = (* 1 *) ELSE
minimal(condition) = (* 1 *) ID
minimal(comparison) = (* 3 *) ID AND ID
minimal(comments) = (* 2 *) COMMENT EOL
minimal(cell) = (* 2 *) LBRACE RBRACE
minimal(catchTok) = (* 1 *) CATCH
minimal(catchBody) = (* 0 *) 
minimal(casesControl) = (* 2 *) CASE ID
minimal(caseControlBreak) = (* 0 *) 
minimal(caseBody) = (* 0 *) 
minimal(assignable) = (* 1 *) ID
follow(whileControl) = SEMI OTHERWISE EOL ENDFUNCTION END ELSEIF ELSE COMMENT COMMA CATCH CASE #
follow(whileConditionBreak) = WHILE VARINT TRY SWITCH STR SELECT RETURN PLUS NUM NOT MINUS LPAREN LBRACK LBRACE IF ID HIDDENFUNCTION HIDDEN FUNCTION FOR END ELSE DOLLAR CONTINUE COMMENT COLON BREAK BOOLTRUE BOOLFALSE
follow(whileBody) = END ELSE
follow(variableFields) = RPAREN COMMA
follow(variableField) = RPAREN COMMA
follow(variableDeclaration) = SEMI RPAREN OTHERWISE EOL ENDFUNCTION END ELSEIF ELSE COMMENT COMMA CATCH CASE #
follow(variable) = WHILE VARINT TRY TIMES THEN SWITCH STR SEMI SELECT RPAREN RETURN RDIVIDE RBRACK RBRACE QUOTE POWER PLUS OTHERWISE OR NUM NOT NE MINUS LT LPAREN LE LDIVIDE LBRACK LBRACE KRONTIMES KRONRDIVIDE KRONLDIVIDE IF ID HIDDENFUNCTION HIDDEN GT GE FUNCTION FOR EQ EOL ENDFUNCTION END ELSEIF ELSE DOTTIMES DOTRDIVIDE DOTQUOTE DOTPOWER DOTLDIVIDE DOT DOLLAR DO CONTROLTIMES CONTROLRDIVIDE CONTROLLDIVIDE CONTINUE COMMENT COMMA COLON CATCH CASE BREAK BOOLTRUE BOOLFALSE ASSIGN AND #
follow(tryTok) = WHILE VARINT TRY SWITCH STR SELECT RETURN PLUS NUM NOT MINUS LPAREN LBRACK LBRACE IF ID HIDDENFUNCTION HIDDEN FUNCTION FOR END DOLLAR CONTINUE COMMENT COLON CATCH BREAK BOOLTRUE BOOLFALSE
follow(tryControl) = SEMI OTHERWISE EOL ENDFUNCTION END ELSEIF ELSE COMMENT COMMA CATCH CASE #
follow(thenTok) = WHILE VARINT TRY SWITCH STR SELECT RETURN PLUS NUM NOT MINUS LPAREN LBRACK LBRACE IF ID HIDDENFUNCTION HIDDEN FUNCTION FOR END ELSEIF ELSE DOLLAR CONTINUE COMMENT COLON BREAK BOOLTRUE BOOLFALSE
follow(thenBody) = END ELSEIF ELSE
follow(specificFunctionCall) = WHILE VARINT TRY TIMES THEN SWITCH STR SEMI SELECT RPAREN RETURN RDIVIDE RBRACK RBRACE QUOTE POWER PLUS OTHERWISE OR NUM NOT NE MINUS LT LPAREN LE LDIVIDE LBRACK LBRACE KRONTIMES KRONRDIVIDE KRONLDIVIDE IF ID HIDDENFUNCTION HIDDEN GT GE FUNCTION FOR EQ EOL ENDFUNCTION END ELSEIF ELSE DOTTIMES DOTRDIVIDE DOTQUOTE DOTPOWER DOTLDIVIDE DOT DOLLAR DO CONTROLTIMES CONTROLRDIVIDE CONTROLLDIVIDE CONTINUE COMMENT COMMA COLON CATCH CASE BREAK BOOLTRUE BOOLFALSE ASSIGN AND #
follow(simpleFunctionCall) = WHILE VARINT TRY TIMES THEN SWITCH STR SEMI SELECT RPAREN RETURN RDIVIDE RBRACK RBRACE QUOTE POWER PLUS OTHERWISE OR NUM NOT NE MINUS LT LPAREN LE LDIVIDE LBRACK LBRACE KRONTIMES KRONRDIVIDE KRONLDIVIDE IF ID HIDDENFUNCTION HIDDEN GT GE FUNCTION FOR EQ EOL ENDFUNCTION END ELSEIF ELSE DOTTIMES DOTRDIVIDE DOTQUOTE DOTPOWER DOTLDIVIDE DOT DOLLAR DO CONTROLTIMES CONTROLRDIVIDE CONTROLLDIVIDE CONTINUE COMMENT COMMA COLON CATCH CASE BREAK BOOLTRUE BOOLFALSE ASSIGN AND #
follow(selectable) = SEMI EOL COMMENT COMMA
follow(selectControl) = SEMI OTHERWISE EOL ENDFUNCTION END ELSEIF ELSE COMMENT COMMA CATCH CASE #
follow(selectConditionBreak) = COMMENT CASE
follow(select) = VARINT STR PLUS NUM NOT MINUS LPAREN LBRACK LBRACE ID DOLLAR COLON BOOLTRUE BOOLFALSE
follow(returnControl) = SEMI RPAREN OTHERWISE EOL ENDFUNCTION END ELSEIF ELSE COMMENT COMMA CATCH CASE #
follow(recursiveExpression) = WHILE VARINT TRY SWITCH STR SELECT RETURN PLUS OTHERWISE NUM NOT MINUS LPAREN LBRACK LBRACE IF ID HIDDENFUNCTION HIDDEN FUNCTION FOR ENDFUNCTION END ELSEIF ELSE DOLLAR CONTINUE COMMENT COLON CATCH CASE BREAK BOOLTRUE BOOLFALSE #
follow(program) = #
follow(operation) = WHILE VARINT TRY TIMES THEN SWITCH STR SEMI SELECT RPAREN RETURN RDIVIDE RBRACK RBRACE QUOTE POWER PLUS OTHERWISE OR NUM NOT NE MINUS LT LPAREN LE LDIVIDE LBRACK LBRACE KRONTIMES KRONRDIVIDE KRONLDIVIDE IF ID HIDDENFUNCTION HIDDEN GT GE FUNCTION FOR EQ EOL ENDFUNCTION END ELSEIF ELSE DOTTIMES DOTRDIVIDE DOTQUOTE DOTPOWER DOTLDIVIDE DOT DOLLAR DO CONTROLTIMES CONTROLRDIVIDE CONTROLLDIVIDE CONTINUE COMMENT COMMA COLON CATCH CASE BREAK BOOLTRUE BOOLFALSE ASSIGN AND #
follow(multipleResults) = ASSIGN
follow(matrixOrCellLines) = VARINT STR RBRACK RBRACE PLUS NUM NOT MINUS LPAREN LBRACK LBRACE ID DOLLAR COMMENT COLON BOOLTRUE BOOLFALSE
follow(matrixOrCellLineBreak) = VARINT STR SEMI RBRACK RBRACE PLUS NUM NOT MINUS LPAREN LBRACK LBRACE ID EOL DOLLAR COMMENT COLON BOOLTRUE BOOLFALSE
follow(matrixOrCellLine) = VARINT STR RBRACK RBRACE PLUS NUM NOT MINUS LPAREN LBRACK LBRACE ID DOLLAR COMMENT COLON BOOLTRUE BOOLFALSE
follow(matrixOrCellColumnsBreak) = VARINT STR SEMI PLUS NUM NOT MINUS LPAREN LBRACK LBRACE ID EOL DOLLAR COMMA COLON BOOLTRUE BOOLFALSE
follow(matrixOrCellColumns) = VARINT STR SEMI RBRACK RBRACE PLUS NUM NOT MINUS LPAREN LBRACK LBRACE ID EOL DOLLAR COMMENT COMMA COLON BOOLTRUE BOOLFALSE
follow(matrix) = WHILE VARINT TRY TIMES THEN SWITCH STR SEMI SELECT RPAREN RETURN RDIVIDE RBRACK RBRACE QUOTE POWER PLUS OTHERWISE OR NUM NOT NE MINUS LT LPAREN LE LDIVIDE LBRACK LBRACE KRONTIMES KRONRDIVIDE KRONLDIVIDE IF ID HIDDENFUNCTION HIDDEN GT GE FUNCTION FOR EQ EOL ENDFUNCTION END ELSEIF ELSE DOTTIMES DOTRDIVIDE DOTQUOTE DOTPOWER DOTLDIVIDE DOT DOLLAR DO CONTROLTIMES CONTROLRDIVIDE CONTROLLDIVIDE CONTINUE COMMENT COMMA COLON CATCH CASE BREAK BOOLTRUE BOOLFALSE ASSIGN AND #
follow(listableEnd) = WHILE VARINT TRY TIMES THEN SWITCH STR SEMI SELECT RPAREN RETURN RDIVIDE RBRACK RBRACE QUOTE POWER PLUS OTHERWISE OR NUM NOT NE MINUS LT LPAREN LE LDIVIDE LBRACK LBRACE KRONTIMES KRONRDIVIDE KRONLDIVIDE IF ID HIDDENFUNCTION HIDDEN GT GE FUNCTION FOR EQ EOL ENDFUNCTION END ELSEIF ELSE DOTTIMES DOTRDIVIDE DOTQUOTE DOTPOWER DOTLDIVIDE DOT DOLLAR DO CONTROLTIMES CONTROLRDIVIDE CONTROLLDIVIDE CONTINUE COMMENT COMMA COLON CATCH CASE BREAK BOOLTRUE BOOLFALSE ASSIGN AND #
follow(listableBegin) = WHILE VARINT TRY TIMES THEN SWITCH STR SEMI SELECT RPAREN RETURN RDIVIDE RBRACK RBRACE QUOTE POWER PLUS OTHERWISE OR NUM NOT NE MINUS LT LPAREN LE LDIVIDE LBRACK LBRACE KRONTIMES KRONRDIVIDE KRONLDIVIDE IF ID HIDDENFUNCTION HIDDEN GT GE FUNCTION FOR EQ EOL ENDFUNCTION END ELSEIF ELSE DOTTIMES DOTRDIVIDE DOTQUOTE DOTPOWER DOTLDIVIDE DOT DOLLAR DO CONTROLTIMES CONTROLRDIVIDE CONTROLLDIVIDE CONTINUE COMMENT COMMA COLON CATCH CASE BREAK BOOLTRUE BOOLFALSE ASSIGN AND #
follow(lineEnd) = WHILE VARINT TRY SWITCH STR SELECT RETURN PLUS NUM NOT MINUS LPAREN LBRACK LBRACE IF ID HIDDENFUNCTION HIDDEN FUNCTION FOR ENDFUNCTION END DOLLAR CONTINUE COMMENT COLON BREAK BOOLTRUE BOOLFALSE
follow(keywords) = WHILE VARINT TRY TIMES THEN SWITCH STR SEMI SELECT RPAREN RETURN RDIVIDE RBRACK RBRACE QUOTE POWER PLUS OTHERWISE OR NUM NOT NE MINUS LT LPAREN LE LDIVIDE LBRACK LBRACE KRONTIMES KRONRDIVIDE KRONLDIVIDE IF ID HIDDENFUNCTION HIDDEN GT GE FUNCTION FOR EQ EOL ENDFUNCTION END ELSEIF ELSE DOTTIMES DOTRDIVIDE DOTQUOTE DOTPOWER DOTLDIVIDE DOT DOLLAR DO CONTROLTIMES CONTROLRDIVIDE CONTROLLDIVIDE CONTINUE COMMENT COMMA COLON CATCH CASE BREAK BOOLTRUE BOOLFALSE ASSIGN AND #
follow(implicitFunctionCall) = VARINT VARFLOAT STR SEMI OTHERWISE NUM ID EOL ENDFUNCTION END ELSEIF ELSE DOLLAR COMMENT COMMA CATCH CASE BOOLTRUE BOOLFALSE #
follow(implicitCallable) = VARINT VARFLOAT STR SEMI OTHERWISE NUM ID EOL ENDFUNCTION END ELSEIF ELSE DOT DOLLAR COMMENT COMMA CATCH CASE BOOLTRUE BOOLFALSE #
follow(ifControl) = SEMI OTHERWISE EOL ENDFUNCTION END ELSEIF ELSE COMMENT COMMA CATCH CASE #
follow(ifConditionBreak) = WHILE VARINT TRY THEN SWITCH STR SELECT RETURN PLUS NUM NOT MINUS LPAREN LBRACK LBRACE IF ID HIDDENFUNCTION HIDDEN FUNCTION FOR END ELSEIF ELSE DOLLAR CONTINUE COMMENT COLON BREAK BOOLTRUE BOOLFALSE
follow(idList) = RPAREN RBRACK COMMA
follow(hiddenFun) = LBRACK ID
follow(functionDelimiter) = SEMI OTHERWISE EOL ENDFUNCTION END ELSEIF ELSE COMMENT COMMA CATCH CASE #
follow(functionDeclarationReturns) = RBRACK
follow(functionDeclarationBreak) = WHILE VARINT TRY SWITCH STR SELECT RETURN PLUS NUM NOT MINUS LPAREN LBRACK LBRACE IF ID HIDDENFUNCTION HIDDEN FUNCTION FOR ENDFUNCTION END DOLLAR CONTINUE COMMENT COLON BREAK BOOLTRUE BOOLFALSE
follow(functionDeclarationArguments) = SEMI EOL COMMENT COMMA
follow(functionDeclaration) = SEMI OTHERWISE EOL ENDFUNCTION END ELSEIF ELSE COMMENT COMMA CATCH CASE #
follow(functionCall) = WHILE VARINT TRY TIMES THEN SWITCH STR SEMI SELECT RPAREN RETURN RDIVIDE RBRACK RBRACE QUOTE POWER PLUS OTHERWISE OR NUM NOT NE MINUS LT LPAREN LE LDIVIDE LBRACK LBRACE KRONTIMES KRONRDIVIDE KRONLDIVIDE IF ID HIDDENFUNCTION HIDDEN GT GE FUNCTION FOR EQ EOL ENDFUNCTION END ELSEIF ELSE DOTTIMES DOTRDIVIDE DOTQUOTE DOTPOWER DOTLDIVIDE DOT DOLLAR DO CONTROLTIMES CONTROLRDIVIDE CONTROLLDIVIDE CONTINUE COMMENT COMMA COLON CATCH CASE BREAK BOOLTRUE BOOLFALSE ASSIGN AND #
follow(functionBody) = ENDFUNCTION END
follow(functionArgs) = RPAREN COMMA
follow(forIterator) = WHILE VARINT TRY SWITCH STR SEMI SELECT RPAREN RETURN PLUS NUM NOT MINUS LPAREN LBRACK LBRACE IF ID HIDDENFUNCTION HIDDEN FUNCTION FOR EOL END DOLLAR DO CONTINUE COMMENT COMMA COLON BREAK BOOLTRUE BOOLFALSE
follow(forControl) = SEMI OTHERWISE EOL ENDFUNCTION END ELSEIF ELSE COMMENT COMMA CATCH CASE #
follow(forConditionBreak) = WHILE VARINT TRY SWITCH STR SELECT RETURN PLUS NUM NOT MINUS LPAREN LBRACK LBRACE IF ID HIDDENFUNCTION HIDDEN FUNCTION FOR END DOLLAR CONTINUE COMMENT COLON BREAK BOOLTRUE BOOLFALSE
follow(forBody) = END
follow(expressions) = OTHERWISE ENDFUNCTION END ELSEIF ELSE CATCH CASE #
follow(expressionLineBreak) = WHILE VARINT TRY SWITCH STR SEMI SELECT RETURN PLUS OTHERWISE NUM NOT MINUS LPAREN LBRACK LBRACE IF ID HIDDENFUNCTION HIDDEN FUNCTION FOR EOL ENDFUNCTION END ELSEIF ELSE DOLLAR CONTINUE COMMENT COMMA COLON CATCH CASE BREAK BOOLTRUE BOOLFALSE #
follow(expression) = SEMI OTHERWISE EOL ENDFUNCTION END ELSEIF ELSE COMMENT COMMA CATCH CASE #
follow(elseWhileBody) = END
follow(elseTok) = WHILE VARINT TRY SWITCH STR SELECT RETURN PLUS NUM NOT MINUS LPAREN LBRACK LBRACE IF ID HIDDENFUNCTION HIDDEN FUNCTION FOR END DOLLAR CONTINUE COMMENT COLON BREAK BOOLTRUE BOOLFALSE
follow(elseIfControl) = END
follow(elseBody) = END
follow(defaultCase) = WHILE VARINT TRY SWITCH STR SELECT RETURN PLUS NUM NOT MINUS LPAREN LBRACK LBRACE IF ID HIDDENFUNCTION HIDDEN FUNCTION FOR END DOLLAR CONTINUE COMMENT COLON BREAK BOOLTRUE BOOLFALSE
follow(condition) = WHILE VARINT TRY THEN SWITCH STR SEMI SELECT RETURN PLUS NUM NOT MINUS LPAREN LBRACK LBRACE IF ID HIDDENFUNCTION HIDDEN FUNCTION FOR EOL END ELSEIF ELSE DOLLAR DO CONTINUE COMMENT COMMA COLON BREAK BOOLTRUE BOOLFALSE
follow(comparison) = WHILE VARINT TRY TIMES THEN SWITCH STR SEMI SELECT RPAREN RETURN RDIVIDE RBRACK RBRACE QUOTE POWER PLUS OTHERWISE OR NUM NOT NE MINUS LT LPAREN LE LDIVIDE LBRACK LBRACE KRONTIMES KRONRDIVIDE KRONLDIVIDE IF ID HIDDENFUNCTION HIDDEN GT GE FUNCTION FOR EQ EOL ENDFUNCTION END ELSEIF ELSE DOTTIMES DOTRDIVIDE DOTQUOTE DOTPOWER DOTLDIVIDE DOT DOLLAR DO CONTROLTIMES CONTROLRDIVIDE CONTROLLDIVIDE CONTINUE COMMENT COMMA COLON CATCH CASE BREAK BOOLTRUE BOOLFALSE ASSIGN AND #
follow(comments) = COMMENT CASE
follow(cell) = WHILE VARINT TRY TIMES THEN SWITCH STR SEMI SELECT RPAREN RETURN RDIVIDE RBRACK RBRACE QUOTE POWER PLUS OTHERWISE OR NUM NOT NE MINUS LT LPAREN LE LDIVIDE LBRACK LBRACE KRONTIMES KRONRDIVIDE KRONLDIVIDE IF ID HIDDENFUNCTION HIDDEN GT GE FUNCTION FOR EQ EOL ENDFUNCTION END ELSEIF ELSE DOTTIMES DOTRDIVIDE DOTQUOTE DOTPOWER DOTLDIVIDE DOT DOLLAR DO CONTROLTIMES CONTROLRDIVIDE CONTROLLDIVIDE CONTINUE COMMENT COMMA COLON CATCH CASE BREAK BOOLTRUE BOOLFALSE ASSIGN AND #
follow(catchTok) = WHILE VARINT TRY SWITCH STR SELECT RETURN PLUS NUM NOT MINUS LPAREN LBRACK LBRACE IF ID HIDDENFUNCTION HIDDEN FUNCTION FOR END DOLLAR CONTINUE COMMENT COLON BREAK BOOLTRUE BOOLFALSE
follow(catchBody) = END CATCH
follow(casesControl) = OTHERWISE END ELSE CASE
follow(caseControlBreak) = WHILE VARINT TRY SWITCH STR SELECT RETURN PLUS OTHERWISE NUM NOT MINUS LPAREN LBRACK LBRACE IF ID HIDDENFUNCTION HIDDEN FUNCTION FOR END ELSE DOLLAR CONTINUE COMMENT COLON CASE BREAK BOOLTRUE BOOLFALSE
follow(caseBody) = OTHERWISE END ELSE CASE
follow(assignable) = ASSIGN
Built an LR(0) automaton with 647 states.
The grammar is not SLR(1) -- 142 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 652 states.
3263 shift/reduce conflicts were silently solved.
File "scilabParser.mly", line 53, characters 0-5:
Warning: the precedence level assigned to ANDAND is never useful.
File "scilabParser.mly", line 67, characters 0-9:
Warning: the precedence level assigned to FUNCTIONCALL is never useful.
File "scilabParser.mly", line 69, characters 0-9:
Warning: the precedence level assigned to LBRACE is never useful.
File "scilabParser.mly", line 52, characters 0-5:
Warning: the precedence level assigned to OROR is never useful.
File "scilabParser.mly", line 45, characters 0-9:
Warning: the precedence level assigned to TOPLEVEL is never useful.
File "scilabParser.mly", line 2628, characters 24-31:
Warning: this %prec declaration is never useful.
File "scilabParser.mly", line 2640, characters 30-37:
Warning: this %prec declaration is never useful.
File "scilabParser.mly", line 2670, characters 11-19:
Warning: this %prec declaration is never useful.
File "scilabParser.mly", line 154, characters 21-29:
Warning: this %prec declaration is never useful.
File "scilabParser.mly", line 161, characters 17-25:
Warning: this %prec declaration is never useful.
File "scilabParser.mly", line 162, characters 30-38:
Warning: this %prec declaration is never useful.
File "scilabParser.mly", line 2536, characters 36-45:
Warning: this %prec declaration is never useful.
File "scilabParser.mly", line 2544, characters 16-25:
Warning: this %prec declaration is never useful.
File "scilabParser.mly", line 1739, characters 30-37:
Warning: this %prec declaration is never useful.
File "scilabParser.mly", line 1774, characters 33-40:
Warning: this %prec declaration is never useful.
File "scilabParser.mly", line 1781, characters 18-25:
Warning: this %prec declaration is never useful.
File "scilabParser.mly", line 1789, characters 15-23:
Warning: this %prec declaration is never useful.
File "scilabParser.mly", line 1796, characters 12-20:
Warning: this %prec declaration is never useful.
File "scilabParser.mly", line 2558, characters 35-44:
Warning: this %prec declaration is never useful.
File "scilabParser.mly", line 2565, characters 39-48:
Warning: this %prec declaration is never useful.
File "scilabParser.mly", line 2572, characters 37-46:
Warning: this %prec declaration is never useful.
File "scilabParser.mly", line 2579, characters 41-50:
Warning: this %prec declaration is never useful.
Warning: 261 states have an end-of-stream conflict.
File "scilabParser.mly", line 79, characters 2-21:
Warning: production program -> expressionLineBreak is never reduced.
File "scilabParser.mly", line 84, characters 1-1:
Warning: production program -> is never reduced.
Warning: in total, 2 productions are never reduced.
206 out of 652 states have a default reduction.
334 out of 652 states are represented.
0 out of 147 symbols keep track of their start position.
0 out of 147 symbols keep track of their end position.
195 out of 425 productions exploit shiftreduce optimization.
0 out of 652 states can peek at an error.
1801 functions before inlining, 265 functions after inlining.
