Grammar has 154 nonterminal symbols, among which 2 start symbols.
Grammar has 60 terminal symbols.
Grammar has 298 productions.
nullable(variable) = false
nullable(useful_info) = false
nullable(unary_negation) = false
nullable(unary_connective) = false
nullable(tptp_input) = false
nullable(tptp_include) = false
nullable(tptp_functor) = false
nullable(tpi_formula) = false
nullable(tpi_annotated) = false
nullable(thf_xprod_type) = false
nullable(thf_variable_list) = false
nullable(thf_variable) = false
nullable(thf_unitary_type) = false
nullable(thf_unitary_formula) = false
nullable(thf_union_type) = false
nullable(thf_unary_formula) = false
nullable(thf_unary_connective) = false
nullable(thf_typed_variable) = false
nullable(thf_typeable_formula) = false
nullable(thf_type_formula) = false
nullable(thf_tuple_list) = false
nullable(thf_tuple) = false
nullable(thf_top_level_type) = false
nullable(thf_subtype) = false
nullable(thf_sequent) = false
nullable(thf_quantifier) = false
nullable(thf_quantified_formula) = false
nullable(thf_pair_connective) = false
nullable(thf_or_formula) = false
nullable(thf_mapping_type) = false
nullable(thf_logic_formula) = false
nullable(thf_let_term_defn) = false
nullable(thf_let_formula_defn) = false
nullable(thf_let) = false
nullable(thf_formula) = false
nullable(thf_conn_term) = false
nullable(thf_conditional) = false
nullable(thf_binary_type) = false
nullable(thf_binary_tuple) = false
nullable(thf_binary_pair) = false
nullable(thf_binary_formula) = false
nullable(thf_atom) = false
nullable(thf_apply_formula) = false
nullable(thf_annotated) = false
nullable(thf_and_formula) = false
nullable(tff_xprod_type) = false
nullable(tff_variable_list) = false
nullable(tff_variable) = false
nullable(tff_untyped_atom) = false
nullable(tff_unitary_type) = false
nullable(tff_unitary_formula) = false
nullable(tff_unary_formula) = false
nullable(tff_typed_variable) = false
nullable(tff_typed_atom) = false
nullable(tff_type_arguments) = false
nullable(tff_tuple_list) = false
nullable(tff_tuple) = false
nullable(tff_top_level_type) = false
nullable(tff_sequent) = false
nullable(tff_quantified_type) = false
nullable(tff_quantified_formula) = false
nullable(tff_or_formula) = false
nullable(tff_monotype) = false
nullable(tff_mapping_type) = false
nullable(tff_logic_formula) = false
nullable(tff_let_term_defn) = false
nullable(tff_let_term_binding) = false
nullable(tff_let_formula_defn) = false
nullable(tff_let_formula_binding) = false
nullable(tff_let) = false
nullable(tff_formula) = false
nullable(tff_conditional) = false
nullable(tff_binary_nonassoc) = false
nullable(tff_binary_formula) = false
nullable(tff_binary_assoc) = false
nullable(tff_atomic_type) = false
nullable(tff_annotated) = false
nullable(tff_and_formula) = false
nullable(term) = false
nullable(system_term) = false
nullable(system_functor) = false
nullable(system_constant) = false
nullable(system_atomic_formula) = false
nullable(subtype_sign) = false
nullable(source) = false
nullable(real) = false
nullable(rational) = false
nullable(plain_term) = false
nullable(plain_atomic_formula) = false
nullable(optional_info) = true
nullable(number) = false
nullable(name_list) = false
nullable(name) = false
nullable(literal) = false
nullable(list(tptp_input)) = true
nullable(let_term) = false
nullable(integer) = false
nullable(input) = false
nullable(infix_inequality) = false
nullable(infix_equality) = false
nullable(general_terms) = false
nullable(general_term) = false
nullable(general_list) = false
nullable(general_function) = false
nullable(general_data) = false
nullable(function_term) = false
nullable(formula_section) = true
nullable(formula_role) = false
nullable(formula_data) = false
nullable(fol_quantifier) = false
nullable(fol_infix_unary) = false
nullable(fof_variable_list) = false
nullable(fof_unitary_formula) = false
nullable(fof_unary_formula) = false
nullable(fof_tuple_list) = false
nullable(fof_tuple) = false
nullable(fof_sequent) = false
nullable(fof_quantified_formula) = false
nullable(fof_or_formula) = false
nullable(fof_logic_formula) = false
nullable(fof_formula) = false
nullable(fof_binary_nonassoc) = false
nullable(fof_binary_formula) = false
nullable(fof_binary_assoc) = false
nullable(fof_annotated) = false
nullable(fof_and_formula) = false
nullable(file_name) = false
nullable(file) = false
nullable(distinct_object) = false
nullable(disjunction) = false
nullable(defined_type) = false
nullable(defined_term) = false
nullable(defined_plain_term) = false
nullable(defined_plain_formula) = false
nullable(defined_infix_pred) = false
nullable(defined_infix_formula) = false
nullable(defined_functor) = false
nullable(defined_constant) = false
nullable(defined_atomic_term) = false
nullable(defined_atomic_formula) = false
nullable(defined_atom) = false
nullable(constant) = false
nullable(conditional_term) = false
nullable(cnf_formula) = false
nullable(cnf_annotated) = false
nullable(binary_connective) = false
nullable(atomic_word) = false
nullable(atomic_system_word) = false
nullable(atomic_formula) = false
nullable(atomic_defined_word) = false
nullable(assoc_connective) = false
nullable(arguments) = false
nullable(annotations) = true
nullable(annotated_formula) = false
first(variable) = UPPER_WORD
first(useful_info) = LEFT_BRACKET
first(unary_negation) = NOT
first(unary_connective) = NOT
first(tptp_input) = TPI THF TFF INCLUDE FOF CNF
first(tptp_include) = INCLUDE
first(tptp_functor) = SINGLE_QUOTED LOWER_WORD
first(tpi_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_FT LEFT_PAREN LEFT_BRACKET ITE_T INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(tpi_annotated) = TPI
first(thf_xprod_type) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION AND
first(thf_variable_list) = UPPER_WORD
first(thf_variable) = UPPER_WORD
first(thf_unitary_type) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION AND
first(thf_unitary_formula) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION AND
first(thf_union_type) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION AND
first(thf_unary_formula) = SIGMA PI NOT
first(thf_unary_connective) = SIGMA PI NOT
first(thf_typed_variable) = UPPER_WORD
first(thf_typeable_formula) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_FT LEFT_PAREN LEFT_IMPLY ITE_T INTEGER IMPLY EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT AND
first(thf_type_formula) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_FT LEFT_PAREN LEFT_IMPLY ITE_T INTEGER IMPLY EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT AND
first(thf_tuple_list) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION AND
first(thf_tuple) = LEFT_BRACKET
first(thf_top_level_type) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION AND
first(thf_subtype) = SINGLE_QUOTED LOWER_WORD
first(thf_sequent) = LEFT_PAREN LEFT_BRACKET
first(thf_quantifier) = LAMBDA INDEFINITE_DESCRIPTION FORALL_TY FORALL EXISTS_TY EXISTS DEFINITE_DESCRIPTION
first(thf_quantified_formula) = LAMBDA INDEFINITE_DESCRIPTION FORALL_TY FORALL EXISTS_TY EXISTS DEFINITE_DESCRIPTION
first(thf_pair_connective) = XOR NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL
first(thf_or_formula) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION AND
first(thf_mapping_type) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION AND
first(thf_logic_formula) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION AND
first(thf_let_term_defn) = LAMBDA INDEFINITE_DESCRIPTION FORALL_TY FORALL EXISTS_TY EXISTS DEFINITE_DESCRIPTION
first(thf_let_formula_defn) = LAMBDA INDEFINITE_DESCRIPTION FORALL_TY FORALL EXISTS_TY EXISTS DEFINITE_DESCRIPTION
first(thf_let) = LET_TF LET_FF
first(thf_formula) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LEFT_BRACKET LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION AND
first(thf_conn_term) = XOR VLINE SIGMA PI NOT_EQUAL NOTVLINE NOTAND NOT LEFT_IMPLY IMPLY EQUIV EQUAL AND
first(thf_conditional) = ITE_F
first(thf_binary_type) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION AND
first(thf_binary_tuple) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION AND
first(thf_binary_pair) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION AND
first(thf_binary_formula) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION AND
first(thf_atom) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_FT LEFT_IMPLY ITE_T INTEGER IMPLY EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT AND
first(thf_apply_formula) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION AND
first(thf_annotated) = THF
first(thf_and_formula) = XOR VLINE UPPER_WORD SINGLE_QUOTED SIGMA REAL RATIONAL PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION AND
first(tff_xprod_type) = UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOLLAR_WORD
first(tff_variable_list) = UPPER_WORD
first(tff_variable) = UPPER_WORD
first(tff_untyped_atom) = SINGLE_QUOTED LOWER_WORD DOLLAR_DOLLAR_WORD
first(tff_unitary_type) = UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOLLAR_WORD
first(tff_unitary_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN ITE_T ITE_F INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(tff_unary_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_FT ITE_T INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(tff_typed_variable) = UPPER_WORD
first(tff_typed_atom) = SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOLLAR_DOLLAR_WORD
first(tff_type_arguments) = UPPER_WORD SINGLE_QUOTED LOWER_WORD DOLLAR_WORD
first(tff_tuple_list) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN ITE_T ITE_F INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(tff_tuple) = LEFT_BRACKET
first(tff_top_level_type) = UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN FORALL_TY DOLLAR_WORD
first(tff_sequent) = LEFT_PAREN LEFT_BRACKET
first(tff_quantified_type) = FORALL_TY
first(tff_quantified_formula) = FORALL EXISTS
first(tff_or_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN ITE_T ITE_F INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(tff_monotype) = UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOLLAR_WORD
first(tff_mapping_type) = UPPER_WORD SINGLE_QUOTED LOWER_WORD LEFT_PAREN DOLLAR_WORD
first(tff_logic_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN ITE_T ITE_F INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(tff_let_term_defn) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD LET_TT LET_FT LEFT_PAREN ITE_T INTEGER FORALL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(tff_let_term_binding) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD LET_TT LET_FT LEFT_PAREN ITE_T INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(tff_let_formula_defn) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD LET_TT LET_FT LEFT_PAREN ITE_T INTEGER FORALL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(tff_let_formula_binding) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD LET_TT LET_FT LEFT_PAREN ITE_T INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(tff_let) = LET_TF LET_FF
first(tff_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_BRACKET ITE_T ITE_F INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(tff_conditional) = ITE_F
first(tff_binary_nonassoc) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN ITE_T ITE_F INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(tff_binary_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN ITE_T ITE_F INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(tff_binary_assoc) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN ITE_T ITE_F INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(tff_atomic_type) = UPPER_WORD SINGLE_QUOTED LOWER_WORD DOLLAR_WORD
first(tff_annotated) = TFF
first(tff_and_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN ITE_T ITE_F INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(term) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD LET_TT LET_FT ITE_T INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(system_term) = DOLLAR_DOLLAR_WORD
first(system_functor) = DOLLAR_DOLLAR_WORD
first(system_constant) = DOLLAR_DOLLAR_WORD
first(system_atomic_formula) = DOLLAR_DOLLAR_WORD
first(subtype_sign) = LESS
first(source) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD LEFT_BRACKET INTEGER DOLLAR_THF DOLLAR_TFF DOLLAR_FOT DOLLAR_FOF DOLLAR_CNF DISTINCT_OBJECT
first(real) = REAL
first(rational) = RATIONAL
first(plain_term) = SINGLE_QUOTED LOWER_WORD
first(plain_atomic_formula) = SINGLE_QUOTED LOWER_WORD
first(optional_info) = COMMA
first(number) = REAL RATIONAL INTEGER
first(name_list) = SINGLE_QUOTED LOWER_WORD INTEGER
first(name) = SINGLE_QUOTED LOWER_WORD INTEGER
first(literal) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_FT ITE_T INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(list(tptp_input)) = TPI THF TFF INCLUDE FOF CNF
first(let_term) = LET_TT LET_FT
first(integer) = INTEGER
first(input) = TPI THF TFF INCLUDE FOF EOF CNF
first(infix_inequality) = NOT_EQUAL
first(infix_equality) = EQUAL
first(general_terms) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD LEFT_BRACKET INTEGER DOLLAR_THF DOLLAR_TFF DOLLAR_FOT DOLLAR_FOF DOLLAR_CNF DISTINCT_OBJECT
first(general_term) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD LEFT_BRACKET INTEGER DOLLAR_THF DOLLAR_TFF DOLLAR_FOT DOLLAR_FOF DOLLAR_CNF DISTINCT_OBJECT
first(general_list) = LEFT_BRACKET
first(general_function) = SINGLE_QUOTED LOWER_WORD
first(general_data) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD INTEGER DOLLAR_THF DOLLAR_TFF DOLLAR_FOT DOLLAR_FOF DOLLAR_CNF DISTINCT_OBJECT
first(function_term) = SINGLE_QUOTED REAL RATIONAL LOWER_WORD INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(formula_section) = COMMA
first(formula_role) = LOWER_WORD
first(formula_data) = DOLLAR_THF DOLLAR_TFF DOLLAR_FOT DOLLAR_FOF DOLLAR_CNF
first(fol_quantifier) = FORALL EXISTS
first(fol_infix_unary) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD LET_TT LET_FT ITE_T INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(fof_variable_list) = UPPER_WORD
first(fof_unitary_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_FT LEFT_PAREN ITE_T INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(fof_unary_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_FT ITE_T INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(fof_tuple_list) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_FT LEFT_PAREN ITE_T INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(fof_tuple) = LEFT_BRACKET
first(fof_sequent) = LEFT_PAREN LEFT_BRACKET
first(fof_quantified_formula) = FORALL EXISTS
first(fof_or_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_FT LEFT_PAREN ITE_T INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(fof_logic_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_FT LEFT_PAREN ITE_T INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(fof_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_FT LEFT_PAREN LEFT_BRACKET ITE_T INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(fof_binary_nonassoc) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_FT LEFT_PAREN ITE_T INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(fof_binary_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_FT LEFT_PAREN ITE_T INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(fof_binary_assoc) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_FT LEFT_PAREN ITE_T INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(fof_annotated) = FOF
first(fof_and_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_FT LEFT_PAREN ITE_T INTEGER FORALL EXISTS DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(file_name) = SINGLE_QUOTED
first(file) = TPI THF TFF INCLUDE FOF EOF CNF
first(distinct_object) = DISTINCT_OBJECT
first(disjunction) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_FT ITE_T INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(defined_type) = DOLLAR_WORD
first(defined_term) = REAL RATIONAL INTEGER DOLLAR_WORD DISTINCT_OBJECT
first(defined_plain_term) = DOLLAR_WORD
first(defined_plain_formula) = DOLLAR_WORD
first(defined_infix_pred) = EQUAL
first(defined_infix_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD LET_TT LET_FT ITE_T INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(defined_functor) = DOLLAR_WORD
first(defined_constant) = DOLLAR_WORD
first(defined_atomic_term) = DOLLAR_WORD
first(defined_atomic_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD LET_TT LET_FT ITE_T INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(defined_atom) = REAL RATIONAL INTEGER DISTINCT_OBJECT
first(constant) = SINGLE_QUOTED LOWER_WORD
first(conditional_term) = ITE_T
first(cnf_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL NOT LOWER_WORD LET_TT LET_FT LEFT_PAREN ITE_T INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(cnf_annotated) = CNF
first(binary_connective) = XOR NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV
first(atomic_word) = SINGLE_QUOTED LOWER_WORD
first(atomic_system_word) = DOLLAR_DOLLAR_WORD
first(atomic_formula) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD LET_TT LET_FT ITE_T INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(atomic_defined_word) = DOLLAR_WORD
first(assoc_connective) = VLINE AND
first(arguments) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD LET_TT LET_FT ITE_T INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
first(annotations) = COMMA
first(annotated_formula) = TPI THF TFF FOF CNF
minimal(variable) = (* 1 *) UPPER_WORD
minimal(useful_info) = (* 2 *) LEFT_BRACKET RIGHT_BRACKET
minimal(unary_negation) = (* 1 *) NOT
minimal(unary_connective) = (* 1 *) NOT
minimal(tptp_input) = (* 5 *) INCLUDE LEFT_PAREN SINGLE_QUOTED RIGHT_PAREN DOT
minimal(tptp_include) = (* 5 *) INCLUDE LEFT_PAREN SINGLE_QUOTED RIGHT_PAREN DOT
minimal(tptp_functor) = (* 1 *) LOWER_WORD
minimal(tpi_formula) = (* 1 *) LOWER_WORD
minimal(tpi_annotated) = (* 9 *) TPI LEFT_PAREN LOWER_WORD COMMA LOWER_WORD COMMA LOWER_WORD RIGHT_PAREN DOT
minimal(thf_xprod_type) = (* 3 *) LOWER_WORD STAR LOWER_WORD
minimal(thf_variable_list) = (* 1 *) UPPER_WORD
minimal(thf_variable) = (* 1 *) UPPER_WORD
minimal(thf_unitary_type) = (* 1 *) LOWER_WORD
minimal(thf_unitary_formula) = (* 1 *) LOWER_WORD
minimal(thf_union_type) = (* 3 *) LOWER_WORD PLUS LOWER_WORD
minimal(thf_unary_formula) = (* 4 *) NOT LEFT_PAREN LOWER_WORD RIGHT_PAREN
minimal(thf_unary_connective) = (* 1 *) NOT
minimal(thf_typed_variable) = (* 3 *) UPPER_WORD COLON LOWER_WORD
minimal(thf_typeable_formula) = (* 1 *) LOWER_WORD
minimal(thf_type_formula) = (* 3 *) LOWER_WORD COLON LOWER_WORD
minimal(thf_tuple_list) = (* 1 *) LOWER_WORD
minimal(thf_tuple) = (* 2 *) LEFT_BRACKET RIGHT_BRACKET
minimal(thf_top_level_type) = (* 1 *) LOWER_WORD
minimal(thf_subtype) = (* 4 *) LOWER_WORD LESS LESS LOWER_WORD
minimal(thf_sequent) = (* 5 *) LEFT_BRACKET RIGHT_BRACKET GENTZEN_ARROW LEFT_BRACKET RIGHT_BRACKET
minimal(thf_quantifier) = (* 1 *) FORALL
minimal(thf_quantified_formula) = (* 6 *) FORALL LEFT_BRACKET UPPER_WORD RIGHT_BRACKET COLON LOWER_WORD
minimal(thf_pair_connective) = (* 1 *) EQUAL
minimal(thf_or_formula) = (* 3 *) LOWER_WORD VLINE LOWER_WORD
minimal(thf_mapping_type) = (* 3 *) LOWER_WORD ARROW LOWER_WORD
minimal(thf_logic_formula) = (* 1 *) LOWER_WORD
minimal(thf_let_term_defn) = (* 6 *) FORALL LEFT_BRACKET UPPER_WORD RIGHT_BRACKET COLON LOWER_WORD
minimal(thf_let_formula_defn) = (* 6 *) FORALL LEFT_BRACKET UPPER_WORD RIGHT_BRACKET COLON LOWER_WORD
minimal(thf_let) = (* 11 *) LET_TF LEFT_PAREN FORALL LEFT_BRACKET UPPER_WORD RIGHT_BRACKET COLON LOWER_WORD COMMA LOWER_WORD RIGHT_PAREN
minimal(thf_formula) = (* 1 *) LOWER_WORD
minimal(thf_conn_term) = (* 1 *) EQUAL
minimal(thf_conditional) = (* 8 *) ITE_F LEFT_PAREN LOWER_WORD COMMA LOWER_WORD COMMA LOWER_WORD RIGHT_PAREN
minimal(thf_binary_type) = (* 3 *) LOWER_WORD ARROW LOWER_WORD
minimal(thf_binary_tuple) = (* 3 *) LOWER_WORD VLINE LOWER_WORD
minimal(thf_binary_pair) = (* 3 *) LOWER_WORD EQUAL LOWER_WORD
minimal(thf_binary_formula) = (* 3 *) LOWER_WORD EQUAL LOWER_WORD
minimal(thf_atom) = (* 1 *) LOWER_WORD
minimal(thf_apply_formula) = (* 3 *) LOWER_WORD APPLY LOWER_WORD
minimal(thf_annotated) = (* 9 *) THF LEFT_PAREN LOWER_WORD COMMA LOWER_WORD COMMA LOWER_WORD RIGHT_PAREN DOT
minimal(thf_and_formula) = (* 3 *) LOWER_WORD AND LOWER_WORD
minimal(tff_xprod_type) = (* 3 *) LOWER_WORD STAR LOWER_WORD
minimal(tff_variable_list) = (* 1 *) UPPER_WORD
minimal(tff_variable) = (* 1 *) UPPER_WORD
minimal(tff_untyped_atom) = (* 1 *) LOWER_WORD
minimal(tff_unitary_type) = (* 1 *) LOWER_WORD
minimal(tff_unitary_formula) = (* 1 *) LOWER_WORD
minimal(tff_unary_formula) = (* 2 *) NOT LOWER_WORD
minimal(tff_typed_variable) = (* 3 *) UPPER_WORD COLON LOWER_WORD
minimal(tff_typed_atom) = (* 3 *) LOWER_WORD COLON LOWER_WORD
minimal(tff_type_arguments) = (* 1 *) LOWER_WORD
minimal(tff_tuple_list) = (* 1 *) LOWER_WORD
minimal(tff_tuple) = (* 2 *) LEFT_BRACKET RIGHT_BRACKET
minimal(tff_top_level_type) = (* 1 *) LOWER_WORD
minimal(tff_sequent) = (* 5 *) LEFT_BRACKET RIGHT_BRACKET GENTZEN_ARROW LEFT_BRACKET RIGHT_BRACKET
minimal(tff_quantified_type) = (* 6 *) FORALL_TY LEFT_BRACKET UPPER_WORD RIGHT_BRACKET COLON LOWER_WORD
minimal(tff_quantified_formula) = (* 6 *) FORALL LEFT_BRACKET UPPER_WORD RIGHT_BRACKET COLON LOWER_WORD
minimal(tff_or_formula) = (* 3 *) LOWER_WORD VLINE LOWER_WORD
minimal(tff_monotype) = (* 1 *) LOWER_WORD
minimal(tff_mapping_type) = (* 3 *) LOWER_WORD ARROW LOWER_WORD
minimal(tff_logic_formula) = (* 1 *) LOWER_WORD
minimal(tff_let_term_defn) = (* 3 *) LOWER_WORD EQUAL LOWER_WORD
minimal(tff_let_term_binding) = (* 3 *) LOWER_WORD EQUAL LOWER_WORD
minimal(tff_let_formula_defn) = (* 3 *) LOWER_WORD EQUIV LOWER_WORD
minimal(tff_let_formula_binding) = (* 3 *) LOWER_WORD EQUIV LOWER_WORD
minimal(tff_let) = (* 8 *) LET_TF LEFT_PAREN LOWER_WORD EQUAL LOWER_WORD COMMA LOWER_WORD RIGHT_PAREN
minimal(tff_formula) = (* 1 *) LOWER_WORD
minimal(tff_conditional) = (* 8 *) ITE_F LEFT_PAREN LOWER_WORD COMMA LOWER_WORD COMMA LOWER_WORD RIGHT_PAREN
minimal(tff_binary_nonassoc) = (* 3 *) LOWER_WORD EQUIV LOWER_WORD
minimal(tff_binary_formula) = (* 3 *) LOWER_WORD EQUIV LOWER_WORD
minimal(tff_binary_assoc) = (* 3 *) LOWER_WORD VLINE LOWER_WORD
minimal(tff_atomic_type) = (* 1 *) LOWER_WORD
minimal(tff_annotated) = (* 9 *) TFF LEFT_PAREN LOWER_WORD COMMA LOWER_WORD COMMA LOWER_WORD RIGHT_PAREN DOT
minimal(tff_and_formula) = (* 3 *) LOWER_WORD AND LOWER_WORD
minimal(term) = (* 1 *) LOWER_WORD
minimal(system_term) = (* 1 *) DOLLAR_DOLLAR_WORD
minimal(system_functor) = (* 1 *) DOLLAR_DOLLAR_WORD
minimal(system_constant) = (* 1 *) DOLLAR_DOLLAR_WORD
minimal(system_atomic_formula) = (* 1 *) DOLLAR_DOLLAR_WORD
minimal(subtype_sign) = (* 2 *) LESS LESS
minimal(source) = (* 1 *) LOWER_WORD
minimal(real) = (* 1 *) REAL
minimal(rational) = (* 1 *) RATIONAL
minimal(plain_term) = (* 1 *) LOWER_WORD
minimal(plain_atomic_formula) = (* 1 *) LOWER_WORD
minimal(optional_info) = (* 0 *) 
minimal(number) = (* 1 *) INTEGER
minimal(name_list) = (* 1 *) LOWER_WORD
minimal(name) = (* 1 *) LOWER_WORD
minimal(literal) = (* 1 *) LOWER_WORD
minimal(list(tptp_input)) = (* 0 *) 
minimal(let_term) = (* 8 *) LET_FT LEFT_PAREN LOWER_WORD EQUIV LOWER_WORD COMMA LOWER_WORD RIGHT_PAREN
minimal(integer) = (* 1 *) INTEGER
minimal(input) = (* 1 *) EOF
minimal(infix_inequality) = (* 1 *) NOT_EQUAL
minimal(infix_equality) = (* 1 *) EQUAL
minimal(general_terms) = (* 1 *) LOWER_WORD
minimal(general_term) = (* 1 *) LOWER_WORD
minimal(general_list) = (* 2 *) LEFT_BRACKET RIGHT_BRACKET
minimal(general_function) = (* 4 *) LOWER_WORD LEFT_PAREN LOWER_WORD RIGHT_PAREN
minimal(general_data) = (* 1 *) LOWER_WORD
minimal(function_term) = (* 1 *) LOWER_WORD
minimal(formula_section) = (* 0 *) 
minimal(formula_role) = (* 1 *) LOWER_WORD
minimal(formula_data) = (* 4 *) DOLLAR_THF LEFT_PAREN LOWER_WORD RIGHT_PAREN
minimal(fol_quantifier) = (* 1 *) FORALL
minimal(fol_infix_unary) = (* 3 *) LOWER_WORD NOT_EQUAL LOWER_WORD
minimal(fof_variable_list) = (* 1 *) UPPER_WORD
minimal(fof_unitary_formula) = (* 1 *) LOWER_WORD
minimal(fof_unary_formula) = (* 2 *) NOT LOWER_WORD
minimal(fof_tuple_list) = (* 1 *) LOWER_WORD
minimal(fof_tuple) = (* 2 *) LEFT_BRACKET RIGHT_BRACKET
minimal(fof_sequent) = (* 5 *) LEFT_BRACKET RIGHT_BRACKET GENTZEN_ARROW LEFT_BRACKET RIGHT_BRACKET
minimal(fof_quantified_formula) = (* 6 *) FORALL LEFT_BRACKET UPPER_WORD RIGHT_BRACKET COLON LOWER_WORD
minimal(fof_or_formula) = (* 3 *) LOWER_WORD VLINE LOWER_WORD
minimal(fof_logic_formula) = (* 1 *) LOWER_WORD
minimal(fof_formula) = (* 1 *) LOWER_WORD
minimal(fof_binary_nonassoc) = (* 3 *) LOWER_WORD EQUIV LOWER_WORD
minimal(fof_binary_formula) = (* 3 *) LOWER_WORD EQUIV LOWER_WORD
minimal(fof_binary_assoc) = (* 3 *) LOWER_WORD VLINE LOWER_WORD
minimal(fof_annotated) = (* 9 *) FOF LEFT_PAREN LOWER_WORD COMMA LOWER_WORD COMMA LOWER_WORD RIGHT_PAREN DOT
minimal(fof_and_formula) = (* 3 *) LOWER_WORD AND LOWER_WORD
minimal(file_name) = (* 1 *) SINGLE_QUOTED
minimal(file) = (* 1 *) EOF
minimal(distinct_object) = (* 1 *) DISTINCT_OBJECT
minimal(disjunction) = (* 1 *) LOWER_WORD
minimal(defined_type) = (* 1 *) DOLLAR_WORD
minimal(defined_term) = (* 1 *) INTEGER
minimal(defined_plain_term) = (* 1 *) DOLLAR_WORD
minimal(defined_plain_formula) = (* 1 *) DOLLAR_WORD
minimal(defined_infix_pred) = (* 1 *) EQUAL
minimal(defined_infix_formula) = (* 3 *) LOWER_WORD EQUAL LOWER_WORD
minimal(defined_functor) = (* 1 *) DOLLAR_WORD
minimal(defined_constant) = (* 1 *) DOLLAR_WORD
minimal(defined_atomic_term) = (* 1 *) DOLLAR_WORD
minimal(defined_atomic_formula) = (* 1 *) DOLLAR_WORD
minimal(defined_atom) = (* 1 *) INTEGER
minimal(constant) = (* 1 *) LOWER_WORD
minimal(conditional_term) = (* 8 *) ITE_T LEFT_PAREN LOWER_WORD COMMA LOWER_WORD COMMA LOWER_WORD RIGHT_PAREN
minimal(cnf_formula) = (* 1 *) LOWER_WORD
minimal(cnf_annotated) = (* 9 *) CNF LEFT_PAREN LOWER_WORD COMMA LOWER_WORD COMMA LOWER_WORD RIGHT_PAREN DOT
minimal(binary_connective) = (* 1 *) EQUIV
minimal(atomic_word) = (* 1 *) LOWER_WORD
minimal(atomic_system_word) = (* 1 *) DOLLAR_DOLLAR_WORD
minimal(atomic_formula) = (* 1 *) LOWER_WORD
minimal(atomic_defined_word) = (* 1 *) DOLLAR_WORD
minimal(assoc_connective) = (* 1 *) VLINE
minimal(arguments) = (* 1 *) LOWER_WORD
minimal(annotations) = (* 0 *) 
minimal(annotated_formula) = (* 9 *) THF LEFT_PAREN LOWER_WORD COMMA LOWER_WORD COMMA LOWER_WORD RIGHT_PAREN DOT
follow(variable) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(useful_info) = RIGHT_PAREN
follow(unary_negation) = XOR VLINE UPPER_WORD STAR SINGLE_QUOTED RIGHT_PAREN RIGHT_BRACKET REAL RATIONAL PLUS NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY ITE_T ITE_F INTEGER IMPLY FORALL EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT COMMA COLON ARROW APPLY AND
follow(unary_connective) = XOR VLINE UPPER_WORD STAR SINGLE_QUOTED RIGHT_PAREN RIGHT_BRACKET REAL RATIONAL PLUS NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY ITE_T ITE_F INTEGER IMPLY FORALL EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT COMMA COLON ARROW APPLY AND
follow(tptp_input) = TPI THF TFF INCLUDE FOF EOF CNF #
follow(tptp_include) = TPI THF TFF INCLUDE FOF EOF CNF #
follow(tptp_functor) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LESS LEFT_PAREN LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(tpi_formula) = RIGHT_PAREN COMMA
follow(tpi_annotated) = TPI THF TFF INCLUDE FOF EOF CNF #
follow(thf_xprod_type) = STAR RIGHT_PAREN RIGHT_BRACKET COMMA
follow(thf_variable_list) = RIGHT_BRACKET
follow(thf_variable) = RIGHT_BRACKET COMMA
follow(thf_unitary_type) = STAR RIGHT_PAREN RIGHT_BRACKET PLUS COMMA ARROW
follow(thf_unitary_formula) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND
follow(thf_union_type) = RIGHT_PAREN RIGHT_BRACKET PLUS COMMA
follow(thf_unary_formula) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND
follow(thf_unary_connective) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(thf_typed_variable) = RIGHT_BRACKET COMMA
follow(thf_typeable_formula) = COLON
follow(thf_type_formula) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(thf_tuple_list) = RIGHT_BRACKET
follow(thf_tuple) = RIGHT_PAREN GENTZEN_ARROW COMMA
follow(thf_top_level_type) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(thf_subtype) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(thf_sequent) = RIGHT_PAREN COMMA
follow(thf_quantifier) = LEFT_BRACKET
follow(thf_quantified_formula) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND
follow(thf_pair_connective) = XOR VLINE UPPER_WORD STAR SINGLE_QUOTED SIGMA RIGHT_PAREN RIGHT_BRACKET REAL RATIONAL PLUS PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION COMMA COLON ARROW APPLY AND
follow(thf_or_formula) = VLINE RIGHT_PAREN RIGHT_BRACKET COMMA
follow(thf_mapping_type) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(thf_logic_formula) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(thf_let_term_defn) = COMMA
follow(thf_let_formula_defn) = COMMA
follow(thf_let) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND
follow(thf_formula) = RIGHT_PAREN COMMA
follow(thf_conn_term) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(thf_conditional) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA ARROW APPLY AND
follow(thf_binary_type) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(thf_binary_tuple) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(thf_binary_pair) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(thf_binary_formula) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(thf_atom) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(thf_apply_formula) = RIGHT_PAREN RIGHT_BRACKET COMMA APPLY
follow(thf_annotated) = TPI THF TFF INCLUDE FOF EOF CNF #
follow(thf_and_formula) = RIGHT_PAREN RIGHT_BRACKET COMMA AND
follow(tff_xprod_type) = STAR RIGHT_PAREN
follow(tff_variable_list) = RIGHT_BRACKET
follow(tff_variable) = RIGHT_BRACKET COMMA
follow(tff_untyped_atom) = COLON
follow(tff_unitary_type) = STAR ARROW
follow(tff_unitary_formula) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND
follow(tff_unary_formula) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND
follow(tff_typed_variable) = RIGHT_BRACKET COMMA
follow(tff_typed_atom) = RIGHT_PAREN COMMA
follow(tff_type_arguments) = RIGHT_PAREN
follow(tff_tuple_list) = RIGHT_BRACKET
follow(tff_tuple) = RIGHT_PAREN GENTZEN_ARROW COMMA
follow(tff_top_level_type) = RIGHT_PAREN COMMA
follow(tff_sequent) = RIGHT_PAREN COMMA
follow(tff_quantified_type) = RIGHT_PAREN COMMA
follow(tff_quantified_formula) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND
follow(tff_or_formula) = VLINE RIGHT_PAREN RIGHT_BRACKET COMMA
follow(tff_monotype) = RIGHT_PAREN COMMA
follow(tff_mapping_type) = RIGHT_PAREN COMMA
follow(tff_logic_formula) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(tff_let_term_defn) = COMMA
follow(tff_let_term_binding) = RIGHT_PAREN COMMA
follow(tff_let_formula_defn) = COMMA
follow(tff_let_formula_binding) = RIGHT_PAREN COMMA
follow(tff_let) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND
follow(tff_formula) = RIGHT_PAREN COMMA
follow(tff_conditional) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND
follow(tff_binary_nonassoc) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(tff_binary_formula) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(tff_binary_assoc) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(tff_atomic_type) = STAR RIGHT_PAREN RIGHT_BRACKET COMMA ARROW
follow(tff_annotated) = TPI THF TFF INCLUDE FOF EOF CNF #
follow(tff_and_formula) = RIGHT_PAREN RIGHT_BRACKET COMMA AND
follow(term) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(system_term) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(system_functor) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(system_constant) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(system_atomic_formula) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND
follow(subtype_sign) = SINGLE_QUOTED LOWER_WORD
follow(source) = RIGHT_PAREN COMMA
follow(real) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(rational) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(plain_term) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(plain_atomic_formula) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND
follow(optional_info) = RIGHT_PAREN
follow(number) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(name_list) = RIGHT_BRACKET
follow(name) = RIGHT_BRACKET COMMA
follow(literal) = VLINE RIGHT_PAREN COMMA
follow(list(tptp_input)) = EOF
follow(let_term) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(integer) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(input) = #
follow(infix_inequality) = XOR VLINE UPPER_WORD STAR SINGLE_QUOTED SIGMA RIGHT_PAREN RIGHT_BRACKET REAL RATIONAL PLUS PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION COMMA COLON ARROW APPLY AND
follow(infix_equality) = XOR VLINE UPPER_WORD STAR SINGLE_QUOTED SIGMA RIGHT_PAREN RIGHT_BRACKET REAL RATIONAL PLUS PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION COMMA COLON ARROW APPLY AND
follow(general_terms) = RIGHT_PAREN RIGHT_BRACKET
follow(general_term) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(general_list) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(general_function) = RIGHT_PAREN RIGHT_BRACKET COMMA COLON
follow(general_data) = RIGHT_PAREN RIGHT_BRACKET COMMA COLON
follow(function_term) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(formula_section) = RIGHT_PAREN
follow(formula_role) = COMMA
follow(formula_data) = RIGHT_PAREN RIGHT_BRACKET COMMA COLON
follow(fol_quantifier) = LEFT_BRACKET
follow(fol_infix_unary) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND
follow(fof_variable_list) = RIGHT_BRACKET
follow(fof_unitary_formula) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND
follow(fof_unary_formula) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND
follow(fof_tuple_list) = RIGHT_BRACKET
follow(fof_tuple) = RIGHT_PAREN GENTZEN_ARROW COMMA
follow(fof_sequent) = RIGHT_PAREN COMMA
follow(fof_quantified_formula) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND
follow(fof_or_formula) = VLINE RIGHT_PAREN RIGHT_BRACKET COMMA
follow(fof_logic_formula) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(fof_formula) = RIGHT_PAREN COMMA
follow(fof_binary_nonassoc) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(fof_binary_formula) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(fof_binary_assoc) = RIGHT_PAREN RIGHT_BRACKET COMMA
follow(fof_annotated) = TPI THF TFF INCLUDE FOF EOF CNF #
follow(fof_and_formula) = RIGHT_PAREN RIGHT_BRACKET COMMA AND
follow(file_name) = RIGHT_PAREN COMMA
follow(file) = #
follow(distinct_object) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(disjunction) = VLINE RIGHT_PAREN COMMA
follow(defined_type) = STAR RIGHT_PAREN RIGHT_BRACKET COMMA ARROW
follow(defined_term) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(defined_plain_term) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(defined_plain_formula) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND
follow(defined_infix_pred) = UPPER_WORD SINGLE_QUOTED REAL RATIONAL LOWER_WORD LET_TT LET_FT ITE_T INTEGER DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT
follow(defined_infix_formula) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND
follow(defined_functor) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(defined_constant) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(defined_atomic_term) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(defined_atomic_formula) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND
follow(defined_atom) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(constant) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LESS LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(conditional_term) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(cnf_formula) = RIGHT_PAREN COMMA
follow(cnf_annotated) = TPI THF TFF INCLUDE FOF EOF CNF #
follow(binary_connective) = XOR VLINE UPPER_WORD STAR SINGLE_QUOTED SIGMA RIGHT_PAREN RIGHT_BRACKET REAL RATIONAL PLUS PI NOT_EQUAL NOTVLINE NOTAND NOT LOWER_WORD LET_TT LET_TF LET_FT LET_FF LEFT_PAREN LEFT_IMPLY LAMBDA ITE_T ITE_F INTEGER INDEFINITE_DESCRIPTION IMPLY FORALL_TY FORALL EXISTS_TY EXISTS EQUIV EQUAL DOLLAR_WORD DOLLAR_DOLLAR_WORD DISTINCT_OBJECT DEFINITE_DESCRIPTION COMMA COLON ARROW APPLY AND
follow(atomic_word) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LESS LEFT_PAREN LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(atomic_system_word) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(atomic_formula) = XOR VLINE RIGHT_PAREN RIGHT_BRACKET NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV COMMA AND
follow(atomic_defined_word) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_PAREN LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(assoc_connective) = XOR VLINE STAR RIGHT_PAREN RIGHT_BRACKET PLUS NOT_EQUAL NOTVLINE NOTAND LEFT_IMPLY IMPLY EQUIV EQUAL COMMA COLON ARROW APPLY AND
follow(arguments) = RIGHT_PAREN
follow(annotations) = RIGHT_PAREN
follow(annotated_formula) = TPI THF TFF INCLUDE FOF EOF CNF #
Built an LR(0) automaton with 567 states.
The grammar is not SLR(1) -- 6 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 630 states.
269 out of 630 states have a default reduction.
168 out of 630 states are represented.
131 out of 218 symbols keep track of their start position.
117 out of 218 symbols keep track of their end position.
164 out of 300 productions exploit shiftreduce optimization.
0 out of 630 states can peek at an error.
1721 functions before inlining, 208 functions after inlining.
