%{
open Lm_printf
open Lm_symbol
open Lm_location

open Omake_pos
open Omake_ast
open Omake_symbol
open Omake_ast_util
open Omake_value_type

module Pos = MakePos (struct let name = "Omake_parse" end)
open Pos;;

(*
 * Define flags.
 *)
let define_flag (s, loc) =
   match s with
      "=" -> DefineNormal
    | "+=" -> DefineAppend
    | _ ->
       raise (OmakeException (loc_exp_pos loc, StringStringError ("undefined assignment operator", s)))

(*
 * Convert arguments to parameters.
 *)
let key_of_id s =
   Lm_symbol.add (String.sub s 1 (String.length s - 1))

let parse_id_param s loc =
   match s.[0] with
      '?' -> OptionalParam (key_of_id s, NullExp loc, loc)
    | '~' -> RequiredParam (key_of_id s, loc)
    | _   -> NormalParam (Lm_symbol.add s, loc)

let param_of_arg arg =
   match arg with
      IdArg (s, _, loc) ->
        parse_id_param s loc
    | NormalArg (KeyArg (v, e)) ->
        OptionalParam (v, e, loc_of_exp e)
    | NormalArg (ExpArg e) ->
        raise (OmakeException (loc_exp_pos (loc_of_exp e), StringAstError ("illegal function parameter", e)))
    | NormalArg (ArrowArg (_, e)) ->
        raise (OmakeException (loc_exp_pos (loc_of_exp e), StringAstError ("illegal function argument", e)))

let get_fun_params args =
   List.map param_of_arg args

(*
 * Remove the IdArg.
 *)
let arg_of_parse_arg = function
   IdArg (s, w, loc1) ->
      let id = StringIdExp (s, loc1) in
      let e =
         match w with
             Some (w, loc2) ->
                SequenceExp ([id; StringWhiteExp (w, loc2)], loc1)
           | None ->
                id
      in
          ExpArg e
 | NormalArg arg ->
      arg

let args_of_parse_args = List.map arg_of_parse_arg

(*
 * Utilities.
 *)
let rec simplify e =
   match e with
      SequenceExp ([e], _) ->
         simplify e
    | _ ->
         e

let sequence_exp l loc =
   match l with
      [e] ->
         e
    | _ ->
         SequenceExp (l, loc)


(*
 * Intern the method name.
 *)
let method_id_intern idl =
   List.map Lm_symbol.add idl

(*
 * Get a string from a method name.
 *)
let method_id_string idl =
   let buf = Buffer.create 32 in
   let rec collect idl =
      match idl with
         [id] ->
            Buffer.add_string buf id
       | id :: idl ->
            Buffer.add_string buf id;
            Buffer.add_char buf '.';
            collect idl
       | [] ->
            ()
   in
      collect idl;
      Buffer.contents buf

let rec method_id_rev_sequence loc items idl =
   match idl with
      [id] ->
         (StringIdExp (id, loc)) :: items
    | id :: idl ->
         let items = StringOpExp (".", loc) :: StringIdExp (id, loc) :: items in
            method_id_rev_sequence loc items idl
    | [] ->
         items

let method_id_sequence loc idl =
   List.rev (method_id_rev_sequence loc [] idl)

let method_id_string_exp idl loc =
   SequenceExp (method_id_sequence loc idl, loc)

let method_id_prefix_string_exp idl loc =
   let idl = List.rev (method_id_rev_sequence loc [StringOpExp (".", loc)] idl) in
      SequenceExp (idl, loc)

let var_quote (strategy, s, loc) =
   KeyExp (strategy, s, loc), loc

(*
 * Convert to a body flag and text.
 *)
let get_optcolon_text opt loc =
   match opt with
      None ->
         OptBody, NullExp loc
    | Some (body, arg) ->
         body, arg
(*
 * A 3-place rule.
 *)
let rule3 multiple (target, loc1) ploc pattern source loc2 body =
   let loc = union_loc loc1 loc2 in
      match pattern with
         Some (pattern, _) ->
            RuleExp (multiple, target, pattern, source, body, loc)
       | None ->
            RuleExp (multiple, target, NullExp loc2, source, body, loc)

let rule2 multiple target ploc source loc2 body =
   rule3 multiple target ploc None source loc2 body
%}
%start deps
%start shell
%start string
%token <string * Lm_location.loc> TokArray
%token <string * Lm_location.loc> TokArrow
%token <string * Lm_location.loc> TokBeginQuote
%token <string * Lm_location.loc> TokBeginQuoteString
%token <string * Lm_location.loc> TokCatch
%token <string * Lm_location.loc> TokClass
%token <string * Lm_location.loc> TokColon
%token <string * Lm_location.loc> TokComma
%token <string * Omake_ast.apply_strategy * Lm_location.loc> TokDollar
%token <string * Lm_location.loc> TokDot
%token <string * Lm_location.loc> TokDoubleColon
%token <string * Lm_location.loc> TokEndQuote
%token <string * Lm_location.loc> TokEndQuoteString
%token <Lm_location.loc> TokEof
%token <Lm_location.loc> TokEol
%token <string * Lm_location.loc> TokEq
%token <string * Lm_location.loc> TokFloat
%token <string * Lm_location.loc> TokId
%token <string * Lm_location.loc> TokInt
%token <string * Lm_location.loc> TokKey
%token <string * Lm_location.loc> TokKeyword
%token <string * Lm_location.loc> TokLeftParen
%token <string * Lm_location.loc> TokNamedColon
%token <string * Lm_location.loc> TokOp
%token <string * Lm_location.loc> TokRightParen
%token <string * Lm_location.loc> TokString
%token <string * Lm_location.loc> TokStringQuote
%token <Omake_ast.apply_strategy * string * Lm_location.loc> TokVar
%token <Omake_ast.apply_strategy * string * Lm_location.loc> TokVarQuote
%token <string * Lm_location.loc> TokWhite
%type <(Omake_ast.exp * Omake_ast.exp * Lm_location.loc) list> deps
%type <Omake_ast.body_flag * Omake_ast.exp> shell
%type <Omake_ast.body_flag * Omake_ast.exp> string
%%

string:
  _1 = TokEof
    {          ( raise End_of_file )}
| _1 = text _2 = TokEol _3 = TokEof
    {          ( NoBody, sequence_exp _1 _2 )}

shell:
  _1 = TokEof
    {          ( raise End_of_file )}
| _1 = shell_line _2 = TokEof
    {          ( _1 )}

shell_line:
  _1 = opt_white _2 = TokEol
    {          ( NoBody, sequence_exp [] _2 )}
| _1 = TokKeyword _2 = TokWhite _3 = keyword_text_optcolon _4 = TokEol
    {          ( let id, loc1 = _1 in
            let body, arg = get_optcolon_text _3 _4 in
            let loc = union_loc loc1 _4 in
               body, CommandExp (Lm_symbol.add id, arg, [], loc)
          )}
| _1 = TokKeyword _2 = opt_literal_colon _3 = TokEol
    {          ( let id, loc1 = _1 in
            let body = _2 in
            let loc = union_loc loc1 _3 in
            let arg = NullExp loc in
               body, CommandExp (Lm_symbol.add id, arg, [], loc)
          )}
| _1 = TokKeyword _2 = opt_white _3 = TokLeftParen _4 = opt_args _5 = TokRightParen _6 = opt_colon _7 = TokEol
    {          ( let id, loc1 = _1 in
            let body = _6 in
            let loc = union_loc loc1 _7 in
	    let args = args_of_parse_args _4 in
            let e = ApplyExp (CommandApply, Lm_symbol.add id, args, loc) in
               body, e
          )}
| _1 = TokCatch _2 = opt_white _3 = TokId _4 = opt_white _5 = TokLeftParen _6 = opt_white _7 = TokId _8 = opt_white _9 = TokRightParen _10 = opt_colon _11 = TokEol
    {          ( let _, loc1 = _1 in
            let loc = union_loc loc1 _11 in
            let name, _ = _3 in
            let v, _ = _7 in
               _10, CatchExp (Lm_symbol.add name, Lm_symbol.add v, [], loc)
          )}
| _1 = TokClass _2 = opt_id_list _3 = TokEol
    {          ( let _, loc1 = _1 in
            let loc = union_loc loc1 _3 in
               NoBody, ClassExp (List.map Lm_symbol.add _2, loc)
          )}
| _1 = method_id_opt_white _2 = TokEq _3 = opt_white _4 = TokEol
    {          ( let id, loc1 = _1 in
            let loc2 = _4 in
            let id = method_id_intern id in
            let loc = union_loc loc1 loc2 in
            let add_flag = define_flag _2 in
               ColonBody, VarDefBodyExp (id, DefineString, add_flag, [], loc)
          )}
| _1 = method_id_prefix_opt_white _2 = TokEq _3 = opt_white _4 = TokEol
    {          ( let id, loc1 = _1 in
            let loc2 = _4 in
            let id = method_id_intern id in
            let loc = union_loc loc1 loc2 in
            let add_flag = define_flag _2 in
               ColonBody, ObjectDefExp (id, add_flag, [], loc)
          )}
| _1 = method_id_opt_white _2 = TokEq _3 = opt_white _4 = text_nonempty _5 = TokEol
    {          ( let id, loc1 = _1 in
            let loc2 = _5 in
            let e = simplify _4 in
            let id = method_id_intern id in
            let loc = union_loc loc1 loc2 in
            let add_flag = define_flag _2 in
               NoBody, VarDefExp (id, DefineString, add_flag, e, loc)
          )}
| _1 = var_quote_opt_white _2 = TokEq _3 = opt_white _4 = TokEol
    {          ( let _, id, loc1 = _1 in
            let loc2 = _4 in
            let loc = union_loc loc1 loc2 in
            let add_flag = define_flag _2 in
               ColonBody, KeyDefBodyExp (id, DefineString, add_flag, [], loc)
          )}
| _1 = var_quote_opt_white _2 = TokEq _3 = opt_white _4 = text_nonempty _5 = TokEol
    {          ( let _, id, loc1 = _1 in
            let loc2 = _5 in
            let e = simplify _4 in
            let loc = union_loc loc1 loc2 in
            let add_flag = define_flag _2 in
               NoBody, KeyDefExp (id, DefineString, add_flag, e, loc)
          )}
| _1 = method_id_opt_white _2 = TokArray _3 = opt_white _4 = TokEq _5 = opt_white _6 = TokEol
    {          ( let id, loc1 = _1 in
            let loc2 = _6 in
            let id = method_id_intern id in
            let loc = union_loc loc1 loc2 in
            let add_flag = define_flag _4 in
               ArrayBody, VarDefBodyExp (id, DefineArray, add_flag, [], loc)
          )}
| _1 = method_id_opt_white _2 = TokArray _3 = opt_white _4 = TokEq _5 = opt_white _6 = text_nonempty _7 = TokEol
    {          ( let id, loc1 = _1 in
            let loc2 = _7 in
            let id = method_id_intern id in
            let loc = union_loc loc1 loc2 in
            let add_flag = define_flag _4 in
               NoBody, VarDefExp (id, DefineArray, add_flag, _6, loc)
          )}
| _1 = method_id_opt_white _2 = TokLeftParen _3 = opt_args _4 = TokRightParen _5 = opt_colon _6 = TokEol
    {          ( let id, loc1 = _1 in
            let body = _5 in
            let loc = union_loc loc1 _6 in
            let args = args_of_parse_args _3 in
            let e =
               match id with
                  [id] ->
                     ApplyExp (CommandApply, Lm_symbol.add id, args, loc)
                | _ ->
                     MethodApplyExp (CommandApply, method_id_intern id, args, loc)
            in
               body, e
          )}
| _1 = method_id_opt_white _2 = TokLeftParen _3 = opt_args _4 = TokRightParen _5 = opt_colon _6 = TokArrow _7 = opt_white _8 = TokEol
    {          ( let id, loc1 = _1 in
            let body = _5 in
            let loc = union_loc loc1 _8 in
            let params = get_fun_params _3 in
            let arg = ArrowArg (params, StringOpExp ("...", loc)) in
            let e =
               match id with
                  [id] ->
                     ApplyExp (CommandApply, Lm_symbol.add id, [arg], loc)
                | _ ->
                     MethodApplyExp (CommandApply, method_id_intern id, [arg], loc)
            in
               body, e
          )}
| _1 = method_id_opt_white _2 = TokLeftParen _3 = opt_args _4 = TokRightParen _5 = opt_white _6 = TokEq _7 = opt_white _8 = TokEol
    {          ( let id, loc1 = _1 in
            let id = method_id_intern id in
            let params = get_fun_params _3 in
            let loc = union_loc loc1 _8 in
               ColonBody, FunDefExp (id, params, [], loc)
          )}
| _1 = other_id_target _2 = TokColon _3 = source _4 = TokEol
    {          ( ColonBody, rule2 false _1 _2 _3 _4 [] )}
| _1 = other_id_target _2 = TokColon _3 = target _4 = TokColon _5 = source _6 = TokEol
    {          ( ColonBody, rule3 false _1 _2 _3 _5 _6 [] )}
| _1 = other_target _2 = TokColon _3 = source _4 = TokEol
    {          ( ColonBody, rule2 false _1 _2 _3 _4 [] )}
| _1 = other_target _2 = TokDoubleColon _3 = source _4 = TokEol
    {          ( ColonBody, rule2 true _1 _2 _3 _4 [] )}
| _1 = other_target _2 = TokColon _3 = target _4 = TokColon _5 = source _6 = TokEol
    {          ( ColonBody, rule3 false _1 _2 _3 _5 _6 [] )}
| _1 = other_target _2 = TokDoubleColon _3 = target _4 = TokColon _5 = source _6 = TokEol
    {          ( ColonBody, rule3 true _1 _2 _3 _5 _6 [] )}
| _1 = method_id_opt_white _2 = TokDoubleColon _3 = opt_white _4 = source_nonapply _5 = TokEol
    {          ( let idl, loc = _1 in
            let e = method_id_string_exp idl loc in
               ColonBody, rule2 true (e, loc) _2 _4 _5 []
          )}
| _1 = method_id_prefix_opt_white _2 = TokDoubleColon _3 = source _4 = TokEol
    {          ( let idl, loc = _1 in
            let e = method_id_prefix_string_exp idl loc in
               ColonBody, rule2 true (e, loc) _2 _3 _4 []
          )}
| _1 = method_id_opt_white _2 = TokDoubleColon _3 = opt_white _4 = method_id_opt_white _5 = TokLeftParen _6 = opt_args _7 = TokRightParen _8 = opt_colon _9 = TokEol
    {          ( let super, loc1 = _1 in
            let name, _ = _4 in
            let body = _8 in
            let loc = union_loc loc1 _9 in
            let args = args_of_parse_args _6 in
            let e =
               match super, name with
                  [super], [name] ->
                     SuperApplyExp (CommandApply, Lm_symbol.add super, Lm_symbol.add name, args, loc)
                | _, [_] ->
                     raise (OmakeException (loc_exp_pos loc, StringStringError ("illegal super class", method_id_string super)))
                | _ ->
                     raise (OmakeException (loc_exp_pos loc, StringStringError ("illegal field name", method_id_string name)))
            in
               body, e
          )}
| _1 = other_id_target _2 = TokEol
    {          ( let e, loc = _1 in
               NoBody, ShellExp (e, loc)
          )}
| _1 = other_target _2 = TokEol
    {          ( let e, loc = _1 in
               NoBody, ShellExp (e, loc)
          )}

deps:
  _1 = rev_deps _2 = TokEof
    {          ( List.rev _1 )}

rev_deps:
  
    {          ( [] )}
| _1 = rev_deps _2 = dep
    {          ( _2 :: _1 )}
| _1 = rev_deps _2 = TokEol
    {          ( _1 )}

dep:
  _1 = target _2 = TokColon _3 = target _4 = TokEol
    {          ( let _, loc2 = _2 in
            let target, loc1 =
               match _1 with
                  Some (e, loc1) -> e, loc1
                | None ->
                     NullExp loc2, loc2
            in
            let source =
               match _3 with
                  Some (e, _) -> e
                | None -> NullExp loc2
            in
            let loc = union_loc loc1 _4 in
               target, source, loc
          )}

apply:
  _1 = TokDollar _2 = opt_white _3 = TokLeftParen _4 = opt_white _5 = method_name _6 = opt_apply_args _7 = TokRightParen
    {          ( let _, strategy, loc1 = _1 in
            let _, loc2 = _7 in
            let idl, _ = _5 in
            let args = args_of_parse_args _6 in
            let loc = union_loc loc1 loc2 in
               match idl with
                  [id] ->
                     ApplyExp (strategy, Lm_symbol.add id, args, loc), loc
                | _ ->
                     MethodApplyExp (strategy, method_id_intern idl, args, loc), loc
          )}
| _1 = TokDollar _2 = opt_white _3 = TokLeftParen _4 = opt_white _5 = id _6 = TokDoubleColon _7 = id _8 = opt_apply_args _9 = TokRightParen
    {          ( let _, strategy, loc1 = _1 in
            let _, loc2 = _9 in
            let super, _ = _5 in
            let v, _ = _7 in
            let args = args_of_parse_args _8 in
            let loc = union_loc loc1 loc2 in
               SuperApplyExp (strategy, Lm_symbol.add super, Lm_symbol.add v, args, loc), loc
          )}
| _1 = TokVar
    {          ( let strategy, id, loc = _1 in
               ApplyExp (strategy, Lm_symbol.add id, [], loc), loc
          )}
| _1 = TokBeginQuote _2 = rev_text _3 = TokEndQuote
    {          ( let id1, loc1 = _1 in
            let id2, loc2 = _3 in
            let loc = union_loc loc1 loc2 in
            let el = StringOtherExp (id1, loc1) :: List.rev_append _2 [StringOtherExp (id2, loc2)] in
               QuoteExp (el, loc), loc
          )}
| _1 = TokBeginQuoteString _2 = rev_text _3 = TokEndQuoteString
    {          ( let id, loc1 = _1 in
            let _, loc2 = _3 in
            let loc = union_loc loc1 loc2 in
               QuoteStringExp (id.[0], List.rev _2, loc), loc
          )}
| _1 = TokStringQuote
    {          ( let s, loc = _1 in
               QuoteExp ([StringOtherExp (s, loc)], loc), loc
          )}

var_quote_opt_white:
  _1 = var_quote
    {          ( _1 )}
| _1 = var_quote_white
    {          ( let strategy, id, _, loc = _1 in
               strategy, id, loc
          )}

var_quote_white:
  _1 = var_quote _2 = TokWhite
    {          ( let strategy, id, loc = _1 in
            let s, _ = _2 in
               strategy, id, s, loc
          )}

var_quote:
  _1 = TokVarQuote
    {          ( _1 )}

quote_opt_white:
  _1 = var_quote_opt_white
    {          ( var_quote _1 )}

quote_white:
  _1 = var_quote_white
    {          ( let strategy, id, s, loc = _1 in
            let e, _ = var_quote (strategy, id, loc) in
               e, s, loc
          )}

quote:
  _1 = var_quote
    {          ( var_quote _1 )}

method_name:
  _1 = rev_method_name
    {          ( let idl, loc = _1 in
               List.rev idl, loc
          )}

rev_method_name:
  _1 = id
    {          ( let id, loc = _1 in
               [id], loc
          )}
| _1 = rev_method_name _2 = TokDot _3 = id
    {          ( let idl, loc1 = _1 in
            let id, loc2 = _3 in
               id :: idl, union_loc loc1 loc2
          )}

id:
  _1 = TokId
    {          ( _1 )}
| _1 = TokKeyword
    {          ( _1 )}
| _1 = TokCatch
    {          ( _1 )}
| _1 = TokClass
    {          ( _1 )}

opt_id_list:
  
    {          ( [] )}
| _1 = opt_id_list _2 = white
    {          ( _1 )}
| _1 = opt_id_list _2 = id
    {          ( let id, _ = _2 in
               id :: _1
          )}

other_id_target:
  _1 = method_id_opt_white
    {          ( let idl, loc = _1 in
               method_id_string_exp idl loc, loc
          )}
| _1 = method_id_prefix_opt_white
    {          ( let idl, loc = _1 in
               method_id_prefix_string_exp idl loc, loc
          )}
| _1 = quote_opt_white
    {          ( _1 )}

method_id_opt_white:
  _1 = rev_method_id
    {          ( let id, loc = _1 in
               List.rev id, loc
          )}
| _1 = rev_method_id_white
    {          ( let id, _, loc = _1 in
               List.rev id, loc
          )}

method_id_prefix_opt_white:
  _1 = rev_method_id_prefix
    {          ( let id, loc = _1 in
               List.rev id, loc
          )}
| _1 = rev_method_id_prefix_white
    {          ( let id, _, loc = _1 in
               List.rev id, loc
          )}

rev_method_id_white:
  _1 = rev_method_id _2 = TokWhite
    {          ( let id, loc1 = _1 in
            let s, loc2 = _2 in
            let loc = union_loc loc1 loc2 in
               id, s, loc
          )}

rev_method_id_prefix_white:
  _1 = rev_method_id_prefix _2 = TokWhite
    {          ( let id, loc1 = _1 in
            let s, loc2 = _2 in
            let loc = union_loc loc1 loc2 in
               id, s, loc
          )}

rev_method_id:
  _1 = TokId
    {          ( let id, loc = _1 in
               [id], loc
          )}
| _1 = rev_method_id_prefix _2 = id
    {          ( let idl, loc1 = _1 in
            let id, loc2 = _2 in
            let loc = union_loc loc1 loc2 in
               id :: idl, loc
          )}

rev_method_id_prefix:
  _1 = rev_method_id _2 = TokDot
    {          ( let idl, loc1 = _1 in
            let _, loc2 = _2 in
            let loc = union_loc loc1 loc2 in
               idl, loc
          )}
| _1 = TokKeyword _2 = TokDot
    {          ( let id, loc1 = _1 in
            let _, loc2 = _2 in
            let loc = union_loc loc1 loc2 in
               [id], loc
          )}
| _1 = TokClass _2 = TokDot
    {          ( let id, loc1 = _1 in
            let _, loc2 = _2 in
            let loc = union_loc loc1 loc2 in
               [id], loc
          )}
| _1 = TokCatch _2 = TokDot
    {          ( let id, loc1 = _1 in
            let _, loc2 = _2 in
            let loc = union_loc loc1 loc2 in
               [id], loc
          )}

other_target:
  _1 = rev_other_target
    {          ( let l, loc = _1 in
               sequence_exp (List.rev l) loc, loc
          )}

rev_other_target:
  _1 = other_start
    {          ( let e, loc = _1 in
               [e], loc
          )}
| _1 = rev_method_id _2 = other_method_id
    {          ( let idl, loc1 = _1 in
            let e, loc2 = _2 in
            let loc = union_loc loc1 loc2 in
            let el = [e; method_id_string_exp (List.rev idl) loc1] in
               el, loc
          )}
| _1 = rev_method_id_white _2 = other_method_id_white
    {          ( let idl, s, loc1 = _1 in
            let e, loc2 = _2 in
            let loc = union_loc loc1 loc2 in
            let el = [e; StringWhiteExp (s, loc1); method_id_string_exp (List.rev idl) loc1] in
               el, loc
          )}
| _1 = rev_method_id_prefix _2 = other_method_id_prefix
    {          ( let idl, loc1 = _1 in
            let e, loc2 = _2 in
            let loc = union_loc loc1 loc2 in
            let el = [e; method_id_prefix_string_exp (List.rev idl) loc1] in
               el, loc
          )}
| _1 = rev_method_id_prefix_white _2 = other_method_id_prefix_white
    {          ( let idl, s, loc1 = _1 in
            let e, loc2 = _2 in
            let loc = union_loc loc1 loc2 in
            let el = [e; StringWhiteExp (s, loc1); method_id_prefix_string_exp (List.rev idl) loc1] in
               el, loc
          )}
| _1 = quote _2 = other_quote_id
    {          ( let id, loc1 = _1 in
            let e, loc2 = _2 in
            let loc = union_loc loc1 loc2 in
            let el = [id; e] in
               el, loc
          )}
| _1 = quote_white _2 = other_quote_id_white
    {          ( let id, s, loc1 = _1 in
            let e, loc2 = _2 in
            let loc = union_loc loc1 loc2 in
            let el = [id; StringWhiteExp (s, loc1); e] in
               el, loc
          )}
| _1 = rev_other_target _2 = target_next
    {          ( let el, loc1 = _1 in
            let e, loc2 = _2 in
            let loc = union_loc loc1 loc2 in
               e :: el, loc
          )}

source:
  _1 = target
    {         ( match _1 with
              Some (e, _) ->
                 SymbolTable.add SymbolTable.empty normal_sym e
            | None ->
                 SymbolTable.empty
         )}
| _1 = source _2 = TokNamedColon _3 = target
    {         ( let table = _1 in
           let name, _ = _2 in
              match _3 with
                 Some (e, _) ->
                    SymbolTable.add table (Lm_symbol.add name) e
               | None ->
                    table
         )}

source_nonapply:
  _1 = source_target
    {         ( match _1 with
              Some (e, _) ->
                 SymbolTable.add SymbolTable.empty normal_sym e
            | None ->
                 SymbolTable.empty
         )}
| _1 = source_nonapply _2 = TokNamedColon _3 = target
    {         ( let table = _1 in
           let name, _ = _2 in
              match _3 with
                 Some (e, _) ->
                    SymbolTable.add table (Lm_symbol.add name) e
               | None ->
                    table
         )}

source_target:
  
    {          ( None )}
| _1 = other_id_target
    {          ( Some _1 )}
| _1 = other_target
    {          ( Some _1 )}

text:
  _1 = rev_text
    {          ( List.rev _1 )}

rev_text:
  
    {          ( [] )}
| _1 = rev_text _2 = text_next
    {          ( let e, _ = _2 in
               e :: _1
          )}

target:
  _1 = opt_white
    {          ( None )}
| _1 = opt_white _2 = rev_target
    {          ( let l, loc = _2 in
               Some (sequence_exp (List.rev l) loc, loc)
          )}

rev_target:
  _1 = target_start
    {          ( let e, loc = _1 in
               [e], loc
          )}
| _1 = rev_target _2 = target_next
    {          ( let l, loc1 = _1 in
            let e, loc2 = _2 in
               e :: l, union_loc loc1 loc2
          )}

keyword_text_optcolon:
  
    {          ( None )}
| _1 = rev_keyword_text
    {          ( let code, _, el, loc = _1 in
               Some (code, sequence_exp (List.rev el) loc)
          )}

rev_keyword_text:
  _1 = keyword_target_start
    {          ( let e, loc = _1 in
               OptBody, [], [e], loc
          )}
| _1 = colon
    {          ( let e, loc = _1 in
               ColonBody, [e], [], loc
          )}
| _1 = rev_keyword_text _2 = white
    {          ( let code, final, prefix, loc1 = _1 in
            let e, loc2 = _2 in
            let loc = union_loc loc1 loc2 in
               code, e :: final, prefix, loc
          )}
| _1 = rev_keyword_text _2 = target_start
    {          ( let _, final, prefix, loc1 = _1 in
            let e, loc2 = _2 in
            let loc = union_loc loc1 loc2 in
               OptBody, [], e :: (final @ prefix), loc
          )}
| _1 = rev_keyword_text _2 = colon
    {          ( let _, final, prefix, loc1 = _1 in
            let e, loc2 = _2 in
            let loc = union_loc loc1 loc2 in
               ColonBody, [e], final @ prefix, loc
          )}

text_nonempty:
  _1 = rev_text_nonempty
    {          ( let l, loc = _1 in
               sequence_exp (List.rev l) loc
          )}

rev_text_nonempty:
  _1 = text_nonwhite
    {          ( let e, loc = _1 in
               [e], loc
          )}
| _1 = rev_text_nonempty _2 = text_next
    {          ( let l, loc1 = _1 in
            let e, loc2 = _2 in
               e :: l, union_loc loc1 loc2
          )}

opt_args:
  _1 = opt_white
    {          ( [] )}
| _1 = args
    {          ( _1 )}

opt_apply_args:
  _1 = opt_white
    {          ( [] )}
| _1 = white _2 = args
    {          ( _2 )}

args:
  _1 = rev_args
    {          ( List.rev _1 )}
| _1 = rev_arrow_args
    {          ( List.rev _1 )}
| _1 = rev_arrow_args _2 = TokComma _3 = rev_args
    {          ( List.rev_append _1 (List.rev _3) )}

rev_arrow_args:
  _1 = arrow_arg
    {          ( [_1] )}
| _1 = rev_arrow_args _2 = TokComma _3 = arrow_arg
    {          ( _3 :: _1 )}

arrow_arg:
  _1 = rev_args _2 = TokArrow _3 = opt_white _4 = rev_any_arg
    {          ( let el, loc2 = _4 in
               NormalArg (ArrowArg (get_fun_params (List.rev _1), sequence_exp (List.rev el) loc2))
          )}

rev_args:
  _1 = arg
    {          ( [_1] )}
| _1 = rev_args _2 = TokComma _3 = arg
    {          ( _3 :: _1 )}

arg:
  _1 = opt_white _2 = arg_inner
    {          ( _2 )}

arg_inner:
  _1 = rev_normal_arg
    {          ( let el, loc = _1 in
            let e = sequence_exp (List.rev el) loc in
               NormalArg (ExpArg e)
          )}
| _1 = arg_id
    {          ( let (id, loc0), w, loc = _1 in
	       IdArg (id, w, loc)
          )}
| _1 = arg_key
    {          ( let (id, loc0), w, loc = _1 in
	       IdArg (id, w, loc)
          )}
| _1 = arg_key _2 = TokEq _3 = opt_white
    {          ( let (id, _), _, loc1 = _1 in
	    let key = key_of_id id in
               NormalArg (KeyArg (key, NullExp loc1))
          )}
| _1 = arg_key _2 = TokEq _3 = opt_white _4 = rev_any_arg
    {          ( let (id, _), _, _ = _1 in
	    let key = key_of_id id in
            let el, loc2 = _4 in
               NormalArg (KeyArg (key, sequence_exp (List.rev el) loc2))
          )}

arg_id:
  _1 = id _2 = opt_white
    {          ( let id = _1 in
            let _, loc = id in
               id, _2, loc
          )}

arg_key:
  _1 = TokKey _2 = opt_white
    {          ( let id = _1 in
            let _, loc = id in
               id, _2, loc
          )}

rev_any_arg:
  _1 = paren_arg_any_start
    {          ( let e, loc = _1 in
               [e], loc
          )}
| _1 = rev_any_arg _2 = paren_arg_next
    {          ( let l, loc1 = _1 in
            let e, loc2 = _2 in
               e :: l, union_loc loc1 loc2
          )}

rev_normal_arg:
  _1 = arg_key _2 = paren_arg_next_noneq
    {          ( let (id, loc0), w, loc1 = _1 in
            let id = StringIdExp (id, loc0) in
            let e, loc2 = _2 in
            let el =
               match w with
                  Some (w, loc0) ->
                     [e; StringWhiteExp (w, loc0); id]
                | None ->
                     [e; id]
            in
               el, union_loc loc1 loc2
          )}
| _1 = arg_id _2 = paren_arg_any_start
    {          ( let (id, loc0), w, loc1 = _1 in
            let id = StringIdExp (id, loc0) in
            let e, loc2 = _2 in
            let el =
               match w with
                  Some (w, loc3) ->
                     [e; StringWhiteExp (w, loc3); id]
                | None ->
                     [e; id]
            in
               el, union_loc loc1 loc2
          )}
| _1 = paren_arg_start
    {          ( let e, loc = _1 in
               [e], loc
          )}
| _1 = rev_normal_arg _2 = paren_arg_next
    {          ( let l, loc1 = _1 in
            let e, loc2 = _2 in
               e :: l, union_loc loc1 loc2
          )}

paren_arg_any_start:
  _1 = arg_any_start
    {   ( _1 )}
| _1 = paren_arg
    {   ( _1 )}

paren_arg_next_noneq:
  _1 = arg_next_noneq
    {   ( _1 )}
| _1 = paren_arg
    {   ( _1 )}

paren_arg_start:
  _1 = arg_start
    {   ( _1 )}
| _1 = paren_arg
    {   ( _1 )}

paren_arg_next:
  _1 = arg_next
    {   ( _1 )}
| _1 = paren_arg
    {   ( _1 )}

paren_arg:
  _1 = TokLeftParen _2 = rev_paren_text _3 = TokRightParen
    {          ( let s1, loc1 = _1 in
            let sl = _2 in
            let s3, loc3 = _3 in
            let loc = union_loc loc1 loc3 in
            let el = StringOpExp (s1, loc1) :: (List.rev (StringOpExp (s3, loc3) :: sl)) in
               SequenceExp (el, loc), loc
          )}

rev_paren_text:
  
    {   ( [] )}
| _1 = rev_paren_text _2 = paren_next
    {   ( let s, _ = _2 in
               s :: _1
          )}
| _1 = rev_paren_text _2 = paren_arg
    {          ( let s, _ = _2 in
               s :: _1
          )}

colon:
  _1 = TokNamedColon
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokDoubleColon
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokColon
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}

white:
  _1 = TokWhite
    {  ( let (s, loc) = _1 in StringWhiteExp (s, loc), loc )}

text_next:
  _1 = TokWhite
    {  ( let (s, loc) = _1 in StringWhiteExp (s, loc), loc )}
| _1 = TokOp
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokLeftParen
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokRightParen
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokArrow
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokComma
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokColon
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokDoubleColon
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokNamedColon
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokEq
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokArray
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokDot
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokId
    {  ( let (s, loc) = _1 in StringIdExp (s, loc), loc )}
| _1 = TokInt
    {  ( let (s, loc) = _1 in StringIntExp (s, loc), loc )}
| _1 = TokFloat
    {  ( let (s, loc) = _1 in StringFloatExp (s, loc), loc )}
| _1 = TokKey
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokKeyword
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokCatch
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokClass
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokString
    {  ( let (s, loc) = _1 in StringOtherExp (s, loc), loc )}
| _1 = quote
    {  ( _1 )}
| _1 = apply
    {  ( _1 )}

text_nonwhite:
  _1 = TokOp
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokLeftParen
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokRightParen
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokArrow
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokComma
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokColon
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokDoubleColon
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokNamedColon
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokEq
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokArray
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokDot
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokId
    {  ( let (s, loc) = _1 in StringIdExp (s, loc), loc )}
| _1 = TokInt
    {  ( let (s, loc) = _1 in StringIntExp (s, loc), loc )}
| _1 = TokFloat
    {  ( let (s, loc) = _1 in StringFloatExp (s, loc), loc )}
| _1 = TokKey
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokKeyword
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokCatch
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokClass
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokString
    {  ( let (s, loc) = _1 in StringOtherExp (s, loc), loc )}
| _1 = quote
    {  ( _1 )}
| _1 = apply
    {  ( _1 )}

target_next:
  _1 = TokWhite
    {  ( let (s, loc) = _1 in StringWhiteExp (s, loc), loc )}
| _1 = TokOp
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokLeftParen
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokRightParen
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokArrow
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokComma
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokEq
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokArray
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokDot
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokId
    {  ( let (s, loc) = _1 in StringIdExp (s, loc), loc )}
| _1 = TokInt
    {  ( let (s, loc) = _1 in StringIntExp (s, loc), loc )}
| _1 = TokFloat
    {  ( let (s, loc) = _1 in StringFloatExp (s, loc), loc )}
| _1 = TokKey
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokKeyword
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokCatch
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokClass
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokString
    {  ( let (s, loc) = _1 in StringOtherExp (s, loc), loc )}
| _1 = quote
    {  ( _1 )}
| _1 = apply
    {  ( _1 )}

target_start:
  _1 = TokOp
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokLeftParen
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokRightParen
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokArrow
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokComma
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokEq
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokArray
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokDot
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokId
    {  ( let (s, loc) = _1 in StringIdExp (s, loc), loc )}
| _1 = TokInt
    {  ( let (s, loc) = _1 in StringIntExp (s, loc), loc )}
| _1 = TokFloat
    {  ( let (s, loc) = _1 in StringFloatExp (s, loc), loc )}
| _1 = TokKey
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokKeyword
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokCatch
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokClass
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokString
    {  ( let (s, loc) = _1 in StringOtherExp (s, loc), loc )}
| _1 = quote
    {  ( _1 )}
| _1 = apply
    {  ( _1 )}

keyword_target_start:
  _1 = TokOp
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokRightParen
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokArrow
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokComma
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokEq
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokArray
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokDot
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokId
    {  ( let (s, loc) = _1 in StringIdExp (s, loc), loc )}
| _1 = TokInt
    {  ( let (s, loc) = _1 in StringIntExp (s, loc), loc )}
| _1 = TokFloat
    {  ( let (s, loc) = _1 in StringFloatExp (s, loc), loc )}
| _1 = TokKey
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokKeyword
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokCatch
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokClass
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokString
    {  ( let (s, loc) = _1 in StringOtherExp (s, loc), loc )}
| _1 = quote
    {  ( _1 )}
| _1 = apply
    {  ( _1 )}

paren_next:
  _1 = TokWhite
    {  ( let (s, loc) = _1 in StringWhiteExp (s, loc), loc )}
| _1 = TokOp
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokArrow
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokComma
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokColon
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokDoubleColon
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokNamedColon
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokEq
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokArray
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokDot
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokId
    {  ( let (s, loc) = _1 in StringIdExp (s, loc), loc )}
| _1 = TokInt
    {  ( let (s, loc) = _1 in StringIntExp (s, loc), loc )}
| _1 = TokFloat
    {  ( let (s, loc) = _1 in StringFloatExp (s, loc), loc )}
| _1 = TokKey
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokKeyword
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokCatch
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokClass
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokString
    {  ( let (s, loc) = _1 in StringOtherExp (s, loc), loc )}
| _1 = quote
    {  ( _1 )}
| _1 = apply
    {  ( _1 )}

arg_next:
  _1 = TokWhite
    {  ( let (s, loc) = _1 in StringWhiteExp (s, loc), loc )}
| _1 = TokOp
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokColon
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokDoubleColon
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokNamedColon
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokEq
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokArray
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokDot
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokId
    {  ( let (s, loc) = _1 in StringIdExp (s, loc), loc )}
| _1 = TokInt
    {  ( let (s, loc) = _1 in StringIntExp (s, loc), loc )}
| _1 = TokFloat
    {  ( let (s, loc) = _1 in StringFloatExp (s, loc), loc )}
| _1 = TokKey
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokKeyword
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokCatch
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokClass
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokString
    {  ( let (s, loc) = _1 in StringOtherExp (s, loc), loc )}
| _1 = quote
    {  ( _1 )}
| _1 = apply
    {  ( _1 )}

arg_start:
  _1 = TokOp
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokColon
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokDoubleColon
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokNamedColon
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokEq
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokArray
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokDot
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokInt
    {  ( let (s, loc) = _1 in StringIntExp (s, loc), loc )}
| _1 = TokFloat
    {  ( let (s, loc) = _1 in StringFloatExp (s, loc), loc )}
| _1 = TokString
    {  ( let (s, loc) = _1 in StringOtherExp (s, loc), loc )}
| _1 = quote
    {  ( _1 )}
| _1 = apply
    {  ( _1 )}

arg_any_start:
  _1 = TokOp
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokColon
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokDoubleColon
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokNamedColon
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokEq
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokArray
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokDot
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokId
    {  ( let (s, loc) = _1 in StringIdExp (s, loc), loc )}
| _1 = TokInt
    {  ( let (s, loc) = _1 in StringIntExp (s, loc), loc )}
| _1 = TokFloat
    {  ( let (s, loc) = _1 in StringFloatExp (s, loc), loc )}
| _1 = TokKey
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokKeyword
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokCatch
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokClass
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokString
    {  ( let (s, loc) = _1 in StringOtherExp (s, loc), loc )}
| _1 = quote
    {  ( _1 )}
| _1 = apply
    {  ( _1 )}

arg_next_noneq:
  _1 = TokOp
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokColon
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokDoubleColon
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokNamedColon
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokArray
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokDot
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokId
    {  ( let (s, loc) = _1 in StringIdExp (s, loc), loc )}
| _1 = TokInt
    {  ( let (s, loc) = _1 in StringIntExp (s, loc), loc )}
| _1 = TokFloat
    {  ( let (s, loc) = _1 in StringFloatExp (s, loc), loc )}
| _1 = TokKey
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokKeyword
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokCatch
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokClass
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokString
    {  ( let (s, loc) = _1 in StringOtherExp (s, loc), loc )}
| _1 = quote
    {  ( _1 )}
| _1 = apply
    {  ( _1 )}

other_start:
  _1 = TokOp
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokLeftParen
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokRightParen
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokArrow
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokComma
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokEq
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokArray
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokDot
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokInt
    {  ( let (s, loc) = _1 in StringIntExp (s, loc), loc )}
| _1 = TokFloat
    {  ( let (s, loc) = _1 in StringFloatExp (s, loc), loc )}
| _1 = TokKey
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokString
    {  ( let (s, loc) = _1 in StringOtherExp (s, loc), loc )}
| _1 = apply
    {  ( _1 )}

other_method_id_white:
  _1 = TokWhite
    {  ( let (s, loc) = _1 in StringWhiteExp (s, loc), loc )}
| _1 = TokOp
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokRightParen
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokArrow
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokComma
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokDot
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokId
    {  ( let (s, loc) = _1 in StringIdExp (s, loc), loc )}
| _1 = TokInt
    {  ( let (s, loc) = _1 in StringIntExp (s, loc), loc )}
| _1 = TokFloat
    {  ( let (s, loc) = _1 in StringFloatExp (s, loc), loc )}
| _1 = TokKey
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokKeyword
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokCatch
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokClass
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokString
    {  ( let (s, loc) = _1 in StringOtherExp (s, loc), loc )}
| _1 = quote
    {  ( _1 )}
| _1 = apply
    {  ( _1 )}

other_method_id:
  _1 = TokOp
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokRightParen
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokArrow
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokComma
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokId
    {  ( let (s, loc) = _1 in StringIdExp (s, loc), loc )}
| _1 = TokInt
    {  ( let (s, loc) = _1 in StringIntExp (s, loc), loc )}
| _1 = TokFloat
    {  ( let (s, loc) = _1 in StringFloatExp (s, loc), loc )}
| _1 = TokKey
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokKeyword
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokCatch
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokClass
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokString
    {  ( let (s, loc) = _1 in StringOtherExp (s, loc), loc )}
| _1 = quote
    {  ( _1 )}
| _1 = apply
    {  ( _1 )}

other_method_id_prefix_white:
  _1 = TokWhite
    {  ( let (s, loc) = _1 in StringWhiteExp (s, loc), loc )}
| _1 = TokOp
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokLeftParen
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokRightParen
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokArrow
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokComma
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokArray
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokDot
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokInt
    {  ( let (s, loc) = _1 in StringIntExp (s, loc), loc )}
| _1 = TokFloat
    {  ( let (s, loc) = _1 in StringFloatExp (s, loc), loc )}
| _1 = TokKey
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokString
    {  ( let (s, loc) = _1 in StringOtherExp (s, loc), loc )}
| _1 = quote
    {  ( _1 )}
| _1 = apply
    {  ( _1 )}

other_method_id_prefix:
  _1 = TokOp
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokLeftParen
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokRightParen
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokArrow
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokComma
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokArray
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokDot
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokInt
    {  ( let (s, loc) = _1 in StringIntExp (s, loc), loc )}
| _1 = TokFloat
    {  ( let (s, loc) = _1 in StringFloatExp (s, loc), loc )}
| _1 = TokKey
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokString
    {  ( let (s, loc) = _1 in StringOtherExp (s, loc), loc )}
| _1 = quote
    {  ( _1 )}
| _1 = apply
    {  ( _1 )}

other_quote_id_white:
  _1 = TokWhite
    {  ( let (s, loc) = _1 in StringWhiteExp (s, loc), loc )}
| _1 = TokOp
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokLeftParen
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokRightParen
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokArrow
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokComma
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokArray
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokDot
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokId
    {  ( let (s, loc) = _1 in StringIdExp (s, loc), loc )}
| _1 = TokInt
    {  ( let (s, loc) = _1 in StringIntExp (s, loc), loc )}
| _1 = TokFloat
    {  ( let (s, loc) = _1 in StringFloatExp (s, loc), loc )}
| _1 = TokKey
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokKeyword
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokCatch
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokClass
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokString
    {  ( let (s, loc) = _1 in StringOtherExp (s, loc), loc )}
| _1 = quote
    {  ( _1 )}
| _1 = apply
    {  ( _1 )}

other_quote_id:
  _1 = TokOp
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokLeftParen
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokRightParen
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokArrow
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokComma
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokArray
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokDot
    {  ( let (s, loc) = _1 in StringOpExp (s, loc), loc )}
| _1 = TokId
    {  ( let (s, loc) = _1 in StringIdExp (s, loc), loc )}
| _1 = TokInt
    {  ( let (s, loc) = _1 in StringIntExp (s, loc), loc )}
| _1 = TokFloat
    {  ( let (s, loc) = _1 in StringFloatExp (s, loc), loc )}
| _1 = TokKey
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokKeyword
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokCatch
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokClass
    {  ( let (s, loc) = _1 in StringKeywordExp (s, loc), loc )}
| _1 = TokString
    {  ( let (s, loc) = _1 in StringOtherExp (s, loc), loc )}
| _1 = quote
    {  ( _1 )}
| _1 = apply
    {  ( _1 )}

opt_literal_colon:
  
    {          ( OptBody )}
| _1 = colon _2 = opt_white
    {          ( ColonBody )}

opt_colon:
  _1 = opt_white
    {          ( OptBody )}
| _1 = opt_white _2 = colon _3 = opt_white
    {          ( ColonBody )}

opt_white:
  
    {          ( None )}
| _1 = TokWhite
    {          ( Some _1 )}

%%


