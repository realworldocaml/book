File "modelica.mly", line 40, characters 83-89:
Warning: the token IMPURE is unused.
File "modelica.mly", line 38, characters 37-41:
Warning: the token PURE is unused.
File "modelica.mly", line 61, characters 6-14:
Warning: the token app_prec is unused.
File "modelica.mly", line 60, characters 10-19:
Warning: the token below_app is unused.
File "modelica.mly", line 46, characters 7-13:
Warning: the token lowest is unused.
File "modelica.mly", line 68, characters 6-15:
Warning: the token type_proj is unused.
%{
    open Ast.Flags
    open Syntax
    open Syntax_fragments
    open Utils

    (* cannot open Location due to menhir's Error exception *)
    type 'a loc = 'a Location.loc = {
       txt : 'a;
       loc : Location.t;
    }

    (* merge the two sources of a modelica-style component definition (i.e. the declaration and the component_clause *)
    let declaration_to_def def_type def_options def_constraint = function
        (def_name, None, None, def_if, def_rhs, comment) ->
           { commented = { def_name ; def_type ; def_options ; def_constraint ; def_rhs ; def_if ; } ;
             comment }
      | (def_name, Some(dims), None, def_if, def_rhs, comment) ->
           { commented = { def_name ; def_type = TArray { base_type = def_type ; dims } ;
                           def_options ; def_constraint ; def_rhs ; def_if ; } ;
             comment }
      | (def_name, Some(dims), Some(modification), def_if, def_rhs, comment) ->
           { commented = { def_name ; def_type = TArray { base_type = TMod { mod_type = def_type ; modification } ; dims } ;
                           def_options ; def_constraint ; def_rhs ; def_if ; } ;
             comment }
      | (def_name, None, Some(modification), def_if, def_rhs, comment) ->
           { commented = { def_name ; def_type = TMod { mod_type = def_type ; modification } ;
                           def_options ; def_constraint ; def_rhs ; def_if ; } ;
             comment }

     let mkloc x loc_start loc_end = {txt=x ; loc={Location.loc_start; Location.loc_end; Location.loc_ghost=false } }
%}
%start modelica_definitions
%start modelica_eq
%start modelica_expr
%start modelica_extends
%start modelica_import
%start modelica_stmt
%start modelica_stored_definition
%start modelica_texpr
%start modelica_type_definition
%token ALGORITHM
%token AND
%token ANNOTATION
%token ASSERT
%token BLOCK
%token BREAK
%token CLASS
%token COLON
%token COLONEQ
%token COMMA
%token CONNECTOR
%token CONSTANT
%token CONSTRAINEDBY
%token DER
%token DISCRETE
%token DIV
%token DOT
%token DOTDIV
%token DOTMINUS
%token DOTPLUS
%token DOTPOWER
%token DOTTIMES
%token EACH
%token ELSE
%token ELSEIF
%token ELSEWHEN
%token ENCAPSULATED
%token END
%token ENDFOR
%token ENDIF
%token ENDWHEN
%token ENDWHILE
%token <string> END_IDENT
%token ENUMERATION
%token EOF
%token EQ
%token EQEQ
%token EQUATION
%token EXPANDABLE
%token EXTENDS
%token EXTERNAL
%token FALSE
%token FINAL
%token <float> FLOAT
%token FLOW
%token FOR
%token FUNCTION
%token GEQ
%token GT
%token <string> IDENT
%token IF
%token IMPORT
%token IMPURE
%token IN
%token INITIAL
%token INITIAL_ALGORITHM
%token INITIAL_EQUATION
%token INNER
%token INPUT
%token <int> INT
%token LBRACE
%token LBRACKET
%token LEQ
%token LOOP
%token LPAREN
%token LT
%token MINUS
%token MODEL
%token NEQ
%token NOT
%token OPERATOR
%token OR
%token OUTER
%token OUTPUT
%token PACKAGE
%token PARAMETER
%token PARTIAL
%token PLUS
%token POWER
%token PROTECTED
%token PUBLIC
%token PURE
%token RBRACE
%token RBRACKET
%token RECORD
%token REDECLARE
%token REPLACEABLE
%token RETURN
%token RPAREN
%token SEMICOLON
%token STREAM
%token <string> STRING
%token THEN
%token TIMES
%token TRUE
%token TYPE
%token WHEN
%token WHILE
%token WITHIN
%right lowest
%nonassoc FLOAT IDENT INT LBRACE LPAREN RBRACE RBRACKET RPAREN STRING
%left COMMA
%left SEMICOLON
%left COLON
%right Not
%left AND OR
%left EQEQ GEQ GT LEQ LT NEQ
%left DOTMINUS DOTPLUS MINUS PLUS
%right UMinus
%right FUNCTION
%left DIV DOTDIV DOTTIMES TIMES
%left DOTPOWER POWER
%nonassoc below_app
%left app_prec
%left type_mod
%left type_var
%left type_conn
%left type_caus
%left type_array
%left type_proj
%left DOT LBRACKET
%type <Syntax.definition list> modelica_definitions
%type <Syntax.equation> modelica_eq
%type <Syntax.exp> modelica_expr
%type <Syntax.extend> modelica_extends
%type <Syntax.import> modelica_import
%type <Syntax.statement> modelica_stmt
%type <Syntax.unit_> modelica_stored_definition
%type <Syntax.texp> modelica_texpr
%type <Syntax.typedef> modelica_type_definition
%%

option_annotation_:
  
    {    ( None )}
| x = annotation
    {    ( Some x )}

option_array_subscripts_:
  
    {    ( None )}
| x = array_subscripts
    {    ( Some x )}

option_class_modification_:
  
    {    ( None )}
| x = class_modification
    {    ( Some x )}

option_composition_annotation_:
  
    {    ( None )}
| x = composition_annotation
    {    ( Some x )}

option_composition_external_:
  
    {    ( None )}
| x = composition_external
    {    ( Some x )}

option_constraining_clause_:
  
    {    ( None )}
| x = constraining_clause
    {    ( Some x )}

option_decl_condition_:
  
    {    ( None )}
| x = decl_condition
    {    ( Some x )}

option_index_range_:
  
    {    ( None )}
| x = index_range
    {    ( Some x )}

option_lexpr_:
  
    {    ( None )}
| x = lexpr
    {    ( Some x )}

option_modification_:
  
    {    ( None )}
| x = modification
    {    ( Some x )}

option_preceded_COLON_simple_expr__:
  
    {    ( None )}
| _1 = COLON x = simple_expr
    {let x =     ( x ) in
    ( Some x )}

option_preceded_binder_expr__:
  
    {    ( None )}
| _1 = EQ x = expr
    {let x =
  let _1 =             () in
      ( x )
in
    ( Some x )}
| _1 = COLONEQ x = expr
    {let x =
  let _1 =                          () in
      ( x )
in
    ( Some x )}

option_str_:
  
    {    ( None )}
| x = str
    {    ( Some x )}

option_within_clause_:
  
    {    ( None )}
| x = within_clause
    {    ( Some x )}

loption_separated_nonempty_list_COMMA_expr__:
  
    {    ( [] )}
| x = separated_nonempty_list_COMMA_expr_
    {    ( x )}

loption_separated_nonempty_list_DOT_ident__:
  
    {    ( [] )}
| x = separated_nonempty_list_DOT_ident_
    {    ( x )}

list_else_if_:
  
    {    ( [] )}
| x = else_if xs = list_else_if_
    {    ( x :: xs )}

list_elseif_equation_:
  
    {    ( [] )}
| x = elseif_equation xs = list_elseif_equation_
    {    ( x :: xs )}

list_elseif_statement_:
  
    {    ( [] )}
| x = elseif_statement xs = list_elseif_statement_
    {    ( x :: xs )}

list_elsewhen_equation_:
  
    {    ( [] )}
| x = elsewhen_equation xs = list_elsewhen_equation_
    {    ( x :: xs )}

list_elsewhen_statement_:
  
    {    ( [] )}
| x = elsewhen_statement xs = list_elsewhen_statement_
    {    ( x :: xs )}

list_equation_:
  
    {    ( [] )}
| x = equation xs = list_equation_
    {    ( x :: xs )}

list_index_:
  
    {    ( [] )}
| x = index xs = list_index_
    {    ( x :: xs )}

list_preceded_COMMA_option_lexpr___:
  
    {    ( [] )}
| _1 = COMMA x = option_lexpr_ xs = list_preceded_COMMA_option_lexpr___
    {let x =     ( x ) in
    ( x :: xs )}

list_statement_:
  
    {    ( [] )}
| x = statement xs = list_statement_
    {    ( x :: xs )}

list_type_definition_clause_:
  
    {    ( [] )}
| x = type_definition_clause xs = list_type_definition_clause_
    {    ( x :: xs )}

nonempty_list_statement_:
  x = statement
    {    ( [ x ] )}
| x = statement xs = nonempty_list_statement_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_declaration_:
  x = declaration
    {    ( [ x ] )}
| x = declaration _2 = COMMA xs = separated_nonempty_list_COMMA_declaration_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_enum_literal_:
  x = enum_literal
    {    ( [ x ] )}
| x = enum_literal _2 = COMMA xs = separated_nonempty_list_COMMA_enum_literal_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_expr_:
  x = expr
    {    ( [ x ] )}
| x = expr _2 = COMMA xs = separated_nonempty_list_COMMA_expr_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_ident_:
  x = ident
    {    ( [ x ] )}
| x = ident _2 = COMMA xs = separated_nonempty_list_COMMA_ident_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_index_:
  x = index
    {    ( [ x ] )}
| x = index _2 = COMMA xs = separated_nonempty_list_COMMA_index_
    {    ( x :: xs )}

separated_nonempty_list_COMMA_named_argument_:
  x = named_argument
    {    ( [ x ] )}
| x = named_argument _2 = COMMA xs = separated_nonempty_list_COMMA_named_argument_
    {    ( x :: xs )}

separated_nonempty_list_DOT_ident_:
  x = ident
    {    ( [ x ] )}
| x = ident _2 = DOT xs = separated_nonempty_list_DOT_ident_
    {    ( x :: xs )}

separated_nonempty_list_SEMICOLON_separated_nonempty_list_COMMA_expr__:
  x = separated_nonempty_list_COMMA_expr_
    {    ( [ x ] )}
| x = separated_nonempty_list_COMMA_expr_ _2 = SEMICOLON xs = separated_nonempty_list_SEMICOLON_separated_nonempty_list_COMMA_expr__
    {    ( x :: xs )}

modelica_stored_definition:
  within = option_within_clause_ toplevel_defs = list_type_definition_clause_ _3 = EOF
    {                                                                                                             ( { within; toplevel_defs } )}

modelica_definitions:
  defs = component_clauses _2 = EOF
    {                                                    ( defs )}

modelica_expr:
  e = expr _2 = EOF
    {                            ( e )}

modelica_stmt:
  s = statement _2 = EOF
    {                                  ( s )}

modelica_type_definition:
  t = type_definition _2 = EOF
    {                                                   ( t )}

modelica_eq:
  eq = equation _2 = EOF
    {                                ( eq )}

modelica_texpr:
  texpr = type_expression _2 = EOF
    {                                             ( texpr )}

modelica_import:
  import = import _2 = EOF
    {                                      ( import )}

modelica_extends:
  extends = extends _2 = EOF
    {                                         ( extends )}

ident:
  x = IDENT
    {let _endpos = _endpos_x_ in
let _startpos = _startpos_x_ in
                ( mkloc x _startpos _endpos )}

str:
  x = STRING
    {let _endpos = _endpos_x_ in
let _startpos = _startpos_x_ in
               ( mkloc x _startpos _endpos )}

expr:
  e = simple_expr
    {                       ( e )}
| _1 = IF condition = expr _3 = THEN then_ = expr else_if = list_else_if_ _6 = ELSE else_ = expr
    {       ( no_attr (If { condition ; then_ ; else_if ; else_ }) )}
| start = simple_expr _2 = COLON first = simple_expr second = option_preceded_COLON_simple_expr__
    {        ( no_attr (Range (match second with Some end_ -> { start; step=Some first; end_ }
                                          | None -> {start; step=None; end_=first} ) )
        )}

simple_expr:
  _1 = TRUE
    {         ( no_attr (Bool(true)) )}
| _1 = FALSE
    {          ( no_attr (Bool(false)) )}
| i = INT
    {        ( no_attr (Int (i)) )}
| f = FLOAT
    {        ( no_attr (Real (f)) )}
| s = STRING
    {        ( no_attr (String(s)) )}
| _1 = DOT x = IDENT
    {        ( no_attr (RootIde x))}
| x = IDENT
    {        ( no_attr (Ide(x)) )}
| _1 = LPAREN e = expr _3 = RPAREN
    {        ( e )}
| _1 = LPAREN _2 = RPAREN
    {                  ( no_attr (OutputExpression [None]) )}
| _1 = LPAREN e = expr _3 = COMMA ps = patterns _5 = RPAREN
    {                                           ( no_attr (OutputExpression ((Some e)::ps)) )}
| _1 = LPAREN _2 = COMMA ps = patterns _4 = RPAREN
    {                                    ( no_attr (OutputExpression (None::ps)) )}
| _1 = LBRACE es = array_args _3 = RBRACE
    {        ( no_attr (Array es) )}
| lhs = simple_expr _2 = LBRACKET indices = separated_nonempty_list_COMMA_expr_ _4 = RBRACKET
    {        ( no_attr (ArrayAccess { lhs; indices }) )}
| _1 = LBRACKET els = separated_nonempty_list_SEMICOLON_separated_nonempty_list_COMMA_expr__ _3 = RBRACKET
    {        ( no_attr (MArray els) )}
| _1 = FUNCTION e = simple_expr
    {        ( no_attr (ExplicitClosure e) )}
| _1 = END %prec END
    {        ( no_attr (End) )}
| _1 = DER
    {        ( no_attr (Der) )}
| _1 = INITIAL
    {            ( no_attr (Initial) )}
| _1 = COLON
    {          ( no_attr (Colon) )}
| _1 = ASSERT
    {           ( no_attr (Assert) )}
| fun_ = simple_expr _2 = LPAREN arguments = function_args _4 = RPAREN
    {        ( let (args, named_args) = arguments in no_attr (App { fun_ ; args; named_args }) )}
| left = simple_expr _2 = PLUS right = simple_expr
    {       ( no_attr (Plus ( {left ; right} )) )}
| left = simple_expr _2 = MINUS right = simple_expr
    {       ( no_attr (Minus ( {left ; right} )) )}
| left = simple_expr _2 = TIMES right = simple_expr
    {       ( no_attr (Mul ( {left ; right} )) )}
| left = simple_expr _2 = DIV right = simple_expr
    {       ( no_attr (Div ( {left ; right} )) )}
| left = simple_expr _2 = POWER right = simple_expr
    {       ( no_attr (Pow ( {left ; right} )) )}
| left = simple_expr _2 = DOTPLUS right = simple_expr
    {       ( no_attr (DPlus ( {left ; right} )) )}
| left = simple_expr _2 = DOTMINUS right = simple_expr
    {       ( no_attr (DMinus ( {left ; right} )) )}
| left = simple_expr _2 = DOTTIMES right = simple_expr
    {       ( no_attr (DMul ( {left ; right} )) )}
| left = simple_expr _2 = DOTDIV right = simple_expr
    {       ( no_attr (DDiv ( {left ; right} )) )}
| left = simple_expr _2 = DOTPOWER right = simple_expr
    {       ( no_attr (DPow ( {left ; right} )) )}
| left = simple_expr _2 = LT right = simple_expr
    {       ( no_attr (Lt ( {left ; right} )) )}
| left = simple_expr _2 = GT right = simple_expr
    {       ( no_attr (Gt ( {left ; right} )) )}
| left = simple_expr _2 = GEQ right = simple_expr
    {       ( no_attr (Geq ( {left ; right} )) )}
| left = simple_expr _2 = LEQ right = simple_expr
    {       ( no_attr (Leq ( {left ; right} )) )}
| left = simple_expr _2 = NEQ right = simple_expr
    {       ( no_attr (Neq ( {left ; right} )) )}
| left = simple_expr _2 = EQEQ right = simple_expr
    {       ( no_attr (Eq ( {left ; right} )) )}
| left = simple_expr _2 = AND right = simple_expr
    {       ( no_attr (And ( {left ; right} )) )}
| left = simple_expr _2 = OR right = simple_expr
    {       ( no_attr (Or ( {left ; right} )) )}
| object_ = simple_expr _2 = DOT field = IDENT
    {       ( no_attr (Proj { object_ ; field }) )}
| _1 = MINUS e = simple_expr %prec UMinus
    {                          ( no_attr (UMinus e) )}
| _1 = PLUS e = simple_expr %prec UMinus
    {                         ( no_attr (UPlus e) )}
| _1 = DOTMINUS e = simple_expr %prec UMinus
    {                             ( no_attr (UDMinus e) )}
| _1 = DOTPLUS e = simple_expr %prec UMinus
    {                            ( no_attr (UDPlus e) )}
| _1 = NOT e = simple_expr %prec Not
    {                        ( no_attr (Not e) )}

else_if:
  _1 = ELSEIF guard = expr _3 = THEN elsethen = expr
    {                                                 ( {guard; elsethen} )}

index_range:
  _1 = IN e = expr
    {                          ( e )}

index:
  variable = ident range = option_index_range_
    {                                                     ( { variable ; range } )}

array_args:
  xs = loption_separated_nonempty_list_COMMA_expr__
    {let es =     ( xs ) in
                                            ( es )}
| exp = expr _2 = FOR idxs = separated_nonempty_list_COMMA_index_
    {                                                                         ( [no_attr (Compr { exp ; idxs })] )}

function_args:
  e = expr _2 = COMMA fs = function_args
    {                                                  ( let (args, named_args) = fs in (e::args, named_args) )}
| e = expr
    {                         ( ([e], []) )}
| m = named_function_args
    {                                        ( ([], m) )}
| exp = expr _2 = FOR idxs = separated_nonempty_list_COMMA_index_
    {                                                                            ( ([no_attr (Compr { exp ; idxs })], []) )}

named_argument:
  argument_name = ident _2 = EQ argument = expr
    {                                                      ( {argument_name ; argument } )}

named_function_args:
  args = separated_nonempty_list_COMMA_named_argument_
    {                                                                           ( args )}
| 
    {                      ( [] )}

annotation:
  _1 = ANNOTATION m = class_modification
    {                                             ( m )}

comment:
  s = option_str_ m = option_annotation_
    {                                             ( { annotated_elem=s ; annotation=m} )}

statement:
  s = statement_body comment = comment _3 = SEMICOLON
    {                                                       ( {commented=s ; comment} )}

else_statements:
  _1 = ELSE else_ = list_statement_
    {                                               ( else_ )}
| 
    {                  ( [] )}

elseif_statement:
  _1 = ELSEIF guard = expr _3 = THEN elsethen = list_statement_
    {                                                                     ( { guard ; elsethen } )}

elsewhen_statement:
  _1 = ELSEWHEN guard = expr _3 = THEN elsethen = list_statement_
    {                                                                         ( { guard ; elsethen } )}

component_reference:
  x = IDENT
    {                                ( no_attr (Ide x) )}
| _1 = ASSERT
    {                             ( no_attr (Assert) )}
| _1 = DOT x = IDENT
    {                                    ( no_attr (RootIde x) )}
| object_ = component_reference _2 = DOT field = IDENT
    {                                                                  ( no_attr (Proj { object_ ; field }) )}
| lhs = component_reference _2 = LBRACKET indices = separated_nonempty_list_COMMA_expr_ _4 = RBRACKET
    {                                                                                        ( no_attr (ArrayAccess { lhs; indices }) )}

lexpr:
  r = component_reference
    {                                ( r )}
| _1 = LPAREN ps = patterns _3 = RPAREN
    {                                  ( no_attr (OutputExpression ps) )}

patterns:
  p = option_lexpr_ ps = list_preceded_COMMA_option_lexpr___
    {                                                                   ( p::ps )}

statement_body:
  procedure = component_reference _2 = LPAREN arguments = function_args _4 = RPAREN
    {                 ( let (pargs, pnamed_args) = arguments in Call { procedure ; pargs; pnamed_args } )}
| _1 = BREAK
    {                       ( Break )}
| _1 = RETURN
    {                        ( Return )}
| _1 = IF condition = expr _3 = THEN then_ = list_statement_ else_if = list_elseif_statement_ else_ = else_statements _7 = ENDIF
    {                    ( IfStmt { condition; then_ ; else_if; else_ } )}
| _1 = WHEN condition = expr _3 = THEN then_ = list_statement_ else_if = list_elsewhen_statement_ _6 = ENDWHEN
    {                    ( WhenStmt { condition; then_ ; else_if; else_ = []} )}
| _1 = FOR idx = list_index_ _3 = LOOP body = list_statement_ _5 = ENDFOR
    {                                                                        ( ForStmt { idx; body } )}
| _1 = WHILE while_ = expr _3 = LOOP while_body = list_statement_ _5 = ENDWHILE
    {                                                                              ( WhileStmt { while_; while_body } )}
| target = lexpr _2 = COLONEQ source = expr
    {                                                  ( Assignment { target; source } )}

equation:
  commented = equation_body comment = comment _3 = SEMICOLON
    {                                                             ( { commented ; comment } )}

else_equations:
  _1 = ELSE else_ = list_equation_
    {                                             ( else_ )}
| 
    {                  ( [] )}

elseif_equation:
  _1 = ELSEIF guard = expr _3 = THEN elsethen = list_equation_
    {                                                                   ( { guard ; elsethen } )}

elsewhen_equation:
  _1 = ELSEWHEN guard = expr _3 = THEN elsethen = list_equation_
    {                                                                       ( { guard ; elsethen } )}

equation_body:
  e = simple_expr
    {                                ( ExpEquation e )}
| left = simple_expr _2 = EQ right = expr
    {                                                   ( SimpleEquation { left ; right } )}
| _1 = IF condition = expr _3 = THEN then_ = list_equation_ else_if = list_elseif_equation_ else_ = else_equations _7 = ENDIF
    {                   ( IfEquation { condition; then_ ; else_if; else_ } )}
| _1 = WHEN condition = expr _3 = THEN then_ = list_equation_ else_if = list_elsewhen_equation_ _6 = ENDWHEN
    {                   ( WhenEquation { condition; then_ ; else_if; else_ = []} )}
| _1 = FOR idx = list_index_ _3 = LOOP body = list_equation_ _5 = ENDFOR
    {                                                                      ( ForEquation { idx; body } )}

variability:
  _1 = CONSTANT
    {                       ( Constant )}
| _1 = PARAMETER
    {                        ( Parameter )}
| _1 = DISCRETE
    {                       ( Discrete )}

connectivity:
  _1 = FLOW
    {                    ( Flow )}
| _1 = STREAM
    {                      ( Stream )}

causality:
  _1 = INPUT
    {                  ( Input )}
| _1 = OUTPUT
    {                   ( Output )}

type_expression:
  x = separated_nonempty_list_DOT_ident_
    {                                                          ( TName x )}
| _1 = DOT x = separated_nonempty_list_DOT_ident_
    {                                                              ( TRootName x )}
| flag = variability flagged = type_expression %prec type_var
    {                                                           ( TVar { flag ; flagged } )}
| flag = causality flagged = type_expression %prec type_caus
    {                                                         ( TCau { flag ; flagged } )}
| flag = connectivity flagged = type_expression %prec type_conn
    {                                                            ( TCon { flag ; flagged } )}
| base_type = type_expression dims = array_subscripts %prec type_array
    {                                                                      ( TArray { base_type ; dims } )}
| mod_type = type_expression modification = class_modification %prec type_mod
    {                                                                               ( TMod { mod_type ; modification } )}

class_modification:
  _1 = LPAREN m = modification_arguments_head _3 = RPAREN
    {                                                                 ( m )}

modification_arguments_head:
  m = modification_arguments
    {                                                         ( m )}
| 
    {                              ( { types = [] ; components = [] ; modifications = [] } )}

modification_arguments:
  _1 = REDECLARE redecl_each = flag_EACH_ type_final = flag_FINAL_ type_replaceable = flag_REPLACEABLE_ partial = flag_PARTIAL_ sort = type_sort td_name = ident _8 = EQ type_exp = type_expression comment = comment cns = option_constraining_clause_ rest = modification_arguments_tail
    {                         ( { rest with types = {
                                    redecl_each ;
                                    redecl_type = { commented = { td_name ; sort ;
                                                                  type_options = { no_type_options with partial ;
                                                                                   type_final; type_replaceable } ;
                                                                  type_exp ; cns} ;
                                                    comment }
                                    } :: rest.types } )}
| redecl_each = flag_EACH_ type_final = flag_FINAL_ _3 = REPLACEABLE partial = flag_PARTIAL_ sort = type_sort td_name = ident _7 = EQ type_exp = type_expression comment = comment cns = option_constraining_clause_ rest = modification_arguments_tail
    {                         ( { rest with types = {
                                    redecl_each ;
                                    redecl_type = { commented = { td_name ; sort ;
                                                                  type_options = { no_type_options with partial ;
                                                                                   type_final; type_replaceable=true } ;
                                                                  type_exp ; cns} ;
                                                    comment }
                                    } :: rest.types } )}
| _1 = REDECLARE each = flag_EACH_ final = flag_FINAL_ replaceable = flag_REPLACEABLE_ def = mod_component_clause rest = modification_arguments_tail
    {                         ( {rest with components =
                             { each ; def = { def with commented =
                                                       { def.commented with def_options =
                                                                            {def.commented.def_options with final; replaceable} };
                                            }
                         }::rest.components} )}
| each = flag_EACH_ final = flag_FINAL_ _3 = REPLACEABLE def = mod_component_clause rest = modification_arguments_tail
    {                         ( {rest with components =
                             { each ; def = { def with commented =
                                                       { def.commented with def_options =
                                                                            {def.commented.def_options with final; replaceable=true} };
                                            }
                         }::rest.components} )}
| mod_each = flag_EACH_ mod_final = flag_FINAL_ mod_name = separated_nonempty_list_DOT_ident_ mod_value = option_modification_ comment = comment rest = modification_arguments_tail
    {                         ( let m = {commented={mod_name;mod_final;mod_each;mod_value};comment} in
                               { rest with modifications = m::rest.modifications }
                         )}

modification:
  _1 = EQ e = expr
    {                                          ( Rebind e )}
| _1 = COLONEQ e = expr
    {                                          ( Rebind e )}
| m = class_modification
    {                                    ( Nested m )}
| nested = class_modification _2 = EQ new_value = expr
    {                                                           ( NestedRebind {nested;new_value} )}

modification_arguments_tail:
  _1 = COMMA m = modification_arguments
    {                                                               ( m )}
| 
    {                              ( { types = [] ; components = [] ; modifications = [] } )}

mod_component_clause:
  scope = scope def_type = type_expression component = declaration def_constraint = option_constraining_clause_
    {                       ( declaration_to_def def_type {no_def_options with scope} def_constraint component )}

import:
  _1 = IMPORT name = separated_nonempty_list_DOT_ident_ comment = comment
    {                                                                           ( { commented = Unnamed name ; comment } )}
| _1 = IMPORT local = ident _3 = EQ global = separated_nonempty_list_DOT_ident_ comment = comment
    {         ( { commented = NamedImport {global;local} ; comment } )}
| _1 = IMPORT name = separated_nonempty_list_DOT_ident_ _3 = DOTTIMES comment = comment
    {                                                                                    ( { commented = UnqualifiedImport name ; comment } )}

extends:
  _1 = EXTENDS ext_type = type_expression ext_annotation = option_annotation_
    {                                                                               ( { ext_type ; ext_annotation } )}

flag_EACH_:
  _1 = EACH
    {             ( true )}
| 
    {                        ( false )}

flag_ENCAPSULATED_:
  _1 = ENCAPSULATED
    {             ( true )}
| 
    {                        ( false )}

flag_FINAL_:
  _1 = FINAL
    {             ( true )}
| 
    {                        ( false )}

flag_PARTIAL_:
  _1 = PARTIAL
    {             ( true )}
| 
    {                        ( false )}

flag_REPLACEABLE_:
  _1 = REPLACEABLE
    {             ( true )}
| 
    {                        ( false )}

scope:
  _1 = INNER
    {              ( Inner )}
| _1 = OUTER
    {              ( Outer )}
| _1 = INNER _2 = OUTER
    {                    ( InnerOuter )}
| 
    {        ( Local )}

type_prefix:
  final = flag_FINAL_ replaceable = flag_REPLACEABLE_ scope = scope
    {                ( { final ; scope ; replaceable } )}

array_subscripts:
  _1 = LBRACKET xs = loption_separated_nonempty_list_COMMA_expr__ _3 = RBRACKET
    {let dims =     ( xs ) in
                                                                        ( dims )}

decl_condition:
  _1 = IF cond = expr
    {                              ( cond )}

decl_modification:
  m = option_class_modification_ e = option_preceded_binder_expr__
    {                                                                                  ( (m, e) )}

declaration:
  x = IDENT dims = option_array_subscripts_ m = decl_modification cond = option_decl_condition_ comment = comment
    {              ( let (modification, rhs) = m in (x, dims, modification, cond, rhs, comment) )}

constraining_clause:
  _1 = CONSTRAINEDBY commented = type_expression comment = comment
    {                                                                               ( { commented ; comment } )}

component_clauses:
  defs = component_clause
    {                                            ( defs )}
| defs = component_clause _2 = SEMICOLON defs2 = component_clauses
    {                                                                                ( List.append defs defs2 )}

component_clause:
  def_options = type_prefix def_type = type_expression components = separated_nonempty_list_COMMA_declaration_ def_constraint = option_constraining_clause_
    {                     ( List.map (declaration_to_def def_type def_options def_constraint) components )}

type_sort:
  _1 = CLASS
    {                  ( Class )}
| _1 = PACKAGE
    {                     (Package)}
| _1 = MODEL
    {                   ( Model )}
| _1 = BLOCK
    {                                     ( Block )}
| _1 = CONNECTOR
    {                                                           ( Connector )}
| _1 = EXPANDABLE _2 = CONNECTOR
    {                                                                                                ( ExpandableConnector )}
| _1 = RECORD
    {                    ( Record )}
| _1 = FUNCTION
    {                                          ( Function )}
| _1 = TYPE
    {                                                              ( Type )}
| _1 = OPERATOR
    {                                                                                  ( Operator )}
| _1 = OPERATOR _2 = RECORD
    {                                                                                                                 ( OperatorRecord )}
| _1 = OPERATOR _2 = FUNCTION
    {                               ( OperatorFunction )}

typedef_prefix:
  type_final = flag_FINAL_ type_replaceable = flag_REPLACEABLE_ encapsulated = flag_ENCAPSULATED_ partial = flag_PARTIAL_
    {                 ( { type_final ; type_replaceable ; encapsulated ; partial } )}

enum_literal:
  commented = IDENT comment = comment
    {                                               ( { commented ; comment } )}

composition_annotation:
  a = annotation _2 = SEMICOLON
    {                                                  ( a )}

type_definition:
  type_options = typedef_prefix sort = type_sort td_name = ident _4 = EQ type_exp = type_expression comment = comment cns = option_constraining_clause_
    {                  ( { commented = Short { td_name ; sort ; type_options ; type_exp ; cns} ;  comment } )}
| type_options = typedef_prefix sort = type_sort td_name = ident annotated_elem = option_str_ type_exp = composition annotation = option_composition_annotation_ end_name = END_IDENT cns = option_constraining_clause_
    {                  ( { commented = Composition { td_name ; sort ; type_options ; type_exp ; cns} ;  comment = {annotated_elem;annotation}})}
| type_options = typedef_prefix sort = type_sort _3 = EXTENDS td_name = ident modification = option_class_modification_ annotated_elem = option_str_ composition = composition annotation = option_composition_annotation_ end_name = END_IDENT cns = option_constraining_clause_
    {                  ( { commented = Extension { td_name ; sort ; type_options ; type_exp=(composition,modification) ; cns} ;
                      comment = {annotated_elem;annotation}})}
| type_options = typedef_prefix sort = type_sort td_name = ident _4 = EQ _5 = ENUMERATION _6 = LPAREN type_exp = separated_nonempty_list_COMMA_enum_literal_ _8 = RPAREN comment = comment cns = option_constraining_clause_
    {                  ( { commented = Enumeration { td_name ; sort ; type_options ; type_exp ; cns} ;  comment } )}
| type_options = typedef_prefix sort = type_sort td_name = ident _4 = EQ _5 = ENUMERATION _6 = LPAREN _7 = COLON _8 = RPAREN comment = comment cns = option_constraining_clause_
    {                  ( { commented = OpenEnumeration { td_name ; sort ; type_options ; type_exp = () ; cns} ;  comment } )}
| type_options = typedef_prefix sort = type_sort td_name = ident _4 = EQ _5 = DER _6 = LPAREN der_name = separated_nonempty_list_DOT_ident_ _8 = COMMA idents = separated_nonempty_list_COMMA_ident_ _10 = RPAREN comment = comment cns = option_constraining_clause_
    {                  ( { commented = DerSpec { td_name ; sort ; type_options ; type_exp = {der_name;idents} ; cns} ;  comment } )}

composition:
  c = public_composition_elements
    {                                              ( c )}

equation_section:
  equation = equation rest = equation_section
    {                     ( {rest with cargo = { rest.cargo with equations = equation::rest.cargo.equations } } )}
| _1 = PUBLIC rest = public_composition_elements
    {let rest =                                                                      ( rest ) in
                                         ( rest )}
| _1 = PROTECTED rest = public_composition_elements
    {let rest =                                                                         ( rest ) in
                                         ( rest )}
| rest = cargo_sections
    {let rest =                                                  ( rest ) in
                                         ( rest )}

initial_equation_section:
  equation = equation rest = initial_equation_section
    {                             ( {rest with cargo = { rest.cargo with initial_equations = equation::rest.cargo.initial_equations } } )}
| _1 = PUBLIC rest = public_composition_elements
    {let rest =                                                                      ( rest ) in
                                                 ( rest )}
| _1 = PROTECTED rest = public_composition_elements
    {let rest =                                                                         ( rest ) in
                                                 ( rest )}
| rest = cargo_sections
    {let rest =                                                  ( rest ) in
                                                 ( rest )}

algorithm:
  stmts = nonempty_list_statement_
    {                                           ( stmts )}

algorithm_section:
  alg = algorithm _1 = PUBLIC rest = public_composition_elements
    {let rest =                                                                      ( rest ) in
                      ( {rest with cargo = { rest.cargo with algorithms = alg::rest.cargo.algorithms } } )}
| alg = algorithm _1 = PROTECTED rest = public_composition_elements
    {let rest =                                                                         ( rest ) in
                      ( {rest with cargo = { rest.cargo with algorithms = alg::rest.cargo.algorithms } } )}
| alg = algorithm rest = cargo_sections
    {let rest =                                                  ( rest ) in
                      ( {rest with cargo = { rest.cargo with algorithms = alg::rest.cargo.algorithms } } )}
| _1 = PUBLIC rest = public_composition_elements
    {let rest =                                                                      ( rest ) in
                                          ( rest )}
| _1 = PROTECTED rest = public_composition_elements
    {let rest =                                                                         ( rest ) in
                                          ( rest )}
| rest = cargo_sections
    {let rest =                                                  ( rest ) in
                                          ( rest )}

initial_algorithm_section:
  alg = algorithm _1 = PUBLIC rest = public_composition_elements
    {let rest =                                                                      ( rest ) in
                              ( {rest with cargo = { rest.cargo with initial_algorithms = alg::rest.cargo.initial_algorithms } } )}
| alg = algorithm _1 = PROTECTED rest = public_composition_elements
    {let rest =                                                                         ( rest ) in
                              ( {rest with cargo = { rest.cargo with initial_algorithms = alg::rest.cargo.initial_algorithms } } )}
| alg = algorithm rest = cargo_sections
    {let rest =                                                  ( rest ) in
                              ( {rest with cargo = { rest.cargo with initial_algorithms = alg::rest.cargo.initial_algorithms } } )}
| _1 = PUBLIC rest = public_composition_elements
    {let rest =                                                                      ( rest ) in
                                                  ( rest )}
| _1 = PROTECTED rest = public_composition_elements
    {let rest =                                                                         ( rest ) in
                                                  ( rest )}
| rest = cargo_sections
    {let rest =                                                  ( rest ) in
                                                  ( rest )}

cargo_sections:
  _1 = EQUATION rest = equation_section
    {                ( rest )}
| _1 = INITIAL_EQUATION rest = initial_equation_section
    {                ( rest )}
| _1 = ALGORITHM rest = algorithm_section
    {                ( rest )}
| _1 = INITIAL_ALGORITHM rest = initial_algorithm_section
    {                ( rest )}
| external_ = option_composition_external_
    {                                                          ( { empty_composition with cargo = { empty_behavior with external_ } } )}

public_composition_elements:
  import = import _2 = SEMICOLON rest = public_composition_elements
    {                ( {rest with imports = import::rest.imports} )}
| extend = extends _2 = SEMICOLON rest = public_composition_elements
    {                ( {rest with public = { rest.public with extensions = extend::rest.public.extensions } } )}
| defs = component_clause _2 = SEMICOLON rest = public_composition_elements
    {                ( {rest with public = { rest.public with defs = defs @ rest.public.defs } } )}
| _1 = REDECLARE defs = component_clause _3 = SEMICOLON rest = public_composition_elements
    {                ( {rest with public = { rest.public with redeclared_defs = defs @ rest.public.redeclared_defs } } )}
| typedef = type_definition _2 = SEMICOLON rest = public_composition_elements
    {                ( {rest with public = { rest.public with typedefs=typedef::rest.public.typedefs} } )}
| _1 = REDECLARE typedef = type_definition _3 = SEMICOLON rest = public_composition_elements
    {                ( {rest with public = { rest.public with redeclared_types=typedef::rest.public.redeclared_types} } )}
| rest = cargo_sections
    {                                    ( rest )}
| _1 = PROTECTED rest = protected_composition_elements
    {                                                              ( rest )}
| _1 = PUBLIC rest = public_composition_elements
    {                                                        ( rest )}

protected_composition_elements:
  import = import _2 = SEMICOLON rest = protected_composition_elements
    {                ( {rest with imports = import::rest.imports} )}
| extend = extends _2 = SEMICOLON rest = protected_composition_elements
    {                ( {rest with protected = { rest.protected with extensions = extend::rest.protected.extensions } } )}
| defs = component_clause _2 = SEMICOLON rest = protected_composition_elements
    {                ( {rest with protected = { rest.protected with defs = defs @ rest.protected.defs } } )}
| _1 = REDECLARE defs = component_clause _3 = SEMICOLON rest = protected_composition_elements
    {                ( {rest with protected = { rest.protected with redeclared_defs = defs @ rest.protected.redeclared_defs } } )}
| typedef = type_definition _2 = SEMICOLON rest = protected_composition_elements
    {                ( {rest with protected = { rest.protected with typedefs=typedef::rest.protected.typedefs} } )}
| _1 = REDECLARE typedef = type_definition _3 = SEMICOLON rest = protected_composition_elements
    {                ( {rest with protected = { rest.protected with redeclared_types=typedef::rest.protected.redeclared_types} } )}
| rest = cargo_sections
    {                                    ( rest )}
| _1 = PROTECTED rest = protected_composition_elements
    {                                                              ( rest )}
| _1 = PUBLIC rest = public_composition_elements
    {                                                        ( rest )}

composition_external:
  _1 = EXTERNAL lang = STRING lhs = external_lhs ext_ident = IDENT _5 = LPAREN xs = loption_separated_nonempty_list_COMMA_expr__ _7 = RPAREN annotation = option_annotation_ _9 = SEMICOLON
    {let ext_args =     ( xs ) in
                ( { annotated_elem = {lang ; ext_ident; ext_lhs=Some lhs; ext_args}; annotation} )}
| _1 = EXTERNAL lang = STRING ext_ident = IDENT _4 = LPAREN xs = loption_separated_nonempty_list_COMMA_expr__ _6 = RPAREN annotation = option_annotation_ _8 = SEMICOLON
    {let ext_args =     ( xs ) in
                ( { annotated_elem = {lang ; ext_ident; ext_lhs=None; ext_args}; annotation} )}

external_lhs:
  e = component_reference _2 = EQ
    {                                        ( e )}

type_definition_clause:
  td = type_definition _2 = SEMICOLON
    {                                                      ( td )}

within_clause:
  _1 = WITHIN xs = loption_separated_nonempty_list_DOT_ident__ _3 = SEMICOLON
    {let name =     ( xs ) in
                                                                 ( name )}

%%


