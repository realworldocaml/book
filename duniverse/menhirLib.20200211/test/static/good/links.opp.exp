File "links.mly", line 115, characters 28-39:
Warning: the token MINUSLBRACE is unused.
%{

open Utility
open List
open Sugartypes

(* Generation of fresh type variables *)

let type_variable_counter = ref 0

let fresh_type_variable : subkind -> datatype =
  function subkind ->
    incr type_variable_counter; TypeVar ("_" ^ string_of_int (!type_variable_counter), subkind)

let fresh_rigid_type_variable : subkind -> datatype =
  function subkind ->
    incr type_variable_counter; RigidTypeVar ("_" ^ string_of_int (!type_variable_counter), subkind)

let fresh_row_variable : subkind -> row_var =
  function subkind ->
    incr type_variable_counter; `Open ("_" ^ string_of_int (!type_variable_counter), subkind)

let fresh_rigid_row_variable : subkind -> row_var =
  function subkind ->
    incr type_variable_counter; `OpenRigid ("_" ^ string_of_int (!type_variable_counter), subkind)

let fresh_presence_variable : unit -> fieldspec =
  function () ->
    incr type_variable_counter; `Var ("_" ^ string_of_int (!type_variable_counter))

let fresh_rigid_presence_variable : unit -> fieldspec =
  function () ->
    incr type_variable_counter; `RigidVar ("_" ^ string_of_int (!type_variable_counter))

let ensure_match (start, finish, _) (opening : string) (closing : string) = function
  | result when opening = closing -> result
  | _ -> raise (ConcreteSyntaxError ("Closing tag '" ^ closing ^ "' does not match start tag '" ^ opening ^ "'.",
                                     (start, finish, None)))

let pos () : Sugartypes.position = Parsing.symbol_start_pos (), Parsing.symbol_end_pos (), None

let default_fixity = Num.num_of_int 9

let annotate (signame, datatype) : _ -> binding =
  let checksig (signame, _) name =
    if signame <> name then
      raise (ConcreteSyntaxError
               ("Signature for `" ^ signame ^ "' should precede definition of `"
                ^ signame ^ "', not `"^ name ^"'.",
                pos ())) in
    function
      | `Fun ((name, bpos), phrase, location, dpos) ->
          let _ = checksig signame name in
            `Fun ((name, None, bpos), ([], phrase), location, Some datatype), dpos
      | `Var (((name, bpos), phrase, location), dpos) ->
          let _ = checksig signame name in
            `Val ([], (`Variable (name, None, bpos), dpos), phrase, location, Some datatype), dpos

let attach_kind pos (t, k) =
   match k with
     | `Type -> `TypeVar (t, `Any)
     | `BaseType -> `TypeVar (t, `Base)
     | `Row -> `RowVar (t, `Any)
     | `BaseRow -> `RowVar (t, `Base)
     | `Presence -> `PresenceVar t

let attach_subkind pos (t, k) =
   match k with
     | "Any" -> t
     | "Base" ->
         begin
           match t with
             | TypeVar (x, _) -> TypeVar (x, `Base)
             | RigidTypeVar (x, _) -> RigidTypeVar (x, `Base)
             | _ -> assert false
         end
     | s -> raise (ConcreteSyntaxError ("Unknown subkind", pos))

let attach_row_subkind pos (r, k) =
   match k with
     | "Any" -> r
     | "Base" ->
         begin
           match r with
             | `Open (x, _) -> `Open (x, `Base)
             | `OpenRigid (x, _) -> `OpenRigid (x, `Base)
             | _ -> assert false
         end
     | s -> raise (ConcreteSyntaxError ("Unknown subkind", pos))

let row_with field (fields, row_var) = field::fields, row_var

(* this preserves 1-tuples *)
let make_tuple pos =
  function
    | [e] -> `RecordLit ([("1", e)], None), pos
    | es -> `TupleLit es, pos

let labels = List.map fst

let parseRegexFlags f =
  let rec asList f i l =
    if (i == String.length f) then
      List.rev l
    else
      asList f (i+1) ((String.get f i)::l) in
    List.map (function 'l' -> `RegexList | 'n' -> `RegexNative | 'g' -> `RegexGlobal) (asList f 0 [])

let datatype d = d, None

%}
%start file
%start interactive
%start just_datatype
%token ALIEN
%token ALTERNATE
%token AMPAMP
%token ANY
%token AS
%token BARBAR
%token BARRBRACE
%token BARRBRACKET
%token BASE
%token BASEROW
%token BASETYPE
%token CARET
%token CASE
%token <string> CDATA
%token <char> CHAR
%token CLIENT
%token COLON
%token COLONCOLON
%token COMMA
%token <string> CONSTRUCTOR
%token DATABASE
%token DEFAULT
%token DELETE
%token DOLLAR
%token DOT
%token DOTDOT
%token ELSE
%token END
%token <string> ENDTAG
%token EQ
%token EQUALSTILDE
%token ESCAPE
%token FALSE
%token FATRARROW
%token FOR
%token FORALL
%token FORMLET
%token FROM
%token FUN
%token IF
%token IN
%token INCLUDE
%token <[`Left|`Right|`None|`Pre|`Post] -> int -> string -> unit> INFIX
%token <string> INFIX0
%token <string> INFIX1
%token <string> INFIX2
%token <string> INFIX3
%token <string> INFIX4
%token <string> INFIX5
%token <string> INFIX6
%token <string> INFIX7
%token <string> INFIX8
%token <string> INFIX9
%token <[`Left|`Right|`None|`Pre|`Post] -> int -> string -> unit> INFIXL
%token <string> INFIXL0
%token <string> INFIXL1
%token <string> INFIXL2
%token <string> INFIXL3
%token <string> INFIXL4
%token <string> INFIXL5
%token <string> INFIXL6
%token <string> INFIXL7
%token <string> INFIXL8
%token <string> INFIXL9
%token <[`Left|`Right|`None|`Pre|`Post] -> int -> string -> unit> INFIXR
%token <string> INFIXR0
%token <string> INFIXR1
%token <string> INFIXR2
%token <string> INFIXR3
%token <string> INFIXR4
%token <string> INFIXR5
%token <string> INFIXR6
%token <string> INFIXR7
%token <string> INFIXR8
%token <string> INFIXR9
%token INSERT
%token <string> KEYWORD
%token LARROW
%token LBRACE
%token LBRACEBAR
%token LBRACKET
%token LBRACKETBAR
%token LLARROW
%token LPAREN
%token LQUOTE
%token <string> LXML
%token MINUS
%token MINUSDOT
%token MINUSLBRACE
%token MU
%token NATIVE
%token OP
%token ORDERBY
%token PAGE
%token PLUS
%token <[`Left|`Right|`None|`Pre|`Post] -> int -> string -> unit> POSTFIX
%token <string> POSTFIXOP
%token <[`Left|`Right|`None|`Pre|`Post] -> int -> string -> unit> PREFIX
%token <string> PREFIXOP
%token PRESENCE
%token QUERY
%token QUESTION
%token <string> QUESTIONVAR
%token <string> QUOTEDMETA
%token <char*char> RANGE
%token RARROW
%token RBRACE
%token RBRACKET
%token READONLY
%token RECEIVE
%token <string> REGEXREPL
%token RETURNING
%token ROW
%token RPAREN
%token RQUOTE
%token RXML
%token SEMICOLON
%token SERVER
%token SET
%token SIG
%token SLASH
%token <string> SLASHFLAGS
%token SLASHRXML
%token SPAWN
%token SPAWNWAIT
%token SQUIGRARROW
%token SSLASH
%token STAR
%token <string> STRING
%token SWITCH
%token TABLE
%token TABLEHANDLE
%token TILDE
%token TRUE
%token TYPE
%token TYPENAME
%token <float> UFLOAT
%token <Num.num> UINTEGER
%token UNDERSCORE
%token UPDATE
%token VALUES
%token VAR
%token <string> VARIABLE
%token VBAR
%token WHERE
%token WITH
%token YIELDS
%type <Sugartypes.phrase> atomic_expression
%type <(string * Sugartypes.phrase list) list> attr_list
%type <Sugartypes.phrase list> attr_val
%type <Sugartypes.binding> binding
%type <Sugartypes.constant * Sugartypes.position> constant
%type <Sugartypes.datatype> datatype
%type <Sugartypes.binding list * Sugartypes.phrase option> file
%type <Sugartypes.sentence> interactive
%type <Sugartypes.datatype> just_datatype
%type <Sugartypes.pattern> pattern
%type <Sugartypes.phrase> postfix_expression
%type <Sugartypes.phrase> primary_expression
%type <Sugartypes.regex> regex_pattern
%type <Sugartypes.regex> regex_pattern_alternate
%type <Sugartypes.regex list> regex_pattern_sequence
%type <(Sugartypes.name * Sugartypes.position) * Sugartypes.funlit * Sugartypes.location * Sugartypes.position> tlfunbinding
%%

interactive:
  _1 = preamble_declaration
    {                                                               ( `Definitions [_1] )}
| _1 = nofun_declaration
    {                                                               ( `Definitions [_1] )}
| _1 = fun_declarations _2 = SEMICOLON
    {                                                               ( `Definitions _1 )}
| _1 = SEMICOLON
    {                                                               ( `Definitions [] )}
| _1 = exp _2 = SEMICOLON
    {                                                               ( `Expression _1 )}
| _1 = directive
    {                                                               ( `Directive _1 )}
| _1 = END
    {                                                               ( `Directive ("quit", []) (* rather hackish *) )}

file:
  _1 = preamble _2 = declarations _3 = exp _4 = END
    {                                                               ( _1 @ _2, Some _3 )}
| _1 = preamble _2 = exp _3 = END
    {                                                               ( _1, Some _2 )}
| _1 = preamble _2 = declarations _3 = END
    {                                                               ( _1 @ _2, None )}

directive:
  _1 = KEYWORD _2 = args _3 = SEMICOLON
    {                                                               ( (_1, _2) )}

args:
  
    {                                                               ( [] )}
| _1 = arg _2 = args
    {                                                               ( _1 :: _2 )}

arg:
  _1 = STRING
    {                                                               ( _1 )}
| _1 = VARIABLE
    {                                                               ( _1 )}
| _1 = CONSTRUCTOR
    {                                                               ( _1 )}
| _1 = UINTEGER
    {                                                               ( Num.string_of_num _1 )}
| _1 = UFLOAT
    {                                                               ( string_of_float _1 )}
| _1 = TRUE
    {                                                               ( "true" )}
| _1 = FALSE
    {                                                               ( "false" )}

var:
  _1 = VARIABLE
    {                                                               ( _1, pos() )}

preamble:
  _1 = preamble_declaration _2 = preamble
    {                                                               ( _1 :: _2 )}
| 
    {                                                               ( [] )}

declarations:
  _1 = declarations _2 = declaration
    {                                                               ( _1 @ [_2] )}
| _1 = declaration
    {                                                               ( [_1] )}

declaration:
  _1 = fun_declaration
    {                                                               ( _1 )}
| _1 = nofun_declaration
    {                                                               ( _1 )}

preamble_declaration:
  _1 = INCLUDE _2 = STRING
    {                                                               ( `Include _2, pos() )}

nofun_declaration:
  _1 = ALIEN _2 = VARIABLE _3 = var _4 = COLON _5 = datatype _6 = SEMICOLON
    {                                                               ( let (name, name_pos) = _3 in
                                                                   `Foreign ((name, None, name_pos), _2, datatype _5), pos() )}
| _1 = fixity _2 = perhaps_uinteger _3 = op _4 = SEMICOLON
    {                                                               ( let assoc, set = _1 in
                                                                   set assoc (Num.int_of_num (from_option default_fixity _2)) (fst _3);
                                                                   (`Infix, pos()) )}
| _1 = tlvarbinding _2 = SEMICOLON
    {                                                               ( let ((d,dpos),p,l), pos = _1
                                                                 in `Val ([], (`Variable (d, None, dpos), pos),p,l,None), pos )}
| _1 = signature _2 = tlvarbinding _3 = SEMICOLON
    {                                                               ( annotate _1 (`Var _2) )}
| _1 = typedecl _2 = SEMICOLON
    {                                                               ( _1 )}

fun_declarations:
  _1 = fun_declarations _2 = fun_declaration
    {                                                               ( _1 @ [_2] )}
| _1 = fun_declaration
    {                                                               ( [_1] )}

fun_declaration:
  _1 = tlfunbinding
    {                                                               ( let ((d,dpos),p,l, pos) = _1
                                                                 in `Fun ((d, None, dpos),([],p),l,None), pos )}
| _1 = signature _2 = tlfunbinding
    {                                                               ( annotate _1 (`Fun _2) )}

perhaps_uinteger:
  
    {                                                               ( None )}
| _1 = UINTEGER
    {                                                               ( Some _1 )}

prefixop:
  _1 = PREFIXOP
    {                                                               ( _1, pos() )}

postfixop:
  _1 = POSTFIXOP
    {                                                               ( _1, pos() )}

tlfunbinding:
  _1 = FUN _2 = var _3 = arg_lists _4 = perhaps_location _5 = block
    {                                                               ( (_2, (_3, (`Block _5, pos ())), _4, pos()) )}
| _1 = OP _2 = pattern _3 = op _4 = pattern _5 = perhaps_location _6 = block
    {                                                               ( (_3, ([[_2; _4]], (`Block _6, pos ())), _5, pos ()) )}
| _1 = OP _2 = prefixop _3 = pattern _4 = perhaps_location _5 = block
    {                                                               ( (_2, ([[_3]], (`Block _5, pos ())), _4, pos ()) )}
| _1 = OP _2 = pattern _3 = postfixop _4 = perhaps_location _5 = block
    {                                                               ( (_3, ([[_2]], (`Block _5, pos ())), _4, pos ()) )}

tlvarbinding:
  _1 = VAR _2 = var _3 = perhaps_location _4 = EQ _5 = exp
    {                                                               ( (_2, _5, _3), pos() )}

signature:
  _1 = SIG _2 = var _3 = COLON _4 = datatype
    {                                                               ( _2, datatype _4 )}
| _1 = SIG _2 = op _3 = COLON _4 = datatype
    {                                                               ( _2, datatype _4 )}

typedecl:
  _1 = TYPENAME _2 = CONSTRUCTOR _3 = typeargs_opt _4 = EQ _5 = datatype
    {                                                               ( `Type (_2, _3, datatype _5), pos()  )}

typeargs_opt:
  
    {                                                               ( [] )}
| _1 = LPAREN _2 = varlist _3 = RPAREN
    {                                                               ( _2 )}

kind:
  _1 = TYPE
    {                                                               ( `Type )}
| _1 = BASETYPE
    {                                                               ( `BaseType )}
| _1 = ROW
    {                                                               ( `Row )}
| _1 = BASEROW
    {                                                               ( `BaseRow )}
| _1 = PRESENCE
    {                                                               ( `Presence )}

subkind:
  _1 = ANY
    {                                                               ( "Any" )}
| _1 = BASE
    {                                                               ( "Base" )}

typearg:
  _1 = VARIABLE
    {                                                               ( (`TypeVar (_1, `Any), None) )}
| _1 = VARIABLE _2 = kind
    {                                                               ( (attach_kind (pos()) (_1, _2), None) )}

varlist:
  _1 = typearg
    {                                                               ( [_1] )}
| _1 = typearg _2 = COMMA _3 = varlist
    {                                                               ( _1 :: _3 )}

fixity:
  _1 = INFIX
    {                                                               ( `None, _1 )}
| _1 = INFIXL
    {                                                               ( `Left, _1 )}
| _1 = INFIXR
    {                                                               ( `Right, _1 )}
| _1 = PREFIX
    {                                                               ( `Pre, _1 )}
| _1 = POSTFIX
    {                                                               ( `Post, _1 )}

perhaps_location:
  _1 = SERVER
    {                                                               ( `Server )}
| _1 = CLIENT
    {                                                               ( `Client )}
| _1 = NATIVE
    {                                                               ( `Native )}
| 
    {                                                               ( `Unknown )}

constant:
  _1 = UINTEGER
    {                                                               ( `Int _1    , pos() )}
| _1 = UFLOAT
    {                                                               ( `Float _1  , pos() )}
| _1 = STRING
    {                                                               ( `String _1 , pos() )}
| _1 = TRUE
    {                                                               ( `Bool true , pos() )}
| _1 = FALSE
    {                                                               ( `Bool false, pos() )}
| _1 = CHAR
    {                                                               ( `Char _1   , pos() )}

atomic_expression:
  _1 = VARIABLE
    {                                                               ( `Var _1, pos() )}
| _1 = constant
    {                                                               ( let c, p = _1 in `Constant c, p )}
| _1 = parenthesized_thing
    {                                                               ( _1 )}

primary_expression:
  _1 = atomic_expression
    {                                                               ( _1 )}
| _1 = LBRACKET _2 = RBRACKET
    {                                                               ( `ListLit ([], None), pos() )}
| _1 = LBRACKET _2 = exps _3 = RBRACKET
    {                                                               ( `ListLit (_2, None), pos() )}
| _1 = LBRACKET _2 = exp _3 = DOTDOT _4 = exp _5 = RBRACKET
    {                                                               ( `RangeLit(_2, _4), pos() )}
| _1 = xml
    {                                                               ( _1 )}
| _1 = FUN _2 = arg_lists _3 = block
    {                                                               ( `FunLit (None, (_2, (`Block _3, pos ()))), pos() )}

constructor_expression:
  _1 = CONSTRUCTOR
    {                                                               ( `ConstructorLit(_1, None, None), pos() )}
| _1 = CONSTRUCTOR _2 = parenthesized_thing
    {                                                               ( `ConstructorLit(_1, Some _2, None), pos() )}

parenthesized_thing:
  _1 = LPAREN _2 = binop _3 = RPAREN
    {                                                               ( `Section _2, pos() )}
| _1 = LPAREN _2 = DOT _3 = record_label _4 = RPAREN
    {                                                               ( `Section (`Project _3), pos() )}
| _1 = LPAREN _2 = RPAREN
    {                                                               ( `RecordLit ([], None), pos() )}
| _1 = LPAREN _2 = labeled_exps _3 = VBAR _4 = exp _5 = RPAREN
    {                                                               ( `RecordLit (_2, Some _4), pos() )}
| _1 = LPAREN _2 = labeled_exps _3 = RPAREN
    {                                                               ( `RecordLit (_2, None),               pos() )}
| _1 = LPAREN _2 = exps _3 = RPAREN
    {                                                               ( `TupleLit (_2), pos() )}
| _1 = LPAREN _2 = exp _3 = WITH _4 = labeled_exps _5 = RPAREN
    {                                                               ( `With (_2, _4), pos() )}

binop:
  _1 = MINUS
    {                                                               ( `Minus )}
| _1 = MINUSDOT
    {                                                               ( `FloatMinus )}
| _1 = op
    {                                                               ( `Name (fst _1) )}

op:
  _1 = INFIX0
    {                                                               ( _1, pos() )}
| _1 = INFIXL0
    {                                                               ( _1, pos() )}
| _1 = INFIXR0
    {                                                               ( _1, pos() )}
| _1 = INFIX1
    {                                                               ( _1, pos() )}
| _1 = INFIXL1
    {                                                               ( _1, pos() )}
| _1 = INFIXR1
    {                                                               ( _1, pos() )}
| _1 = INFIX2
    {                                                               ( _1, pos() )}
| _1 = INFIXL2
    {                                                               ( _1, pos() )}
| _1 = INFIXR2
    {                                                               ( _1, pos() )}
| _1 = INFIX3
    {                                                               ( _1, pos() )}
| _1 = INFIXL3
    {                                                               ( _1, pos() )}
| _1 = INFIXR3
    {                                                               ( _1, pos() )}
| _1 = INFIX4
    {                                                               ( _1, pos() )}
| _1 = INFIXL4
    {                                                               ( _1, pos() )}
| _1 = INFIXR4
    {                                                               ( _1, pos() )}
| _1 = INFIX5
    {                                                               ( _1, pos() )}
| _1 = INFIXL5
    {                                                               ( _1, pos() )}
| _1 = INFIXR5
    {                                                               ( _1, pos() )}
| _1 = INFIX6
    {                                                               ( _1, pos() )}
| _1 = INFIXL6
    {                                                               ( _1, pos() )}
| _1 = INFIXR6
    {                                                               ( _1, pos() )}
| _1 = INFIX7
    {                                                               ( _1, pos() )}
| _1 = INFIXL7
    {                                                               ( _1, pos() )}
| _1 = INFIXR7
    {                                                               ( _1, pos() )}
| _1 = INFIX8
    {                                                               ( _1, pos() )}
| _1 = INFIXL8
    {                                                               ( _1, pos() )}
| _1 = INFIXR8
    {                                                               ( _1, pos() )}
| _1 = INFIX9
    {                                                               ( _1, pos() )}
| _1 = INFIXL9
    {                                                               ( _1, pos() )}
| _1 = INFIXR9
    {                                                               ( _1, pos() )}

postfix_expression:
  _1 = primary_expression
    {                                                               ( _1 )}
| _1 = primary_expression _2 = POSTFIXOP
    {                                                               ( `UnaryAppl (([], `Name _2), _1), pos() )}
| _1 = block
    {                                                               ( `Block _1, pos () )}
| _1 = SPAWN _2 = block
    {                                                               ( `Spawn ((`Block _2, pos()), None), pos () )}
| _1 = SPAWNWAIT _2 = block
    {                                                               ( `SpawnWait ((`Block _2, pos()), None), pos () )}
| _1 = QUERY _2 = block
    {                                                               ( `Query (None, (`Block _2, pos ()), None), pos () )}
| _1 = QUERY _2 = LBRACKET _3 = exp _4 = RBRACKET _5 = block
    {                                                               ( `Query (Some (_3,
                                                                               (`Constant (`Int (Num.num_of_int 0)), pos ())),
                                                                         (`Block _5, pos ()), None), pos () )}
| _1 = QUERY _2 = LBRACKET _3 = exp _4 = COMMA _5 = exp _6 = RBRACKET _7 = block
    {                                                               ( `Query (Some (_3, _5), (`Block _7, pos ()), None), pos () )}
| _1 = postfix_expression _2 = arg_spec
    {                                                               ( `FnAppl (_1, _2), pos() )}
| _1 = postfix_expression _2 = DOT _3 = record_label
    {                                                               ( `Projection (_1, _3), pos() )}

arg_spec:
  _1 = LPAREN _2 = RPAREN
    {                                                               ( [] )}
| _1 = LPAREN _2 = exps _3 = RPAREN
    {                                                               ( _2 )}

exps:
  _1 = exp _2 = COMMA _3 = exps
    {                                                               ( _1 :: _3 )}
| _1 = exp
    {                                                               ( [_1] )}

unary_expression:
  _1 = MINUS _2 = unary_expression
    {                                                               ( `UnaryAppl (([], `Minus),      _2), pos() )}
| _1 = MINUSDOT _2 = unary_expression
    {                                                               ( `UnaryAppl (([], `FloatMinus), _2), pos() )}
| _1 = PREFIXOP _2 = unary_expression
    {                                                               ( `UnaryAppl (([], `Name _1), _2), pos() )}
| _1 = postfix_expression
    {                                                               ( _1 )}
| _1 = constructor_expression
    {                                                               ( _1 )}

infixr_9:
  _1 = unary_expression
    {                                                               ( _1 )}
| _1 = unary_expression _2 = INFIX9 _3 = unary_expression
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}
| _1 = unary_expression _2 = INFIXR9 _3 = infixr_9
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}

infixl_9:
  _1 = infixr_9
    {                                                               ( _1 )}
| _1 = infixl_9 _2 = INFIXL9 _3 = infixr_9
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}

infixr_8:
  _1 = infixl_9
    {                                                               ( _1 )}
| _1 = infixl_9 _2 = INFIX8 _3 = infixl_9
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}
| _1 = infixl_9 _2 = INFIXR8 _3 = infixr_8
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}
| _1 = infixl_9 _2 = COLONCOLON _3 = infixr_8
    {                                                               ( `InfixAppl (([], `Cons), _1, _3), pos() )}

infixl_8:
  _1 = infixr_8
    {                                                               ( _1 )}
| _1 = infixl_8 _2 = INFIXL8 _3 = infixr_8
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}

infixr_7:
  _1 = infixl_8
    {                                                               ( _1 )}
| _1 = infixl_8 _2 = INFIX7 _3 = infixl_8
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}
| _1 = infixl_8 _2 = INFIXR7 _3 = infixr_7
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}

infixl_7:
  _1 = infixr_7
    {                                                               ( _1 )}
| _1 = infixl_7 _2 = INFIXL7 _3 = infixr_7
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}

infixr_6:
  _1 = infixl_7
    {                                                               ( _1 )}
| _1 = infixl_7 _2 = INFIX6 _3 = infixl_7
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}
| _1 = infixl_7 _2 = INFIXR6 _3 = infixr_6
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}

infixl_6:
  _1 = infixr_6
    {                                                               ( _1 )}
| _1 = infixl_6 _2 = INFIXL6 _3 = infixr_6
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}
| _1 = infixl_6 _2 = MINUS _3 = infixr_6
    {                                                               ( `InfixAppl (([], `Minus), _1, _3), pos() )}
| _1 = infixl_6 _2 = MINUSDOT _3 = infixr_6
    {                                                               ( `InfixAppl (([], `FloatMinus), _1, _3), pos() )}

infixr_5:
  _1 = infixl_6
    {                                                               ( _1 )}
| _1 = infixl_6 _2 = INFIX5 _3 = infixl_6
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}
| _1 = infixl_6 _2 = INFIXR5 _3 = infixr_5
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}

infixl_5:
  _1 = infixr_5
    {                                                               ( _1 )}
| _1 = infixl_5 _2 = INFIXL5 _3 = infixr_5
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}

infixr_4:
  _1 = infixl_5
    {                                                               ( _1 )}
| _1 = infixl_5 _2 = INFIX4 _3 = infixl_5
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}
| _1 = infixl_5 _2 = INFIXR4 _3 = infixr_4
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}
| _1 = infixr_5 _2 = EQUALSTILDE _3 = regex
    {                                                               ( let r, flags = _3 in `InfixAppl (([], `RegexMatch flags), _1, r), pos() )}

infixl_4:
  _1 = infixr_4
    {                                                               ( _1 )}
| _1 = infixl_4 _2 = INFIXL4 _3 = infixr_4
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}

infixr_3:
  _1 = infixl_4
    {                                                               ( _1 )}
| _1 = infixl_4 _2 = INFIX3 _3 = infixl_4
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}
| _1 = infixl_4 _2 = INFIXR3 _3 = infixr_3
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}

infixl_3:
  _1 = infixr_3
    {                                                               ( _1 )}
| _1 = infixl_3 _2 = INFIXL3 _3 = infixr_3
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}

infixr_2:
  _1 = infixl_3
    {                                                               ( _1 )}
| _1 = infixl_3 _2 = INFIX2 _3 = infixl_3
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}
| _1 = infixl_3 _2 = INFIXR2 _3 = infixr_2
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}

infixl_2:
  _1 = infixr_2
    {                                                               ( _1 )}
| _1 = infixl_2 _2 = INFIXL2 _3 = infixr_2
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}

infixr_1:
  _1 = infixl_2
    {                                                               ( _1 )}
| _1 = infixl_2 _2 = INFIX1 _3 = infixl_2
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}
| _1 = infixl_2 _2 = INFIXR1 _3 = infixr_1
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}

infixl_1:
  _1 = infixr_1
    {                                                               ( _1 )}
| _1 = infixl_1 _2 = INFIXL1 _3 = infixr_1
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}

infixr_0:
  _1 = infixl_1
    {                                                               ( _1 )}
| _1 = infixl_1 _2 = INFIX0 _3 = infixl_1
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}
| _1 = infixl_1 _2 = INFIXR0 _3 = infixr_0
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}

infixl_0:
  _1 = infixr_0
    {                                                               ( _1 )}
| _1 = infixl_0 _2 = INFIXL0 _3 = infixr_0
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}

logical_expression:
  _1 = infixl_0
    {                                                               ( _1 )}
| _1 = logical_expression _2 = BARBAR _3 = infixl_0
    {                                                               ( `InfixAppl (([], `Or), _1, _3), pos() )}
| _1 = logical_expression _2 = AMPAMP _3 = infixl_0
    {                                                               ( `InfixAppl (([], `And), _1, _3), pos() )}

typed_expression:
  _1 = logical_expression
    {                                                               ( _1 )}
| _1 = typed_expression _2 = COLON _3 = datatype
    {                                                               ( `TypeAnnotation (_1, datatype _3), pos() )}
| _1 = typed_expression _2 = COLON _3 = datatype _4 = LARROW _5 = datatype
    {                                                               ( `Upcast (_1, datatype _3, datatype _5), pos() )}

db_expression:
  _1 = typed_expression
    {                                                               ( _1 )}
| _1 = DELETE _2 = LPAREN _3 = table_generator _4 = RPAREN _5 = perhaps_where
    {                                                               ( let pat, phrase = _3 in `DBDelete (pat, phrase, _5), pos() )}
| _1 = UPDATE _2 = LPAREN _3 = table_generator _4 = RPAREN _5 = perhaps_where _6 = SET _7 = LPAREN _8 = labeled_exps _9 = RPAREN
    {                                                               ( let pat, phrase = _3 in `DBUpdate(pat, phrase, _5, _8), pos() )}

xml:
  _1 = xml_tree
    {                                                               ( _1 )}

xmlid:
  _1 = VARIABLE
    {                                                               ( _1 )}

attrs:
  _1 = block
    {                                                               ( [], Some (`Block _1, pos ()) )}
| _1 = attr_list
    {                                                               ( _1, None )}
| _1 = attr_list _2 = block
    {                                                               ( _1, Some (`Block _2, pos ()) )}

attr_list:
  _1 = attr
    {                                                               ( [_1] )}
| _1 = attr_list _2 = attr
    {                                                               ( _2 :: _1 )}

attr:
  _1 = xmlid _2 = EQ _3 = LQUOTE _4 = attr_val _5 = RQUOTE
    {                                                               ( (_1, _4) )}
| _1 = xmlid _2 = EQ _3 = LQUOTE _4 = RQUOTE
    {                                                               ( (_1, [(`Constant (`String ""), pos() : Sugartypes.phrase)]) )}

attr_val:
  _1 = block
    {                                                               ( [`Block _1, pos ()] )}
| _1 = STRING
    {                                                               ( [`Constant (`String _1), pos()] )}
| _1 = block _2 = attr_val
    {                                                               ( (`Block _1, pos ()) :: _2 )}
| _1 = STRING _2 = attr_val
    {                                                               ( (`Constant (`String _1), pos()) :: _2)}

xml_tree:
  _1 = LXML _2 = SLASHRXML
    {                                                               ( `Xml (_1, [], None, []), pos() )}
| _1 = LXML _2 = RXML _3 = ENDTAG
    {                                                               ( ensure_match (pos()) _1 _3 (`Xml (_1, [], None, []), pos()) )}
| _1 = LXML _2 = RXML _3 = xml_contents_list _4 = ENDTAG
    {                                                               ( ensure_match (pos()) _1 _4 (`Xml (_1, [], None, _3), pos()) )}
| _1 = LXML _2 = attrs _3 = RXML _4 = ENDTAG
    {                                                               ( ensure_match (pos()) _1 _4 (`Xml (_1, fst _2, snd _2, []), pos()) )}
| _1 = LXML _2 = attrs _3 = SLASHRXML
    {                                                               ( `Xml (_1, fst _2, snd _2, []), pos() )}
| _1 = LXML _2 = attrs _3 = RXML _4 = xml_contents_list _5 = ENDTAG
    {                                                               ( ensure_match (pos()) _1 _5 (`Xml (_1, fst _2, snd _2, _4), pos()) )}

xml_contents_list:
  _1 = xml_contents
    {                                                               ( [_1] )}
| _1 = xml_contents _2 = xml_contents_list
    {                                                               ( _1 :: _2 )}

xml_contents:
  _1 = block
    {                                                               ( `Block _1, pos () )}
| _1 = formlet_binding
    {                                                               ( _1 )}
| _1 = formlet_placement
    {                                                               ( _1 )}
| _1 = page_placement
    {                                                               ( _1 )}
| _1 = xml_tree
    {                                                               ( _1 )}
| _1 = CDATA
    {                                                               ( `TextNode (Utility.xml_unescape _1), pos() )}

formlet_binding:
  _1 = LBRACE _2 = logical_expression _3 = RARROW _4 = pattern _5 = RBRACE
    {                                                               ( `FormBinding(_2, _4), pos())}

formlet_placement:
  _1 = LBRACE _2 = logical_expression _3 = FATRARROW _4 = logical_expression _5 = RBRACE
    {                                                               ( `FormletPlacement (_2, _4, (`ListLit ([], None), pos())), pos () )}
| _1 = LBRACE _2 = logical_expression _3 = FATRARROW _4 = logical_expression _5 = WITH _6 = logical_expression _7 = RBRACE
    {                                                               ( `FormletPlacement (_2, _4, _6), pos () )}

page_placement:
  _1 = LBRACEBAR _2 = exp _3 = BARRBRACE
    {                                                               ( `PagePlacement _2, pos() )}

conditional_expression:
  _1 = db_expression
    {                                                               ( _1 )}
| _1 = IF _2 = LPAREN _3 = exp _4 = RPAREN _5 = exp _6 = ELSE _7 = exp
    {                                                               ( `Conditional (_3, _5, _7), pos() )}

cases:
  _1 = case
    {                                                               ( [_1] )}
| _1 = case _2 = cases
    {                                                               ( _1 :: _2 )}

case:
  _1 = CASE _2 = pattern _3 = RARROW _4 = block_contents
    {                                                               ( _2, (`Block (_4), pos()) )}

perhaps_cases:
  
    {                                                               ( [] )}
| _1 = cases
    {                                                               ( _1 )}

case_expression:
  _1 = conditional_expression
    {                                                               ( _1 )}
| _1 = SWITCH _2 = LPAREN _3 = exp _4 = RPAREN _5 = LBRACE _6 = perhaps_cases _7 = RBRACE
    {                                                               ( `Switch (_3, _6, None), pos() )}
| _1 = RECEIVE _2 = LBRACE _3 = perhaps_cases _4 = RBRACE
    {                                                               ( `Receive (_3, None), pos() )}

iteration_expression:
  _1 = case_expression
    {                                                               ( _1 )}
| _1 = FOR _2 = LPAREN _3 = perhaps_generators _4 = RPAREN _5 = perhaps_where _6 = perhaps_orderby _7 = exp
    {                                                               ( `Iteration (_3, _7, _5, _6), pos() )}

perhaps_generators:
  
    {                                                               ( [] )}
| _1 = generators
    {                                                               ( _1 )}

generators:
  _1 = generator
    {                                                               ( [_1] )}
| _1 = generator _2 = COMMA _3 = generators
    {                                                               ( _1 :: _3 )}

generator:
  _1 = list_generator
    {                                                               ( `List _1 )}
| _1 = table_generator
    {                                                               ( `Table _1 )}

list_generator:
  _1 = pattern _2 = LARROW _3 = exp
    {                                                               ( (_1, _3) )}

table_generator:
  _1 = pattern _2 = LLARROW _3 = exp
    {                                                               ( (_1, _3) )}

perhaps_where:
  
    {                                                               ( None )}
| _1 = WHERE _2 = LPAREN _3 = exp _4 = RPAREN
    {                                                               ( Some _3 )}

perhaps_orderby:
  
    {                                                               ( None )}
| _1 = ORDERBY _2 = LPAREN _3 = exps _4 = RPAREN
    {                                                               ( Some (make_tuple (pos()) _3) )}

escape_expression:
  _1 = iteration_expression
    {                                                               ( _1 )}
| _1 = ESCAPE _2 = var _3 = IN _4 = postfix_expression
    {                                                               ( `Escape ((fst _2, None, snd _2), _4), pos() )}

formlet_expression:
  _1 = escape_expression
    {                                                               ( _1 )}
| _1 = FORMLET _2 = xml _3 = YIELDS _4 = exp
    {                                                               ( `Formlet (_2, _4), pos() )}
| _1 = PAGE _2 = xml
    {                                                               ( `Page (_2), pos() )}

table_expression:
  _1 = formlet_expression
    {                                                               ( _1 )}
| _1 = TABLE _2 = exp _3 = WITH _4 = datatype _5 = perhaps_table_constraints _6 = FROM _7 = exp
    {                                                               ( `TableLit (_2, datatype _4, _5, _7), pos())}

perhaps_table_constraints:
  _1 = WHERE _2 = table_constraints
    {                                                               ( _2 )}
| 
    {                                                               ( [] )}

table_constraints:
  _1 = record_label _2 = field_constraints
    {                                                               ( [(_1, _2)] )}
| _1 = record_label _2 = field_constraints _3 = COMMA _4 = table_constraints
    {                                                               ( (_1, _2) :: _4 )}

field_constraints:
  _1 = field_constraint
    {                                                               ( [_1] )}
| _1 = field_constraint _2 = field_constraints
    {                                                               ( _1 :: _2 )}

field_constraint:
  _1 = READONLY
    {                                                               ( `Readonly )}
| _1 = DEFAULT
    {                                                               ( `Default )}

perhaps_db_args:
  _1 = atomic_expression
    {                                                               ( Some _1 )}
| 
    {                                                               ( None )}

perhaps_db_driver:
  _1 = atomic_expression _2 = perhaps_db_args
    {                                                               ( Some _1, _2 )}
| 
    {                                                               ( None, None )}

database_expression:
  _1 = table_expression
    {                                                               ( _1 )}
| _1 = INSERT _2 = exp _3 = VALUES _4 = LPAREN _5 = RPAREN _6 = exp
    {                                                               ( `DBInsert (_2, [], _6, None), pos() )}
| _1 = INSERT _2 = exp _3 = VALUES _4 = LPAREN _5 = record_labels _6 = RPAREN _7 = exp
    {                                                               ( `DBInsert (_2, _5, _7, None), pos() )}
| _1 = INSERT _2 = exp _3 = VALUES _4 = LBRACKET _5 = LPAREN _6 = labeled_exps _7 = RPAREN _8 = RBRACKET
    {                                                               ( `DBInsert (_2,
                                                                            labels _6,
                                                                            (`ListLit ([`RecordLit (_6, None), pos()], None), pos()),
                                                                            None),
                                                                 pos() )}
| _1 = INSERT _2 = exp _3 = VALUES _4 = LPAREN _5 = RPAREN _6 = db_expression _7 = RETURNING _8 = VARIABLE
    {                                                               ( `DBInsert (_2, [], _6, Some (`Constant (`String _8), pos())), pos() )}
| _1 = INSERT _2 = exp _3 = VALUES _4 = LPAREN _5 = record_labels _6 = RPAREN _7 = db_expression _8 = RETURNING _9 = VARIABLE
    {                                                               ( `DBInsert (_2, _5, _7, Some (`Constant (`String _9), pos())), pos() )}
| _1 = INSERT _2 = exp _3 = VALUES _4 = LBRACKET _5 = LPAREN _6 = RPAREN _7 = RBRACKET _8 = RETURNING _9 = VARIABLE
    {                                                               ( `DBInsert (_2,
                                                                            [],
                                                                            (`ListLit ([`RecordLit ([], None), pos()], None), pos()),
                                                                            Some (`Constant (`String _9), pos())),
                                                                 pos() )}
| _1 = INSERT _2 = exp _3 = VALUES _4 = LBRACKET _5 = LPAREN _6 = labeled_exps _7 = RPAREN _8 = RBRACKET _9 = RETURNING _10 = VARIABLE
    {                                                               ( `DBInsert (_2,
                                                                            labels _6,
                                                                            (`ListLit ([`RecordLit (_6, None), pos()], None), pos()),
                                                                            Some (`Constant (`String _10), pos())),
                                                                 pos() )}
| _1 = DATABASE _2 = atomic_expression _3 = perhaps_db_driver
    {                                                               ( `DatabaseLit (_2, _3), pos() )}

record_labels:
  _1 = record_label _2 = COMMA _3 = record_labels
    {                                                               ( _1 :: _3 )}
| _1 = record_label
    {                                                               ( [_1] )}

binding:
  _1 = VAR _2 = pattern _3 = EQ _4 = exp _5 = SEMICOLON
    {                                                               ( `Val ([], _2, _4, `Unknown, None), pos () )}
| _1 = exp _2 = SEMICOLON
    {                                                               ( `Exp _1, pos () )}
| _1 = FUN _2 = var _3 = arg_lists _4 = block
    {                                                               ( `Fun ((fst _2, None, snd _2), ([], (_3, (`Block _4, pos ()))), `Unknown, None), pos () )}
| _1 = typedecl _2 = SEMICOLON
    {                                                               ( _1 )}

bindings:
  _1 = binding
    {                                                               ( [_1] )}
| _1 = bindings _2 = binding
    {                                                               ( _1 @ [_2] )}

block:
  _1 = LBRACE _2 = block_contents _3 = RBRACE
    {                                                               ( _2 )}

block_contents:
  _1 = bindings _2 = exp _3 = SEMICOLON
    {                                                               ( (_1 @ [`Exp _2, pos ()], (`RecordLit ([], None), pos())) )}
| _1 = bindings _2 = exp
    {                                                               ( (_1, _2) )}
| _1 = exp _2 = SEMICOLON
    {                                                               ( ([`Exp _1, pos ()], (`RecordLit ([], None), pos())) )}
| _1 = exp
    {                                                               ( [], _1 )}
| _1 = perhaps_semi
    {                                                               ( ([], (`TupleLit [], pos())) )}

perhaps_semi:
  _1 = SEMICOLON
    {                                                               ()}
| 
    {                                                               ()}

exp:
  _1 = database_expression
    {                                                               ( _1 )}

labeled_exps:
  _1 = record_label _2 = EQ _3 = exp
    {                                                               ( [_1, _3] )}
| _1 = record_label _2 = EQ _3 = exp _4 = COMMA _5 = labeled_exps
    {                                                               ( (_1, _3) :: _5 )}

just_datatype:
  _1 = datatype _2 = END
    {                                                               ( _1 )}

datatype:
  _1 = mu_datatype
    {                                                               ( _1 )}
| _1 = straight_arrow
    {                                                               ( _1 )}
| _1 = squiggly_arrow
    {                                                               ( _1 )}

arrow_prefix:
  _1 = LBRACE _2 = RBRACE
    {                                                               ( ([], `Closed) )}
| _1 = LBRACE _2 = efields _3 = RBRACE
    {                                                               ( _2 )}

straight_arrow_prefix:
  _1 = arrow_prefix
    {                                                               ( _1 )}
| _1 = MINUS _2 = nonrec_row_var
    {                                                               ( ([], _2) )}
| _1 = MINUS _2 = kinded_nonrec_row_var
    {                                                               ( ([], _2) )}

squig_arrow_prefix:
  _1 = hear_arrow_prefix
    {                                                               ( _1 )}
| _1 = arrow_prefix
    {                                                               ( _1 )}
| _1 = TILDE _2 = nonrec_row_var
    {                                                               ( ([], _2) )}
| _1 = TILDE _2 = kinded_nonrec_row_var
    {                                                               ( ([], _2) )}

hear_arrow_prefix:
  _1 = LBRACE _2 = COLON _3 = datatype _4 = COMMA _5 = efields _6 = RBRACE
    {                                                               ( row_with
                                                                   ("wild", `Present UnitType)
                                                                   (row_with
                                                                      ("hear", `Present _3)
                                                                      _5) )}
| _1 = LBRACE _2 = COLON _3 = datatype _4 = RBRACE
    {                                                               ( ([("wild", `Present UnitType);
                                                                   ("hear", `Present _3)],
                                                                  `Closed) )}
| _1 = LBRACE _2 = COLON _3 = datatype _4 = VBAR _5 = nonrec_row_var _6 = RBRACE
    {                                                               ( ([("wild", `Present UnitType);
                                                                   ("hear", `Present _3)],
                                                                  _5) )}
| _1 = LBRACE _2 = COLON _3 = datatype _4 = VBAR _5 = kinded_nonrec_row_var _6 = RBRACE
    {                                                               ( ([("wild", `Present UnitType);
                                                                   ("hear", `Present _3)],
                                                                  _5) )}

straight_arrow:
  _1 = parenthesized_datatypes _2 = straight_arrow_prefix _3 = RARROW _4 = datatype
    {                                                               ( FunctionType (_1, _2, _4) )}
| _1 = parenthesized_datatypes _2 = RARROW _3 = datatype
    {                                                               ( FunctionType (_1,
                                                                               ([], fresh_rigid_row_variable `Any),
                                                                               _3) )}

squiggly_arrow:
  _1 = parenthesized_datatypes _2 = squig_arrow_prefix _3 = SQUIGRARROW _4 = datatype
    {                                                               ( FunctionType (_1,
                                                                               row_with
                                                                                 ("wild", `Present UnitType)
                                                                                 _2,
                                                                               _4) )}
| _1 = parenthesized_datatypes _2 = SQUIGRARROW _3 = datatype
    {                                                               ( FunctionType (_1,
                                                                               ([("wild", `Present UnitType)],
                                                                                 fresh_rigid_row_variable `Any),
                                                                                _3) )}

mu_datatype:
  _1 = MU _2 = VARIABLE _3 = DOT _4 = mu_datatype
    {                                                               ( MuType (_2, _4) )}
| _1 = forall_datatype
    {                                                               ( _1 )}

forall_datatype:
  _1 = FORALL _2 = varlist _3 = DOT _4 = datatype
    {                                                               ( ForallType (List.map fst _2, _4) )}
| _1 = primary_datatype
    {                                                               ( _1 )}

parenthesized_datatypes:
  _1 = LPAREN _2 = RPAREN
    {                                                               ( [] )}
| _1 = LPAREN _2 = datatypes _3 = RPAREN
    {                                                               ( _2 )}

primary_datatype:
  _1 = parenthesized_datatypes
    {                                                               ( match _1 with
                                                                   | [] -> UnitType
                                                                   | [t] -> t
                                                                   | ts  -> TupleType ts )}
| _1 = LPAREN _2 = rfields _3 = RPAREN
    {                                                               ( RecordType _2 )}
| _1 = TABLEHANDLE _2 = LPAREN _3 = datatype _4 = COMMA _5 = datatype _6 = COMMA _7 = datatype _8 = RPAREN
    {                                                               ( TableType (_3, _5, _7) )}
| _1 = LBRACKETBAR _2 = vrow _3 = BARRBRACKET
    {                                                               ( VariantType _2 )}
| _1 = LBRACKET _2 = datatype _3 = RBRACKET
    {                                                               ( ListType _2 )}
| _1 = type_var
    {                                                               ( _1 )}
| _1 = kinded_type_var
    {                                                               ( _1 )}
| _1 = CONSTRUCTOR
    {                                                               ( match _1 with
                                                                   | "Bool"    -> PrimitiveType `Bool
                                                                   | "Int"     -> PrimitiveType `Int
                                                                   | "Char"    -> PrimitiveType `Char
                                                                   | "Float"   -> PrimitiveType `Float
                                                                   | "XmlItem" -> PrimitiveType `XmlItem
                                                                   | "String"  -> PrimitiveType `String
                                                                   | "Database"-> DBType
                                                                   | t         -> TypeApplication (t, [])
                                                               )}
| _1 = CONSTRUCTOR _2 = LPAREN _3 = type_arg_list _4 = RPAREN
    {                                                               ( TypeApplication (_1, _3) )}

type_var:
  _1 = VARIABLE
    {                                                               ( RigidTypeVar (_1, `Any) )}
| _1 = QUESTIONVAR
    {                                                               ( TypeVar (_1, `Any) )}
| _1 = UNDERSCORE
    {                                                               ( fresh_rigid_type_variable `Any )}
| _1 = QUESTION
    {                                                               ( fresh_type_variable `Any )}

kinded_type_var:
  _1 = type_var _2 = subkind
    {                                                               ( attach_subkind (pos()) (_1, _2) )}

type_arg_list:
  _1 = type_arg
    {                                                               ( [_1] )}
| _1 = type_arg _2 = COMMA _3 = type_arg_list
    {                                                               ( _1 :: _3 )}

type_arg:
  _1 = datatype
    {                                                               ( `Type _1 )}
| _1 = TYPE _2 = LPAREN _3 = datatype _4 = RPAREN
    {                                                               ( `Type _3 )}
| _1 = ROW _2 = LPAREN _3 = row _4 = RPAREN
    {                                                               ( `Row _3 )}
| _1 = PRESENCE _2 = LPAREN _3 = fieldspec _4 = RPAREN
    {                                                               ( `Presence _3 )}
| _1 = LBRACE _2 = row _3 = RBRACE
    {                                                               ( `Row _2 )}

vrow:
  _1 = vfields
    {                                                               ( _1 )}
| 
    {                                                               ( [], `Closed )}

datatypes:
  _1 = datatype
    {                                                               ( [_1] )}
| _1 = datatype _2 = COMMA _3 = datatypes
    {                                                               ( _1 :: _3 )}

row:
  _1 = fields
    {                                                               ( _1 )}
| 
    {                                                               ( [], `Closed )}

fields:
  _1 = field
    {                                                               ( [_1], `Closed )}
| _1 = field _2 = VBAR _3 = row_var
    {                                                               ( [_1], _3 )}
| _1 = field _2 = VBAR _3 = kinded_row_var
    {                                                               ( [_1], _3 )}
| _1 = VBAR _2 = row_var
    {                                                               ( [], _2 )}
| _1 = VBAR _2 = kinded_row_var
    {                                                               ( [], _2 )}
| _1 = field _2 = COMMA _3 = fields
    {                                                               ( _1 :: fst _3, snd _3 )}

field:
  _1 = field_label
    {                                                               ( _1, `Present UnitType )}
| _1 = field_label _2 = fieldspec
    {                                                               ( _1, _2 )}

field_label:
  _1 = CONSTRUCTOR
    {                                                               ( _1 )}
| _1 = VARIABLE
    {                                                               ( _1 )}
| _1 = STRING
    {                                                               ( _1 )}
| _1 = UINTEGER
    {                                                               ( Num.string_of_num _1 )}

rfields:
  _1 = rfield
    {                                                               ( [_1], `Closed )}
| _1 = rfield _2 = VBAR _3 = row_var
    {                                                               ( [_1], _3 )}
| _1 = rfield _2 = VBAR _3 = kinded_row_var
    {                                                               ( [_1], _3 )}
| _1 = VBAR _2 = row_var
    {                                                               ( [], _2 )}
| _1 = VBAR _2 = kinded_row_var
    {                                                               ( [], _2 )}
| _1 = rfield _2 = COMMA _3 = rfields
    {                                                               ( _1 :: fst _3, snd _3 )}

rfield:
  _1 = record_label
    {                                                               ( _1, `Present UnitType )}
| _1 = record_label _2 = fieldspec
    {                                                               ( _1, _2 )}

record_label:
  _1 = field_label
    {                                                               ( _1 )}

vfields:
  _1 = vfield
    {                                                               ( [_1], `Closed )}
| _1 = row_var
    {                                                               ( [], _1 )}
| _1 = kinded_row_var
    {                                                               ( [], _1 )}
| _1 = vfield _2 = VBAR _3 = vfields
    {                                                               ( _1 :: fst _3, snd _3 )}

vfield:
  _1 = CONSTRUCTOR
    {                                                               ( _1, `Present UnitType )}
| _1 = CONSTRUCTOR _2 = fieldspec
    {                                                               ( _1, _2 )}

efields:
  _1 = efield
    {                                                               ( [_1], `Closed )}
| _1 = efield _2 = VBAR _3 = nonrec_row_var
    {                                                               ( [_1], _3 )}
| _1 = efield _2 = VBAR _3 = kinded_nonrec_row_var
    {                                                               ( [_1], _3 )}
| _1 = VBAR _2 = nonrec_row_var
    {                                                               ( [], _2 )}
| _1 = VBAR _2 = kinded_nonrec_row_var
    {                                                               ( [], _2 )}
| _1 = efield _2 = COMMA _3 = efields
    {                                                               ( _1 :: fst _3, snd _3 )}

efield:
  _1 = effect_label
    {                                                               ( _1, `Present UnitType )}
| _1 = effect_label _2 = fieldspec
    {                                                               ( _1, _2 )}

effect_label:
  _1 = CONSTRUCTOR
    {                                                               ( _1 )}
| _1 = VARIABLE
    {                                                               ( _1 )}

fieldspec:
  _1 = COLON _2 = datatype
    {                                                               ( `Present _2 )}
| _1 = LBRACE _2 = COLON _3 = datatype _4 = RBRACE
    {                                                               ( `Present _3 )}
| _1 = MINUS
    {                                                               ( `Absent )}
| _1 = LBRACE _2 = MINUS _3 = RBRACE
    {                                                               ( `Absent )}
| _1 = LBRACE _2 = VARIABLE _3 = RBRACE
    {                                                               ( `RigidVar _2 )}
| _1 = LBRACE _2 = QUESTIONVAR _3 = RBRACE
    {                                                               ( `Var _2 )}
| _1 = LBRACE _2 = UNDERSCORE _3 = RBRACE
    {                                                               ( fresh_rigid_presence_variable () )}
| _1 = LBRACE _2 = QUESTION _3 = RBRACE
    {                                                               ( fresh_presence_variable () )}

nonrec_row_var:
  _1 = VARIABLE
    {                                                               ( `OpenRigid (_1, `Any) )}
| _1 = QUESTIONVAR
    {                                                               ( `Open (_1, `Any) )}
| _1 = UNDERSCORE
    {                                                               ( fresh_rigid_row_variable `Any )}
| _1 = QUESTION
    {                                                               ( fresh_row_variable `Any )}

row_var:
  _1 = nonrec_row_var
    {                                                               ( _1 )}
| _1 = LPAREN _2 = MU _3 = VARIABLE _4 = DOT _5 = vfields _6 = RPAREN
    {                                                               ( `Recursive (_3, _5) )}

kinded_nonrec_row_var:
  _1 = nonrec_row_var _2 = subkind
    {                                                               ( attach_row_subkind (pos()) (_1, _2) )}

kinded_row_var:
  _1 = row_var _2 = subkind
    {                                                               ( attach_row_subkind (pos()) (_1, _2) )}

regex:
  _1 = SLASH _2 = regex_pattern_alternate _3 = regex_flags_opt
    {                                                                                 ( (`Regex _2, pos()), _3 )}
| _1 = SLASH _2 = regex_flags_opt
    {                                                                                 ( (`Regex (`Simply ""), pos()), _2 )}
| _1 = SSLASH _2 = regex_pattern_alternate _3 = SLASH _4 = regex_replace _5 = regex_flags_opt
    {                                                                                 ( (`Regex (`Replace (_2, _4)), pos()), `RegexReplace :: _5 )}

regex_flags_opt:
  _1 = SLASH
    {                                                               ([])}
| _1 = SLASHFLAGS
    {                                                               (parseRegexFlags _1)}

regex_replace:
  
    {                                                               ( `Literal "")}
| _1 = REGEXREPL
    {                                                               ( `Literal _1)}
| _1 = block
    {                                                               ( `Splice (`Block _1, pos ()) )}

regex_pattern:
  _1 = RANGE
    {                                                               ( `Range _1 )}
| _1 = STRING
    {                                                               ( `Simply _1 )}
| _1 = QUOTEDMETA
    {                                                               ( `Quote (`Simply _1) )}
| _1 = DOT
    {                                                               ( `Any )}
| _1 = CARET
    {                                                               ( `StartAnchor )}
| _1 = DOLLAR
    {                                                               ( `EndAnchor )}
| _1 = LPAREN _2 = regex_pattern_alternate _3 = RPAREN
    {                                                               ( `Group _2 )}
| _1 = regex_pattern _2 = STAR
    {                                                               ( `Repeat (Regex.Star, _1) )}
| _1 = regex_pattern _2 = PLUS
    {                                                               ( `Repeat (Regex.Plus, _1) )}
| _1 = regex_pattern _2 = QUESTION
    {                                                               ( `Repeat (Regex.Question, _1) )}
| _1 = block
    {                                                               ( `Splice (`Block _1, pos ()) )}

regex_pattern_alternate:
  _1 = regex_pattern_sequence
    {                                                               ( `Seq _1 )}
| _1 = regex_pattern_sequence _2 = ALTERNATE _3 = regex_pattern_alternate
    {                                                               ( `Alternate (`Seq _1, _3) )}

regex_pattern_sequence:
  _1 = regex_pattern
    {                                                               ( [_1] )}
| _1 = regex_pattern _2 = regex_pattern_sequence
    {                                                               ( _1 :: _2 )}

pattern:
  _1 = typed_pattern
    {                                                            ( _1 )}
| _1 = typed_pattern _2 = COLON _3 = primary_datatype
    {                                                            ( (`HasType (_1, datatype _3), pos()) )}

typed_pattern:
  _1 = cons_pattern
    {                                                            ( _1 )}
| _1 = cons_pattern _2 = AS _3 = var
    {                                                            ( `As ((fst _3, None, snd _3), _1), pos() )}

cons_pattern:
  _1 = constructor_pattern
    {                                                            ( _1 )}
| _1 = constructor_pattern _2 = COLONCOLON _3 = cons_pattern
    {                                                            ( `Cons (_1, _3), pos() )}

constructor_pattern:
  _1 = negative_pattern
    {                                                            ( _1 )}
| _1 = CONSTRUCTOR
    {                                                            ( `Variant (_1, None), pos() )}
| _1 = CONSTRUCTOR _2 = parenthesized_pattern
    {                                                            ( `Variant (_1, Some _2), pos() )}

constructors:
  _1 = CONSTRUCTOR
    {                                                            ( [_1] )}
| _1 = CONSTRUCTOR _2 = COMMA _3 = constructors
    {                                                            ( _1 :: _3 )}

negative_pattern:
  _1 = primary_pattern
    {                                                            ( _1 )}
| _1 = MINUS _2 = CONSTRUCTOR
    {                                                            ( `Negative [_2], pos() )}
| _1 = MINUS _2 = LPAREN _3 = constructors _4 = RPAREN
    {                                                            ( `Negative _3, pos() )}

parenthesized_pattern:
  _1 = LPAREN _2 = RPAREN
    {                                                            ( `Tuple [], pos() )}
| _1 = LPAREN _2 = pattern _3 = RPAREN
    {                                                            ( _2 )}
| _1 = LPAREN _2 = pattern _3 = COMMA _4 = patterns _5 = RPAREN
    {                                                            ( `Tuple (_2 :: _4), pos() )}
| _1 = LPAREN _2 = labeled_patterns _3 = VBAR _4 = pattern _5 = RPAREN
    {                                                            ( `Record (_2, Some _4), pos() )}
| _1 = LPAREN _2 = labeled_patterns _3 = RPAREN
    {                                                            ( `Record (_2, None), pos() )}

primary_pattern:
  _1 = VARIABLE
    {                                                            ( `Variable (_1, None, pos()), pos() )}
| _1 = UNDERSCORE
    {                                                            ( `Any, pos() )}
| _1 = constant
    {                                                            ( let c, p = _1 in `Constant c, p )}
| _1 = LBRACKET _2 = RBRACKET
    {                                                            ( `Nil, pos() )}
| _1 = LBRACKET _2 = patterns _3 = RBRACKET
    {                                                            ( `List _2, pos() )}
| _1 = parenthesized_pattern
    {                                                            ( _1 )}

patterns:
  _1 = pattern
    {                                                            ( [_1] )}
| _1 = pattern _2 = COMMA _3 = patterns
    {                                                            ( _1 :: _3 )}

labeled_patterns:
  _1 = record_label _2 = EQ _3 = pattern
    {                                                            ( [(_1, _3)] )}
| _1 = record_label _2 = EQ _3 = pattern _4 = COMMA _5 = labeled_patterns
    {                                                            ( (_1, _3) :: _5 )}

multi_args:
  _1 = LPAREN _2 = patterns _3 = RPAREN
    {                                                            ( _2 )}
| _1 = LPAREN _2 = RPAREN
    {                                                            ( [] )}

arg_lists:
  _1 = multi_args
    {                                                            ( [_1] )}
| _1 = multi_args _2 = arg_lists
    {                                                            ( _1 :: _2 )}

%%


