Grammar has 34 nonterminal symbols, among which 2 start symbols.
Grammar has 78 terminal symbols.
Grammar has 140 productions.
nullable(vars) = true
nullable(tyapp) = false
nullable(ty0s) = true
nullable(ty0) = false
nullable(ty) = false
nullable(sig_decl) = false
nullable(qv) = false
nullable(quantifier) = false
nullable(qual_id) = false
nullable(qlist) = false
nullable(prog) = false
nullable(preterms_brack) = false
nullable(preterm_brack) = false
nullable(preterm0) = false
nullable(preterm) = false
nullable(parse_input_line) = false
nullable(parse) = false
nullable(kind) = false
nullable(infixr_preterm) = false
nullable(infixn_preterm) = false
nullable(infixl_preterm) = false
nullable(infix_decl) = false
nullable(goal_decl) = false
nullable(goal) = false
nullable(directive) = false
nullable(decls) = true
nullable(decl) = false
nullable(dcg_term) = false
nullable(dcg_rule) = false
nullable(constr) = false
nullable(const) = false
nullable(comma_tys) = false
nullable(app_or_qid) = false
nullable(app) = false
first(vars) = ID
first(tyapp) = QUAL_ID ID
first(ty0s) = UNDERSCORE QUAL_ID LPAREN LBRACK ID
first(ty0) = UNDERSCORE QUAL_ID LPAREN LBRACK ID
first(ty) = UNDERSCORE QUAL_ID LPAREN LBRACK ID
first(sig_decl) = TYPE PRED ID FUNC CNST
first(qv) = ID
first(quantifier) = NEW FORALL EXISTS
first(qual_id) = QUAL_ID ID
first(qlist) = ID
first(prog) = UNDERSCORE TRUE QUAL_ID NOT NEW LPAREN LITERAL LBRACK INT ID FORALL EXISTS CUT CHAR
first(preterms_brack) = UNDERSCORE TRUE QUAL_ID LPAREN LITERAL LBRACK INT ID CUT CHAR
first(preterm_brack) = UNDERSCORE TRUE QUAL_ID LPAREN LITERAL LBRACK INT ID CUT CHAR
first(preterm0) = UNDERSCORE TRUE QUAL_ID LPAREN LITERAL LBRACK INT ID CUT CHAR
first(preterm) = UNDERSCORE TRUE QUAL_ID NOT NEW LPAREN LITERAL LBRACK INT ID FORALL EXISTS CUT CHAR
first(parse_input_line) = USE UNDERSCORE TYPEQ TRUE TRACE QUIT QUAL_ID OPEN NOT NEW LPAREN LITERAL LBRACK INT INFIXR INFIXN INFIXL ID HELP FORALL EXISTS EOF CUT CHAR
first(parse) = USE UNDERSCORE TYPEQ TYPE TRUE TRACE QUIT QUESTION QUAL_ID PRED OPEN NOT NEW NAMESPACE LPAREN LITERAL LBRACK INT INFIXR INFIXN INFIXL ID HELP FUNC FORALL EXISTS EOF CUT CNST CHAR
first(kind) = TYPE NAME_TYPE
first(infixr_preterm) = UNDERSCORE TRUE QUAL_ID NOT NEW LPAREN LITERAL LBRACK INT ID FORALL EXISTS CUT CHAR
first(infixn_preterm) = UNDERSCORE TRUE QUAL_ID NOT NEW LPAREN LITERAL LBRACK INT ID FORALL EXISTS CUT CHAR
first(infixl_preterm) = UNDERSCORE TRUE QUAL_ID NOT NEW LPAREN LITERAL LBRACK INT ID FORALL EXISTS CUT CHAR
first(infix_decl) = INFIXR INFIXN INFIXL
first(goal_decl) = USE UNDERSCORE TYPEQ TRUE TRACE QUIT QUAL_ID OPEN NOT NEW LPAREN LITERAL LBRACK INT INFIXR INFIXN INFIXL ID HELP FORALL EXISTS CUT CHAR
first(goal) = UNDERSCORE TRUE QUAL_ID NOT NEW LPAREN LITERAL LBRACK INT ID FORALL EXISTS CUT CHAR
first(directive) = USE TYPEQ TRACE QUIT OPEN HELP
first(decls) = USE UNDERSCORE TYPEQ TYPE TRUE TRACE QUIT QUESTION QUAL_ID PRED OPEN NOT NEW NAMESPACE LPAREN LITERAL LBRACK INT INFIXR INFIXN INFIXL ID HELP FUNC FORALL EXISTS CUT CNST CHAR
first(decl) = USE UNDERSCORE TYPEQ TYPE TRUE TRACE QUIT QUESTION QUAL_ID PRED OPEN NOT NEW NAMESPACE LPAREN LITERAL LBRACK INT INFIXR INFIXN INFIXL ID HELP FUNC FORALL EXISTS CUT CNST CHAR
first(dcg_term) = QUAL_ID LITERAL LBRACE ID CHAR
first(dcg_rule) = QUAL_ID ID
first(constr) = ID
first(const) = UNDERSCORE TRUE LPAREN LITERAL LBRACK INT CUT CHAR
first(comma_tys) = UNDERSCORE QUAL_ID LPAREN LBRACK ID
first(app_or_qid) = QUAL_ID ID
first(app) = QUAL_ID ID
minimal(vars) = (* 0 *) 
minimal(tyapp) = (* 2 *) QUAL_ID UNDERSCORE
minimal(ty0s) = (* 0 *) 
minimal(ty0) = (* 1 *) UNDERSCORE
minimal(ty) = (* 1 *) UNDERSCORE
minimal(sig_decl) = (* 2 *) PRED ID
minimal(qv) = (* 1 *) ID
minimal(quantifier) = (* 1 *) FORALL
minimal(qual_id) = (* 1 *) QUAL_ID
minimal(qlist) = (* 1 *) ID
minimal(prog) = (* 1 *) QUAL_ID
minimal(preterms_brack) = (* 1 *) QUAL_ID
minimal(preterm_brack) = (* 1 *) QUAL_ID
minimal(preterm0) = (* 1 *) QUAL_ID
minimal(preterm) = (* 1 *) QUAL_ID
minimal(parse_input_line) = (* 1 *) EOF
minimal(parse) = (* 1 *) EOF
minimal(kind) = (* 1 *) TYPE
minimal(infixr_preterm) = (* 3 *) QUAL_ID INFIXR1 QUAL_ID
minimal(infixn_preterm) = (* 3 *) QUAL_ID INFIXN1 QUAL_ID
minimal(infixl_preterm) = (* 3 *) QUAL_ID INFIXL1 QUAL_ID
minimal(infix_decl) = (* 3 *) INFIXN ID INT
minimal(goal_decl) = (* 1 *) QUAL_ID
minimal(goal) = (* 1 *) QUAL_ID
minimal(directive) = (* 1 *) QUIT
minimal(decls) = (* 0 *) 
minimal(decl) = (* 1 *) QUAL_ID
minimal(dcg_term) = (* 1 *) QUAL_ID
minimal(dcg_rule) = (* 3 *) QUAL_ID DCG_ARROW QUAL_ID
minimal(constr) = (* 3 *) ID HASH ID
minimal(const) = (* 1 *) UNDERSCORE
minimal(comma_tys) = (* 1 *) UNDERSCORE
minimal(app_or_qid) = (* 1 *) QUAL_ID
minimal(app) = (* 2 *) QUAL_ID QUAL_ID
follow(vars) = ID EQ
follow(tyapp) = UNDERSCORE RPAREN RBRACK QUAL_ID LPAREN LBRACK ID DOT COMMA BACKSLASH ARROW
follow(ty0s) = UNDERSCORE QUAL_ID LPAREN LBRACK ID EQ DOT
follow(ty0) = UNDERSCORE RPAREN RBRACK QUAL_ID LPAREN LBRACK ID EQ DOT COMMA BACKSLASH ARROW
follow(ty) = RPAREN RBRACK DOT COMMA BACKSLASH ARROW
follow(sig_decl) = DOT
follow(qv) = DOT COMMA
follow(quantifier) = ID
follow(qual_id) = UNDERSCORE TRUE SLASH SEMI RPAREN RBRACK RBRACE QUAL_ID LPAREN LITERAL LBRACK LARROW IS INT INFIXR9 INFIXR8 INFIXR7 INFIXR6 INFIXR5 INFIXR4 INFIXR3 INFIXR2 INFIXR1 INFIXN9 INFIXN8 INFIXN7 INFIXN6 INFIXN5 INFIXN4 INFIXN3 INFIXN2 INFIXN1 INFIXL9 INFIXL8 INFIXL7 INFIXL6 INFIXL5 INFIXL4 INFIXL3 INFIXL2 INFIXL1 ID HASH EQ DOT DCG_ARROW DARROW CUT CONS COMMA CHAR BAR BACKSLASH ARROW
follow(qlist) = DOT COMMA
follow(prog) = DOT
follow(preterms_brack) = RBRACK COMMA BAR
follow(preterm_brack) = RBRACK CONS COMMA BAR
follow(preterm0) = UNDERSCORE TRUE SLASH SEMI RPAREN RBRACK RBRACE QUAL_ID LPAREN LITERAL LBRACK LARROW IS INT INFIXR9 INFIXR8 INFIXR7 INFIXR6 INFIXR5 INFIXR4 INFIXR3 INFIXR2 INFIXR1 INFIXN9 INFIXN8 INFIXN7 INFIXN6 INFIXN5 INFIXN4 INFIXN3 INFIXN2 INFIXN1 INFIXL9 INFIXL8 INFIXL7 INFIXL6 INFIXL5 INFIXL4 INFIXL3 INFIXL2 INFIXL1 ID HASH EQ DOT DCG_ARROW DARROW CUT CONS COMMA CHAR BAR ARROW
follow(preterm) = SLASH SEMI RPAREN RBRACE LARROW IS INFIXR9 INFIXR8 INFIXR7 INFIXR6 INFIXR5 INFIXR4 INFIXR3 INFIXR2 INFIXR1 INFIXN9 INFIXN8 INFIXN7 INFIXN6 INFIXN5 INFIXN4 INFIXN3 INFIXN2 INFIXN1 INFIXL9 INFIXL8 INFIXL7 INFIXL6 INFIXL5 INFIXL4 INFIXL3 INFIXL2 INFIXL1 HASH EQ DOT DARROW CONS COMMA BAR ARROW
follow(parse_input_line) = #
follow(parse) = #
follow(kind) = DOT ARROW
follow(infixr_preterm) = SLASH SEMI RPAREN RBRACE LARROW IS INFIXR9 INFIXR8 INFIXR7 INFIXR6 INFIXR5 INFIXR4 INFIXR3 INFIXR2 INFIXR1 INFIXN9 INFIXN8 INFIXN7 INFIXN6 INFIXN5 INFIXN4 INFIXN3 INFIXN2 INFIXN1 INFIXL9 INFIXL8 INFIXL7 INFIXL6 INFIXL5 INFIXL4 INFIXL3 INFIXL2 INFIXL1 HASH EQ DOT DARROW CONS COMMA BAR ARROW
follow(infixn_preterm) = SLASH SEMI RPAREN RBRACE LARROW IS INFIXR9 INFIXR8 INFIXR7 INFIXR6 INFIXR5 INFIXR4 INFIXR3 INFIXR2 INFIXR1 INFIXN9 INFIXN8 INFIXN7 INFIXN6 INFIXN5 INFIXN4 INFIXN3 INFIXN2 INFIXN1 INFIXL9 INFIXL8 INFIXL7 INFIXL6 INFIXL5 INFIXL4 INFIXL3 INFIXL2 INFIXL1 HASH EQ DOT DARROW CONS COMMA BAR ARROW
follow(infixl_preterm) = SLASH SEMI RPAREN RBRACE LARROW IS INFIXR9 INFIXR8 INFIXR7 INFIXR6 INFIXR5 INFIXR4 INFIXR3 INFIXR2 INFIXR1 INFIXN9 INFIXN8 INFIXN7 INFIXN6 INFIXN5 INFIXN4 INFIXN3 INFIXN2 INFIXN1 INFIXL9 INFIXL8 INFIXL7 INFIXL6 INFIXL5 INFIXL4 INFIXL3 INFIXL2 INFIXL1 HASH EQ DOT DARROW CONS COMMA BAR ARROW
follow(infix_decl) = DOT
follow(goal_decl) = DOT
follow(goal) = DOT
follow(directive) = DOT
follow(decls) = USE UNDERSCORE TYPEQ TYPE TRUE TRACE RPAREN QUIT QUESTION QUAL_ID PRED OPEN NOT NEW NAMESPACE LPAREN LITERAL LBRACK INT INFIXR INFIXN INFIXL ID HELP FUNC FORALL EXISTS EOF CUT CNST CHAR
follow(decl) = DOT
follow(dcg_term) = SLASH SEMI DOT COMMA
follow(dcg_rule) = DOT
follow(constr) = SLASH SEMI RPAREN RBRACE LARROW IS INFIXR9 INFIXR8 INFIXR7 INFIXR6 INFIXR5 INFIXR4 INFIXR3 INFIXR2 INFIXR1 INFIXN9 INFIXN8 INFIXN7 INFIXN6 INFIXN5 INFIXN4 INFIXN3 INFIXN2 INFIXN1 INFIXL9 INFIXL8 INFIXL7 INFIXL6 INFIXL5 INFIXL4 INFIXL3 INFIXL2 INFIXL1 HASH EQ DOT DARROW CONS COMMA BAR ARROW
follow(const) = UNDERSCORE TRUE SLASH SEMI RPAREN RBRACK RBRACE QUAL_ID LPAREN LITERAL LBRACK LARROW IS INT INFIXR9 INFIXR8 INFIXR7 INFIXR6 INFIXR5 INFIXR4 INFIXR3 INFIXR2 INFIXR1 INFIXN9 INFIXN8 INFIXN7 INFIXN6 INFIXN5 INFIXN4 INFIXN3 INFIXN2 INFIXN1 INFIXL9 INFIXL8 INFIXL7 INFIXL6 INFIXL5 INFIXL4 INFIXL3 INFIXL2 INFIXL1 ID HASH EQ DOT DCG_ARROW DARROW CUT CONS COMMA CHAR BAR ARROW
follow(comma_tys) = RPAREN
follow(app_or_qid) = SLASH SEMI DOT DCG_ARROW COMMA
follow(app) = UNDERSCORE TRUE SLASH SEMI RPAREN RBRACK RBRACE QUAL_ID LPAREN LITERAL LBRACK LARROW IS INT INFIXR9 INFIXR8 INFIXR7 INFIXR6 INFIXR5 INFIXR4 INFIXR3 INFIXR2 INFIXR1 INFIXN9 INFIXN8 INFIXN7 INFIXN6 INFIXN5 INFIXN4 INFIXN3 INFIXN2 INFIXN1 INFIXL9 INFIXL8 INFIXL7 INFIXL6 INFIXL5 INFIXL4 INFIXL3 INFIXL2 INFIXL1 ID HASH EQ DOT DCG_ARROW DARROW CUT CONS COMMA CHAR BAR ARROW
Built an LR(0) automaton with 259 states.
The grammar is not SLR(1) -- 54 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 259 states.
1418 shift/reduce conflicts were silently solved.
79 out of 259 states have a default reduction.
87 out of 259 states are represented.
0 out of 116 symbols keep track of their start position.
0 out of 116 symbols keep track of their end position.
66 out of 142 productions exploit shiftreduce optimization.
0 out of 259 states can peek at an error.
701 functions before inlining, 133 functions after inlining.
