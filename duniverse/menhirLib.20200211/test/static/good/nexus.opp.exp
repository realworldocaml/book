%{

let mesquite_error =
    ("This@ seems@ to@ be@ a@ Mesquite@ \"NEXUS\"@ file.@ Unfortunately@ " ^
     "Mesquite@ has@ invented@ a@ new@ command@ TITLE@ that@ is@ not@ a@ " ^
     "valid@ NEXUS@ command.@ You@ will@ have@ to@ remove@ it@ by@ hand.@ " ^
     "You@ can@ read@ their@ information@ about@ it@ here:@ http://mesquiteproject.org/mesquite_folder/docs/mesquite/otherPrograms.html")

let parse_error s =
    try let b = (Parsing.symbol_start_pos ())
        and e = (Parsing.symbol_end_pos ()) in
        let b = string_of_int (b.Lexing.pos_cnum)
        and e = string_of_int (e.Lexing.pos_cnum) in
        !P.print_error (s ^ "@ between@ characters@ " ^ b ^ "@ and@ " ^ e)
    with | _ ->
        !P.print_error s

let report_error text b e =
    let b = string_of_int (b.Lexing.pos_cnum)
    and e = string_of_int (e.Lexing.pos_cnum) in
    !P.print_error ("There@ was@ a@ parsing@ error@ between@ characters@ " ^ b ^ "@ and@ " ^ e ^ " in the " ^ text)

%}
%start block
%start header
%start symbol_list
%start symbol_pair
%start tree
%start trees
%token <string> ALPHA
%token <string> ANCSTATES
%token <string> ANNOTATIONS
%token <string> APPROXIMATE
%token <string> ASSUMPTIONS
%token <string> AVERAGE
%token BACKSLASH
%token <string> BEGIN
%token <string> BINHEX
%token <string> BOTH
%token <string> BREAKINVERSION
%token <string> BREAKPOINT
%token <string> CHANGESET
%token <char> CHAR
%token <string> CHARACTER
%token <string> CHARACTERBRANCH
%token <string> CHARACTERS
%token <string> CHARLABELS
%token <string> CHARPARTITION
%token <string> CHARSET
%token <string> CHARSTATELABELS
%token <string> CHROMOSOME
%token <string> CIRCULAR
%token <string> CODEORDER
%token <string> CODESET
%token <string> CODONS
%token COLON
%token COMMA
%token <string> CONDONPOSSET
%token <string> CONTINUOUS
%token <string> COST
%token <string> COUNT
%token <string> COUPLED
%token <string> COVERAGE
%token <string> CSTREE
%token DASH
%token <string> DATA
%token <string> DATACSTREE
%token <string> DATATYPE
%token <string> DEFAULT
%token <string> DEFTYPE
%token <string> DIAGONAL
%token <string> DIMENSIONS
%token <string> DISTANCE
%token <string> DISTANCES
%token <string> DNA
%token <string> DROS
%token <string> EIDENT
%token <string> ELIMINATE
%token <string> ENCODE
%token <string> ENDNEXUS
%token EOF
%token <string> EPS
%token EQUAL
%token <string> EQUATE
%token <string> EXSET
%token <string> EXT
%token <string> EXTENSIONS
%token <string> FILE
%token <string> FLOAT
%token <string> FORMAT
%token <string> FREQUENCY
%token <string> GAP
%token <string> GAPOPENING
%token <string> GENETICCODE
%token <string> GENOME
%token <string> GIF
%token <string> IDENT
%token <string> INDEL
%token <string> INDIVIDUALS
%token <string> INLINE
%token <string> INTEGER
%token <string> INTERLEAVE
%token <string> INVERSION
%token <string> ITEMS
%token <string> JPEG
%token <string> LABELS
%token LBRACKET
%token <string> LEVEL
%token <string> LIKELIHOOD
%token <string> LINK
%token <string> LOWER
%token LPARENT
%token <string> MAM
%token <string> MAP
%token <string> MATCHCHAR
%token <string> MAUVE
%token <string> MAX
%token <string> MAXSTEPS
%token <string> MEDIAN
%token <string> MIN
%token <string> MINSTEPS
%token <string> MISSING
%token <string> MODEL
%token <string> MTDNA
%token <string> NCHAR
%token <string> NEWSTATE
%token <string> NEWTAXA
%token NEXUS
%token <string> NOLABELS
%token <string> NONE
%token <string> NOTES
%token <string> NOTOKENS
%token <string> NTAX
%token <string> NUCLEOTIDE
%token <string> NUCORDER
%token <string> OPTIONS
%token <string> PARAMETERS
%token <string> PERCENT
%token <string> PICT
%token <string> PICTURE
%token <string> POLYTCOUNT
%token <string> POY
%token <string> PRIORS
%token <string> PROTEIN
%token <string> QUALITY
%token QUOTE
%token <string> QUOTED
%token RBRACKET
%token <string> REARRANGEMENT
%token <string> RESOURCE
%token <string> RESPECTCASE
%token <string> RNA
%token RPARENT
%token <string> SAMPLESIZE
%token SEMICOLON
%token <string> SETS
%token <string> SINGLEQUOTED
%token <string> SITES
%token SLASH
%token <string> SOLVER
%token <string> SOURCE
%token <string> STANDARD
%token STAR
%token <string> STATE
%token <string> STATELABELS
%token <string> STATES
%token <string> STATESET
%token <string> STATESFORMAT
%token <string> STATESPRESENT
%token <string> STDERROR
%token <string> STEPMATRIX
%token <string> SYMBOLS
%token <string> SYMMETRIC
%token <string> TAXA
%token <string> TAXLABELS
%token <string> TAXON
%token <string> TAXPARTITION
%token <string> TAXSET
%token <string> TCM
%token <string> TEXT
%token <string> TIFF
%token <string> TITLE
%token <string> TOKENS
%token <string> TRANSLATE
%token <string> TRANSPOSE
%token <string> TREE
%token <string> TREEPARTITION
%token <string> TREES
%token <string> TREESET
%token <string> TRIANGLE
%token <string> TYPESET
%token <string> UNALIGNED
%token <string> UNIVERSAL
%token <string> UPPER
%token <string> USERTYPE
%token <string> UTREE
%token <string> UUENCODE
%token <string> VARIANCE
%token <string> VARIATION
%token <string> VECTOR
%token <string> WTSET
%token <string> YEAST
%type <P.block> block
%type <unit> header
%type <string list> symbol_list
%type <(string * string list)> symbol_pair
%type <P.tree> tree
%type <P.tree list> trees
%%

header:
  _1 = NEXUS
    {            ( () )}

block:
  _1 = BEGIN _2 = TAXA _3 = SEMICOLON _4 = mesquite_broken _5 = taxa _6 = ENDNEXUS _7 = SEMICOLON
    {        ( P.Taxa _5 )}
| _1 = BEGIN _2 = CHARACTERS _3 = SEMICOLON _4 = mesquite_broken _5 = characters _6 = ENDNEXUS _7 = SEMICOLON
    {        ( P.Characters _5 )}
| _1 = BEGIN _2 = DATA _3 = SEMICOLON _4 = mesquite_broken _5 = characters _6 = ENDNEXUS _7 = SEMICOLON
    {        ( P.Characters _5 )}
| _1 = BEGIN _2 = UNALIGNED _3 = SEMICOLON _4 = mesquite_broken _5 = unaligned _6 = ENDNEXUS _7 = SEMICOLON
    {        ( P.Unaligned _5 )}
| _1 = BEGIN _2 = TREES _3 = SEMICOLON _4 = mesquite_broken _5 = optional_translate _6 = tree_list _7 = ENDNEXUS _8 = SEMICOLON
    {        ( P.Trees (_5,_6) )}
| _1 = BEGIN _2 = NOTES _3 = SEMICOLON _4 = mesquite_broken _5 = notes _6 = ENDNEXUS _7 = SEMICOLON
    {        ( P.Notes _5 )}
| _1 = BEGIN _2 = DISTANCES _3 = SEMICOLON _4 = mesquite_broken _5 = distances _6 = ENDNEXUS _7 = SEMICOLON
    {        ( P.Distances _5 )}
| _1 = BEGIN _2 = ASSUMPTIONS _3 = SEMICOLON _4 = mesquite_broken _5 = assumptions _6 = ENDNEXUS _7 = SEMICOLON
    {        ( P.Assumptions _5 )}
| _1 = BEGIN _2 = SETS _3 = SEMICOLON _4 = mesquite_broken _5 = sets_block _6 = ENDNEXUS _7 = SEMICOLON
    {        ( P.Sets _5 )}
| _1 = BEGIN _2 = POY _3 = SEMICOLON _4 = poy_block _5 = ENDNEXUS _6 = SEMICOLON
    {        ( P.Poy _4 )}
| _1 = BEGIN _2 = NOTES _3 = SEMICOLON _4 = error _5 = ENDNEXUS _6 = SEMICOLON
    {        ( P.Error _2 )}
| _1 = BEGIN _2 = DISTANCES _3 = SEMICOLON _4 = error _5 = ENDNEXUS _6 = SEMICOLON
    {        ( P.Error _2 )}
| _1 = BEGIN _2 = IDENT _3 = error _4 = ENDNEXUS _5 = SEMICOLON
    {        ( P.Error _2 )}
| _1 = header
    {        ( P.Error "File Contains Multiple Nexus Files; will try to append" )}

mesquite_broken:
  _1 = mesquite_broken_items _2 = mesquite_broken
    {                                            ( _1 :: _2  )}
| 
    {                                            ( []        )}

mesquite_broken_items:
  _1 = TITLE _2 = any_thing_minus_end _3 = SEMICOLON
    {                                          ( () )}
| _1 = LINK _2 = any_thing_minus_end _3 = EQUAL _4 = any_thing_minus_end _5 = SEMICOLON
    {                                                                    ( () )}

assumptions:
  _1 = assumption_items _2 = assumptions
    {                                   ( _1 :: _2 )}
| 
    {      ( [] )}

assumption_items:
  _1 = optional_assumption_options
    {                                    ( P.Options _1 )}
| _1 = optional_user_type
    {                                    ( P.UserType _1 )}
| _1 = optional_type_set
    {                                    ( P.TypeDef _1 )}
| _1 = optional_wtset
    {                                    ( P.WeightDef _1 )}
| _1 = optional_exset
    {                                    ( P.ExcludeSet _1 )}
| _1 = optional_ancstates
    {                                    ( P.AncestralDef _1 )}
| _1 = error
    {        ( report_error "Assumption Block" (Parsing.symbol_start_pos ()) (Parsing.symbol_end_pos ());
          raise Parsing.Parse_error )}

set_in_block:
  _1 = CHARSET _2 = nexus_word _3 = optional_lparent _4 = optional_standard_or_vector _5 = optional_rparent _6 = EQUAL _7 = characterset_list
    {        ( _2, P.CharacterSet _7     )}
| _1 = STATESET _2 = nexus_word _3 = optional_lparent _4 = optional_standard_or_vector _5 = optional_rparent _6 = EQUAL _7 = characterset_list
    {        ( _2, P.StateSet _7         )}
| _1 = TAXSET _2 = nexus_word _3 = optional_lparent _4 = optional_standard_or_vector _5 = optional_rparent _6 = EQUAL _7 = characterset_list
    {        ( _2, P.TaxonSet _7         )}
| _1 = TREESET _2 = nexus_word _3 = optional_lparent _4 = optional_standard_or_vector _5 = optional_rparent _6 = EQUAL _7 = characterset_list
    {        ( _2, P.TreeSet _7          )}
| _1 = CHARPARTITION _2 = nexus_word _3 = partition_contents
    {        ( _2, P.CharPartition _3    )}
| _1 = TAXPARTITION _2 = nexus_word _3 = partition_contents
    {        ( _2, P.TaxPartition _3     )}
| _1 = TREEPARTITION _2 = nexus_word _3 = partition_contents
    {        ( _2, P.TreePartition _3    )}

optional_lparent:
  _1 = LPARENT
    {               ( () )}
| 
    {      ( () )}

optional_rparent:
  _1 = RPARENT
    {              ( () )}
| 
    {      ( () )}

partition_contents:
  _1 = do_token _2 = EQUAL _3 = standard_type_set
    {                                                ( P.Standard _3 )}
| _1 = do_token _2 = STANDARD _3 = EQUAL _4 = standard_type_set
    {                                                ( P.Standard _4 )}
| _1 = do_token _2 = VECTOR _3 = EQUAL _4 = vector_type_set
    {                                                ( P.Vector _4   )}

sets_block:
  _1 = set_in_block _2 = SEMICOLON _3 = sets_block
    {                                        ( _1 :: _3 )}
| 
    {                                        (       [] )}

optional_standard_or_vector:
  _1 = STANDARD
    {               ( Some _1 )}
| _1 = VECTOR
    {               ( Some _1 )}
| 
    {      ( None )}

optional_assumption_options:
  _1 = OPTIONS _2 = deftype _3 = polytcount _4 = gapmode _5 = SEMICOLON
    {                                                   ( (_2, _3, _4) )}

deftype:
  _1 = DEFTYPE _2 = EQUAL _3 = IDENT
    {                          ( Some _3 )}
| 
    {      ( None )}

polytcount:
  _1 = POLYTCOUNT _2 = EQUAL _3 = MINSTEPS
    {                                ( P.MinSteps )}
| _1 = POLYTCOUNT _2 = EQUAL _3 = MAXSTEPS
    {                                ( P.MaxSteps )}
| 
    {      ( P.MinSteps )}

gapmode:
  _1 = GAP _2 = EQUAL _3 = MISSING
    {                        ( P.Missing )}
| _1 = GAP _2 = EQUAL _3 = NEWSTATE
    {                         ( P.NewState )}
| 
    {      ( P.NewState )}

optional_user_type:
  _1 = USERTYPE _2 = IDENT _3 = user_type_definition _4 = SEMICOLON
    {                                                    ( (_2, _3) )}

user_type_definition:
  _1 = EQUAL _2 = INTEGER _3 = numbers_and_chars
    {                                      ( P.StepMatrix (_2, _3) )}
| _1 = STEPMATRIX _2 = EQUAL _3 = INTEGER _4 = numbers_and_chars
    {        ( P.StepMatrix (_3, _4) )}
| _1 = LPARENT _2 = STEPMATRIX _3 = RPARENT _4 = EQUAL _5 = INTEGER _6 = numbers_and_chars
    {        ( P.StepMatrix (_5, _6) )}
| _1 = CSTREE _2 = DATACSTREE
    {                        ( P.CSTree _2 )}

numbers_and_chars:
  _1 = number_and_char _2 = numbers_and_chars
    {                                        ( _1 :: _2 )}
| _1 = number_and_char
    {                      ( [_1] )}

number_and_char:
  _1 = INTEGER
    {                ( _1 )}
| _1 = FLOAT
    {                ( _1 )}
| _1 = CHAR
    {                ( Char.escaped _1 )}
| _1 = COLON
    {                ( ":" )}
| _1 = EQUAL
    {                ( "=" )}
| _1 = COMMA
    {                ( "," )}
| _1 = BACKSLASH
    {                ( "/" )}
| _1 = DASH
    {                ( "-" )}
| _1 = STAR
    {                ( "*" )}
| _1 = IDENT
    {                ( _1 )}

optional_type_set:
  _1 = TYPESET _2 = optional_set_for_assumptions
    {                                           ( _2 )}

optional_wtset:
  _1 = WTSET _2 = optional_set_for_assumptions
    {                                         ( _2 )}

do_token:
  _1 = NOTOKENS
    {                ( false )}
| _1 = TOKENS
    {                ( true  )}
| 
    {                ( false )}

do_star:
  _1 = STAR
    {           ( true )}
| 
    {           ( false )}

optional_set_for_assumptions:
  _1 = do_star _2 = IDENT _3 = do_token _4 = EQUAL _5 = standard_type_set _6 = SEMICOLON
    {        ( (_1, _2, _3, P.Standard _5) )}
| _1 = do_star _2 = IDENT _3 = STANDARD _4 = do_token _5 = EQUAL _6 = standard_type_set _7 = SEMICOLON
    {        ( (_1, _2, _4, P.Standard _6) )}
| _1 = do_star _2 = IDENT _3 = VECTOR _4 = do_token _5 = EQUAL _6 = vector_type_set _7 = SEMICOLON
    {        ( (_1, _2, _4,P.Vector _6) )}

standard_type_set_item:
  _1 = INTEGER _2 = COLON _3 = characterset_list
    {                                      ( P.Code (_1, _3) )}
| _1 = FLOAT _2 = COLON _3 = characterset_list
    {                                      ( P.Code (_1, _3) )}
| _1 = IDENT _2 = COLON _3 = characterset_list
    {                                      ( P.IName (_1, _3) )}
| _1 = SINGLEQUOTED _2 = COLON _3 = characterset_list
    {                                           ( P.IName(_1, _3) )}
| _1 = QUOTED _2 = COLON _3 = characterset_list
    {                                     ( P.IName(_1, _3) )}

standard_type_set:
  _1 = standard_type_set_item _2 = COMMA _3 = standard_type_set
    {                                                     ( (_1 :: _3) )}
| _1 = standard_type_set_item
    {                             ( [_1] )}
| 
    {                             ( []   )}

vector_type_set:
  _1 = INTEGER _2 = vector_type_set
    {                              ( (_1 :: _2)  )}
| 
    {                              ( []          )}

optional_exset:
  _1 = EXSET _2 = do_star _3 = nexus_word _4 = EQUAL _5 = characterset_list _6 = SEMICOLON
    {        ( (_2, _3, P.STDStandard _5) )}
| _1 = EXSET _2 = do_star _3 = nexus_word _4 = STANDARD _5 = EQUAL _6 = characterset_list _7 = SEMICOLON
    {        ( (_2, _3, P.STDStandard _6) )}
| _1 = EXSET _2 = do_star _3 = nexus_word _4 = VECTOR _5 = EQUAL _6 = vector_type_set _7 = SEMICOLON
    {        ( (_2, _3, P.STDVector _6)   )}

optional_ancstates:
  _1 = ANCSTATES _2 = optional_set_for_assumptions
    {                                             ( _2 )}

distances:
  _1 = optional_distances_dimensions _2 = optional_format _3 = optional_taxlabels _4 = DATA _5 = SEMICOLON
    {        ( (_1, _2, _3, _4) )}

optional_distances_dimensions:
  _1 = DIMENSIONS _2 = NEWTAXA _3 = NTAX _4 = EQUAL _5 = INTEGER _6 = NCHAR _7 = EQUAL _8 = INTEGER _9 = SEMICOLON
    {        ( Some (true, _5, _8) )}
| _1 = DIMENSIONS _2 = NTAX _3 = EQUAL _4 = INTEGER _5 = NCHAR _6 = EQUAL _7 = INTEGER _8 = SEMICOLON
    {        ( Some (false, _4, _7) )}
| 
    {      ( None )}

notes:
  _1 = optional_text _2 = optional_picture
    {        ( _1, _2 )}

optional_text:
  _1 = TEXT _2 = optional_set_pair_list _3 = SOURCE _4 = EQUAL _5 = source _6 = DATA _7 = SEMICOLON
    {        ( Some (_2, _5, _6) )}
| 
    {      ( None )}

optional_picture:
  _1 = PICTURE _2 = optional_set_pair_list _3 = optional_pictureformat _4 = optional_encode _5 = SOURCE _6 = EQUAL _7 = source _8 = DATA _9 = SEMICOLON
    {        ( Some (_2, _3, _4, _7, _8) )}
| 
    {        ( None )}

optional_set_pair_list:
  _1 = set_pair _2 = optional_set_pair_list
    {                                      ( _1 :: _2 )}
| 
    {      ( [] )}

set_pair:
  _1 = TAXON _2 = EQUAL _3 = characterset_list
    {                                        ( P.TaxonSet _3     )}
| _1 = CHARACTER _2 = EQUAL _3 = characterset_list
    {                                        ( P.CharacterSet _3 )}
| _1 = STATE _2 = EQUAL _3 = characterset_list
    {                                        ( P.StateSet _3     )}
| _1 = TREE _2 = EQUAL _3 = characterset_list
    {                                        ( P.TreeSet _3      )}

source:
  _1 = INLINE
    {                (P.Inline )}
| _1 = FILE
    {                ( P.File )}
| _1 = RESOURCE
    {                ( P.Resource )}

optional_pictureformat:
  _1 = FORMAT _2 = EQUAL _3 = pictureformat
    {                                 ( Some _3 )}
| 
    {      ( None )}

pictureformat:
  _1 = PICT
    {                ( P.Pict )}
| _1 = TIFF
    {                ( P.Tiff )}
| _1 = EPS
    {                ( P.Eps )}
| _1 = JPEG
    {                ( P.Jpeg )}
| _1 = GIF
    {                ( P.Gif )}

optional_encode:
  _1 = ENCODE _2 = EQUAL _3 = pictureencoding
    {                                   ( Some _3 )}
| 
    {      ( None )}

pictureencoding:
  _1 = NONE
    {            ( P.None )}
| _1 = UUENCODE
    {               ( P.UUEncode )}
| _1 = BINHEX
    {                ( P.BinHex )}

optional_translate:
  _1 = TRANSLATE _2 = names _3 = SEMICOLON
    {        ( snd (List.fold_left (fun (i,acc) x -> (i+1),(string_of_int i,x)::acc) (1,[]) _2) )}
| _1 = TRANSLATE _2 = pairs_list _3 = SEMICOLON
    {                                     ( _2 )}
| 
    {      ( [] )}

tree_list:
  _1 = optional_tree_prequel _2 = DATA _3 = SEMICOLON _4 = tree_list
    {                                                     ( _2 :: _4 )}
| 
    {      ( [] )}

optional_tree_prequel:
  _1 = TREE _2 = do_star _3 = optional_label _4 = EQUAL
    {                                        (_3)}
| _1 = UTREE _2 = do_star _3 = optional_label _4 = EQUAL
    {                                         (_3)}
| 
    {      ( None )}

poy_block:
  _1 = CHARACTERBRANCH _2 = charbranch_block _3 = poy_block
    {        ( (P.CharacterBranch _2) :: _3)}
| _1 = LIKELIHOOD _2 = model_block _3 = poy_block
    {        ( P.Likelihood _2 :: _3 )}
| _1 = GAPOPENING _2 = do_star _3 = nexus_word _4 = EQUAL _5 = standard_type_set _6 = SEMICOLON _7 = poy_block
    {        ( (P.GapOpening (_2, _3, _5)) :: _7 )}
| _1 = WTSET _2 = do_star _3 = nexus_word _4 = EQUAL _5 = standard_type_set _6 = SEMICOLON _7 = poy_block
    {        ( (P.DynamicWeight (_2, _3, _5)) :: _7 )}
| _1 = TCM _2 = do_star _3 = nexus_word _4 = EQUAL _5 = standard_type_set _6 = SEMICOLON _7 = poy_block
    {        ( (P.Tcm (_2, _3, _5)) :: _7 )}
| _1 = LEVEL _2 = do_star _3 = nexus_word _4 = EQUAL _5 = standard_type_set _6 = SEMICOLON _7 = poy_block
    {        ( (P.Level(_2,_3,_5)) :: _7 )}
| _1 = CHROMOSOME _2 = chrome_options _3 = COLON _4 = characterset_list _5 = SEMICOLON _6 = poy_block
    {        ( (P.Chrom (_2,_4)) :: _6 )}
| _1 = GENOME _2 = genome_options _3 = COLON _4 = characterset_list _5 = SEMICOLON _6 = poy_block
    {        ( (P.Genome (_2,_4)) :: _6 )}
| _1 = BREAKINVERSION _2 = breakinv_options _3 = COLON _4 = characterset_list _5 = SEMICOLON _6 = poy_block
    {        ( (P.BreakInv (_2,_4)) :: _6 )}
| 
    {        ( [] )}

breakinv_options:
  _1 = MEDIAN _2 = EQUAL _3 = INTEGER _4 = SEMICOLON _5 = breakinv_options
    {            ( (P.Chrom_Median (int_of_string _3)) :: _5 )}
| _1 = BREAKPOINT _2 = EQUAL _3 = INTEGER _4 = SEMICOLON _5 = chrome_options
    {            ( (P.Chrom_Locus_Breakpoint (int_of_string _3)) :: _5 )}
| _1 = INVERSION _2 = EQUAL _3 = INTEGER _4 = SEMICOLON _5 = chrome_options
    {            ( (P.Chrom_Locus_Inversion (int_of_string _3)) :: _5 )}
| 
    {            ( [] )}

annotation_options:
  _1 = QUALITY _2 = EQUAL _3 = FLOAT _4 = SEMICOLON _5 = annotation_options
    {            ( (P.Annot_Quality (float_of_string _3)) :: _5 )}
| _1 = MIN _2 = EQUAL _3 = INTEGER _4 = SEMICOLON _5 = annotation_options
    {            ( (P.Annot_Min_Percent (float_of_string _3)) :: _5 )}
| _1 = MAX _2 = EQUAL _3 = INTEGER _4 = SEMICOLON _5 = annotation_options
    {            ( (P.Annot_Max_Percent (float_of_string _3)) :: _5 )}
| _1 = COVERAGE _2 = EQUAL _3 = FLOAT _4 = SEMICOLON _5 = annotation_options
    {            (   let len = float_of_string _3 in
                assert( len > 0.0 && len <= 1.0 );
                (P.Annot_Coverage len) :: _5
            )}
| _1 = MODEL _2 = EQUAL _3 = MAUVE _4 = SEMICOLON _5 = annotation_options
    {            ( (P.Annot_Type `Mauve) :: _5 )}
| _1 = MODEL _2 = EQUAL _3 = DEFAULT _4 = SEMICOLON _5 = annotation_options
    {            ( (P.Annot_Type `Default) :: _5 )}
| _1 = REARRANGEMENT _2 = EQUAL _3 = INTEGER _4 = SEMICOLON _5 = annotation_options
    {            ( (P.Annot_Rearrangement (int_of_string _3)):: _5 )}
| 
    {            ( [] )}

chrome_options:
  _1 = SOLVER _2 = EQUAL _3 = IDENT _4 = SEMICOLON _5 = chrome_options
    {            ( (P.Chrom_Solver _3) :: _5 )}
| _1 = MEDIAN _2 = EQUAL _3 = INTEGER _4 = SEMICOLON _5 = chrome_options
    {            ( (P.Chrom_Median (int_of_string _3)) :: _5 )}
| _1 = BREAKPOINT _2 = EQUAL _3 = INTEGER _4 = SEMICOLON _5 = chrome_options
    {            ( (P.Chrom_Locus_Breakpoint (int_of_string _3)) :: _5 )}
| _1 = SYMMETRIC _2 = SEMICOLON _3 = chrome_options
    {            ( (P.Chrom_Symmetric true) :: _3 )}
| _1 = APPROXIMATE _2 = SEMICOLON _3 = chrome_options
    {            ( (P.Chrom_Approx true) :: _3 )}
| _1 = INDEL _2 = EQUAL _3 = INTEGER _4 = COMMA _5 = FLOAT _6 = SEMICOLON _7 = chrome_options
    {            ( (P.Chrom_Locus_Indel (int_of_string _3, float_of_string _5)) :: _7 )}
| _1 = INVERSION _2 = EQUAL _3 = INTEGER _4 = SEMICOLON _5 = chrome_options
    {            ( (P.Chrom_Locus_Inversion (int_of_string _3)) :: _5 )}
| _1 = ANNOTATIONS _2 = annotation_options _3 = SEMICOLON _4 = chrome_options
    {            ( (P.Chrom_Annotations _2) :: _4 )}
| 
    {            ( [] )}

genome_options:
  _1 = CIRCULAR _2 = SEMICOLON _3 = genome_options
    {            ( (P.Genome_Circular true) :: _3 )}
| _1 = BREAKPOINT _2 = EQUAL _3 = INTEGER _4 = SEMICOLON _5 = genome_options
    {            ( (P.Genome_Breakpoint (int_of_string _3)) :: _5 )}
| _1 = INDEL _2 = EQUAL _3 = INTEGER _4 = COMMA _5 = FLOAT _6 = SEMICOLON _7 = genome_options
    {            ( (P.Genome_Indel (int_of_string _3, float_of_string _5)) :: _7 )}
| _1 = MEDIAN _2 = EQUAL _3 = INTEGER _4 = SEMICOLON _5 = genome_options
    {            ( (P.Genome_Median (int_of_string _3)) :: _5 )}
| _1 = DISTANCE _2 = EQUAL _3 = FLOAT _4 = SEMICOLON _5 = genome_options
    {            ( (P.Genome_Distance (float_of_string _3)) :: _5 )}
| 
    {            ( [] )}

charbranch_block:
  _1 = TREES _2 = EQUAL _3 = names _4 = charbranch_block
    {        ( (P.Tree_Names _3) :: _4 )}
| _1 = CHARSET _2 = EQUAL _3 = characterset_list _4 = SEMICOLON _5 = charbranch_block
    {        ( (P.Set_Names _3) :: _5 )}
| _1 = MAP _2 = pairs_list_float _3 = SEMICOLON _4 = charbranch_block
    {        ( (P.Labeling _2) :: _4 )}
| 
    {        ( [] )}

model_block:
  _1 = MODEL _2 = EQUAL _3 = IDENT _4 = SEMICOLON _5 = model_block
    {            ( (P.Model _3) :: _5 )}
| _1 = VARIATION _2 = EQUAL _3 = NONE _4 = SEMICOLON _5 = model_block
    {            ( (P.Variation "none") :: _5 )}
| _1 = VARIATION _2 = EQUAL _3 = IDENT _4 = SEMICOLON _5 = model_block
    {            ( (P.Variation _3) :: _5 )}
| _1 = COST _2 = EQUAL _3 = IDENT _4 = SEMICOLON _5 = model_block
    {            ( (P.Cost_Mode _3) :: _5 )}
| _1 = SITES _2 = EQUAL _3 = INTEGER _4 = SEMICOLON _5 = model_block
    {            ( (P.Variation_Sites _3) :: _5 )}
| _1 = PERCENT _2 = EQUAL _3 = FLOAT _4 = SEMICOLON _5 = model_block
    {            ( (P.Variation_Invar _3) :: _5 )}
| _1 = ALPHA _2 = EQUAL _3 = FLOAT _4 = SEMICOLON _5 = model_block
    {            ( (P.Variation_Alpha _3) :: _5 )}
| _1 = PRIORS _2 = EQUAL _3 = priors_options _4 = model_block
    {            ( _3 :: _4 )}
| _1 = CHARSET _2 = EQUAL _3 = characterset_list _4 = SEMICOLON _5 = model_block
    {            ( (P.Chars _3) :: _5 )}
| _1 = PARAMETERS _2 = EQUAL _3 = float_list _4 = model_block
    {            ( (P.Parameters _3) :: _4 )}
| _1 = FILE _2 = EQUAL _3 = QUOTED _4 = SEMICOLON _5 = model_block
    {            ( (P.Files _3) :: _5 )}
| _1 = GAP _2 = EQUAL _3 = COUPLED _4 = COLON _5 = FLOAT _6 = SEMICOLON _7 = model_block
    {            ( (P.Gap_Mode (_3,(Some (float_of_string _5)))) :: _7 )}
| _1 = GAP _2 = EQUAL _3 = COUPLED _4 = SEMICOLON _5 = model_block
    {            ( (P.Gap_Mode (_3,None)) :: _5 )}
| _1 = GAP _2 = EQUAL _3 = MISSING _4 = SEMICOLON _5 = model_block
    {            ( (P.Gap_Mode (_3,None)) :: _5 )}
| _1 = GAP _2 = EQUAL _3 = IDENT _4 = SEMICOLON _5 = model_block
    {            ( (P.Gap_Mode (_3,None)) :: _5 )}
| _1 = SEMICOLON
    {                ( [] )}

priors_options:
  _1 = pairs_list_float
    {                        ( P.Given_Priors _1 )}
| _1 = IDENT _2 = SEMICOLON
    {                        ( P.Other_Priors _1 )}

float_list:
  _1 = FLOAT _2 = float_list
    {                            ( (float_of_string _1) :: _2 )}
| _1 = INTEGER _2 = float_list
    {                            ( (float_of_string _1) :: _2 )}
| _1 = FLOAT _2 = SEMICOLON
    {                            ( [(float_of_string _1)] )}
| _1 = INTEGER _2 = SEMICOLON
    {                            ( [(float_of_string _1)] )}

names:
  _1 = IDENT _2 = COMMA _3 = names
    {                        ( _1 :: _3 )}
| _1 = INTEGER _2 = COMMA _3 = names
    {                          ( _1 :: _3 )}
| _1 = IDENT _2 = SEMICOLON
    {                      ( [_1] )}

pairs_list:
  _1 = nexus_ident _2 = IDENT _3 = COMMA _4 = pairs_list
    {                                           ( (_1, _2) :: _4 )}
| _1 = nexus_ident _2 = IDENT
    {                                           ( [_1, _2] )}

pairs_list_float:
  _1 = IDENT _2 = FLOAT _3 = COMMA _4 = pairs_list_float
    {                                         ( (_1,(float_of_string _2)) :: _4 )}
| _1 = DASH _2 = FLOAT _3 = COMMA _4 = pairs_list_float
    {                                         ( ("-",(float_of_string _2)) :: _4 )}
| _1 = IDENT _2 = FLOAT _3 = SEMICOLON
    {                            ( [(_1,(float_of_string _2))] )}
| _1 = DASH _2 = FLOAT _3 = SEMICOLON
    {                            ( [("-",(float_of_string _2))] )}

characters:
  _1 = DIMENSIONS _2 = optional_taxa_dimensions _3 = NCHAR _4 = EQUAL _5 = INTEGER _6 = SEMICOLON _7 = optional_format _8 = optional_eliminate _9 = optional_taxlabels _10 = optional_charstatelabels _11 = optional_charlabels _12 = optional_statelabels _13 = DATA _14 = SEMICOLON
    {     (
         {
             P.char_taxon_dimensions = _2;
             P.char_char_dimensions = _5;
             P.char_format = _7;
             P.char_eliminate = _8;
             P.char_taxlabels = _9;
             P.char_statelabels = _10;
             P.char_charlabels = _11;
             P.char_charstates = _12;
             P.chars = _13;
        }
     )}

unaligned:
  _1 = optional_unaligned_dimensions _2 = optional_format _3 = DATA _4 = SEMICOLON
    {        ( { P.unal_taxon_dimensions = _1; unal_format = _2; unal = _3 } )}

optional_unaligned_dimensions:
  _1 = DIMENSIONS _2 = optional_taxa_dimensions
    {                                          ( _2 )}
| 
    {      ( None )}

optional_charlabels:
  _1 = CHARLABELS _2 = taxonlist _3 = SEMICOLON
    {                                        ( _2 )}
| 
    {                                        ( [] )}

charstatelabels:
  _1 = INTEGER _2 = nexus_word _3 = BACKSLASH _4 = taxonlist _5 = COMMA _6 = charstatelabels
    {                                                                   ( (_1, _2, _4) :: _6 )}
| _1 = INTEGER _2 = nexus_word _3 = BACKSLASH _4 = taxonlist _5 = SEMICOLON
    {                                                                   ( (_1, _2, _4) :: [] )}
| _1 = SEMICOLON
    {                                                                   ( []                 )}

optional_charstatelabels:
  _1 = CHARSTATELABELS _2 = charstatelabels
    {                                      ( _2 )}
| 
    {                                      ( [] )}

optional_statelabels:
  _1 = STATELABELS _2 = statelabels _3 = SEMICOLON
    {                                        ( _2 )}
| 
    {                                        ( [] )}

statelabels:
  _1 = INTEGER _2 = taxonlist _3 = COMMA _4 = statelabels
    {                                          ( (_1, _2) :: _4 )}
| _1 = INTEGER _2 = taxonlist
    {                                          ( (_1, _2) :: [] )}
| 
    {                                          ( []             )}

optional_taxlabels:
  _1 = TAXLABELS _2 = taxonlist _3 = SEMICOLON
    {                                    ( _2 )}
| 
    {                                ( [] )}

optional_eliminate:
  _1 = ELIMINATE _2 = characterset _3 = SEMICOLON
    {                                       ( Some _2 )}
| 
    {                                ( None )}

optional_format:
  _1 = FORMAT _2 = format_items_list _3 = SEMICOLON
    {                                         ( _2 )}
| 
    {                ( [] )}

format_items_list:
  _1 = format_items _2 = format_items_list
    {                                     ( _1 :: _2 )}
| _1 = error _2 = format_items_list
    {                              (
        report_error "Format list" (Parsing.symbol_start_pos ()) (Parsing.symbol_end_pos ());
        _2 )}
| 
    {                ( [] )}

format_items:
  _1 = DATATYPE _2 = EQUAL _3 = datatype
    {                              ( P.Datatype _3 )}
| _1 = DATATYPE _2 = EQUAL _3 = error
    {                           (
        !P.print_error
        ("Many@ \"NEXUS\"@ files@ include@ in@ the@ CHARACTERS@ or@ DATA@ " ^
        "block@ the@ dataype@ @[<b>mixed@]@ or@ @[<b>restriction@]@ or@ something@ else.@ " ^
        "@ Those@ are@ most@ likely@ Mr.Bayes@ files.@ No@ matter@ that@ " ^
        "they@ say@ #NEXUS@ at@ the@ beginning,@ this@ is@ not@ a@ valid@ " ^
        "NEXUS@ file.@ I can@ not@ process@ this.@ I@ am@ sorry. " ^
        "You'll@ have@ to@ convert@ it@ to@ a@ valid@ nexus@ file.");
        raise Parsing.Parse_error )}
| _1 = RESPECTCASE
    {                  ( P.RespectCase )}
| _1 = MISSING _2 = EQUAL _3 = symbol
    {                           ( P.FMissing _3 )}
| _1 = GAP _2 = EQUAL _3 = symbol
    {                       ( P.Gap _3 )}
| _1 = SYMBOLS _2 = EQUAL _3 = QUOTED
    {                           ( P.Symbols _3)}
| _1 = EQUATE _2 = EQUAL _3 = QUOTED
    {                          ( P.Equate _3 )}
| _1 = MATCHCHAR _2 = EQUAL _3 = symbol
    {                             ( P.MatchChar _3 )}
| _1 = NOLABELS
    {                   ( P.Labels false )}
| _1 = LABELS
    {                    ( P.Labels true )}
| _1 = TRANSPOSE
    {                    ( P.Transpose )}
| _1 = INTERLEAVE _2 = EQUAL
    {                          (
        !P.print_error
        ("Many@ \"NEXUS\"@ files@ include@ in@ the@ CHARACTERS@ or@ DATA@ " ^
        "block@ the@ directives@ interleave=yes@ or@ interleave=no.@ " ^
        "@[<b>That@ is@ not@ a@ valid@ NEXUS@ directive@].@ To@ fix@ your@ file@ " ^
        "replace@ interleave=yes@ with@ INTERLEAVE,@ or@ just@ remove@ it@ " ^
        "if@ you@ see@ interleave=no.");
        raise Parsing.Parse_error )}
| _1 = INTERLEAVE
    {                    ( P.Interleave )}
| _1 = ITEMS _2 = EQUAL _3 = item
    {                       ( P.Items _3 )}
| _1 = STATESFORMAT _2 = EQUAL _3 = states_format
    {                                       ( P.StatesFormat _3 )}
| _1 = NOTOKENS
    {                   ( P.Tokens false )}
| _1 = TOKENS
    {                    ( P.Tokens true )}
| _1 = TRIANGLE _2 = EQUAL _3 = triangle_format
    {                                     ( P.Triangle _3 )}

triangle_format:
  _1 = LOWER
    {            ( P.Lower )}
| _1 = UPPER
    {            ( P.Upper )}
| _1 = BOTH
    {           ( P.Both )}

datatype:
  _1 = STANDARD
    {                    ( P.DStandard   )}
| _1 = DNA
    {                    ( P.Dna         )}
| _1 = RNA
    {                    ( P.Rna         )}
| _1 = NUCLEOTIDE
    {                    ( P.Nucleotide  )}
| _1 = PROTEIN
    {                    ( P.Protein     )}
| _1 = CONTINUOUS
    {                    ( P.Continuous  )}

symbol:
  _1 = IDENT
    {            ( _1 )}
| _1 = DASH
    {           ( "-" )}
| _1 = CHAR
    {            ( Char.escaped _1 )}

symbol_list:
  _1 = symbol _2 = symbol_list
    {                            ( _1 :: _2  )}
| 
    {                            ( []        )}

symbol_pair:
  _1 = symbol _2 = EQUAL _3 = symbol
    {                          ((_1, [_3]))}
| _1 = symbol _2 = EQUAL _3 = LPARENT _4 = symbol_list _5 = RPARENT
    {                                               ( (_1, _4) )}

item:
  _1 = MIN
    {                    ( P.Min         )}
| _1 = MAX
    {                    ( P.Max         )}
| _1 = MEDIAN
    {                    ( P.Median      )}
| _1 = AVERAGE
    {                    ( P.Average     )}
| _1 = VARIANCE
    {                    ( P.Variance    )}
| _1 = STDERROR
    {                    ( P.Stderror    )}
| _1 = SAMPLESIZE
    {                    ( P.SampleSize  )}
| _1 = STATES
    {                    ( P.States      )}

states_format:
  _1 = STATESPRESENT
    {                    ( P.StatesPresent   )}
| _1 = INDIVIDUALS
    {                    ( P.Individuals     )}
| _1 = COUNT
    {                    ( P.Count           )}
| _1 = FREQUENCY
    {                    ( P.Frequency       )}

optional_taxa_dimensions:
  _1 = NTAX _2 = EQUAL _3 = INTEGER
    {                            ( Some _3   )}
| 
    {                            ( None      )}

taxa:
  _1 = DIMENSIONS _2 = NTAX _3 = EQUAL _4 = INTEGER _5 = SEMICOLON _6 = TAXLABELS _7 = taxonlist _8 = SEMICOLON
    {        ( (_4, _7) )}

nexus_word:
  _1 = IDENT
    {                    ( _1 )}
| _1 = SINGLEQUOTED
    {                    ( _1 )}
| _1 = DNA
    {                    ( _1 )}
| _1 = RNA
    {                    ( _1 )}

nexus_ident:
  _1 = nexus_word
    {                    ( _1 )}
| _1 = INTEGER
    {                    ( _1 )}

taxonlist:
  _1 = nexus_word _2 = taxonlist
    {                                ( _1 :: _2  )}
| 
    {                                ( []        )}

characterset_list:
  _1 = characterset _2 = characterset_list
    {                                     ( _1 :: _2 )}
| _1 = characterset
    {                                     ( [_1]     )}

characterset:
  _1 = INTEGER _2 = DASH _3 = CHAR _4 = optional_step
    {                        ( P.Range (int_of_string _1, None, _4) )}
| _1 = INTEGER _2 = DASH _3 = INTEGER _4 = optional_step
    {                        ( P.Range (int_of_string _1, Some (int_of_string _3), _4) )}
| _1 = INTEGER
    {                        ( P.Single (int_of_string _1) )}
| _1 = IDENT
    {                        ( P.Name _1 )}
| _1 = SINGLEQUOTED
    {                        ( P.Name _1 )}
| _1 = CHAR
    {                        ( P.Name (String.make 1 _1) )}
| _1 = DNA
    {                        ( P.Name "DNA" )}
| _1 = RNA
    {                        ( P.Name "RNA" )}
| _1 = PROTEIN
    {                        ( P.Name "PROTEIN" )}

optional_step:
  _1 = SLASH _2 = INTEGER
    {                    ( int_of_string _2 )}
| 
    {                    ( 1                )}

tree:
  _1 = do_star _2 = IDENT _3 = EQUAL _4 = single_tree _5 = EOF
    {                                          ( (_2,_4) )}

single_tree:
  _1 = nexus_ident _2 = optional_length _3 = optional_comment
    {        ( P.Leaf (_1, (_2, _3))         )}
| _1 = LPARENT _2 = single_tree_list _3 = RPARENT _4 = optional_label _5 = optional_length _6 = optional_comment
    {        ( P.Node (_2, _4, (_5, _6))     )}

single_tree_list:
  _1 = single_tree _2 = COMMA _3 = single_tree_list
    {                                         ( _1 :: _3 )}
| _1 = single_tree
    {                                         ( [_1]     )}

optional_length:
  _1 = COLON _2 = INTEGER
    {                    ( Some (float_of_string _2) )}
| _1 = COLON _2 = FLOAT
    {                    ( Some (float_of_string _2) )}
| 
    {                    ( None                      )}

optional_comment:
  _1 = LBRACKET _2 = nexus_ident _3 = RBRACKET
    {                                    ( Some _2 )}
| 
    {                              ( None    )}

optional_label:
  _1 = nexus_ident
    {                  ( Some _1   )}
| _1 = FLOAT
    {                  ( None      )}
| 
    {                  ( None      )}

trees:
  _1 = do_star _2 = nexus_word _3 = EQUAL _4 = single_tree _5 = SEMICOLON _6 = trees
    {                                                           ((_2,_4)::_6)}
| _1 = do_star _2 = single_tree _3 = SEMICOLON _4 = trees
    {                                                           (("",_2)::_4)}
| _1 = EOF
    {                                                           (  []       )}

any_thing_minus_end:
  _1 = TAXA
    {            ( () )}
| _1 = DATA
    {            ( () )}
| _1 = UNALIGNED
    {                 ( () )}
| _1 = TREES
    {             ( () )}
| _1 = NOTES
    {             ( () )}
| _1 = DISTANCES
    {                 ( () )}
| _1 = ASSUMPTIONS
    {                   ( () )}
| _1 = SETS
    {            ( () )}
| _1 = CHARACTERS
    {                 ( () )}
| _1 = ANCSTATES
    {                ( () )}
| _1 = AVERAGE
    {              ( () )}
| _1 = BINHEX
    {             ( () )}
| _1 = BOTH
    {           ( () )}
| _1 = CHANGESET
    {                ( () )}
| _1 = CHAR
    {           ( () )}
| _1 = CHARACTER
    {                ( () )}
| _1 = CHARLABELS
    {                 ( () )}
| _1 = CHARPARTITION
    {                    ( () )}
| _1 = CHARSTATELABELS
    {                      ( () )}
| _1 = CODEORDER
    {                ( () )}
| _1 = CODESET
    {              ( () )}
| _1 = CODONS
    {             ( () )}
| _1 = CONDONPOSSET
    {                   ( () )}
| _1 = CONTINUOUS
    {                 ( () )}
| _1 = COUNT
    {            ( () )}
| _1 = CSTREE
    {             ( () )}
| _1 = QUOTED
    {             ( () )}
| _1 = DATATYPE
    {               ( () )}
| _1 = DEFTYPE
    {              ( () )}
| _1 = DIAGONAL
    {               ( () )}
| _1 = DIMENSIONS
    {                 ( () )}
| _1 = DNA
    {          ( () )}
| _1 = DROS
    {           ( () )}
| _1 = ELIMINATE
    {                ( () )}
| _1 = ENCODE
    {             ( () )}
| _1 = EPS
    {          ( () )}
| _1 = EQUATE
    {             ( () )}
| _1 = EXSET
    {            ( () )}
| _1 = EXT
    {          ( () )}
| _1 = EXTENSIONS
    {                 ( () )}
| _1 = FILE
    {           ( () )}
| _1 = FORMAT
    {             ( () )}
| _1 = FREQUENCY
    {                ( () )}
| _1 = GAP
    {          ( () )}
| _1 = GENETICCODE
    {                  ( () )}
| _1 = GIF
    {          ( () )}
| _1 = INDIVIDUALS
    {                  ( () )}
| _1 = INLINE
    {             ( () )}
| _1 = INTERLEAVE
    {                 ( () )}
| _1 = ITEMS
    {            ( () )}
| _1 = JPEG
    {           ( () )}
| _1 = LABELS
    {             ( () )}
| _1 = LOWER
    {            ( () )}
| _1 = MAM
    {          ( () )}
| _1 = MATCHCHAR
    {                ( () )}
| _1 = MAX
    {          ( () )}
| _1 = MAXSTEPS
    {               ( () )}
| _1 = MEDIAN
    {             ( () )}
| _1 = MIN
    {          ( () )}
| _1 = MINSTEPS
    {               ( () )}
| _1 = MISSING
    {              ( () )}
| _1 = MTDNA
    {            ( () )}
| _1 = NCHAR
    {            ( () )}
| _1 = NEWSTATE
    {               ( () )}
| _1 = NEWTAXA
    {              ( () )}
| _1 = NONE
    {           ( () )}
| _1 = NTAX
    {           ( () )}
| _1 = NUCLEOTIDE
    {                 ( () )}
| _1 = NUCORDER
    {               ( () )}
| _1 = OPTIONS
    {              ( () )}
| _1 = PICT
    {           ( () )}
| _1 = PICTURE
    {              ( () )}
| _1 = POLYTCOUNT
    {                 ( () )}
| _1 = PROTEIN
    {              ( () )}
| _1 = RESOURCE
    {               ( () )}
| _1 = RESPECTCASE
    {                  ( () )}
| _1 = RNA
    {          ( () )}
| _1 = SAMPLESIZE
    {                 ( () )}
| _1 = SOURCE
    {             ( () )}
| _1 = STANDARD
    {               ( () )}
| _1 = STATE
    {            ( () )}
| _1 = STATELABELS
    {                  ( () )}
| _1 = STATES
    {             ( () )}
| _1 = STATESET
    {               ( () )}
| _1 = STATESFORMAT
    {                   ( () )}
| _1 = STATESPRESENT
    {                    ( () )}
| _1 = STDERROR
    {               ( () )}
| _1 = STEPMATRIX
    {                 ( () )}
| _1 = SYMBOLS
    {              ( () )}
| _1 = TAXON
    {            ( () )}
| _1 = TAXLABELS
    {                ( () )}
| _1 = TAXPARTITION
    {                   ( () )}
| _1 = TAXSET
    {             ( () )}
| _1 = TEXT
    {           ( () )}
| _1 = TIFF
    {           ( () )}
| _1 = TOKENS
    {             ( () )}
| _1 = TRANSLATE
    {                ( () )}
| _1 = TRANSPOSE
    {                ( () )}
| _1 = TREE
    {           ( () )}
| _1 = TREEPARTITION
    {                    ( () )}
| _1 = TREESET
    {              ( () )}
| _1 = TRIANGLE
    {               ( () )}
| _1 = TYPESET
    {              ( () )}
| _1 = UNIVERSAL
    {                ( () )}
| _1 = UPPER
    {            ( () )}
| _1 = USERTYPE
    {               ( () )}
| _1 = UUENCODE
    {               ( () )}
| _1 = VARIANCE
    {               ( () )}
| _1 = VECTOR
    {             ( () )}
| _1 = WTSET
    {            ( () )}
| _1 = YEAST
    {            ( () )}
| _1 = EIDENT
    {             ( () )}
| _1 = STAR
    {           ( () )}
| _1 = COLON
    {            ( () )}
| _1 = IDENT
    {            ( () )}
| _1 = FLOAT
    {            ( () )}
| _1 = INTEGER
    {              ( () )}
| _1 = SEMICOLON
    {                 ( () )}
| _1 = EQUAL
    {            ( () )}
| _1 = COMMA
    {            ( () )}
| _1 = QUOTE
    {            ( () )}
| _1 = BACKSLASH
    {                ( () )}
| _1 = DASH
    {           ( () )}
| _1 = LPARENT
    {              ( () )}
| _1 = RPARENT
    {              ( () )}
| _1 = SINGLEQUOTED
    {                   ( () )}

%%


