File "reason_parser.mly", line 976, characters 29-36:
Warning: the token COMMENT is unused.
File "reason_parser.mly", line 978, characters 7-10:
Warning: the token EOL is unused.
File "reason_parser.mly", line 917, characters 7-16:
Warning: the token LESSMINUS is unused.
File "reason_parser.mly", line 925, characters 7-16:
Warning: the token LESSSLASH is unused.
File "reason_parser.mly", line 931, characters 7-19:
Warning: the token MINUSGREATER is unused.
File "reason_parser.mly", line 934, characters 19-28:
Warning: the token NATIVEINT is unused.
File "reason_parser.mly", line 956, characters 7-15:
Warning: the token SEMISEMI is unused.
File "reason_parser.mly", line 964, characters 7-12:
Warning: the token TILDE is unused.
%{
open Migrate_parsetree.OCaml_404.Ast
open Syntax_util
open Location
open Asttypes
open Longident
open Parsetree
open Ast_helper
open Ast_mapper

(*
   TODO:
   - Remove all [open]s from the top of this file one by one and fix compilation
   failures that ensue by specifying the appropriate long identifiers. That
   will make the parser much easier to reason about.
   - Go back to trunk, do the same (remove [open]s, and fully specify long
   idents), to perform a clean diff.

*)

(**

   location.ml:
   ------------
   let mkloc txt loc = { txt ; loc }
   let rhs_loc n = {
     loc_start = Parsing.rhs_start_pos n;
     loc_end = Parsing.rhs_end_pos n;
     loc_ghost = false;
   }
   let symbol_rloc () = {
     loc_start = Parsing.symbol_start_pos ();
     loc_end = Parsing.symbol_end_pos ();
     loc_ghost = false;
   }

   let symbol_gloc () = {
     loc_start = Parsing.symbol_start_pos ();
     loc_end = Parsing.symbol_end_pos ();
     loc_ghost = true;
   }

   ast_helper.ml:
   ------------
   module Typ = struct
    val mk: ?loc:loc -> ?attrs:attrs -> core_type_desc -> core_type
    let mk ?(loc = !default_loc) ?(attrs = []) d =
       {ptyp_desc = d; ptyp_loc = loc; ptyp_attributes = attrs}
     ..
   end

   parse_tree.mli
   --------------
   and core_type = {
     ptyp_desc: core_type_desc;
     ptyp_loc: Location.t;
     ptyp_attributes: attributes; (* ... [@id1] [@id2] *)
   }

   and core_type_desc =
     | Ptyp_any
           (*  _ *)
     | Ptyp_var of string
           (* 'a *)
     | Ptyp_arrow of label * core_type * core_type
           (* T1 -> T2       (label = "")
              ~l:T1 -> T2    (label = "l")
              ?l:T1 -> T2    (label = "?l")
            *)
     | Ptyp_tuple of core_type list
           (* T1 * ... * Tn   (n >= 2) *)

   reason_parser.mly
   ---------------
   In general:

                                          syntax variant          {pblah_desc: core_blah_desc
                                                                   pblah_loc: {txt, loc}
                                                                   pblah_attributes: ... }
                                         /              \            /       \
   val mkblah: ~loc -> ~attributes ->     core_blah_desc     ->      core_blah
   let mkblah = Blah.mk

*)


let dummy_loc () = {
  loc_start = Lexing.dummy_pos;
  loc_end = Lexing.dummy_pos;
  loc_ghost = false;
}

let mklocation loc_start loc_end = {
  loc_start = loc_start;
  loc_end = loc_end;
  loc_ghost = false;
}

let with_txt a txt = {
    a with txt=txt;
}

let make_real_loc loc = {
    loc with loc_ghost = false
}

let make_ghost_loc loc = {
    loc with loc_ghost = true
}

let ghloc ?(loc=dummy_loc ()) d = { txt = d; loc = (make_ghost_loc loc) }

(**
  * turn an object into a real
  *)
let make_real_exp exp = {
    exp with pexp_loc = make_real_loc exp.pexp_loc
}
let make_real_pat pat = {
    pat with ppat_loc = make_real_loc pat.ppat_loc
}
let make_real_cf cf = {
    cf with pcf_loc = make_real_loc cf.pcf_loc
}

(**
  * turn a object into ghost
  *)
let make_ghost_cf cf = {
    cf with pcf_loc = make_ghost_loc cf.pcf_loc
}
let make_ghost_exp exp = {
    exp with pexp_loc = make_ghost_loc exp.pexp_loc
}

let make_ghost_pat pat = {
    pat with ppat_loc = make_ghost_loc pat.ppat_loc
}

(**
  * change the location state to be a ghost location or real location
  *)
let set_loc_state is_ghost loc =
    if is_ghost then make_ghost_loc loc else make_real_loc loc

let mktyp ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Typ.mk ~loc d

let mkpat ?(attrs=[]) ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Pat.mk ~loc ~attrs d

let mkexp ?(attrs=[]) ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Exp.mk ~loc ~attrs d

let mkmty ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Mty.mk ~loc d

let mksig ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Sig.mk ~loc d

let mkmod ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Mod.mk ~loc d

let mkstr ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Str.mk ~loc d

let mkclass ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Cl.mk ~loc d

let mkcty ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Cty.mk ~loc d

let mkctf ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Ctf.mk ~loc d

(**
  Make a core_type from a as_loc(LIDENT).
  Useful for record type punning.
  type props = {width: int, height: int};
  type state = {nbrOfClicks: int};
  type component = {props, state};
*)
let mkct lbl =
  let lident = Lident lbl.txt in
  let ttype = Ptyp_constr({txt = lident; loc = lbl.loc}, []) in
  {ptyp_desc = ttype; ptyp_loc = lbl.loc; ptyp_attributes = []}

let mkcf ?(loc=dummy_loc()) ?(ghost=false) d =
    let loc = set_loc_state ghost loc in
    Cf.mk ~loc d

let simple_ghost_text_attr ?(loc=dummy_loc ()) txt =
  let loc = set_loc_state true loc in
  [({txt; loc}, PStr [])]

let mkExplicitArityTuplePat ?(loc=dummy_loc ()) pat =
  (* Tell OCaml type system that what this tuple construction represents is
     not actually a tuple, and should represent several constructor
     arguments.  This allows the syntax the ability to distinguish between:

     X (10, 20)  -- One argument constructor
     X 10 20     -- Multi argument constructor
  *)
  mkpat
    ~loc
    ~attrs:(simple_ghost_text_attr ~loc "explicit_arity")
    pat

let mkExplicitArityTupleExp ?(loc=dummy_loc ()) exp =
  mkexp
    ~loc
    ~attrs:(simple_ghost_text_attr ~loc "explicit_arity")
    exp

let is_pattern_list_single_any = function
  | [{ppat_desc=Ppat_any; ppat_attributes=[]} as onlyItem] -> Some onlyItem
  | _ -> None

let set_structure_item_location x loc = {x with pstr_loc = loc};;

let mkoperator_loc name loc =
  Exp.mk ~loc (Pexp_ident(mkloc (Lident name) loc))

let mkoperator name pos =
  mkoperator_loc name (rhs_loc pos)

(*
  Ghost expressions and patterns:
  expressions and patterns that do not appear explicitly in the
  source file they have the loc_ghost flag set to true.
  Then the profiler will not try to instrument them and the
  -annot option will not try to display their type.

  Every grammar rule that generates an element with a location must
  make at most one non-ghost element, the topmost one.

  How to tell whether your location must be ghost:
  A location corresponds to a range of characters in the source file.
  If the location contains a piece of code that is syntactically
  valid (according to the documentation), and corresponds to the
  AST node, then the location must be real; in all other cases,
  it must be ghost.

  jordwalke: Noticed that ghost expressions are often used when inserting
   additional AST nodes from a parse rule. Either an extra wrapping one, or an
   additional inner node. This is consistent with the above description, I
   believe.
*)


let ghunit ?(loc=dummy_loc ()) () =
  mkexp ~ghost:true ~loc (Pexp_construct (mknoloc (Lident "()"), None))

let mkinfixop arg1 op arg2 =
  mkexp(Pexp_apply(op, [Nolabel, arg1; Nolabel, arg2]))

let mkinfix arg1 name arg2 =
  mkinfixop arg1 (mkoperator name 2) arg2

let neg_string f =
  if String.length f > 0 && f.[0] = '-'
  then String.sub f 1 (String.length f - 1)
  else "-" ^ f

let mkuminus name arg =
  match name, arg.pexp_desc with
  | "-", Pexp_constant(Pconst_integer (n,m)) ->
      mkexp(Pexp_constant(Pconst_integer(neg_string n,m)))
  | ("-" | "-."), Pexp_constant(Pconst_float (f, m)) ->
      mkexp(Pexp_constant(Pconst_float(neg_string f, m)))
  | _ ->
      mkexp(Pexp_apply(mkoperator ("~" ^ name) 1, [Nolabel, arg]))

let mkFunctorThatReturns functorArgs returns =
  List.fold_left (
    fun acc (n, t) -> mkmod (Pmod_functor(n, t, acc))
  ) returns functorArgs

let mkuplus name arg =
  let desc = arg.pexp_desc in
  match name, desc with
  | "+", Pexp_constant(Pconst_integer _)
  | ("+" | "+."), Pexp_constant(Pconst_float _) -> mkexp desc
  | _ ->
      mkexp(Pexp_apply(mkoperator ("~" ^ name) 1, [Nolabel, arg]))

let mkexp_cons consloc args loc =
  mkexp ~loc (Pexp_construct(mkloc (Lident "::") consloc, Some args))

let mkexp_constructor_unit consloc loc =
  mkexp ~loc (Pexp_construct(mkloc (Lident "()") consloc, None))

let ghexp_cons consloc args loc =
  mkexp ~ghost:true ~loc (Pexp_construct(mkloc (Lident "::") loc, Some args))

let mkpat_cons consloc args loc =
  mkpat ~loc (Ppat_construct(mkloc (Lident "::") loc, Some args))

let ghpat_cons consloc args loc =
  mkpat ~ghost:true ~loc (Ppat_construct(mkloc (Lident "::") loc, Some args))

let simple_pattern_list_to_tuple ?(loc=dummy_loc ()) lst =
  match lst with
    | [] -> assert false
    | _ -> mkpat ~loc (Ppat_tuple (List.rev lst))

let mktailexp_extension loc seq ext_opt =
  let rec handle_seq = function
    [] ->
      let base_case = match ext_opt with
        | Some ext ->
          ext
        | None ->
          let loc = make_ghost_loc loc in
          let nil = { txt = Lident "[]"; loc } in
          Exp.mk ~loc (Pexp_construct (nil, None)) in
      base_case
  | e1 :: el ->
      let exp_el = handle_seq el in
      let loc = mklocation e1.pexp_loc.loc_start exp_el.pexp_loc.loc_end in
      let arg = mkexp ~ghost:true ~loc (Pexp_tuple [e1; exp_el]) in
      ghexp_cons loc arg loc in
  handle_seq seq

let mktailpat_extension loc seq ext_opt =
  let rec handle_seq = function
    [] ->
      let base_case = match ext_opt with
        | Some ext ->
          ext
        | None ->
          let loc = make_ghost_loc loc in
          let nil = { txt = Lident "[]"; loc } in
          mkpat ~loc (Ppat_construct (nil, None)) in
      base_case
  | p1 :: pl ->
      let pat_pl = handle_seq pl in
      let loc = mklocation p1.ppat_loc.loc_start pat_pl.ppat_loc.loc_end in
      let arg = mkpat ~ghost:true ~loc (Ppat_tuple [p1; pat_pl]) in
      ghpat_cons loc arg loc in
  handle_seq seq

let makeFrag loc body =
  let attribute = ({txt = "JSX"; loc = loc}, PStr []) in
  { body with pexp_attributes = [attribute] @ body.pexp_attributes }


(* Applies attributes to the structure item, not the expression itself. Makes
 * structure item have same location as expression. *)
let mkstrexp e attrs =
  { pstr_desc = Pstr_eval (e, attrs); pstr_loc = e.pexp_loc }

let ghexp_constraint loc e (t1, t2) =
  match t1, t2 with
  | Some t, None -> mkexp ~ghost:true ~loc (Pexp_constraint(e, t))
  | _, Some t -> mkexp ~ghost:true ~loc (Pexp_coerce(e, t1, t))
  | None, None -> assert false

let array_function ?(loc=dummy_loc()) str name =
  ghloc ~loc (Ldot(Lident str, (if !Clflags.fast then "unsafe_" ^ name else name)))

let syntax_error_str loc msg =
  if !Reason_config.recoverable then
    Str.mk ~loc:loc (Pstr_extension (Syntax_util.syntax_error_extension_node loc msg, []))
  else
    raise(Syntaxerr.Error(Syntaxerr.Other loc))

let syntax_error () =
  raise Syntaxerr.Escape_error

let syntax_error_exp loc msg =
  if !Reason_config.recoverable then
    Exp.mk ~loc (Pexp_extension (Syntax_util.syntax_error_extension_node loc msg))
  else
    syntax_error ()

let unclosed opening closing =
  raise(Syntaxerr.Error(Syntaxerr.Unclosed(opening.loc, opening.txt,
                                           closing.loc, closing.txt)))

let unclosed_extension closing =
  Syntax_util.syntax_error_extension_node closing.loc ("Expecting \"" ^ closing.txt ^ "\"")

let unclosed_mod opening closing =
  if !Reason_config.recoverable then
    mkmod(Pmod_extension (unclosed_extension closing))
  else
    unclosed opening closing

let unclosed_cl opening closing =
  if !Reason_config.recoverable then
    mkclass(Pcl_extension (unclosed_extension closing))
  else
    unclosed opening closing

let unclosed_mty opening closing =
  if !Reason_config.recoverable then
    mkmty(Pmty_extension (unclosed_extension closing))
  else
    unclosed opening closing

let unclosed_cty opening closing =
  if !Reason_config.recoverable then
    mkcty(Pcty_extension (unclosed_extension closing))
  else
    unclosed opening closing

let unclosed_exp opening closing =
  if !Reason_config.recoverable then
    mkexp(Pexp_extension (unclosed_extension closing))
  else
    unclosed opening closing

let unclosed_pat opening closing =
  if !Reason_config.recoverable then
    mkpat(Ppat_extension (unclosed_extension closing))
  else
    unclosed opening closing

let expecting nonterm =
    raise Syntaxerr.(Error(Expecting(nonterm.loc, nonterm.txt)))

let expecting_pat nonterm =
  if !Reason_config.recoverable then
    mkpat(Ppat_extension (Syntax_util.syntax_error_extension_node nonterm.loc ("Expecting " ^ nonterm.txt)))
  else
    expecting nonterm

let not_expecting start_pos end_pos nonterm =
    raise Syntaxerr.(Error(Not_expecting(mklocation start_pos end_pos, nonterm)))

let bigarray_function ?(loc=dummy_loc()) str name =
  ghloc ~loc (Ldot(Ldot(Lident "Bigarray", str), name))

let bigarray_untuplify = function
    { pexp_desc = Pexp_tuple explist; pexp_loc = _ } -> explist
  | exp -> [exp]

let bigarray_get ?(loc=dummy_loc()) arr arg =
  let get = if !Clflags.fast then "unsafe_get" else "get" in
  match bigarray_untuplify arg with
    [c1] ->
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(bigarray_function ~loc "Array1" get)),
                       [Nolabel, arr; Nolabel, c1]))
  | [c1;c2] ->
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(bigarray_function ~loc "Array2" get)),
                       [Nolabel, arr; Nolabel, c1; Nolabel, c2]))
  | [c1;c2;c3] ->
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(bigarray_function ~loc "Array3" get)),
                       [Nolabel, arr; Nolabel, c1; Nolabel, c2; Nolabel, c3]))
  | coords ->
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(bigarray_function ~loc "Genarray" "get")),
                       [Nolabel, arr; Nolabel, mkexp ~ghost:true ~loc (Pexp_array coords)]))

let bigarray_set ?(loc=dummy_loc()) arr arg newval =
  let set = if !Clflags.fast then "unsafe_set" else "set" in
  match bigarray_untuplify arg with
    [c1] ->
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(bigarray_function ~loc "Array1" set)),
                       [Nolabel, arr; Nolabel, c1; Nolabel, newval]))
  | [c1;c2] ->
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(bigarray_function ~loc "Array2" set)),
                       [Nolabel, arr; Nolabel, c1; Nolabel, c2; Nolabel, newval]))
  | [c1;c2;c3] ->
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(bigarray_function ~loc "Array3" set)),
                       [Nolabel, arr; Nolabel, c1; Nolabel, c2; Nolabel, c3; Nolabel, newval]))
  | coords ->
      mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(bigarray_function ~loc "Genarray" "set")),
                       [Nolabel, arr;
                        Nolabel, mkexp ~ghost:true ~loc (Pexp_array coords);
                        Nolabel, newval]))

let lapply p1 p2 start_pos end_pos =
  if !Clflags.applicative_functors
  then Lapply(p1, p2)
  else raise (Syntaxerr.Error(Syntaxerr.Applicative_path (mklocation start_pos end_pos)))

let exp_of_label label =
  mkexp ~loc:label.loc (Pexp_ident {label with txt=Lident(Longident.last label.txt)})

let pat_of_label label =
  mkpat ~loc:label.loc (Ppat_var {label with txt=(Longident.last label.txt)})

let check_variable vl loc v =
  if List.mem v vl then
    raise Syntaxerr.(Error(Variable_in_scope(loc,v)))

let varify_constructors var_names t =
  let rec loop t =
    let desc =
      match t.ptyp_desc with
      | Ptyp_any -> Ptyp_any
      | Ptyp_var x ->
          check_variable var_names t.ptyp_loc x;
          Ptyp_var x
      | Ptyp_arrow (label,core_type,core_type') ->
          Ptyp_arrow(label, loop core_type, loop core_type')
      | Ptyp_tuple lst -> Ptyp_tuple (List.map loop lst)
      | Ptyp_constr( { txt = Lident s }, []) when List.mem s var_names ->
          Ptyp_var s
      | Ptyp_constr(longident, lst) ->
          Ptyp_constr(longident, List.map loop lst)
      | Ptyp_object (lst, o) ->
          Ptyp_object
            (List.map (fun (s, attrs, t) -> (s, attrs, loop t)) lst, o)
      | Ptyp_class (longident, lst) ->
          Ptyp_class (longident, List.map loop lst)
      | Ptyp_alias(core_type, string) ->
          check_variable var_names t.ptyp_loc string;
          Ptyp_alias(loop core_type, string)
      | Ptyp_variant(row_field_list, flag, lbl_lst_option) ->
          Ptyp_variant(List.map loop_row_field row_field_list,
                       flag, lbl_lst_option)
      | Ptyp_poly(string_lst, core_type) ->
          List.iter (check_variable var_names t.ptyp_loc) string_lst;
          Ptyp_poly(string_lst, loop core_type)
      | Ptyp_package(longident,lst) ->
          Ptyp_package(longident,List.map (fun (n,typ) -> (n,loop typ) ) lst)
      | Ptyp_extension (s, arg) ->
          Ptyp_extension (s, arg)
    in
    {t with ptyp_desc = desc}
  and loop_row_field  =
    function
      | Rtag(label,attrs,flag,lst) ->
          Rtag(label,attrs,flag,List.map loop lst)
      | Rinherit t ->
          Rinherit (loop t)
  in
  loop t

let pexp_newtypes ?loc newtypes exp =
  List.fold_right (fun newtype exp -> mkexp ?loc (Pexp_newtype (newtype, exp)))
    newtypes exp

(**
  I believe that wrap_type_annotation will automatically generate the type
  arguments (type a) (type b) based on what was listed before the dot in a
  polymorphic type annotation that uses locally abstract types.
 *)
let wrap_type_annotation newtypes core_type body =
  let exp = mkexp(Pexp_constraint(body,core_type)) in
  let exp = pexp_newtypes newtypes exp in
  let typ = mktyp ~ghost:true (Ptyp_poly(newtypes,varify_constructors newtypes core_type)) in
  (exp, typ)


let struct_item_extension (ext_attrs, ext_id) structure_item =
  mkstr ~ghost:true (Pstr_extension ((ext_id, PStr [structure_item]), ext_attrs))

let extension_expression (ext_attrs, ext_id) item_expr =
  mkexp ~ghost:true ~attrs:ext_attrs (Pexp_extension (ext_id, PStr [mkstrexp item_expr []]))

(* There's no more need for these functions - this was for the following:
 *
 *     fun % ext [@foo] arg => arg;
 *
 *   Becoming
 *
 *     [%ext  (fun arg => arg) [@foo]]
 *
 *   Which we no longer support.
 *)
(* Applies the attributes to the body, then wraps entire thing in an extension
 * expression, whose payload consists of a single structure item that is body
 *)
(* let wrap_exp_attrs body (ext, attrs) = *)
(*   (* todo: keep exact location for the entire attribute *) *)
(*   let body = {body with pexp_attributes = attrs @ body.pexp_attributes} in *)
(*   match ext with *)
(*   | None -> body *)
(*   | Some id -> mkexp ~ghost:true (Pexp_extension (id, PStr [mkstrexp body []])) *)

(* Why not just mkexp with the right attributes in the first place? *)
(* let mkexp_attrs d attrs = *)
(*   wrap_exp_attrs (mkexp d) attrs *)

let mkcf_attrs ?(loc=dummy_loc()) d attrs =
  Cf.mk ~loc ~attrs d

let mkctf_attrs d attrs =
  Ctf.mk ~attrs d

type let_binding =
  { lb_pattern: pattern;
    lb_expression: expression;
    (* The meaning of lb_leading_attributes and lbs_extension are dependent on
     * the context of the let binding (module/expression etc) *)
    lb_attributes: attributes;
    (* lb_docs: docs Lazy.t; *)
    (* lb_text: text Lazy.t; *)
    lb_loc: Location.t; }

type let_bindings =
  { lbs_bindings: let_binding list;
    lbs_rec: rec_flag;
    lbs_extension: string Asttypes.loc option;
    (* In Reason, we use this field to represent
       extension attributes attached to the extension on a series of "let/and"
       bindings As in: let [@extAttrs ] [%id] [@attribute] x = ...; It only
       makes sense to have [lbs_attributes] when there is an [lbs_extension].
     *)
    lbs_attributes: attributes;
    lbs_loc: Location.t }

let mklb (p, e) attrs loc =
  { lb_pattern = p;
    lb_expression = e;
    (* Only some individual let bindings are allowed to have attributes
     * depending on the context *)
    lb_attributes = attrs;
    lb_loc = loc; }

let mklbs (extAttrs, extId) rf lb loc =
  { lbs_bindings = [lb];
    lbs_rec = rf;
    lbs_extension = extId ;
    lbs_attributes = extAttrs;
    lbs_loc = loc; }

let addlb lbs lb =
  { lbs with lbs_bindings = lb :: lbs.lbs_bindings }

let val_of_let_bindings lbs =
  let bindings =
    List.map
      (fun lb ->
         Vb.mk ~loc:lb.lb_loc ~attrs:lb.lb_attributes
           (* ~docs:(Lazy.force lb.lb_docs) *)
           (* ~text:(Lazy.force lb.lb_text) *)
           lb.lb_pattern lb.lb_expression)
      lbs.lbs_bindings
  in
  let str = mkstr(Pstr_value(lbs.lbs_rec, List.rev bindings)) in
  (* Note that for value bindings, when there's an extension, the
   * lbs_attributes are attributes on the extension *)
  match (lbs.lbs_extension) with
    | None -> str
    | Some ext_id -> struct_item_extension (lbs.lbs_attributes, ext_id) str

let expr_of_let_bindings lbs body =
  let bindings =
    List.map
      (fun lb ->
         (* Individual let bindings in an *expression* can't have item attributes. *)
         if lb.lb_attributes <> [] then
           raise Syntaxerr.(Error(Not_expecting(lb.lb_loc, "item attribute")));
         Vb.mk ~loc:lb.lb_loc lb.lb_pattern lb.lb_expression)
      lbs.lbs_bindings
  in
  (* The location of this expression unfortunately includes the entire rule,
   * which will include any preceeding extensions. *)
  let item_expr = mkexp (Pexp_let(lbs.lbs_rec, List.rev bindings, body)) in
  (* Note that for let expression bindings, when there's an extension, the
   * lbs_attributes are attributes on the entire [let ..in x] expression. *)
  match lbs.lbs_extension with
    | None -> item_expr
    | Some ext_id -> extension_expression (lbs.lbs_attributes, ext_id) item_expr

let class_of_let_bindings lbs body =
  let bindings =
    List.map
      (fun lb ->
         if lb.lb_attributes <> [] then
           raise Syntaxerr.(Error(Not_expecting(lb.lb_loc, "item attribute")));
         Vb.mk ~loc:lb.lb_loc lb.lb_pattern lb.lb_expression)
      lbs.lbs_bindings
  in
    if lbs.lbs_extension <> None then
      raise Syntaxerr.(Error(Not_expecting(lbs.lbs_loc, "extension")));
    if lbs.lbs_attributes <> [] then
      raise Syntaxerr.(Error(Not_expecting(lbs.lbs_loc, "attributes")));
    mkclass(Pcl_let (lbs.lbs_rec, List.rev bindings, body))

(*
 * arity_conflict_resolving_mapper is triggered when both "implicit_arity" "explicit_arity"
 * are in the attribtues. In that case we have to remove "explicit_arity"
 *
 * However, if we simply remove explicit_arity, we would end up with a
 * wrapping tuple which has only one component (inner tuple).
 * This is against the invariance where tuples must have 2+ components.
 * Therefore, in the case we have to remove explicit_arity, we also need to
 * unwrap the tuple to expose the inner tuple directly.
 *
 *)
let arity_conflict_resolving_mapper =
{ default_mapper with
  expr = begin fun mapper expr ->
    match expr with
      | {pexp_desc=Pexp_construct(lid, args);
         pexp_loc;
         pexp_attributes} when attributes_conflicted "implicit_arity" "explicit_arity" pexp_attributes ->
         let new_args =
           match args with
             | Some {pexp_desc = Pexp_tuple [sp]} -> Some sp
             | _ -> args in
         default_mapper.expr mapper
         {pexp_desc=Pexp_construct(lid, new_args); pexp_loc; pexp_attributes=
          normalized_attributes "explicit_arity" pexp_attributes}
      | x -> default_mapper.expr mapper x
  end;
  pat = begin fun mapper pattern ->
    match pattern with
      | {ppat_desc=Ppat_construct(lid, args);
         ppat_loc;
         ppat_attributes} when attributes_conflicted "implicit_arity" "explicit_arity" ppat_attributes ->
         let new_args =
           match args with
             | Some {ppat_desc = Ppat_tuple [sp]} -> Some sp
             | _ -> args in
         default_mapper.pat mapper
         {ppat_desc=Ppat_construct(lid, new_args); ppat_loc; ppat_attributes=
          normalized_attributes "explicit_arity" ppat_attributes}
      | x -> default_mapper.pat mapper x
  end;
}

(* NB: making this a function might have parse-time performance penalties *)
let default_mapper_chain () =
  let chain = [default_mapper; arity_conflict_resolving_mapper;
               reason_to_ml_swap_operator_mapper;
               unescape_stars_slashes_mapper]
  in
  if !Reason_config.add_printers then chain @ [create_auto_printer_mapper]
  else chain

let rec string_of_longident = function
    | Lident s -> s
    | Ldot(longPrefix, s) ->
        s
    | Lapply (y,s) -> string_of_longident s

let built_in_explicit_arity_constructors = ["Some"; "Assert_failure"; "Match_failure"]

let jsx_component module_name attrs children loc =
  let firstPart = (List.hd (Longident.flatten module_name)) in
  let lident = if String.get firstPart 0 != '_' && firstPart = String.capitalize firstPart then
    (* firstPart will be non-empty so the 0th access is fine. Modules can't start with underscore *)
    Ldot(module_name, "createElement")
  else
    Lident firstPart
  in
  let ident = mkloc lident loc in
  let body = mkexp(Pexp_apply(mkexp(Pexp_ident ident) ~loc, attrs @ children)) ~loc in
  let attribute = ({txt = "JSX"; loc = loc}, PStr []) in
  { body with pexp_attributes = attribute :: body.pexp_attributes }

let ensureTagsAreEqual startTag endTag loc =
  if startTag <> endTag then
     let startTag = (String.concat "" (Longident.flatten startTag)) in
     let endTag = (String.concat "" (Longident.flatten endTag)) in
     let _ = Location.raise_errorf ~loc "Syntax error: Start tag <%s> does not match end tag </%s>" startTag endTag in
     ()

type object_record =
  | Object_open
  | Object_closed
  | Record

type core_type_object =
  | Core_type of core_type
  | Record_type of label_declaration list

let only_core_type t loc =
  match t with
  | Core_type ct -> ct
  | Record_type _ -> Location.raise_errorf ~loc "Record type is not allowed"

let only_labels l =
  let rec loop label_declarations result =
    match label_declarations with
    | hd :: tail ->
      let (l, a) = hd in
      if (List.length a > 0) then
        syntax_error ()
      else
        loop tail (result @ [l] )
    | [] -> result
  in
  loop l []

%}
%start implementation
%start interface
%start parse_core_type
%start parse_expression
%start parse_pattern
%start toplevel_phrase
%start use_file
%token AMPERAMPER
%token AMPERSAND
%token AND
%token AS
%token ASSERT
%token BACKQUOTE
%token BANG
%token BAR
%token BARBAR
%token BARRBRACKET
%token BEGIN
%token <char> CHAR
%token CLASS
%token COLON
%token COLONCOLON
%token <string> COLONCOLONLIDENT
%token COLONEQUAL
%token COLONGREATER
%token COMMA
%token <string * Location.t> COMMENT
%token CONSTRAINT
%token DO
%token DONE
%token DOT
%token DOTDOT
%token DOTDOTDOT
%token DOWNTO
%token ELSE
%token END
%token EOF
%token EOL
%token EQUAL
%token EQUALGREATER
%token EXCEPTION
%token EXTERNAL
%token FALSE
%token <string * char option> FLOAT
%token FOR
%token FUN
%token FUNCTION
%token FUNCTOR
%token GREATER
%token GREATERRBRACE
%token IF
%token IN
%token INCLUDE
%token <string> INFIXOP0
%token <string> INFIXOP1
%token <string> INFIXOP2
%token <string> INFIXOP3
%token <string> INFIXOP4
%token INHERIT
%token INITIALIZER
%token <string * char option> INT
%token LAZY
%token LBRACE
%token LBRACELESS
%token LBRACKET
%token LBRACKETAT
%token LBRACKETATAT
%token LBRACKETATATAT
%token LBRACKETBAR
%token LBRACKETGREATER
%token LBRACKETLESS
%token LBRACKETPERCENT
%token LBRACKETPERCENTPERCENT
%token LESS
%token LESSDOTDOTGREATER
%token LESSGREATER
%token <string> LESSIDENT
%token LESSMINUS
%token LESSSLASH
%token LESSSLASHGREATER
%token <string> LESSSLASHIDENTGREATER
%token LET
%token <string> LIDENT
%token <string> LIDENTCOLONCOLON
%token LPAREN
%token MINUS
%token MINUSDOT
%token MINUSGREATER
%token MODULE
%token MUTABLE
%token <nativeint> NATIVEINT
%token NEW
%token NONREC
%token OBJECT
%token OF
%token OPEN
%token OPTIONAL_NO_DEFAULT
%token OR
%token PERCENT
%token PLUS
%token PLUSDOT
%token PLUSEQ
%token <string> PREFIXOP
%token PRI
%token PUB
%token QUESTION
%token QUOTE
%token RBRACE
%token RBRACKET
%token REC
%token RPAREN
%token SEMI
%token SEMISEMI
%token SHARP
%token <string> SHARPOP
%token SIG
%token SLASHGREATER
%token STAR
%token <string * string option> STRING
%token STRUCT
%token SWITCH
%token THEN
%token TILDE
%token TO
%token TRUE
%token TRY
%token TYPE
%token <string> UIDENT
%token UNDERSCORE
%token VAL
%token VIRTUAL
%token WHEN
%token WHILE
%token WITH
%nonassoc below_SEMI
%nonassoc below_EQUALGREATER
%right EQUALGREATER
%right COLON
%right EQUAL
%right COLONEQUAL
%nonassoc QUESTION
%nonassoc WITH
%nonassoc AND
%nonassoc ELSE
%nonassoc AS
%nonassoc below_BAR
%left BAR
%right BARBAR OR
%right AMPERAMPER AMPERSAND
%left GREATER INFIXOP0 LESS
%left LESSDOTDOTGREATER LESSGREATER
%right INFIXOP1
%right COLONCOLON
%left INFIXOP2 MINUS MINUSDOT PLUS PLUSDOT PLUSEQ
%left INFIXOP3 PERCENT SLASHGREATER STAR
%right INFIXOP4
%nonassoc prec_unary_minus prec_unary_plus
%nonassoc prec_constant_constructor
%nonassoc prec_constr_appl
%nonassoc below_DOT_AND_SHARP
%nonassoc SHARP
%left SHARPOP
%nonassoc below_DOT
%nonassoc DOT
%nonassoc below_LBRACKETAT
%nonassoc LBRACKETAT
%nonassoc BACKQUOTE BANG CHAR FALSE FLOAT INT LBRACE LBRACELESS LBRACKET LBRACKETBAR LBRACKETLESS LBRACKETPERCENT LESSIDENT LIDENT LPAREN NEW PREFIXOP STRING TRUE UIDENT
%type <Ast_404.Parsetree.structure> implementation
%type <Ast_404.Parsetree.signature> interface
%type <Ast_404.Parsetree.core_type> parse_core_type
%type <Ast_404.Parsetree.expression> parse_expression
%type <Ast_404.Parsetree.pattern> parse_pattern
%type <Ast_404.Parsetree.toplevel_phrase> toplevel_phrase
%type <Ast_404.Parsetree.toplevel_phrase list> use_file
%on_error_reduce _core_type _core_type2 _curried_binding_return_typed _expr _non_arrowed_simple_core_type _pattern_optional_constraint _simple_expr _simple_non_labeled_expr_list_as_tuple _simple_pattern_not_ident _structure_item attributes constr_longident curried_binding expr_optional_constraint less_aggressive_simple_expression let_binding_body let_binding_impl nonrec_flag opt_semi optional_type_parameters pattern post_item_attributes type_constraint_right_of_colon type_longident val_ident
%%

option_LET_:
  
    {    ( None )}
| x = LET
    {    ( Some x )}

option_OF_:
  
    {    ( None )}
| x = OF
    {    ( Some x )}

implementation:
  _1 = structure _2 = EOF
    {                                         ( apply_mapper_chain_to_structure _1 (default_mapper_chain ()) )}

interface:
  _1 = signature _2 = EOF
    {                                         ( apply_mapper_chain_to_signature _1 (default_mapper_chain ()) )}

toplevel_phrase:
  _1 = _toplevel_phrase
    {                                  (apply_mapper_chain_to_toplevel_phrase _1 (default_mapper_chain ()) )}

_toplevel_phrase:
  _1 = structure_item _2 = SEMI
    {                                        ( Ptop_def [_1])}
| _1 = EOF
    {                                        ( raise End_of_file)}
| _1 = toplevel_directive _2 = SEMI
    {                                        ( _1 )}

use_file:
  _1 = _use_file
    {                    (apply_mapper_chain_to_use_file _1 (default_mapper_chain ()))}

_use_file:
  _1 = EOF
    {                                                   ( [] )}
| _1 = structure_item _2 = SEMI _3 = use_file
    {                                                   ( Ptop_def[_1] :: _3 )}
| _1 = toplevel_directive _2 = SEMI _3 = use_file
    {                                                   ( _1 :: _3 )}
| _1 = structure_item _2 = EOF
    {                                                   ( [Ptop_def[_1]] )}
| _1 = toplevel_directive _2 = EOF
    {                                                   ( [_1] )}

parse_core_type:
  _1 = core_type _2 = EOF
    {      (
        let core_loc = mklocation _startpos__1_ _endpos__1_ in
        apply_mapper_chain_to_type (only_core_type _1 core_loc) (default_mapper_chain ())
      )}

parse_expression:
  _1 = expr _2 = EOF
    {             ( apply_mapper_chain_to_expr _1 (default_mapper_chain ()) )}

parse_pattern:
  _1 = pattern _2 = EOF
    {                ( apply_mapper_chain_to_pattern _1 (default_mapper_chain ()) )}

mark_position_mod__module_binding_body_functor_:
  x = _module_binding_body_functor
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 ( {x with pmod_loc = {x.pmod_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_mod__module_expr_:
  x = _module_expr
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 ( {x with pmod_loc = {x.pmod_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_mod__simple_module_expr_:
  x = _simple_module_expr
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 ( {x with pmod_loc = {x.pmod_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_cty__class_constructor_type_:
  x = _class_constructor_type
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 ( {x with pcty_loc = {x.pcty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_cty__class_instance_type_:
  x = _class_instance_type
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 ( {x with pcty_loc = {x.pcty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_cty__non_arrowed_class_constructor_type_:
  x = _non_arrowed_class_constructor_type
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 ( {x with pcty_loc = {x.pcty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_ctf__class_sig_field_:
  x = _class_sig_field
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 ( {x with pctf_loc = {x.pctf_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_exp__curried_binding_return_typed_:
  x = _curried_binding_return_typed
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_exp__expr_:
  x = _expr
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_exp__semi_terminated_seq_expr_:
  x = _semi_terminated_seq_expr
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_exp__semi_terminated_seq_expr_row_:
  x = _semi_terminated_seq_expr_row
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_exp__simple_expr_:
  x = _simple_expr
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_exp__simple_non_labeled_expr_list_as_tuple_:
  x = _simple_non_labeled_expr_list_as_tuple
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_exp_expr_:
  x = expr
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 ( {x with pexp_loc = {x.pexp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_typ__poly_type_:
  x = _poly_type
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 ( {x with ptyp_loc = {x.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_typ__type_variable_:
  x = _type_variable
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 ( {x with ptyp_loc = {x.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_typ2__core_type_:
  x = _core_type
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 (
	match x with
	| Core_type ct -> Core_type ({ct with ptyp_loc = {ct.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}})
	| Record_type _ -> x
	)}

mark_position_typ2__core_type2_:
  x = _core_type2
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 (
	match x with
	| Core_type ct -> Core_type ({ct with ptyp_loc = {ct.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}})
	| Record_type _ -> x
	)}

mark_position_typ2__non_arrowed_non_simple_core_type_:
  x = _non_arrowed_non_simple_core_type
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 (
	match x with
	| Core_type ct -> Core_type ({ct with ptyp_loc = {ct.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}})
	| Record_type _ -> x
	)}

mark_position_typ2__non_arrowed_simple_core_type_:
  x = _non_arrowed_simple_core_type
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 (
	match x with
	| Core_type ct -> Core_type ({ct with ptyp_loc = {ct.ptyp_loc with loc_start = _symbolstartpos; loc_end = _endpos}})
	| Record_type _ -> x
	)}

mark_position_mty__module_declaration_:
  x = _module_declaration
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 ( {x with pmty_loc = {x.pmty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_mty__module_type_:
  x = _module_type
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 ( {x with pmty_loc = {x.pmty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_mty__non_arrowed_module_type_:
  x = _non_arrowed_module_type
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 ( {x with pmty_loc = {x.pmty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_mty__simple_module_type_:
  x = _simple_module_type
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 ( {x with pmty_loc = {x.pmty_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_sig__signature_item_:
  x = _signature_item
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 ( {x with psig_loc = {x.psig_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_str__structure_item_:
  x = _structure_item
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 ( {x with pstr_loc = {x.pstr_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_str__structure_item_without_item_extension_sugar_:
  x = _structure_item_without_item_extension_sugar
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 ( {x with pstr_loc = {x.pstr_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_cl__class_expr_:
  x = _class_expr
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_cl__class_expr_lets_and_rest_:
  x = _class_expr_lets_and_rest
    {let _endpos = _endpos_x_ in
let _symbolstartpos = if _startpos_x_ != _endpos_x_ then
  _startpos_x_
else
  _endpos in
 ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_cl__class_fun_binding_:
  x = _class_fun_binding
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_cl__class_fun_def_:
  x = _class_fun_def
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_cl__class_simple_expr_:
  x = _class_simple_expr
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_cl__constrained_class_declaration_:
  x = _constrained_class_declaration
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 ( {x with pcl_loc = {x.pcl_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_cf__class_field_:
  x = _class_field
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 ( {x with pcf_loc = {x.pcf_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_pat__class_self_pattern_:
  x = _class_self_pattern
    {let _endpos = _endpos_x_ in
let _symbolstartpos = if _startpos_x_ != _endpos_x_ then
  _startpos_x_
else
  _endpos in
 ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_pat__or_pattern_:
  x = _or_pattern
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_pat__pattern_optional_constraint_:
  x = _pattern_optional_constraint
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_pat__pattern_without_or_:
  x = _pattern_without_or
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_pat__simple_pattern_:
  x = _simple_pattern
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

mark_position_pat__simple_pattern_not_ident_:
  x = _simple_pattern_not_ident
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
 ( {x with ppat_loc = {x.ppat_loc with loc_start = _symbolstartpos; loc_end = _endpos}} )}

functor_arg:
  _1 = LPAREN _2 = RPAREN
    { ( mkloc "*" (mklocation _startpos__2_ _endpos__2_), None )}
| _1 = LPAREN x = functor_arg_name _3 = COLON _4 = module_type _5 = RPAREN
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( _2, Some _4 )}

functor_arg_name:
  _1 = UIDENT
    {               ( _1 )}
| _1 = UNDERSCORE
    {               ( "_" )}

functor_args:
  _1 = functor_args _2 = functor_arg
    {      ( _2 :: _1 )}
| _1 = functor_arg
    {      ( [ _1 ] )}

simple_module_expr:
  _1 = mark_position_mod__simple_module_expr_
    {                                                           (_1)}

_simple_module_expr:
  x = mod_longident
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( mkmod(Pmod_ident _1) )}
| _1 = LBRACE _2 = structure _3 = RBRACE
    {      ( mkmod(Pmod_structure(_2)) )}
| _1 = LPAREN _2 = module_expr _3 = COLON _4 = module_type _5 = RPAREN
    {      ( mkmod(Pmod_constraint(_2, _4)) )}
| x = LPAREN _2 = module_expr _3 = COLON _4 = module_type x_inlined1 = error
    {let _5 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( unclosed_mod (with_txt _1 "(") (with_txt _5 ")"))}
| _1 = LPAREN _2 = module_expr _3 = RPAREN
    {      ( _2 )}
| _1 = LPAREN _2 = VAL _3 = expr _4 = RPAREN
    {      ( mkmod(Pmod_unpack _3) )}
| _1 = LPAREN _2 = VAL _3 = expr _4 = COLON _5 = package_type _6 = RPAREN
    {let _endpos = _endpos__6_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        mkmod (Pmod_unpack(
               mkexp ~ghost:true ~loc (Pexp_constraint(_3, mktyp ~ghost:true ~loc (Ptyp_package _5))))) )}
| _1 = LPAREN _2 = VAL _3 = expr _4 = COLON _5 = package_type _6 = COLONGREATER _7 = package_type _8 = RPAREN
    {let _endpos = _endpos__8_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        mkmod (Pmod_unpack(
               mkexp ~ghost:true ~loc (Pexp_coerce(_3, Some(mktyp ~ghost:true ~loc (Ptyp_package _5)),
                                      mktyp ~ghost:true ~loc (Ptyp_package _7))))) )}
| _1 = LPAREN _2 = VAL _3 = expr _4 = COLONGREATER _5 = package_type _6 = RPAREN
    {let _endpos = _endpos__6_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        mkmod (Pmod_unpack(
               mkexp ~ghost:true ~loc (Pexp_coerce(_3, None, mktyp ~ghost:true ~loc (Ptyp_package _5))))) )}
| _1 = LPAREN _2 = RPAREN
    {      ( mkmod (Pmod_structure []) )}
| _1 = extension
    {      ( mkmod (Pmod_extension _1) )}

module_expr:
  _1 = mark_position_mod__module_expr_
    {                                             (_1)}

_module_expr:
  _1 = simple_module_expr
    {      ( _1 )}
| _1 = FUN _2 = functor_args _3 = EQUALGREATER _4 = module_expr
    {      ( mkFunctorThatReturns _2 _4 )}
| _1 = module_expr _2 = simple_module_expr
    {      ( mkmod (Pmod_apply(_1, _2)) )}
| _1 = module_expr x = LPAREN _3 = module_expr x_inlined1 = error
    {let _4 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( unclosed_mod (with_txt _2 "(") (with_txt _4 ")") )}
| x = LPAREN _2 = module_expr x_inlined1 = error
    {let _3 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( unclosed_mod (with_txt _1 "(") (with_txt _3 ")") )}
| x = LPAREN _2 = VAL _3 = expr _4 = COLON x_inlined1 = error
    {let _5 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( unclosed_mod (with_txt _1 "(") (with_txt _5 ")") )}
| x = LPAREN _2 = VAL _3 = expr _4 = COLONGREATER x_inlined1 = error
    {let _5 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( unclosed_mod (with_txt _1 "(") (with_txt _5 ")") )}
| x = LPAREN _2 = VAL _3 = expr x_inlined1 = error
    {let _4 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( unclosed_mod (with_txt _1 "(") (with_txt _4 ")") )}
| _1 = module_expr _2 = attribute
    {      ( Mod.attr _1 _2 )}

structure:
  
    {                ( [] )}
| x = error _2 = structure
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
                            (
    let menhirError = Syntax_util.findMenhirErrorMessage _1.loc in
    match menhirError with
      | MenhirMessagesError errMessage -> (syntax_error_str errMessage.loc errMessage.msg) :: _2
      | _ -> (syntax_error_str _1.loc "Invalid statement") :: _2
  )}
| x = error _2 = SEMI _3 = structure
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
                                 (
    let menhirError = Syntax_util.findMenhirErrorMessage _1.loc in
    match menhirError with
      | MenhirMessagesError errMessage -> (syntax_error_str errMessage.loc errMessage.msg) :: _3
      | _ -> (syntax_error_str _1.loc "Invalid statement") :: _3
    )}
| _1 = structure_item
    {                   ( [_1] )}
| x = structure_item _2 = error _3 = structure
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
                                           (
    let menhirError = Syntax_util.findMenhirErrorMessage _1.loc in
    match menhirError with
      | MenhirMessagesError errMessage -> (syntax_error_str errMessage.loc errMessage.msg) :: _3
      | _ -> (syntax_error_str _1.loc "Statement has to end with a semicolon") :: _3
  )}
| _1 = structure_item _2 = SEMI _3 = structure
    {                                  (
      let effective_loc = mklocation _startpos__1_ _endpos__2_ in
      set_structure_item_location _1 effective_loc :: _3
  )}

structure_item:
  _1 = mark_position_str__structure_item_
    {                                                   (_1)}

_structure_item:
  _1 = item_extension_sugar _2 = structure_item_without_item_extension_sugar
    {                                                                     (
    struct_item_extension _1 _2
  )}
| _1 = structure_item_without_item_extension_sugar
    {                                                (
    _1
  )}
| _1 = let_bindings
    {                 ( val_of_let_bindings _1 )}

structure_item_without_item_extension_sugar:
  _1 = mark_position_str__structure_item_without_item_extension_sugar_
    {                                                                  (_1)}

_structure_item_without_item_extension_sugar:
  _1 = expr _2 = post_item_attributes
    {                              (
      mkstrexp _1 _2
    )}
| _1 = EXTERNAL x = val_ident _3 = COLON _4 = core_type _5 = EQUAL _6 = primitive_declaration _7 = post_item_attributes
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__7_ in
let _symbolstartpos = _startpos__1_ in
                                                                                                (
      let loc = mklocation _symbolstartpos _endpos in
      let core_loc = mklocation _startpos__4_ _endpos__4_ in
      mkstr
        (Pstr_primitive (Val.mk _2 (only_core_type _4 core_loc) ~prim:_6 ~attrs:_7 ~loc))
    )}
| _1 = many_type_declarations
    {                           (
      let (nonrec_flag, tyl) = _1 in
      mkstr(Pstr_type (nonrec_flag, List.rev tyl))
    )}
| _1 = str_type_extension
    {                       (
      mkstr(Pstr_typext _1)
    )}
| _1 = str_exception_declaration
    {                              (
      mkstr(Pstr_exception _1)
    )}
| _1 = opt_let_module _2 = nonlocal_module_binding_details _3 = post_item_attributes
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
                                                                        (
      let (ident, body) = _2 in
      let loc = mklocation _symbolstartpos _endpos in
      mkstr(Pstr_module (Mb.mk ident body ~attrs:_3 ~loc))
    )}
| _1 = many_nonlocal_module_bindings
    {                                  (
      mkstr(Pstr_recmodule(List.rev _1))
    )}
| _1 = MODULE _2 = TYPE _3 = option_OF_ x = ident _5 = post_item_attributes
    {let _4 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
                                                       (
      let item_attrs = _5 in
      let ident = _4 in
      let loc = mklocation _symbolstartpos _endpos in
      mkstr(Pstr_modtype (Mtd.mk ident ~attrs:item_attrs ~loc))
    )}
| _1 = MODULE _2 = TYPE _3 = option_OF_ x = ident _5 = EQUAL _6 = module_type _7 = post_item_attributes
    {let _4 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__7_ in
let _symbolstartpos = _startpos__1_ in
                                                                         (
      let ident = _4 in
      let loc = mklocation _symbolstartpos _endpos in
      mkstr(Pstr_modtype (Mtd.mk ident ~typ:_6 ~attrs:_7 ~loc))
    )}
| _1 = open_statement
    {                   (
      mkstr(Pstr_open _1)
    )}
| _1 = many_class_declarations
    {                            (
      (* Each declaration has their own preceeding post_item_attributes *)
      mkstr(Pstr_class (List.rev _1))
    )}
| _1 = many_class_type_declarations
    {                                 (
      (* Each declaration has their own preceeding post_item_attributes *)
      mkstr(Pstr_class_type (List.rev _1))
    )}
| _1 = INCLUDE _2 = module_expr _3 = post_item_attributes
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
                                             (
      let loc = mklocation _symbolstartpos _endpos in
      mkstr(Pstr_include (Incl.mk _2 ~attrs:_3 ~loc))
    )}
| _1 = item_extension _2 = post_item_attributes
    {                                        (
    (* No sense in having item_extension_sugar for something that's already an
     * item_extension *)
    mkstr(Pstr_extension (_1, _2))
  )}
| _1 = floating_attribute
    {      ( mkstr(Pstr_attribute _1) )}

module_binding_body_expr:
  _1 = EQUAL _2 = module_expr
    {      ( _2 )}
| _1 = COLON _2 = module_type _3 = EQUAL _4 = module_expr
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        mkmod ~loc (Pmod_constraint(_4, _2))
      )}

module_binding_body_functor:
  _1 = mark_position_mod__module_binding_body_functor_
    {                                                                             (_1)}

_module_binding_body_functor:
  _1 = functor_args _2 = EQUALGREATER _3 = module_expr
    {                                          (
      mkFunctorThatReturns _1 _3
    )}
| _1 = functor_args _2 = COLON _3 = non_arrowed_module_type _4 = EQUALGREATER _5 = module_expr
    {                                                                        (
      let loc = mklocation _startpos__5_ _endpos__5_ in
      mkFunctorThatReturns _1 (mkmod ~loc (Pmod_constraint(_5, _3)))
    )}

module_binding_body:
  _1 = module_binding_body_expr
    {                             ( _1 )}
| _1 = module_binding_body_functor
    {                                ( _1 )}

many_nonlocal_module_bindings:
  _1 = opt_let_module _2 = REC _3 = nonlocal_module_binding_details _4 = post_item_attributes
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
                                                                            (
    let (ident, body) = _3 in
    let loc = mklocation _symbolstartpos _endpos in
    [Mb.mk ident body ~attrs:_4 ~loc]
  )}
| _1 = many_nonlocal_module_bindings _2 = and_nonlocal_module_bindings
    {                                                               (
    _2::_1
  )}

and_nonlocal_module_bindings:
  _1 = AND _2 = nonlocal_module_binding_details _3 = post_item_attributes
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
                                                             (
    let (ident, body) = _2 in
    let loc = mklocation _symbolstartpos _endpos in
    Mb.mk ident body ~attrs:_3 ~loc
  )}

nonlocal_module_binding_details:
  x = UIDENT _2 = module_binding_body
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
                                      (
      (_1, _2)
    )}

non_arrowed_module_type:
  _1 = mark_position_mty__non_arrowed_module_type_
    {                                                                     (_1)}

_non_arrowed_module_type:
  _1 = simple_module_type
    {                       (_1)}
| _1 = MODULE _2 = TYPE _3 = OF _4 = module_expr %prec below_LBRACKETAT
    {      ( mkmty(Pmty_typeof _4) )}
| _1 = module_type _2 = attribute
    {      ( Mty.attr _1 _2 )}

simple_module_type:
  _1 = mark_position_mty__simple_module_type_
    {                                                           (_1)}

_simple_module_type:
  _1 = LPAREN _2 = module_type _3 = RPAREN
    {      ( _2 )}
| x = LPAREN _2 = module_type x_inlined1 = error
    {let _3 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( unclosed_mty (with_txt _1 "(") (with_txt _3 ")"))}
| x = mty_longident
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( mkmty(Pmty_ident _1) )}
| _1 = LBRACE _2 = signature _3 = RBRACE
    {      ( mkmty(Pmty_signature _2) )}
| x = LBRACE _2 = signature x_inlined1 = error
    {let _3 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( unclosed_mty (with_txt _1 "{") (with_txt _3 "}"))}
| _1 = extension
    {      ( mkmty(Pmty_extension _1) )}

module_type:
  _1 = mark_position_mty__module_type_
    {                                             (_1)}

_module_type:
  _1 = module_type _2 = WITH _3 = with_constraints
    {                                      (
    (* See note above about why WITH constraints aren't considered
     * non-arrowed.
     * We might just consider unifying the syntax for record extension with
     * module extension/WITH constraints.
     *
     *    mod MyModule = {
     *       ModuleToInclude...
     *    };
     *
     *    let module CreateFactory
     *               (Spec: ContainerSpec)
     *               :{DescriptorFactoryIntf.S with
     *                  type props = Spec.props and type dependencies = Spec.props} =>
     *
     *)
    mkmty(Pmty_with(_1, List.rev _3))
  )}
| _1 = non_arrowed_module_type %prec below_EQUALGREATER
    {                                                     (
    (* below_EQUALGREATER to prevent following shift reduce conflict:
     *  1158: shift/reduce conflict (shift 1285, reduce 75) on EQUALGREATER
     *  state 1158
     *    module_binding_body_functor : functor_args COLON non_arrowed_module_type . EQUALGREATER module_expr  (59)
     *    module_type : non_arrowed_module_type .  (75)
     *
     *    EQUALGREATER  shift 1285
     *    LBRACKETAT  reduce 75
     *    WITH  reduce 75
     *)
    _1
  )}
| _1 = LPAREN x = functor_arg_name _3 = COLON _4 = module_type _5 = RPAREN _6 = EQUALGREATER _7 = module_type %prec below_SEMI
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
                                                                                                       (
    (* Why does this rule cause a conflict with core_type2? It has nothing to do
     * with it.
     *
     * Update: I'm guessing it has something to do with the fact that this isn't
     * parsed correctly because the => is considered part of "type dependenences" :
     *
     *    let module CreateFactory
     *               (Spec: ContainerSpec)
     *               :DescriptorFactoryIntf.S with
     *                  type props = Spec.props and type dependencies = Spec.props =>
     *)
      mkmty(Pmty_functor(_2, Some _4, _7))
     )}
| _1 = module_type _2 = EQUALGREATER _3 = module_type %prec below_SEMI
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
                                                          (
      (**
       * In OCaml, this is invalid:
       * module MyFunctor: functor MT -> (sig end) = functor MT -> (struct end);;
       *
       * Not only must curried functor args have annotations, but functor
       * annotations must include *names* for each argument in a functor type.
       *
       * module MyFunctor: functor (MT:MT) -> (sig end) = functor (MT:MT) -> (struct end)
       *
       * In Reason, we will parse the functor type:
       *
       *    (AB:MT) -> ReturnSig
       *
       * as in:
       *                   /----------------\
       * module MyFunctor: (A:B) => ReturnSig = functor (C:D) => {}
       *
       * But only for the sake of compatibility with existing OCaml code (the
       * ability to "view" OCaml code in Reason's syntax without loss of
       * information.) Do not write identifiers in functor argument type
       * positions - you wouldn't do it with functions, and they are
       * meaningless in functors.
       *
       *  But for sake of consistency (and for sake of a syntax that truly
       *  unifies functor syntax with function syntax, the following "sugars"
       *  will be parsed (and printed):
       *
       *   A => B => C
       *
       * Is parsed into:
       *
       * functor (_:A) -> functor (_:B) -> C
       *
       * And a dummy "_" is inserted into the parse tree where no name has been
       * provided.
       *
       *   {SomeSig} => {} => {}
       *
       * Is parsed into:
       *
       * (_:SomeSig) => (_:{}) => {}
       *
       *
       *)
      let loc = mklocation _symbolstartpos _endpos in
      mkmty(Pmty_functor(ghloc ~loc "_", Some _1, _3))
    )}

signature:
  
    {                         ( [] )}
| _1 = signature_item _2 = SEMI _3 = signature
    {                                  ( _1 :: _3 )}

signature_item:
  _1 = mark_position_sig__signature_item_
    {                                                   ( _1 )}

_signature_item:
  _1 = LET x = val_ident _3 = COLON _4 = core_type _5 = post_item_attributes
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
                                                               (
        let loc = mklocation _symbolstartpos _endpos in
        let core_type_loc = mklocation _startpos__4_ _endpos__4_ in
        mksig(Psig_value (Val.mk _2 (only_core_type _4 core_type_loc) ~attrs:_5 ~loc))
    )}
| _1 = EXTERNAL x = val_ident _3 = COLON _4 = core_type _5 = EQUAL _6 = primitive_declaration _7 = post_item_attributes
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__7_ in
let _symbolstartpos = _startpos__1_ in
                                                                                                (
      let loc = mklocation _symbolstartpos _endpos in
      let core_type_loc = mklocation _startpos__4_ _endpos__4_ in
      mksig(Psig_value (Val.mk _2 (only_core_type _4 core_type_loc) ~prim:_6 ~attrs:_7 ~loc))
    )}
| _1 = many_type_declarations
    {                           (
        let (nonrec_flag, tyl) = _1 in
        mksig(Psig_type (nonrec_flag, List.rev tyl))
    )}
| _1 = sig_type_extension
    {                       (
      mksig(Psig_typext _1)
    )}
| _1 = sig_exception_declaration
    {                              (
      mksig(Psig_exception _1)
    )}
| _1 = opt_let_module x = UIDENT _3 = module_declaration _4 = post_item_attributes
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
                                                                          (
      let loc = mklocation _symbolstartpos _endpos in
      mksig(Psig_module (Md.mk _2 _3 ~attrs:_4 ~loc))
    )}
| _1 = opt_let_module x = UIDENT _3 = EQUAL x_inlined1 = mod_longident _5 = post_item_attributes
    {let _4 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let (_endpos__4_, _startpos__4_) = (_endpos_x_inlined1_, _startpos_x_inlined1_) in
let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
                                                                                   (
      let loc = mklocation _symbolstartpos _endpos in
      let loc_mod = mklocation _startpos__4_ _endpos__4_ in
      mksig(
        Psig_module (
          Md.mk
            _2
            (Mty.alias ~loc:loc_mod _4)
            ~attrs:_5
            ~loc
        )
      )
    )}
| _1 = many_module_rec_declarations
    {                                 (
      mksig(Psig_recmodule (List.rev _1))
    )}
| _1 = MODULE _2 = TYPE x = ident _4 = post_item_attributes
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
                                                   (
      let loc = mklocation _symbolstartpos _endpos in
      mksig(Psig_modtype (Mtd.mk _3 ~attrs:_4 ~loc))
    )}
| _1 = MODULE _2 = TYPE x = ident _4 = EQUAL _5 = module_type _6 = post_item_attributes
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__6_ in
let _symbolstartpos = _startpos__1_ in
                                                                     (
      let loc = mklocation _symbolstartpos _endpos in
      mksig(Psig_modtype (Mtd.mk _3 ~typ:_5 ~loc ~attrs:_6))
    )}
| _1 = open_statement
    {                   (
      mksig(Psig_open _1)
    )}
| _1 = INCLUDE _2 = module_type _3 = post_item_attributes
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
                                             (
      let loc = mklocation _symbolstartpos _endpos in
      mksig(Psig_include (Incl.mk _2 ~attrs:_3 ~loc))
    )}
| _1 = many_class_descriptions
    {                            (
      mksig(Psig_class (List.rev _1))
    )}
| _1 = many_class_type_declarations
    {                                 (
      mksig(Psig_class_type (List.rev _1))
    )}
| _1 = item_extension _2 = post_item_attributes
    {                                        (
      mksig(Psig_extension (_1, _2))
    )}
| _1 = floating_attribute
    {                       (
      mksig(Psig_attribute _1)
    )}

open_statement:
  _1 = OPEN _2 = override_flag x = mod_longident _4 = post_item_attributes
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        Opn.mk _3 ~override:_2 ~attrs:_4 ~loc
      )}

module_declaration:
  _1 = mark_position_mty__module_declaration_
    {                                                           (_1)}

_module_declaration:
  _1 = COLON _2 = module_type
    {      ( _2 )}
| _1 = LPAREN x = UIDENT _3 = COLON _4 = module_type _5 = RPAREN _6 = module_declaration
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( mkmty(Pmty_functor(_2, Some _4, _6)) )}
| _1 = LPAREN _2 = RPAREN _3 = module_declaration
    {      ( mkmty(Pmty_functor(mkloc "*" (mklocation _startpos__1_ _endpos__1_), None, _3)) )}

module_rec_declaration_details:
  x = UIDENT _2 = COLON _3 = module_type
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
                                     ( (_1, _3) )}

many_module_rec_declarations:
  _1 = opt_let_module _2 = REC _3 = module_rec_declaration_details _4 = post_item_attributes
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
                                                                           (
      let (ident, body) = _3 in
      let loc = mklocation _symbolstartpos _endpos in
      [Md.mk ident body ~attrs:_4 ~loc]
    )}
| _1 = many_module_rec_declarations _2 = and_module_rec_declaration
    {                                                             (
      _2::_1
    )}

and_module_rec_declaration:
  _1 = AND _2 = module_rec_declaration_details _3 = post_item_attributes
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
                                                            (
      let (ident, body) = _2 in
      let loc = mklocation _symbolstartpos _endpos in
      Md.mk ident body ~attrs:_3 ~loc
    )}

many_class_declarations:
  _1 = CLASS _2 = class_declaration_details _3 = post_item_attributes
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
                                                         (
    let (ident, binding, virt, params) = _2 in
    let loc = mklocation _symbolstartpos _endpos in
    [Ci.mk ident binding ~virt ~params ~attrs:_3 ~loc]
  )}
| _1 = many_class_declarations _2 = and_class_declaration
    {                                                  (
    _2::_1
  )}

and_class_declaration:
  _1 = AND _2 = class_declaration_details _3 = post_item_attributes
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
                                                     (
    let (ident, binding, virt, params) = _2 in
    let loc = mklocation _symbolstartpos _endpos in
    Ci.mk ident binding ~virt ~params ~attrs:_3 ~loc
  )}

constrained_class_declaration:
  _1 = mark_position_cl__constrained_class_declaration_
    {                                                                                (_1)}

_constrained_class_declaration:
  _1 = COLON _2 = class_constructor_type _3 = EQUAL _4 = class_expr
    {      ( mkclass(Pcl_constraint(_4, _2)) )}

class_declaration_details:
  _1 = virtual_flag x = LIDENT _3 = class_type_parameters _4 = class_fun_binding
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      (
       (_2, _4, _1, List.rev _3)
      )}
| _1 = virtual_flag x = LIDENT _3 = class_type_parameters _4 = constrained_class_declaration
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    (
       (_2, _4, _1, List.rev _3)
    )}
| _1 = virtual_flag x = LIDENT _3 = class_type_parameters _4 = EQUAL _5 = class_expr
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    (
       (_2, _5, _1, List.rev _3)
    )}

class_fun_binding:
  _1 = mark_position_cl__class_fun_binding_
    {                                                        (_1)}

_class_fun_binding:
  _1 = labeled_simple_pattern _2 = class_fun_binding
    {      ( let (l,o,p) = _1 in mkclass(Pcl_fun(l, o, p, _2)) )}
| _1 = labeled_simple_pattern _2 = class_fun_return
    {      ( let (l,o,p) = _1 in mkclass(Pcl_fun(l, o, p, _2)) )}

class_fun_return:
  _1 = EQUALGREATER _2 = class_expr
    {      ( _2 )}
| _1 = COLON _2 = non_arrowed_class_constructor_type _3 = EQUALGREATER _4 = class_expr
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        mkclass ~loc (Pcl_constraint(_4, _2))
      )}

class_type_parameters:
  
    {              ( [] )}
| _1 = class_type_parameters _2 = type_parameter
    {                                         (
      _2::_1
    )}

class_fun_def:
  _1 = mark_position_cl__class_fun_def_
    {                                               (_1)}

_class_fun_def:
  _1 = labeled_simple_pattern _2 = EQUALGREATER _3 = class_expr
    {      ( let (l,o,p) = _1 in mkclass(Pcl_fun(l, o, p, _3)) )}
| _1 = labeled_simple_pattern _2 = class_fun_def
    {      ( let (l,o,p) = _1 in mkclass(Pcl_fun(l, o, p, _2)) )}

class_expr_lets_and_rest:
  _1 = mark_position_cl__class_expr_lets_and_rest_
    {                                                                      (_1)}

_class_expr_lets_and_rest:
  _1 = class_self_pattern_and_structure
    {                                     ( mkclass(Pcl_structure _1))}
| _1 = class_expr
    {               (_1)}
| _1 = let_bindings _2 = SEMI _3 = class_expr_lets_and_rest
    {                                               (
    class_of_let_bindings _1 _3
  )}

class_self_pattern:
  _1 = mark_position_pat__class_self_pattern_
    {                                                           (_1)}

_class_self_pattern:
  
    {let _endpos = _endpos__0_ in
let _symbolstartpos = _endpos in
    (
    let loc = mklocation _symbolstartpos _endpos in
    mkpat (Ppat_var (mkloc "this" loc))
  )}
| _1 = AS _2 = pattern _3 = SEMI
    {      ( _2 )}

class_self_pattern_and_structure:
  _1 = class_self_pattern _2 = semi_terminated_class_fields
    {    ( Cstr.mk _1 _2 )}

class_expr:
  _1 = mark_position_cl__class_expr_
    {                                          (_1)}

_class_expr:
  _1 = class_simple_expr
    {      ( _1 )}
| _1 = FUN _2 = class_fun_def
    {      ( _2 )}
| _1 = class_simple_expr _2 = simple_labeled_expr_list
    {      ( mkclass(Pcl_apply(_1, List.rev _2)) )}
| _1 = class_expr _2 = attribute
    {      ( Cl.attr _1 _2 )}
| _1 = CLASS x = class_longident
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
                                  (
      mkclass(Pcl_constr(_2, []))
    )}
| _1 = CLASS x = class_longident _3 = non_arrowed_simple_core_type_list
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
                                                                    (
      mkclass(Pcl_constr(_2, List.rev _3))
    )}
| _1 = extension
    {      ( mkclass(Pcl_extension _1) )}

class_simple_expr:
  _1 = mark_position_cl__class_simple_expr_
    {                                                        (_1)}

_class_simple_expr:
  x = class_longident
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( mkclass(Pcl_constr(_1, [])) )}
| _1 = LBRACE _2 = class_expr_lets_and_rest _3 = RBRACE
    {                                           ( _2 )}
| x = LBRACE _2 = class_expr_lets_and_rest x_inlined1 = error
    {let _3 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( unclosed_cl (with_txt _1 "{") (with_txt _3 "}") )}
| _1 = LPAREN _2 = class_expr _3 = COLON _4 = class_constructor_type _5 = RPAREN
    {      ( mkclass(Pcl_constraint(_2, _4)) )}
| x = LPAREN _2 = class_expr _3 = COLON _4 = class_constructor_type x_inlined1 = error
    {let _5 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( unclosed_cl (with_txt _1 "(") (with_txt _5 ")") )}
| _1 = LPAREN _2 = class_expr _3 = RPAREN
    {      ( _2 )}
| x = LPAREN _2 = class_expr x_inlined1 = error
    {let _3 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( unclosed_cl (with_txt _1 "(") (with_txt _3 ")") )}

class_field:
  _1 = mark_position_cf__class_field_
    {                                            (_1)}

_class_field:
  _1 = INHERIT _2 = override_flag _3 = class_expr _4 = parent_binder _5 = post_item_attributes
    {      ( mkcf_attrs (Pcf_inherit (_2, _3, _4)) _5 )}
| _1 = VAL _2 = value _3 = post_item_attributes
    {      ( mkcf_attrs (Pcf_val _2) _3 )}
| _1 = PUB _2 = method_ _3 = post_item_attributes
    {      ( let (a, b) = _2 in mkcf_attrs (Pcf_method (a, Public, b)) _3 )}
| _1 = PRI _2 = method_ _3 = post_item_attributes
    {        ( let (a, b) = _2 in mkcf_attrs (Pcf_method (a, Private, b)) _3 )}
| _1 = CONSTRAINT _2 = constrain_field _3 = post_item_attributes
    {      ( mkcf_attrs (Pcf_constraint _2) _3 )}
| _1 = INITIALIZER _2 = EQUALGREATER _3 = expr _4 = post_item_attributes
    {      ( mkcf_attrs (Pcf_initializer _3) _4 )}
| _1 = item_extension _2 = post_item_attributes
    {      ( mkcf_attrs (Pcf_extension _1) _2 )}
| _1 = floating_attribute
    {      ( mkcf (Pcf_attribute _1) )}

semi_terminated_class_fields:
  
    {                          ([])}
| _1 = class_field
    {                          ( [_1] )}
| _1 = class_field _2 = SEMI _3 = semi_terminated_class_fields
    {                                                    ( _1::_3 )}

parent_binder:
  _1 = AS _2 = LIDENT
    {          ( Some _2 )}
| 
    {          ( None )}

value:
  _1 = override_flag _2 = MUTABLE _3 = VIRTUAL x = label _5 = COLON _6 = core_type
    {let _4 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let (_endpos__4_, _startpos__4_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__6_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
                                                                (
      let core_type_loc = mklocation _startpos__4_ _endpos__4_ in
      if _1 = Override
      then not_expecting _symbolstartpos _endpos "members marked virtual may not also be marked overridden"
      else _4, Mutable, Cfk_virtual (only_core_type _6 core_type_loc)
    )}
| _1 = override_flag _2 = MUTABLE _3 = VIRTUAL _4 = label _5 = COLON _6 = core_type _7 = EQUAL
    {      ( not_expecting _startpos__7_ _endpos__7_ "not expecting equal - cannot specify value for virtual val" )}
| _1 = VIRTUAL _2 = mutable_flag x = label _4 = COLON _5 = core_type
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      (
        let core_type_loc = mklocation _startpos__5_ _endpos__5_ in
        _3, _2, Cfk_virtual (only_core_type _5 core_type_loc)
      )}
| _1 = VIRTUAL _2 = mutable_flag _3 = label _4 = COLON _5 = core_type _6 = EQUAL
    {      ( not_expecting _startpos__6_ _endpos__6_ "not expecting equal - cannot specify value for virtual val" )}
| _1 = override_flag _2 = mutable_flag x = label _4 = EQUAL _5 = expr
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( _3, _2, Cfk_concrete (_1, _5) )}
| _1 = override_flag _2 = mutable_flag x = label _4 = type_constraint _5 = EQUAL _6 = expr
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _startpos__3_ = _startpos_x_ in
let _endpos = _endpos__6_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  if _startpos__2_ != _endpos__2_ then
    _startpos__2_
  else
    _startpos__3_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        let e = ghexp_constraint loc _6 _4 in
        _3, _2, Cfk_concrete (_1, e)
      )}

method_:
  _1 = override_flag _2 = VIRTUAL x = label _4 = COLON _5 = poly_type
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( if _1 = Override then syntax_error ();
        _3, Cfk_virtual _5 )}
| _1 = override_flag x = label _3 = curried_binding
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _startpos__2_ = _startpos_x_ in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
      ( _2,
        Cfk_concrete (_1, let loc = mklocation _symbolstartpos _endpos in mkexp ~ghost:true ~loc (Pexp_poly (_3, None))) )}
| _1 = override_flag x = label _3 = COLON _4 = poly_type _5 = EQUAL _6 = expr
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _startpos__2_ = _startpos_x_ in
let _endpos = _endpos__6_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
      ( _2,
        Cfk_concrete (_1, let loc = mklocation _symbolstartpos _endpos in mkexp ~ghost:true ~loc (Pexp_poly(_6, Some _4))) )}
| _1 = override_flag x = label _3 = EQUAL _4 = expr
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _startpos__2_ = _startpos_x_ in
let _endpos = _endpos__4_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
      ( _2,
        Cfk_concrete (_1, let loc = mklocation _symbolstartpos _endpos in mkexp ~ghost:true ~loc (Pexp_poly(_4, None))) )}
| _1 = override_flag x = label _3 = COLON _4 = TYPE _5 = lident_list _6 = DOT _7 = core_type _8 = EQUAL _9 = expr
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _startpos__2_ = _startpos_x_ in
let _endpos = _endpos__9_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
      (
        let core_type_loc = mklocation _startpos__7_ _endpos__7_ in
        (* For non, methods we'd create a pattern binding:
           ((Ppat_constraint(mkpatvar ..., Ptyp_poly (typeVars, poly_type_varified))),
            exp_with_newtypes_constrained_by_non_varified)

           For methods, we create:
           Pexp_poly (Pexp_constraint (methodFunWithNewtypes, non_varified), Some (Ptyp_poly newTypes varified))
         *)
        let (exp_with_newtypes_constrained_by_non_varified, poly_type_varified) =
          wrap_type_annotation _5 (only_core_type _7 core_type_loc) _9 in
        (
          _2,
          Cfk_concrete (
            _1,
            let loc = mklocation _symbolstartpos _endpos in
            mkexp ~ghost:true ~loc (Pexp_poly(exp_with_newtypes_constrained_by_non_varified, Some poly_type_varified))
          )
        )
      )}

class_constructor_type:
  _1 = mark_position_cty__class_constructor_type_
    {                                                                   (_1)}

_class_constructor_type:
  _1 = NEW _2 = class_instance_type
    {      ( _2 )}
| _1 = LIDENTCOLONCOLON _2 = QUESTION _3 = non_arrowed_core_type _4 = EQUALGREATER _5 = class_constructor_type
    {      (
        let core_type_loc = mklocation _startpos__3_ _endpos__3_ in
        let ct = only_core_type _3 core_type_loc in
        mkcty(Pcty_arrow(Optional _1, ct, _5))
       )}
| _1 = LIDENTCOLONCOLON _2 = non_arrowed_core_type _3 = EQUALGREATER _4 = class_constructor_type
    {      (
        let core_type_loc = mklocation _startpos__2_ _endpos__2_ in
        let ct = only_core_type _2 core_type_loc in
        mkcty(Pcty_arrow(Labelled _1, ct, _4))
      )}
| _1 = non_arrowed_core_type _2 = EQUALGREATER _3 = class_constructor_type
    {      (
        let core_type_loc = mklocation _startpos__1_ _endpos__1_ in
        let ct = only_core_type _1 core_type_loc in
        mkcty(Pcty_arrow(Nolabel, ct, _3))
      )}

non_arrowed_class_constructor_type:
  _1 = mark_position_cty__non_arrowed_class_constructor_type_
    {                                                                                           (_1)}

_non_arrowed_class_constructor_type:
  _1 = class_instance_type
    {      ( _1 )}
| _1 = LPAREN _2 = class_constructor_type _3 = RPAREN
    {                                         ( _2)}

class_instance_type:
  _1 = mark_position_cty__class_instance_type_
    {                                                             (_1)}

_class_instance_type:
  x = clty_longident
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( mkcty(Pcty_constr (_1, [])) )}
| x = clty_longident _2 = non_arrowed_simple_core_type_list
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( mkcty(Pcty_constr (_1, List.rev _2)) )}
| _1 = LBRACE _2 = class_sig_body _3 = RBRACE
    {      ( mkcty(Pcty_signature _2) )}
| x = LBRACE _2 = class_sig_body x_inlined1 = error
    {let _3 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( unclosed_cty (with_txt _1 "{") (with_txt _3 "}") )}
| _1 = class_instance_type _2 = attribute
    {      ( Cty.attr _1 _2 )}
| _1 = extension
    {      ( mkcty(Pcty_extension _1) )}

class_sig_body:
  _1 = class_self_type _2 = class_sig_fields _3 = opt_semi
    {    ( Csig.mk _1 (List.rev _2 ))}

class_self_type:
  _1 = AS _2 = core_type _3 = SEMI
    {      (
        let core_type_loc = mklocation _startpos__2_ _endpos__2_ in
        only_core_type _2 core_type_loc
      )}
| 
    {let _endpos = _endpos__0_ in
let _symbolstartpos = _endpos in
      (
        let loc = mklocation _symbolstartpos _endpos in
        Typ.mk ~loc Ptyp_any
       )}

class_sig_fields:
  
    {                                        ( [] )}
| _1 = class_sig_field
    {                  ( [_1] )}
| _1 = class_sig_fields _2 = SEMI _3 = class_sig_field
    {                                        ( _3 :: _1 )}

class_sig_field:
  _1 = mark_position_ctf__class_sig_field_
    {                                                      (_1)}

_class_sig_field:
  _1 = INHERIT _2 = class_instance_type
    {      ( mkctf_attrs (Pctf_inherit _2) [] )}
| _1 = INHERIT _2 = class_instance_type _3 = item_attribute _4 = post_item_attributes
    {      ( mkctf_attrs (Pctf_inherit _2) (_3::_4) )}
| _1 = VAL _2 = value_type _3 = post_item_attributes
    {                                        (
      mkctf_attrs (Pctf_val _2) _3
    )}
| _1 = PRI _2 = private_virtual_flags _3 = label _4 = COLON _5 = poly_type _6 = post_item_attributes
    {         (
          mkctf_attrs (Pctf_method (_3, Private, _2, _5)) _6
         )}
| _1 = PUB _2 = private_virtual_flags _3 = label _4 = COLON _5 = poly_type _6 = post_item_attributes
    {       (
        mkctf_attrs (Pctf_method (_3, Public, _2, _5)) _6
       )}
| _1 = CONSTRAINT _2 = constrain_field _3 = post_item_attributes
    {       ( mkctf_attrs (Pctf_constraint _2) _3 )}
| _1 = item_extension _2 = post_item_attributes
    {       ( mkctf_attrs (Pctf_extension _1) _2 )}
| _1 = floating_attribute
    {      ( mkctf(Pctf_attribute _1) )}

value_type:
  _1 = VIRTUAL _2 = mutable_flag _3 = label _4 = COLON _5 = core_type
    {      ( _3, _2, Virtual, only_core_type _5 (mklocation _startpos__5_ _endpos__5_))}
| _1 = MUTABLE _2 = virtual_flag _3 = label _4 = COLON _5 = core_type
    {      ( _3, Mutable, _2, only_core_type _5 (mklocation _startpos__5_ _endpos__5_))}
| _1 = label _2 = COLON _3 = core_type
    {      ( _1, Immutable, Concrete, only_core_type _3 (mklocation _startpos__3_ _endpos__3_))}

constrain:
  _1 = core_type _2 = EQUAL _3 = core_type
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
                              (
    let loc = mklocation _symbolstartpos _endpos in
    (only_core_type _1 (mklocation _startpos__1_ _endpos__1_), only_core_type _3 (mklocation _startpos__3_ _endpos__3_), loc)
  )}

constrain_field:
  _1 = core_type _2 = EQUAL _3 = core_type
    {                                           ( only_core_type _1 (mklocation _startpos__1_ _endpos__1_), only_core_type _3 (mklocation _startpos__3_ _endpos__3_))}

many_class_descriptions:
  _1 = CLASS _2 = class_description_details _3 = post_item_attributes
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
                                                         (
    let (ident, binding, virt, params) = _2 in
    let loc = mklocation _symbolstartpos _endpos in
    [Ci.mk ident binding ~virt ~params ~attrs:_3 ~loc]
  )}
| _1 = many_class_descriptions _2 = and_class_description
    {                                                  (
    _2 :: _1
  )}

and_class_description:
  _1 = AND _2 = class_description_details _3 = post_item_attributes
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
                                                       (
    let (ident, binding, virt, params) = _2 in
    let loc = mklocation _symbolstartpos _endpos in
    Ci.mk ident binding ~virt ~params ~attrs:_3 ~loc
  )}

class_description_details:
  _1 = virtual_flag x = LIDENT _3 = class_type_parameters _4 = COLON _5 = class_constructor_type
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
                                                                                   (
    (_2, _5, _1, List.rev _3)
  )}

many_class_type_declarations:
  _1 = CLASS _2 = TYPE _3 = class_type_declaration_details _4 = post_item_attributes
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
                                                                   (
    let (ident, instance_type, virt, class_type_params) = _3 in
    let loc = mklocation _symbolstartpos _endpos in
    [Ci.mk ident instance_type ~virt:virt ~params:class_type_params ~attrs:_4 ~loc]
  )}
| _1 = many_class_type_declarations _2 = and_class_type_declaration
    {                                                            (
    _2::_1
  )}

and_class_type_declaration:
  _1 = AND _2 = class_type_declaration_details _3 = post_item_attributes
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
                                                          (
    let (ident, instance_type, virt, class_type_params) = _2 in
    let loc = mklocation _symbolstartpos _endpos in
    Ci.mk ident instance_type ~virt:virt ~params:class_type_params ~attrs:_3 ~loc
  )}

class_type_declaration_details:
  _1 = virtual_flag x = LIDENT _3 = class_type_parameters _4 = EQUAL _5 = class_instance_type
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
                                                                                (
      (_2, _5, _1, List.rev _3)
    )}

semi_terminated_seq_expr:
  _1 = mark_position_exp__semi_terminated_seq_expr_
    {                                                                        (_1)}

_semi_terminated_seq_expr:
  _1 = item_extension_sugar _2 = semi_terminated_seq_expr_row
    {                                                      (
      extension_expression _1 _2
    )}
| _1 = semi_terminated_seq_expr_row
    {                                 (
      _1
    )}
| _1 = let_bindings _2 = SEMI _3 = semi_terminated_seq_expr
    {                                               (
      expr_of_let_bindings _1 _3
    )}
| _1 = let_bindings _2 = opt_semi
    {let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos__1_ in
                          (
      let loc = mklocation _symbolstartpos _endpos in
      expr_of_let_bindings _1 @@ ghunit ~loc ()
    )}

semi_terminated_seq_expr_row:
  _1 = mark_position_exp__semi_terminated_seq_expr_row_
    {                                                                                (_1)}

_semi_terminated_seq_expr_row:
  _1 = expr _2 = post_item_attributes _3 = opt_semi
    {                                        (
      let expr = _1 in
      let item_attrs = _2 in
      (* Final item in the sequence - just append item attributes to the
       * expression attributes *)
      {expr with pexp_attributes = item_attrs @ expr.pexp_attributes}
    )}
| _1 = opt_let_module x = UIDENT _3 = module_binding_body _4 = post_item_attributes _5 = SEMI _6 = semi_terminated_seq_expr
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
                                                                                                         (
      let item_attrs = _4 in
      mkexp ~attrs:item_attrs (Pexp_letmodule(_2, _3, _6))
    )}
| _1 = option_LET_ _2 = OPEN _3 = override_flag x = mod_longident _5 = post_item_attributes _6 = SEMI _7 = semi_terminated_seq_expr
    {let _4 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
                                                                                                     (
      let item_attrs = _5 in
      mkexp ~attrs:item_attrs (Pexp_open(_3, _4, _7))
    )}
| _1 = expr _2 = post_item_attributes _3 = SEMI _4 = semi_terminated_seq_expr
    {                                                             (
      let item_attrs = _2 in
      mkexp ~attrs:item_attrs (Pexp_sequence(_1, _4))
    )}

labeled_simple_pattern:
  _1 = COLONCOLONLIDENT
    {      (
        let loc = mklocation _startpos__1_ _endpos__1_ in
        (Labelled _1, None, mkpat(Ppat_var (mkloc _1 loc)) ~loc)
      )}
| _1 = COLONCOLONLIDENT _2 = OPTIONAL_NO_DEFAULT
    {let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        (Optional _1, None, mkpat(Ppat_var (mkloc _1 loc)) ~loc)
      )}
| _1 = COLONCOLONLIDENT _2 = EQUAL _3 = simple_expr
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        (Optional _1, Some _3, mkpat(Ppat_var (mkloc _1 loc)) ~loc)
      )}
| _1 = LIDENTCOLONCOLON _2 = simple_pattern
    {      ( (Labelled _1, None, _2) )}
| _1 = LIDENTCOLONCOLON _2 = simple_pattern _3 = OPTIONAL_NO_DEFAULT
    {      ( (Optional _1, None, _2) )}
| _1 = LIDENTCOLONCOLON _2 = simple_pattern _3 = EQUAL _4 = simple_expr
    {      ( (Optional _1, Some _4, _2) )}
| _1 = simple_pattern
    {      ( (Nolabel, None, _1) )}

jsx_arguments:
  
    {              ( [] )}
| _1 = LIDENT _2 = OPTIONAL_NO_DEFAULT _3 = simple_expr _4 = jsx_arguments
    {      (
        (* a=?b *)
        [(Optional _1, _3)] @ _4
      )}
| _1 = LIDENT _2 = EQUAL _3 = simple_expr _4 = jsx_arguments
    {      (
        (* a=b *)
        [(Labelled _1, _3)] @ _4
      )}
| _1 = LIDENT _2 = jsx_arguments
    {      (
        (* a (punning) *)
        let loc_lident = mklocation _startpos__1_ _endpos__1_ in
        [(Labelled _1, mkexp (Pexp_ident {txt = Lident _1; loc = loc_lident}) ~loc:loc_lident)] @ _2
      )}

jsx_start_tag_and_args:
  _1 = LESSIDENT _2 = jsx_arguments
    {                            (
    let name = Longident.parse _1 in
    (jsx_component name _2, name)
  )}

jsx_start_tag_and_args_without_leading_less:
  _1 = mod_longident _2 = jsx_arguments
    {                                (
    (jsx_component _1 _2, _1)
  )}

simple_expr_list:
  
    {            ( [] )}
| _1 = simple_expr _2 = simple_expr_list
    {                                ( [_1] @ _2 )}

jsx:
  _1 = LESSGREATER _2 = simple_expr_list _3 = LESSSLASHGREATER
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
                                                  (
    let loc = mklocation _symbolstartpos _endpos in
    let body = mktailexp_extension loc _2 None in
    makeFrag loc body
  )}
| _1 = jsx_start_tag_and_args _2 = SLASHGREATER
    {let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos__1_ in
                                        (
    let (component, _) = _1 in
    let loc = mklocation _symbolstartpos _endpos in
    component [
      (Labelled "children", mktailexp_extension loc [] None);
      (Nolabel, mkexp_constructor_unit loc loc)
    ] loc
  )}
| _1 = jsx_start_tag_and_args _2 = GREATER _3 = simple_expr_list _4 = LESSSLASHIDENTGREATER
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
                                                                          (
    let (component, start) = _1 in
    let loc = mklocation _symbolstartpos _endpos in
    (* TODO: Make this tag check simply a warning *)
    let endName = Longident.parse _4 in
    let _ = ensureTagsAreEqual start endName loc in
    let siblings = if List.length _3 > 0 then _3 else [] in
    component [
      (Labelled "children", mktailexp_extension loc siblings None);
      (Nolabel, mkexp_constructor_unit loc loc)
    ] loc
  )}

jsx_without_leading_less:
  _1 = GREATER _2 = simple_expr_list _3 = LESSSLASHGREATER
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
                                              (
    let loc = mklocation _symbolstartpos _endpos in
    let body = mktailexp_extension loc _2 None in
    makeFrag loc body
  )}
| _1 = jsx_start_tag_and_args_without_leading_less _2 = SLASHGREATER
    {let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos__1_ in
                                                             (
    let (component, _) = _1 in
    let loc = mklocation _symbolstartpos _endpos in
    component [
      (Labelled "children", mktailexp_extension loc [] None);
      (Nolabel, mkexp_constructor_unit loc loc)
    ] loc
  )}
| _1 = jsx_start_tag_and_args_without_leading_less _2 = GREATER _3 = simple_expr_list _4 = LESSSLASHIDENTGREATER
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
                                                                                               (
    let (component, start) = _1 in
    let loc = mklocation _symbolstartpos _endpos in
    (* TODO: Make this tag check simply a warning *)
    let endName = Longident.parse _4 in
    let _ = ensureTagsAreEqual start endName loc in
    let siblings = if List.length _3 > 0 then _3 else [] in
    component [
      (Labelled "children", mktailexp_extension loc siblings None);
      (Nolabel, mkexp_constructor_unit loc loc)
    ] loc
  )}

expr:
  _1 = mark_position_exp__expr_
    {                               (_1)}

_expr:
  _1 = less_aggressive_simple_expression
    {      ( _1 )}
| _1 = less_aggressive_simple_expression _2 = simple_labeled_expr_list
    {      ( mkexp(Pexp_apply(_1, List.rev _2)) )}
| _1 = FUN _2 = labeled_simple_pattern _3 = fun_def
    {                                       (
      let (l,o,p) = _2 in
      mkexp (Pexp_fun(l, o, p, _3))
    )}
| _1 = FUN _2 = LPAREN _3 = TYPE _4 = lident_list _5 = RPAREN _6 = fun_def
    {      ( pexp_newtypes _4 _6 )}
| _1 = FUN _2 = leading_bar_match_cases %prec below_BAR
    {      ( mkexp (Pexp_function(List.rev _2)) )}
| _1 = SWITCH _2 = simple_expr _3 = LBRACE _4 = leading_bar_match_cases_to_sequence_body _5 = RBRACE
    {      ( mkexp (Pexp_match(_2, List.rev _4)) )}
| _1 = TRY _2 = simple_expr _3 = LBRACE _4 = leading_bar_match_cases_to_sequence_body _5 = RBRACE
    {      ( mkexp (Pexp_try(_2, List.rev _4)) )}
| _1 = TRY _2 = simple_expr _3 = WITH _4 = error
    {      ( syntax_error_exp (mklocation _startpos__4_ _endpos__4_) "Invalid try with")}
| x = constr_longident _2 = simple_non_labeled_expr_list_as_tuple
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    (
      if List.mem (string_of_longident _1.txt)
         built_in_explicit_arity_constructors then
        (* unboxing the inner tupple *)
        match _2 with
          | {pexp_desc=Pexp_tuple [inner]; pexp_loc; pexp_attributes} -> mkexp (Pexp_construct(_1, Some inner))
          | _ -> assert false
      else
        mkExplicitArityTupleExp (Pexp_construct(_1, Some _2))
    )}
| _1 = name_tag _2 = simple_expr
    {    (
      mkexp(Pexp_variant(_1, Some _2))
    )}
| _1 = IF _2 = simple_expr _3 = simple_expr _4 = ELSE _5 = expr
    {      ( mkexp(Pexp_ifthenelse(_2, _3, Some _5)) )}
| _1 = IF _2 = simple_expr _3 = simple_expr
    {      ( mkexp (Pexp_ifthenelse(_2, _3, None)) )}
| _1 = WHILE _2 = simple_expr _3 = simple_expr
    {      ( mkexp (Pexp_while(_2, _3)) )}
| _1 = FOR _2 = pattern _3 = IN _4 = simple_expr _5 = direction_flag _6 = simple_expr _7 = simple_expr
    {      ( mkexp(Pexp_for(_2, _4, _6, _5, _7)) )}
| _1 = LPAREN _2 = COLONCOLON _3 = RPAREN _4 = LPAREN _5 = expr _6 = COMMA _7 = expr _8 = RPAREN
    {let _endpos = _endpos__8_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc_colon = mklocation _startpos__2_ _endpos__2_ in
        let loc = mklocation _symbolstartpos _endpos in
        mkexp_cons loc_colon (mkexp ~ghost:true ~loc (Pexp_tuple[_5;_7])) loc
      )}
| _1 = expr _1_inlined1 = INFIXOP0 _3 = expr
    {let _2 =
  let _1 = _1_inlined1 in
                                                  ( _1 )
in
      ( mkinfix _1 _2 _3 )}
| _1 = expr _1_inlined1 = INFIXOP1 _3 = expr
    {let _2 =
  let _1 = _1_inlined1 in
                                                  ( _1 )
in
      ( mkinfix _1 _2 _3 )}
| _1 = expr _1_inlined1 = INFIXOP2 _3 = expr
    {let _2 =
  let _1 = _1_inlined1 in
                                                  ( _1 )
in
      ( mkinfix _1 _2 _3 )}
| _1 = expr _1_inlined1 = INFIXOP3 _3 = expr
    {let _2 =
  let _1 = _1_inlined1 in
                                                  ( _1 )
in
      ( mkinfix _1 _2 _3 )}
| _1 = expr _1_inlined1 = SLASHGREATER _3 = expr
    {let _2 =
  let _1 = _1_inlined1 in
                                                  ( "/>" )
in
      ( mkinfix _1 _2 _3 )}
| _1 = expr _1_inlined1 = INFIXOP4 _3 = expr
    {let _2 =
  let _1 = _1_inlined1 in
                                                  ( _1 )
in
      ( mkinfix _1 _2 _3 )}
| _1 = expr _1_inlined1 = PLUS _3 = expr
    {let _2 =
  let _1 = _1_inlined1 in
                                                  ( "+" )
in
      ( mkinfix _1 _2 _3 )}
| _1 = expr _1_inlined1 = PLUSDOT _3 = expr
    {let _2 =
  let _1 = _1_inlined1 in
                                                  ( "+." )
in
      ( mkinfix _1 _2 _3 )}
| _1 = expr _1_inlined1 = MINUS _3 = expr
    {let _2 =
  let _1 = _1_inlined1 in
                                                  ( "-" )
in
      ( mkinfix _1 _2 _3 )}
| _1 = expr _1_inlined1 = MINUSDOT _3 = expr
    {let _2 =
  let _1 = _1_inlined1 in
                                                  ( "-." )
in
      ( mkinfix _1 _2 _3 )}
| _1 = expr _1_inlined1 = STAR _3 = expr
    {let _2 =
  let _1 = _1_inlined1 in
                                                  ( "*" )
in
      ( mkinfix _1 _2 _3 )}
| _1 = expr _1_inlined1 = LESS _3 = expr
    {let _2 =
  let _1 = _1_inlined1 in
                                                  ( "<" )
in
      ( mkinfix _1 _2 _3 )}
| _1 = expr _1_inlined1 = GREATER _3 = expr
    {let _2 =
  let _1 = _1_inlined1 in
                                                  ( ">" )
in
      ( mkinfix _1 _2 _3 )}
| _1 = expr _1_inlined1 = OR _3 = expr
    {let _2 =
  let _1 = _1_inlined1 in
                                                  ( "or" )
in
      ( mkinfix _1 _2 _3 )}
| _1 = expr _1_inlined1 = BARBAR _3 = expr
    {let _2 =
  let _1 = _1_inlined1 in
                                                  ( "||" )
in
      ( mkinfix _1 _2 _3 )}
| _1 = expr _1_inlined1 = AMPERSAND _3 = expr
    {let _2 =
  let _1 = _1_inlined1 in
                                                  ( "&" )
in
      ( mkinfix _1 _2 _3 )}
| _1 = expr _1_inlined1 = AMPERAMPER _3 = expr
    {let _2 =
  let _1 = _1_inlined1 in
                                                  ( "&&" )
in
      ( mkinfix _1 _2 _3 )}
| _1 = expr _1_inlined1 = COLONEQUAL _3 = expr
    {let _2 =
  let _1 = _1_inlined1 in
                                                  ( ":=" )
in
      ( mkinfix _1 _2 _3 )}
| _1 = expr _1_inlined1 = PLUSEQ _3 = expr
    {let _2 =
  let _1 = _1_inlined1 in
                                                  ( "+=" )
in
      ( mkinfix _1 _2 _3 )}
| _1 = expr _1_inlined1 = PERCENT _3 = expr
    {let _2 =
  let _1 = _1_inlined1 in
                                                  ( "%" )
in
      ( mkinfix _1 _2 _3 )}
| _1 = expr _1_inlined1 = LESSDOTDOTGREATER _3 = expr
    {let _2 =
  let _1 = _1_inlined1 in
                                                  ( "<..>" )
in
      ( mkinfix _1 _2 _3 )}
| _1 = expr _1_inlined1 = GREATER _2 = GREATER _3 = expr
    {let _2 =
  let _1 = _1_inlined1 in
                                                  ( ">>" )
in
      ( mkinfix _1 _2 _3 )}
| _1 = subtractive _2 = expr %prec prec_unary_minus
    {      (
        mkuminus _1 _2
      )}
| _1 = additive _2 = expr %prec prec_unary_plus
    {      (
        mkuplus _1 _2
      )}
| _1 = simple_expr _2 = DOT x = label_longident _4 = EQUAL _5 = expr
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( mkexp(Pexp_setfield(_1, _3, _5)) )}
| _1 = simple_expr _2 = DOT _3 = LPAREN _4 = expr _5 = RPAREN _6 = EQUAL _7 = expr
    {let _endpos = _endpos__7_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(array_function ~loc "Array" "set")),
                         [Nolabel,_1; Nolabel,_4; Nolabel,_7])) )}
| _1 = simple_expr _2 = DOT _3 = LBRACKET _4 = expr _5 = RBRACKET _6 = EQUAL _7 = expr
    {let _endpos = _endpos__7_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(array_function ~loc "String" "set")),
                         [Nolabel,_1; Nolabel,_4; Nolabel,_7])) )}
| _1 = simple_expr _2 = DOT _3 = LBRACE _4 = expr _5 = RBRACE _6 = EQUAL _7 = expr
    {let _endpos = _endpos__7_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        bigarray_set ~loc _1 _4 _7
      )}
| x = label _2 = EQUAL _3 = expr
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( mkexp(Pexp_setinstvar(_1, _3)) )}
| _1 = ASSERT _2 = simple_expr
    {      ( mkexp (Pexp_assert _2) )}
| _1 = LAZY _2 = simple_expr
    {      ( mkexp (Pexp_lazy _2) )}
| _1 = expr _2 = QUESTION _3 = expr _4 = COLON _5 = expr
    {                                  (
      (* Should use ghost expressions, but not sure how that would work with source maps *)
      (* So ? will become true and : becomes false for now*)
      let loc_question = mklocation _startpos__2_ _endpos__2_ in
      let loc_colon = mklocation _startpos__4_ _endpos__4_ in
      let fauxTruePat =
        Pat.mk ~loc:loc_question (Ppat_construct({txt = Lident "true"; loc = loc_question}, None)) in
      let fauxFalsePat =
        Pat.mk ~loc:loc_colon (Ppat_construct({txt = Lident "false"; loc = loc_colon}, None)) in
      let fauxMatchCaseTrue = Exp.case fauxTruePat _3 in
      let fauxMatchCaseFalse = Exp.case fauxFalsePat _5 in
      mkexp (Pexp_match (_1, [fauxMatchCaseTrue; fauxMatchCaseFalse]))
    )}
| _1 = expr _2 = attribute
    {      ( Exp.attr _1 _2 )}

simple_expr:
  _1 = mark_position_exp__simple_expr_
    {                                             (_1)}

_simple_expr:
  x = val_longident
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( mkexp (Pexp_ident _1) )}
| _1 = constant
    {             ( mkexp (Pexp_constant _1) )}
| x = constr_longident %prec prec_constant_constructor
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    (
      mkexp (Pexp_construct (_1, None))
    )}
| _1 = name_tag %prec prec_constant_constructor
    {      ( mkexp (Pexp_variant (_1, None)) )}
| _1 = jsx
    {        ( _1 )}
| _1 = LBRACKETLESS _2 = jsx_without_leading_less _3 = COMMA _4 = expr_comma_seq_extension
    {                                                                         (
      let entireLoc = mklocation _startpos__1_ _endpos__4_ in
      let (seq, ext_opt) = _4 in
      mktailexp_extension entireLoc (_2::seq) ext_opt
  )}
| _1 = LBRACKETLESS _2 = jsx_without_leading_less _3 = RBRACKET
    {                                                   (
      let entireLoc = mklocation _startpos__1_ _endpos__3_ in
      mktailexp_extension entireLoc (_2::[]) None
  )}
| _1 = LPAREN _2 = expr _3 = RPAREN
    {      ( _2 )}
| x = LPAREN _2 = expr x_inlined1 = error
    {let _3 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( unclosed_exp (with_txt _1 "(") (with_txt _3 ")") )}
| _1 = LPAREN _2 = expr _3 = type_constraint _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        ghexp_constraint loc _2 _3
      )}
| _1 = LBRACE _2 = semi_terminated_seq_expr _3 = RBRACE
    {      ( _2 )}
| _1 = LBRACE x = semi_terminated_seq_expr _3 = error
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( syntax_error_exp _2.loc "SyntaxError in block" )}
| _1 = LPAREN _2 = expr_comma_list _3 = opt_comma _4 = RPAREN
    {      ( mkexp(Pexp_tuple(List.rev _2)) )}
| x = LPAREN _2 = expr_comma_list x_inlined1 = error
    {let _3 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( unclosed_exp (with_txt _1 "(") (with_txt _3 ")") )}
| _1 = simple_expr _2 = DOT x = label_longident
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( mkexp(Pexp_field(_1, _3)) )}
| x = mod_longident _2 = DOT _3 = LPAREN _4 = expr _5 = RPAREN
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( mkexp(Pexp_open(Fresh, _1, _4)) )}
| x = mod_longident _2 = DOT _3 = LPAREN _4 = expr_comma_list _5 = RPAREN
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( mkexp(Pexp_open(Fresh, _1, mkexp(Pexp_tuple(List.rev _4)))) )}
| _1 = mod_longident _2 = DOT x = LPAREN _4 = expr x_inlined1 = error
    {let _5 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( unclosed_exp (with_txt _3 "(") (with_txt _5 ")") )}
| x = mod_longident _2 = DOT _3 = LBRACE _4 = RBRACE
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _startpos__1_ = _startpos_x_ in
let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        let pat = mkpat (Ppat_var (mkloc "this" loc)) in
        mkexp(Pexp_open (Fresh, _1,
                         mkexp(Pexp_object(Cstr.mk pat [])))) )}
| _1 = simple_expr _2 = DOT _3 = LPAREN _4 = expr _5 = RPAREN
    {let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(array_function ~loc "Array" "get")),
                         [Nolabel,_1; Nolabel,_4])) )}
| _1 = simple_expr _2 = DOT x = LPAREN _4 = expr x_inlined1 = error
    {let _5 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( unclosed_exp (with_txt _3 "(") (with_txt _5 ")") )}
| _1 = simple_expr _2 = DOT _3 = LBRACKET _4 = expr _5 = RBRACKET
    {let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        mkexp(Pexp_apply(mkexp ~ghost:true ~loc (Pexp_ident(array_function ~loc "String" "get")),
                         [Nolabel,_1; Nolabel,_4])) )}
| _1 = simple_expr _2 = DOT x = LBRACKET _4 = expr x_inlined1 = error
    {let _5 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( unclosed_exp (with_txt _3 "[") (with_txt _5 "]") )}
| _1 = simple_expr _2 = DOT _3 = LBRACE _4 = expr _5 = RBRACE
    {let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        bigarray_get ~loc _1 _4
      )}
| _1 = LBRACE _2 = DOTDOTDOT _3 = expr_optional_constraint _4 = opt_comma _5 = RBRACE
    {let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        let msg = "Record construction must have at least one field explicitly set" in
        syntax_error_exp loc msg
      )}
| _1 = LBRACE _2 = record_expr _3 = RBRACE
    {      ( let (exten, fields) = _2 in mkexp (Pexp_record(fields, exten)) )}
| x = LBRACE _2 = record_expr x_inlined1 = error
    {let _3 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( unclosed_exp (with_txt _1 "{") (with_txt _3 "}"))}
| _1 = LBRACE _2 = record_expr_with_string_keys _3 = RBRACE
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        let (exten, fields) = _2 in
        mkexp ~loc (Pexp_extension (mkloc ("bs.obj") loc,
               PStr [mkstrexp (mkexp ~loc (Pexp_record(fields, exten))) []]))
      )}
| x = LBRACE _2 = record_expr_with_string_keys x_inlined1 = error
    {let _3 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( unclosed_exp (with_txt _1 "{") (with_txt _3 "}"))}
| _1 = LBRACE _2 = class_self_pattern_and_structure _3 = RBRACE
    {      ( mkexp (Pexp_object _2) )}
| x = LBRACE _2 = class_self_pattern_and_structure x_inlined1 = error
    {let _3 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( unclosed_exp (with_txt _1 "{") (with_txt _3 "}") )}
| x = mod_longident _2 = DOT _3 = LBRACE _4 = record_expr _5 = RBRACE
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _startpos__1_ = _startpos_x_ in
let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
      ( let (exten, fields) = _4 in
        let loc = mklocation _symbolstartpos _endpos in
        let rec_exp = mkexp ~loc (Pexp_record (fields, exten)) in
        mkexp(Pexp_open(Fresh, _1, rec_exp)) )}
| _1 = mod_longident _2 = DOT x = LBRACE _4 = record_expr x_inlined1 = error
    {let _5 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( unclosed_exp (with_txt _3 "{") (with_txt _5 "}") )}
| _1 = LBRACKETBAR _2 = expr_comma_seq _3 = opt_comma _4 = BARRBRACKET
    {      ( mkexp (Pexp_array(List.rev _2)) )}
| x = LBRACKETBAR _2 = expr_comma_seq _3 = opt_comma x_inlined1 = error
    {let _4 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( unclosed_exp (with_txt _1 "[|") (with_txt _4 "|]") )}
| _1 = LBRACKETBAR _2 = BARRBRACKET
    {      ( mkexp (Pexp_array []) )}
| x = mod_longident _2 = DOT _3 = LBRACKETBAR _4 = expr_comma_seq _5 = opt_comma _6 = BARRBRACKET
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _startpos__1_ = _startpos_x_ in
let _endpos = _endpos__6_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        let rec_exp = Exp.mk ~loc ~attrs:[] (Pexp_array(List.rev _4)) in
        mkexp(Pexp_open(Fresh, _1, rec_exp))
      )}
| _1 = mod_longident _2 = DOT x = LBRACKETBAR _4 = expr_comma_seq _5 = opt_comma x_inlined1 = error
    {let _6 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( unclosed_exp (with_txt _3 "[|") (with_txt _6 "|]") )}
| _1 = LBRACKET _2 = expr_comma_seq_extension
    {      ( let seq, ext_opt = _2 in
        let loc = mklocation _startpos__2_ _endpos__2_ in
        make_real_exp (mktailexp_extension loc seq ext_opt) )}
| x = mod_longident _2 = DOT _3 = LBRACKET _4 = expr_comma_seq_extension
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( let seq, ext_opt = _4 in
        let loc = mklocation _startpos__4_ _endpos__4_ in
        let list_exp = make_real_exp (mktailexp_extension loc seq ext_opt) in
        let list_exp = { list_exp with pexp_loc = loc } in
        mkexp (Pexp_open (Fresh, _1, list_exp)) )}
| _1 = PREFIXOP _2 = simple_expr %prec below_DOT_AND_SHARP
    {      (
        mkexp(Pexp_apply(mkoperator _1 1, [Nolabel, _2]))
      )}
| x = BANG _2 = simple_expr %prec below_DOT_AND_SHARP
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      (
        mkexp(Pexp_apply(mkoperator "!" 1, [Nolabel,_2]))
      )}
| _1 = NEW x = class_longident
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( mkexp (Pexp_new _2) )}
| _1 = LBRACELESS _2 = field_expr_list _3 = opt_comma _4 = GREATERRBRACE
    {      ( mkexp (Pexp_override(List.rev _2)) )}
| x = LBRACELESS _2 = field_expr_list _3 = opt_comma x_inlined1 = error
    {let _4 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( unclosed_exp (with_txt _1 "{<") (with_txt _4 ">}" ) )}
| _1 = LBRACELESS _2 = GREATERRBRACE
    {      ( mkexp (Pexp_override []))}
| x = mod_longident _2 = DOT _3 = LBRACELESS _4 = field_expr_list _5 = opt_comma _6 = GREATERRBRACE
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _startpos__1_ = _startpos_x_ in
let _endpos = _endpos__6_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        let exp = Exp.mk ~loc ~attrs:[] (Pexp_override(List.rev _4)) in
        mkexp(Pexp_open(Fresh, _1, exp))
      )}
| _1 = mod_longident _2 = DOT x = LBRACELESS _4 = field_expr_list _5 = opt_comma x_inlined1 = error
    {let _6 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( unclosed_exp (with_txt _3 "{<") (with_txt _6 ">}") )}
| _1 = simple_expr _2 = SHARP _3 = label
    {      ( mkexp(Pexp_send(_1, _3)) )}
| _1 = simple_expr x = SHARPOP _3 = simple_expr
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( mkinfixop _1 (mkoperator_loc _2.txt _2.loc) _3 )}
| _1 = LPAREN _2 = MODULE _3 = module_expr _4 = RPAREN
    {      ( mkexp (Pexp_pack _3) )}
| _1 = LPAREN _2 = MODULE _3 = module_expr _4 = COLON _5 = package_type _6 = RPAREN
    {let _endpos = _endpos__6_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        mkexp (Pexp_constraint (mkexp ~ghost:true ~loc (Pexp_pack _3),
                                mktyp ~ghost:true ~loc (Ptyp_package _5))) )}
| x = LPAREN _2 = MODULE _3 = module_expr _4 = COLON x_inlined1 = error
    {let _5 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( unclosed_exp (with_txt _1 "(") (with_txt _5 ")") )}
| x = mod_longident _2 = DOT _3 = LPAREN _4 = MODULE _5 = module_expr _6 = COLON _7 = package_type _8 = RPAREN
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _startpos__1_ = _startpos_x_ in
let _endpos = _endpos__8_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        mkexp(Pexp_open(Fresh, _1,
        mkexp ~loc (Pexp_constraint (mkexp ~ghost:true ~loc (Pexp_pack _5),
                                     mktyp ~ghost:true ~loc (Ptyp_package _7))))) )}
| _1 = mod_longident _2 = DOT x = LPAREN _4 = MODULE _5 = module_expr _6 = COLON x_inlined1 = error
    {let _7 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( unclosed_exp (with_txt _3 "(") (with_txt _7 ")"))}
| _1 = extension
    {      ( mkexp (Pexp_extension _1) )}

less_aggressive_simple_expression:
  _1 = simple_expr
    {              (_1)}

simple_non_labeled_expr_list:
  _1 = less_aggressive_simple_expression
    {      ( [_1] )}
| _1 = simple_non_labeled_expr_list _2 = less_aggressive_simple_expression
    {      ( _2 :: _1 )}

simple_non_labeled_expr_list_as_tuple:
  _1 = mark_position_exp__simple_non_labeled_expr_list_as_tuple_
    {                                                                                                 (_1)}

_simple_non_labeled_expr_list_as_tuple:
  _1 = simple_non_labeled_expr_list
    {                               (
    mkexp (Pexp_tuple(List.rev _1))
  )}

simple_labeled_expr_list:
  _1 = labeled_simple_expr
    {      ( [_1] )}
| _1 = simple_labeled_expr_list _2 = labeled_simple_expr
    {      ( _2 :: _1 )}

labeled_simple_expr:
  _1 = less_aggressive_simple_expression
    {      ( (Nolabel, _1) )}
| _1 = label_expr
    {      ( _1 )}

label_expr:
  _1 = COLONCOLONLIDENT
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        (Labelled _1, mkexp (Pexp_ident(mkloc (Lident _1) loc)) ~loc)
      )}
| _1 = LIDENTCOLONCOLON _2 = less_aggressive_simple_expression
    {      ( (Labelled _1, _2) )}
| _1 = COLONCOLON _2 = QUESTION _3 = val_longident
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
     (
       let loc = mklocation _symbolstartpos _endpos in
       (Optional (String.concat "" (Longident.flatten _3)), mkexp (Pexp_ident(mkloc _3 loc)) ~loc)
     )}
| _1 = LIDENTCOLONCOLON _2 = QUESTION _3 = less_aggressive_simple_expression
    {      ( (Optional _1, _3) )}

and_let_binding:
  _1 = AND _2 = let_binding_body _3 = post_item_attributes
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
      (
         let loc = mklocation _symbolstartpos _endpos in
         mklb _2 _3 loc
      )}

let_bindings:
  _1 = let_binding
    {                                                ( _1 )}
| _1 = let_bindings _2 = and_let_binding
    {                                                ( addlb _1 _2 )}

lident_list:
  _1 = LIDENT
    {                                      ( [_1] )}
| _1 = LIDENT _2 = lident_list
    {                                      ( _1 :: _2 )}

let_binding_impl:
  _1 = LET _2 = rec_flag _3 = let_binding_body _4 = post_item_attributes
    {                                                       (
      (_2, _3, _4)
    )}

let_binding:
  _1 = let_binding_impl
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
                     (
    let (rec_flag, body, item_attrs) = _1 in
    let loc = mklocation _symbolstartpos _endpos in
    mklbs ([], None) rec_flag (mklb body item_attrs loc) loc
  )}
| _1 = item_extension_sugar _2 = let_binding_impl
    {let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos__1_ in
                                          (
      let (rec_flag, body, item_attrs) = _2 in
      let (ext_attrs, ext_id) = _1 in
      let loc = mklocation _symbolstartpos _endpos in
      mklbs (ext_attrs, Some ext_id) rec_flag (mklb body item_attrs loc) loc
    )}

let_binding_body:
  x = val_ident _2 = type_constraint _3 = EQUAL _4 = expr
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
      ( let loc = mklocation _symbolstartpos _endpos in
      mkpat ~loc (Ppat_var (mkloc x loc)) )
in
let _startpos__1_ = _startpos_x_ in
let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        (_1, ghexp_constraint loc _4 _2)
      )}
| x = val_ident _2 = curried_binding_return_typed
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
      ( let loc = mklocation _symbolstartpos _endpos in
      mkpat ~loc (Ppat_var (mkloc x loc)) )
in
      ( (_1, _2) )}
| x = val_ident _2 = COLON _3 = typevar_list _4 = DOT _5 = core_type _6 = EQUAL _7 = mark_position_exp_expr_
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
      ( let loc = mklocation _symbolstartpos _endpos in
      mkpat ~loc (Ppat_var (mkloc x loc)) )
in
let _startpos__1_ = _startpos_x_ in
let _endpos = _endpos__7_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        let core_loc = mklocation _startpos__5_ _endpos__5_ in
        (mkpat ~ghost:true ~loc (Ppat_constraint(_1, mktyp ~ghost:true (Ptyp_poly(List.rev _3, only_core_type _5 core_loc)))), _7)
      )}
| x = val_ident _2 = COLON _3 = TYPE _4 = lident_list _5 = DOT _6 = core_type _7 = EQUAL _8 = mark_position_exp_expr_
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
      ( let loc = mklocation _symbolstartpos _endpos in
      mkpat ~loc (Ppat_var (mkloc x loc)) )
in
let _startpos__1_ = _startpos_x_ in
let _endpos = _endpos__8_ in
let _symbolstartpos = _startpos__1_ in
     (
       let core_loc = mklocation _startpos__6_ _endpos__6_ in
       let exp, poly = wrap_type_annotation _4 (only_core_type _6 core_loc) _8 in
       let loc = mklocation _symbolstartpos _endpos in
       (mkpat ~ghost:true ~loc (Ppat_constraint(_1, poly)), exp)
     )}
| _1 = pattern _2 = EQUAL _3 = expr
    {      ( (_1, _3) )}
| _1 = simple_pattern_not_ident _2 = COLON _3 = core_type _4 = EQUAL _5 = expr
    {let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        let core_loc = mklocation _startpos__3_ _endpos__3_ in
        (mkpat ~loc (Ppat_constraint(_1, only_core_type _3 core_loc)), _5)
      )}

curried_binding_return_typed:
  _1 = mark_position_exp__curried_binding_return_typed_
    {                                                                               (_1)}

_curried_binding_return_typed:
  _1 = labeled_simple_pattern _2 = curried_binding_return_typed_
    {let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos__1_ in
      (
         let loc = mklocation _symbolstartpos _endpos in
         let (l, o, p) = _1 in mkexp ~loc (Pexp_fun(l, o, p, _2))
      )}
| _1 = LPAREN _2 = TYPE _3 = lident_list _4 = RPAREN _5 = curried_binding_return_typed_
    {      ( pexp_newtypes _3 _5 )}

curried_binding_return_typed_:
  _1 = curried_binding
    {    (_1)}
| _1 = COLON _2 = non_arrowed_core_type _3 = EQUALGREATER _4 = expr
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        let core_loc = mklocation _startpos__2_ _endpos__2_ in
        let ct = only_core_type _2 core_loc in
        ghexp_constraint loc _4 (Some ct, None)
      )}

curried_binding:
  _1 = EQUALGREATER _2 = expr
    {      ( _2 )}
| _1 = labeled_simple_pattern _2 = curried_binding_return_typed_
    {let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        let (l, o, p) = _1 in
        mkexp ~loc (Pexp_fun(l, o, p, _2))
      )}
| _1 = LPAREN _2 = TYPE _3 = lident_list _4 = RPAREN _5 = curried_binding_return_typed_
    {let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        pexp_newtypes ~loc _3 _5
      )}

leading_bar_match_cases:
  _1 = leading_bar_match_case
    {                           ( [_1] )}
| _1 = leading_bar_match_cases _2 = leading_bar_match_case
    {                                                   ( _2 :: _1 )}

leading_bar_match_cases_to_sequence_body:
  _1 = leading_bar_match_case_to_sequence_body
    {                                            ( [_1] )}
| _1 = leading_bar_match_cases_to_sequence_body _2 = leading_bar_match_case_to_sequence_body
    {                                                                                     ( _2 :: _1 )}

or_pattern:
  _1 = mark_position_pat__or_pattern_
    {                                           (_1)}

_or_pattern:
  _1 = pattern _2 = BAR _3 = pattern
    {    ( mkpat(Ppat_or(_1, _3)) )}

pattern_with_bar:
  _1 = BAR _2 = pattern
    {                               (
  _2
)}

leading_bar_match_case:
  _1 = pattern_with_bar _2 = EQUALGREATER _3 = expr
    {                                       (
      Exp.case _1 _3
    )}
| _1 = pattern_with_bar _2 = WHEN _3 = expr _4 = EQUALGREATER _5 = expr
    {      ( Exp.case _1 ~guard:_3 _5 )}

leading_bar_match_case_to_sequence_body:
  _1 = pattern_with_bar _2 = EQUALGREATER _3 = semi_terminated_seq_expr
    {      ( Exp.case _1 _3 )}
| _1 = pattern_with_bar _2 = WHEN _3 = expr _4 = EQUALGREATER _5 = semi_terminated_seq_expr
    {      ( Exp.case _1 ~guard:_3 _5 )}

fun_def:
  _1 = EQUALGREATER _2 = expr
    {                      ( _2 )}
| _1 = COLON _2 = non_arrowed_core_type _3 = EQUALGREATER _4 = expr
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        let core_loc = mklocation _startpos__2_ _endpos__2_ in
        let ct = only_core_type _2 core_loc in
        mkexp ~loc (Pexp_constraint(_4, ct))
      )}
| _1 = labeled_simple_pattern _2 = fun_def
    {let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos__1_ in
      (
       let (l,o,p) = _1 in
       let loc = mklocation _symbolstartpos _endpos in
       mkexp ~ghost:true ~loc (Pexp_fun(l, o, p, _2))
      )}
| _1 = LPAREN _2 = TYPE _3 = lident_list _4 = RPAREN _5 = fun_def
    {let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        pexp_newtypes ~loc _3 _5
      )}

expr_comma_list:
  _1 = expr_comma_list _2 = COMMA _3 = expr_optional_constraint
    {      ( _3 :: _1 )}
| _1 = expr_optional_constraint _2 = COMMA _3 = expr_optional_constraint
    {      ( [_3; _1] )}

expr_comma_seq:
  _1 = expr_comma_seq _2 = COMMA _3 = expr_optional_constraint
    {      ( _3::_1 )}
| _1 = expr_optional_constraint
    {      ( [_1] )}

expr_comma_seq_extension:
  _1 = DOTDOTDOT _2 = expr_optional_constraint _3 = RBRACKET
    {    ( ([], Some _2) )}
| _1 = expr_optional_constraint _2 = opt_comma _3 = RBRACKET
    {    ( ([_1], None) )}
| _1 = expr_optional_constraint _2 = COMMA _3 = expr_comma_seq_extension
    {    ( let seq, ext = _3 in (_1::seq, ext) )}

expr_optional_constraint:
  _1 = expr
    {                         ( _1 )}
| _1 = expr _2 = type_constraint
    {let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos__1_ in
                         (
      let loc = mklocation _symbolstartpos _endpos in
      ghexp_constraint loc _1 _2
    )}

record_expr:
  _1 = DOTDOTDOT _2 = expr_optional_constraint _3 = COMMA _4 = lbl_expr_list
    {                                                           ( (Some _2, _4) )}
| _1 = lbl_expr_list_that_is_not_a_single_punned_field
    {                                                           ( (None, _1) )}

lbl_expr_list:
  _1 = lbl_expr
    {              ( [_1] )}
| _1 = lbl_expr _2 = COMMA _3 = lbl_expr_list
    {                                  ( _1 :: _3 )}
| _1 = lbl_expr _2 = COMMA
    {                    ( [_1] )}

lbl_expr:
  x = label_longident _2 = COLON _3 = expr
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( (_1, _3) )}
| x = label_longident
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      (
        (_1, exp_of_label _1)
      )}

record_expr_with_string_keys:
  _1 = DOTDOTDOT _2 = expr_optional_constraint _3 = COMMA _4 = string_literal_expr_list
    {                                                                      ( (Some _2, _4) )}
| _1 = string_literal_expr_list_that_is_not_a_single_punned_field
    {                                                                      ( (None, _1))}

string_literal_expr_list:
  _1 = string_literal_expr
    {                         ( [_1] )}
| _1 = string_literal_expr _2 = COMMA _3 = string_literal_expr_list
    {                                                        ( _1 :: _3 )}
| _1 = string_literal_expr _2 = COMMA
    {                               ( [_1] )}

string_literal_expr:
  _1 = STRING _2 = COLON _3 = expr
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        let (s, d) = _1 in
        let lident_lident_loc = mkloc (Lident s) loc in
        (lident_lident_loc, _3)
      )}
| _1 = STRING
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        let (s, d) = _1 in
        let lident_lident_loc = mkloc (Lident s) loc in
        (lident_lident_loc, mkexp (Pexp_ident lident_lident_loc))
      )}

non_punned_lbl_expression:
  x = label_longident _2 = COLON _3 = expr
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( (_1, _3) )}

non_punned_string_literal_expression:
  _1 = STRING _2 = COLON _3 = expr
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        let (s, d) = _1 in
        let lident_lident_loc = mkloc (Lident s) loc in
        (lident_lident_loc, _3)
      )}

lbl_expr_list_that_is_not_a_single_punned_field:
  _1 = non_punned_lbl_expression
    {     ( [_1] )}
| _1 = lbl_expr _2 = COMMA _3 = lbl_expr_list
    {      ( _1::_3 )}

string_literal_expr_list_that_is_not_a_single_punned_field:
  _1 = non_punned_string_literal_expression
    {    ( [_1] )}
| _1 = string_literal_expr _2 = COMMA _3 = string_literal_expr_list
    {    ( _1::_3 )}

field_expr:
  x = LIDENT _2 = COLON _3 = expr
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
    ( (_1, _3) )}
| _1 = LIDENT
    {let _endpos = _endpos__1_ in
let _symbolstartpos = _startpos__1_ in
    (
      let loc = mklocation _symbolstartpos _endpos in
      let lident_loc = mkloc _1 loc in
      let lident_lident_loc = mkloc (Lident _1) loc in
      (lident_loc, mkexp (Pexp_ident lident_lident_loc))
    )}

field_expr_list:
  _1 = field_expr
    {     ( [_1] )}
| _1 = field_expr_list _2 = COMMA _3 = field_expr
    {      ( _3::_1 )}

type_constraint_right_of_colon:
  _1 = core_type
    {                                          ( (Some (only_core_type _1 (mklocation _startpos__1_ _endpos__1_)), None) )}
| _1 = core_type _2 = COLONGREATER _3 = core_type
    {                                          ( (Some (only_core_type _1 (mklocation _startpos__1_ _endpos__1_)), Some (only_core_type _3 (mklocation _startpos__3_ _endpos__3_))) )}

type_constraint:
  _1 = COLON _2 = type_constraint_right_of_colon
    {                                                ( _2 )}
| _1 = COLONGREATER _2 = core_type
    {                                                ( (None, Some (only_core_type _2 (mklocation _startpos__2_ _endpos__2_))) )}

pattern:
  _1 = pattern_without_or
    {                       ( _1 )}
| _1 = or_pattern
    {               ( _1 )}

pattern_without_or:
  _1 = mark_position_pat__pattern_without_or_
    {                                                           (_1)}

_pattern_without_or:
  _1 = simple_pattern
    {      ( _1 )}
| _1 = pattern_without_or _2 = AS x = val_ident
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( mkpat(Ppat_alias(_1, _3)) )}
| _1 = pattern_without_or _2 = AS x = error
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( expecting_pat (with_txt _3 "identifier") )}
| x = constr_longident _2 = simple_pattern_list
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _startpos__1_ = _startpos_x_ in
let _endpos = _endpos__2_ in
let _symbolstartpos = _startpos__1_ in
    (
      match is_pattern_list_single_any _2 with
        | Some singleAnyPat ->
            mkpat
              (Ppat_construct(_1, Some singleAnyPat))
        | None ->
          let loc = mklocation _symbolstartpos _endpos in
          let argPattern = simple_pattern_list_to_tuple ~loc _2 in
          mkExplicitArityTuplePat (Ppat_construct(_1, Some argPattern))
    )}
| _1 = name_tag _2 = simple_pattern
    {    (
      mkpat (Ppat_variant(_1, Some _2))
    )}
| _1 = pattern_without_or x = COLONCOLON _3 = pattern_without_or
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( Location.raise_errorf ~loc:_2.loc ":: is not supported in Reason, please use [hd, ...tl] instead" )}
| _1 = pattern_without_or _2 = COLONCOLON x = error
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( expecting_pat (with_txt _3 "pattern") )}
| _1 = LPAREN _2 = COLONCOLON _3 = RPAREN _4 = LPAREN _5 = pattern_without_or _6 = COMMA _7 = pattern_without_or _8 = RPAREN
    {let _endpos = _endpos__8_ in
let _symbolstartpos = _startpos__1_ in
      (
         let loc_coloncolon = mklocation _startpos__2_ _endpos__2_ in
         let loc = mklocation _symbolstartpos _endpos in
         mkpat_cons loc_coloncolon (mkpat ~ghost:true ~loc (Ppat_tuple[_5;_7])) loc
      )}
| x = LPAREN _2 = COLONCOLON _3 = RPAREN _4 = LPAREN _5 = pattern_without_or _6 = COMMA _7 = pattern_without_or x_inlined1 = error
    {let _8 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( unclosed_pat (with_txt _1 "(") (with_txt _8 ")") )}
| _1 = LAZY _2 = simple_pattern
    {      ( mkpat(Ppat_lazy _2) )}
| _1 = EXCEPTION _2 = pattern_without_or %prec prec_constr_appl
    {      ( mkpat(Ppat_exception _2) )}
| _1 = pattern_without_or _2 = attribute
    {      ( Pat.attr _1 _2 )}

simple_pattern:
  _1 = mark_position_pat__simple_pattern_
    {                                                   (_1)}

_simple_pattern:
  x = val_ident
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( mkpat(Ppat_var _1) )}
| _1 = simple_pattern_not_ident
    {                             ( _1 )}

simple_pattern_not_ident:
  _1 = mark_position_pat__simple_pattern_not_ident_
    {                                                                       (_1)}

_simple_pattern_not_ident:
  _1 = UNDERSCORE
    {      ( mkpat(Ppat_any) )}
| _1 = signed_constant
    {      ( mkpat(Ppat_constant _1) )}
| _1 = signed_constant _2 = DOTDOT _3 = signed_constant
    {      ( mkpat(Ppat_interval (_1, _3)) )}
| x = constr_longident
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( mkpat(Ppat_construct(_1, None)) )}
| _1 = name_tag
    {      ( mkpat(Ppat_variant(_1, None)) )}
| _1 = SHARP x = type_longident
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( mkpat(Ppat_type (_2)) )}
| _1 = LBRACE _2 = lbl_pattern_list _3 = RBRACE
    {      ( let (fields, closed) = _2 in mkpat(Ppat_record(fields, closed)) )}
| x = LBRACE _2 = lbl_pattern_list x_inlined1 = error
    {let _3 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( unclosed_pat (with_txt _1 "{") (with_txt _3 "}") )}
| _1 = LBRACKET _2 = pattern_comma_list_extension _3 = opt_semi _4 = RBRACKET
    {      ( let seq, ext_opt = _2 in
        let loc_rbracket = mklocation _startpos__2_ _endpos__2_ in
        make_real_pat (mktailpat_extension loc_rbracket (List.rev seq) ext_opt) )}
| x = LBRACKET _2 = pattern_comma_list_extension _3 = opt_semi x_inlined1 = error
    {let _4 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( unclosed_pat (with_txt _1 "[") (with_txt _4 "]") )}
| _1 = LBRACKETBAR _2 = pattern_comma_list _3 = opt_semi _4 = BARRBRACKET
    {      ( mkpat(Ppat_array(List.rev _2)) )}
| _1 = LBRACKETBAR _2 = BARRBRACKET
    {      ( mkpat(Ppat_array []) )}
| x = LBRACKETBAR _2 = pattern_comma_list _3 = opt_semi x_inlined1 = error
    {let _4 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( unclosed_pat (with_txt _1 "[|") (with_txt _4 "|]") )}
| _1 = LPAREN _2 = pattern _3 = RPAREN
    {      ( _2 )}
| _1 = LPAREN _2 = pattern_two_or_more_comma_list _3 = RPAREN
    {      ( mkpat(Ppat_tuple(List.rev _2)) )}
| x = LPAREN _2 = pattern x_inlined1 = error
    {let _3 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( unclosed_pat (with_txt _1 "(") (with_txt _3 ")") )}
| _1 = LPAREN _2 = pattern _3 = COLON _4 = core_type _5 = RPAREN
    {      ( mkpat(Ppat_constraint(_2, only_core_type _4 (mklocation _startpos__4_ _endpos__4_))) )}
| x = LPAREN _2 = pattern _3 = COLON _4 = core_type x_inlined1 = error
    {let _5 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( unclosed_pat (with_txt _1 "(") (with_txt _5 ")") )}
| _1 = LPAREN _2 = pattern _3 = COLON x = error
    {let _4 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( expecting_pat (with_txt _4 "type") )}
| _1 = LPAREN _2 = MODULE x = UIDENT _4 = RPAREN
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( mkpat(Ppat_unpack _3) )}
| _1 = LPAREN _2 = MODULE x = UIDENT _4 = COLON _5 = package_type _6 = RPAREN
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__6_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        mkpat(Ppat_constraint(mkpat ~ghost:true ~loc (Ppat_unpack _3),
                              mktyp ~ghost:true ~loc (Ptyp_package _5))) )}
| x = LPAREN _2 = MODULE _3 = UIDENT _4 = COLON _5 = package_type x_inlined1 = error
    {let _6 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( unclosed_pat (with_txt _1 "(") (with_txt _6 ")") )}
| _1 = extension
    {      ( mkpat(Ppat_extension _1) )}

pattern_two_or_more_comma_list:
  _1 = pattern_two_or_more_comma_list _2 = COMMA _3 = pattern_optional_constraint
    {    ( _3::_1 )}
| _1 = pattern_optional_constraint _2 = COMMA _3 = pattern_optional_constraint
    {    ( [_3; _1] )}

simple_pattern_list:
  _1 = simple_pattern_list _2 = simple_pattern
    {    ( _2::_1 )}
| _1 = simple_pattern
    {    ( [_1] )}

pattern_optional_constraint:
  _1 = mark_position_pat__pattern_optional_constraint_
    {                                                                             (_1)}

_pattern_optional_constraint:
  _1 = pattern
    {                                ( _1 )}
| _1 = pattern _2 = COLON _3 = core_type
    {                                (
    let core_loc = mklocation _startpos__3_ _endpos__3_ in
    let ct = only_core_type _3 core_loc in
    mkpat(Ppat_constraint(_1, ct))
    )}

pattern_comma_list:
  _1 = pattern
    {                                                ( [_1] )}
| _1 = pattern_comma_list _2 = COMMA _3 = pattern
    {                                                  ( _3 :: _1 )}

pattern_comma_list_extension:
  _1 = pattern
    {                                                ( [_1], None )}
| _1 = pattern_comma_list _2 = COMMA _3 = DOTDOTDOT _4 = pattern
    {                                                ( (_1, Some _4) )}
| _1 = pattern_comma_list _2 = COMMA _3 = pattern
    {                                                ( (_3 :: _1, None) )}

lbl_pattern_list:
  _1 = lbl_pattern
    {                ( [_1], Closed )}
| _1 = lbl_pattern _2 = COMMA
    {                      ( [_1], Closed )}
| _1 = lbl_pattern _2 = COMMA _3 = UNDERSCORE _4 = opt_comma
    {                                           ( [_1], Open )}
| _1 = lbl_pattern _2 = COMMA _3 = lbl_pattern_list
    {      ( let (fields, closed) = _3 in _1 :: fields, closed )}

lbl_pattern:
  x = label_longident _2 = COLON _3 = pattern
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( (_1,_3) )}
| x = label_longident
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      (
        (_1, pat_of_label _1)
      )}

primitive_declaration:
  _1 = STRING
    {                                                ( [fst _1] )}
| _1 = STRING _2 = primitive_declaration
    {                                                ( fst _1 :: _2 )}

many_type_declarations:
  _1 = TYPE _2 = nonrec_flag _3 = type_declaration_details _4 = post_item_attributes
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
                                                                  (
   let (ident, params, constraints, kind, priv, manifest) = _3 in
   let loc = mklocation _symbolstartpos _endpos in
   let ty = Type.mk ident ~params:params ~cstrs:constraints
            ~kind ~priv ?manifest ~attrs:_4 ~loc
   in
   (_2, [ty])
   )}
| _1 = many_type_declarations _2 = and_type_declaration
    {                                               (
   let (nonrec_flag, tyl) = _1 in
   (nonrec_flag, _2 :: tyl)
   )}

and_type_declaration:
  _1 = AND _2 = type_declaration_details _3 = post_item_attributes
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
                                                      (
    let (ident, params, constraints, kind, priv, manifest) = _2 in
    let loc = mklocation _symbolstartpos _endpos in
    Type.mk ident
      ~params:params ~cstrs:constraints
      ~kind ~priv ?manifest ~attrs:_3 ~loc
  )}

type_declaration_details:
  x = UIDENT _2 = optional_type_parameters _3 = type_kind _4 = constraints
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( Location.raise_errorf ~loc:_1.loc "A type's name need to begin with a lower-case letter or _" )}
| x = LIDENT _2 = optional_type_parameters _3 = type_kind _4 = constraints
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( let (kind, priv, manifest) = _3 in
        (_1, _2, List.rev _4, kind, priv, manifest)
       )}

constraints:
  _1 = constraints _2 = CONSTRAINT _3 = constrain
    {                                                ( _3 :: _1 )}
| 
    {                                                ( [] )}

type_kind:
  
    {      ( (Ptype_abstract, Public, None) )}
| _1 = EQUAL _2 = core_type
    {      (
      match _2 with
      | Core_type ct -> (Ptype_abstract, Public, Some ct)
      | Record_type rt -> (Ptype_record rt, Public, None)
      )}
| _1 = EQUAL _2 = PRI _3 = core_type
    {                        (
      match _3 with
      | Core_type ct -> (Ptype_abstract, Private, Some ct)
      | Record_type rt -> (Ptype_record rt, Private, None)
    )}
| _1 = EQUAL _2 = constructor_declarations
    {      ( (Ptype_variant(_2),  Public, None) )}
| _1 = EQUAL _2 = PRI _3 = constructor_declarations
    {      ( (Ptype_variant(_3), Private, None) )}
| _1 = EQUAL _2 = DOTDOT
    {      ( (Ptype_open, Public, None) )}
| _1 = EQUAL _2 = core_type _3 = EQUAL _4 = constructor_declarations
    {      (
        let core_type_loc = mklocation _startpos__2_ _endpos__2_ in
        (Ptype_variant(_4), Public,  Some (only_core_type _2 core_type_loc))
      )}
| _1 = EQUAL _2 = core_type _3 = EQUAL _4 = PRI _5 = constructor_declarations
    {      (
        let core_type_loc = mklocation _startpos__2_ _endpos__2_ in
        (Ptype_variant(_5), Private, Some (only_core_type _2 core_type_loc))
      )}
| _1 = EQUAL _2 = core_type _3 = EQUAL _4 = DOTDOT
    {      (
        let core_type_loc = mklocation _startpos__2_ _endpos__2_ in
        (Ptype_open, Public, Some (only_core_type _2 core_type_loc))
      )}
| _1 = EQUAL _2 = core_type _3 = EQUAL _4 = private_flag _5 = LBRACE _6 = label_declarations _7 = opt_comma _8 = RBRACE
    {      (
        let core_type_loc = mklocation _startpos__2_ _endpos__2_ in
        (Ptype_record(List.rev (only_labels _6)), _4, Some (only_core_type _2 core_type_loc))
      )}

optional_type_parameters:
  
    {                                   ( [] )}
| _1 = optional_type_parameter_list
    {                                   ( List.rev _1 )}

optional_type_parameter_list:
  _1 = optional_type_variable_with_variance
    {                                                                         ( [_1] )}
| _1 = optional_type_parameter_list _2 = optional_type_variable_with_variance
    {                                                                         ( _2 :: _1 )}

optional_type_variable_with_variance:
  x = _optional_type_variable_with_variance
    {let _endpos = _endpos_x_ in
let _symbolstartpos = _startpos_x_ in
                                                                                (
      let first = fst x in
      let second = snd x in
      ({
        first with ptyp_loc = {
        first.ptyp_loc with
        loc_start = _symbolstartpos;
        loc_end = _endpos}}, second )
)}

_optional_type_variable_with_variance:
  _1 = QUOTE _2 = ident
    {                                                ( mktyp (Ptyp_var _2), Invariant )}
| _1 = UNDERSCORE
    {                                                ( mktyp (Ptyp_any), Invariant )}
| _1 = PLUS _2 = QUOTE _3 = ident
    {                                                ( mktyp (Ptyp_var _3), Covariant)}
| _1 = PLUS _2 = UNDERSCORE
    {                                                ( mktyp (Ptyp_any), Covariant )}
| _1 = MINUS _2 = QUOTE _3 = ident
    {                                                ( mktyp (Ptyp_var _3), Contravariant )}
| _1 = MINUS _2 = UNDERSCORE
    {                                                ( mktyp Ptyp_any, Contravariant )}

type_parameter:
  _1 = type_variance _2 = type_variable
    {                                                  ( _2, _1 )}

type_variance:
  
    {                                                ( Invariant )}
| _1 = PLUS
    {                                                ( Covariant )}
| _1 = MINUS
    {                                                ( Contravariant )}

type_variable:
  _1 = mark_position_typ__type_variable_
    {                                                 (_1)}

_type_variable:
  _1 = QUOTE _2 = ident
    {                                                ( mktyp (Ptyp_var _2) )}

constructor_declarations_leading_bar:
  _1 = constructor_declaration_leading_bar
    {                                                                             ( [_1] )}
| _1 = constructor_declarations_leading_bar _2 = constructor_declaration_leading_bar
    {                                                                             ( _2 :: _1 )}

constructor_declarations:
  _1 = constructor_declarations_leading_bar
    {                                                                                ( List.rev _1 )}
| _1 = constructor_declaration_no_leading_bar
    {                                                                                ( [_1] )}
| _1 = constructor_declaration_no_leading_bar _2 = constructor_declarations_leading_bar
    {                                                                                 ( _1 :: List.rev _2 )}

constructor_declaration_no_leading_bar:
  _1 = UIDENT _2 = generalized_constructor_arguments _3 = attributes
    {let _1 =
  let x =                                                 ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
     (
        let args,res = _2 in
        let loc = mklocation _symbolstartpos _endpos in
        Type.constructor _1 ~args ?res ~loc ~attrs:_3
     )}
| _1 = LBRACKET _2_inlined1 = RBRACKET _2 = generalized_constructor_arguments _3 = attributes
    {let _1 =
  let (_endpos__2_, _2) = (_endpos__2_inlined1_, _2_inlined1) in
  let x =                                                 ( "[]" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
     (
        let args,res = _2 in
        let loc = mklocation _symbolstartpos _endpos in
        Type.constructor _1 ~args ?res ~loc ~attrs:_3
     )}
| _1 = LPAREN _2_inlined1 = RPAREN _2 = generalized_constructor_arguments _3 = attributes
    {let _1 =
  let (_endpos__2_, _2) = (_endpos__2_inlined1_, _2_inlined1) in
  let x =                                                 ( "()" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
     (
        let args,res = _2 in
        let loc = mklocation _symbolstartpos _endpos in
        Type.constructor _1 ~args ?res ~loc ~attrs:_3
     )}
| _1 = COLONCOLON _2 = generalized_constructor_arguments _3 = attributes
    {let _1 =
  let x =                                                 ( "::" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
     (
        let args,res = _2 in
        let loc = mklocation _symbolstartpos _endpos in
        Type.constructor _1 ~args ?res ~loc ~attrs:_3
     )}
| _1 = FALSE _2 = generalized_constructor_arguments _3 = attributes
    {let _1 =
  let x =                                                 ( "false" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
     (
        let args,res = _2 in
        let loc = mklocation _symbolstartpos _endpos in
        Type.constructor _1 ~args ?res ~loc ~attrs:_3
     )}
| _1 = TRUE _2 = generalized_constructor_arguments _3 = attributes
    {let _1 =
  let x =                                                 ( "true" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
     (
        let args,res = _2 in
        let loc = mklocation _symbolstartpos _endpos in
        Type.constructor _1 ~args ?res ~loc ~attrs:_3
     )}

constructor_declaration_leading_bar:
  _1 = BAR _1_inlined1 = UIDENT _3 = generalized_constructor_arguments _4 = attributes
    {let _2 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let x =                                                 ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
      (
       let args,res = _3 in
       let loc = mklocation _symbolstartpos _endpos in
       Type.constructor _2 ~args ?res ~loc ~attrs:_4
      )}
| _1 = BAR _1_inlined1 = LBRACKET _2 = RBRACKET _3 = generalized_constructor_arguments _4 = attributes
    {let _2 =
  let (_startpos__1_, _1) = (_startpos__1_inlined1_, _1_inlined1) in
  let x =                                                 ( "[]" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
      (
       let args,res = _3 in
       let loc = mklocation _symbolstartpos _endpos in
       Type.constructor _2 ~args ?res ~loc ~attrs:_4
      )}
| _1 = BAR _1_inlined1 = LPAREN _2 = RPAREN _3 = generalized_constructor_arguments _4 = attributes
    {let _2 =
  let (_startpos__1_, _1) = (_startpos__1_inlined1_, _1_inlined1) in
  let x =                                                 ( "()" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
      (
       let args,res = _3 in
       let loc = mklocation _symbolstartpos _endpos in
       Type.constructor _2 ~args ?res ~loc ~attrs:_4
      )}
| _1 = BAR _1_inlined1 = COLONCOLON _3 = generalized_constructor_arguments _4 = attributes
    {let _2 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let x =                                                 ( "::" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
      (
       let args,res = _3 in
       let loc = mklocation _symbolstartpos _endpos in
       Type.constructor _2 ~args ?res ~loc ~attrs:_4
      )}
| _1 = BAR _1_inlined1 = FALSE _3 = generalized_constructor_arguments _4 = attributes
    {let _2 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let x =                                                 ( "false" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
      (
       let args,res = _3 in
       let loc = mklocation _symbolstartpos _endpos in
       Type.constructor _2 ~args ?res ~loc ~attrs:_4
      )}
| _1 = BAR _1_inlined1 = TRUE _3 = generalized_constructor_arguments _4 = attributes
    {let _2 =
  let (_endpos__1_, _startpos__1_, _1) = (_endpos__1_inlined1_, _startpos__1_inlined1_, _1_inlined1) in
  let x =                                                 ( "true" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
      (
       let args,res = _3 in
       let loc = mklocation _symbolstartpos _endpos in
       Type.constructor _2 ~args ?res ~loc ~attrs:_4
      )}

str_exception_declaration:
  _1 = EXCEPTION _2 = extension_constructor_declaration _3 = post_item_attributes
    {      (
        let ext = _2 in
        {ext with pext_attributes = ext.pext_attributes @ _3}
      )}
| _1 = EXCEPTION _2 = extension_constructor_rebind _3 = post_item_attributes
    {      (
        let ext = _2 in
        {ext with pext_attributes = ext.pext_attributes @ _3}
      )}

sig_exception_declaration:
  _1 = EXCEPTION _2 = extension_constructor_declaration _3 = post_item_attributes
    {      (
        let ext = _2 in
        {ext with pext_attributes = ext.pext_attributes @ _3}
      )}

generalized_constructor_arguments:
  
    {                                                ( (Pcstr_tuple [],None) )}
| _2 = constructor_arguments
    {let _1 =                                                (  ) in
                                          ( (_2, None) )}
| _1 = OF _2 = constructor_arguments
    {let _1 =                                                (  ) in
                                          ( (_2, None) )}
| _2 = constructor_arguments _3 = COLON _4 = core_type
    {let _1 =                                                (  ) in
                                                ( (_2,Some (only_core_type _4 (mklocation _startpos__4_ _endpos__4_))) )}
| _1 = OF _2 = constructor_arguments _3 = COLON _4 = core_type
    {let _1 =                                                (  ) in
                                                ( (_2,Some (only_core_type _4 (mklocation _startpos__4_ _endpos__4_))) )}
| _1 = COLON _2 = core_type
    {                                                ( (Pcstr_tuple [],Some (only_core_type _2 (mklocation _startpos__2_ _endpos__2_))) )}

label_declarations:
  _1 = label_declaration
    {                                                ( [_1] )}
| _1 = label_declarations _2 = COMMA _3 = label_declaration
    {                                                 ( _3 :: _1 )}

constructor_arguments:
  _1 = non_arrowed_simple_core_type
    {      (
        match _1 with
        | Core_type ct -> Pcstr_tuple [ct]
        | Record_type rt -> Pcstr_record rt
      )}
| _1 = non_arrowed_simple_core_type _2 = non_arrowed_simple_core_type_list
    {      (
        let core_type_loc = mklocation _startpos__1_ _endpos__1_ in
        let ct = only_core_type _1 core_type_loc in
        Pcstr_tuple (ct :: List.rev _2)
      )}

label_declaration:
  _1 = mutable_flag x = LIDENT _3 = attributes
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _startpos__2_ = _startpos_x_ in
let _endpos = _endpos__3_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
      (
       let loc = mklocation _symbolstartpos _endpos in
       let ct = mkct _2 in
       (Type.field _2 ct ~mut:_1 ~loc, _3)
      )}
| _1 = mutable_flag x = LIDENT _3 = attributes _4 = COLON _5 = poly_type _6 = attributes
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _startpos__2_ = _startpos_x_ in
let _endpos = _endpos__6_ in
let _symbolstartpos = if _startpos__1_ != _endpos__1_ then
  _startpos__1_
else
  _startpos__2_ in
      (
       let loc = mklocation _symbolstartpos _endpos in
       (Type.field _2 _5 ~mut:_1 ~attrs:_6 ~loc, _3)
      )}

potentially_long_ident_and_optional_type_parameters:
  _1 = LIDENT _2 = optional_type_parameters
    {                                  (
      let loc = mklocation _startpos__1_ _endpos__1_ in
      let lident_lident_loc = mkloc (Lident _1) loc in
      (lident_lident_loc, _2)
  )}
| x = type_strictly_longident _2 = optional_type_parameters
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
                                                             ((_1, _2))}

str_type_extension:
  _1 = TYPE _2 = nonrec_flag _3 = potentially_long_ident_and_optional_type_parameters _4 = PLUSEQ _5 = private_flag _6 = opt_bar _7 = str_extension_constructors _8 = post_item_attributes
    {  (
    if _2 <> Recursive then not_expecting _startpos__2_ _endpos__2_ "nonrec flag";
    let (potentially_long_ident, optional_type_parameters) = _3 in
    Te.mk potentially_long_ident (List.rev _7)
          ~params:optional_type_parameters ~priv:_5 ~attrs:_8
  )}

sig_type_extension:
  _1 = TYPE _2 = nonrec_flag _3 = potentially_long_ident_and_optional_type_parameters _4 = PLUSEQ _5 = private_flag _6 = opt_bar _7 = sig_extension_constructors _8 = post_item_attributes
    {  (
    if _2 <> Recursive then not_expecting _startpos__2_ _endpos__2_ "nonrec flag";
    let (potentially_long_ident, optional_type_parameters) = _3 in
    Te.mk potentially_long_ident (List.rev _7)
          ~params:optional_type_parameters ~priv:_5 ~attrs:_8
  )}

str_extension_constructors:
  _1 = extension_constructor_declaration
    {                                                          ( [_1] )}
| _1 = extension_constructor_rebind
    {                                                          ( [_1] )}
| _1 = str_extension_constructors _2 = BAR _3 = extension_constructor_declaration
    {      ( _3 :: _1 )}
| _1 = str_extension_constructors _2 = BAR _3 = extension_constructor_rebind
    {      ( _3 :: _1 )}

sig_extension_constructors:
  _1 = extension_constructor_declaration
    {                                                          ( [_1] )}
| _1 = sig_extension_constructors _2 = BAR _3 = extension_constructor_declaration
    {      ( _3 :: _1 )}

extension_constructor_declaration:
  _1 = UIDENT _2 = generalized_constructor_arguments _3 = attributes
    {let _1 =
  let x =                                                 ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
      ( let args, res = _2 in
        let loc = mklocation _symbolstartpos _endpos in
        Te.decl _1 ~args ?res ~loc ~attrs:_3 )}
| _1 = LBRACKET _2_inlined1 = RBRACKET _2 = generalized_constructor_arguments _3 = attributes
    {let _1 =
  let (_endpos__2_, _2) = (_endpos__2_inlined1_, _2_inlined1) in
  let x =                                                 ( "[]" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
      ( let args, res = _2 in
        let loc = mklocation _symbolstartpos _endpos in
        Te.decl _1 ~args ?res ~loc ~attrs:_3 )}
| _1 = LPAREN _2_inlined1 = RPAREN _2 = generalized_constructor_arguments _3 = attributes
    {let _1 =
  let (_endpos__2_, _2) = (_endpos__2_inlined1_, _2_inlined1) in
  let x =                                                 ( "()" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
      ( let args, res = _2 in
        let loc = mklocation _symbolstartpos _endpos in
        Te.decl _1 ~args ?res ~loc ~attrs:_3 )}
| _1 = COLONCOLON _2 = generalized_constructor_arguments _3 = attributes
    {let _1 =
  let x =                                                 ( "::" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
      ( let args, res = _2 in
        let loc = mklocation _symbolstartpos _endpos in
        Te.decl _1 ~args ?res ~loc ~attrs:_3 )}
| _1 = FALSE _2 = generalized_constructor_arguments _3 = attributes
    {let _1 =
  let x =                                                 ( "false" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
      ( let args, res = _2 in
        let loc = mklocation _symbolstartpos _endpos in
        Te.decl _1 ~args ?res ~loc ~attrs:_3 )}
| _1 = TRUE _2 = generalized_constructor_arguments _3 = attributes
    {let _1 =
  let x =                                                 ( "true" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
      ( let args, res = _2 in
        let loc = mklocation _symbolstartpos _endpos in
        Te.decl _1 ~args ?res ~loc ~attrs:_3 )}

extension_constructor_rebind:
  _1 = UIDENT _2 = EQUAL x = constr_longident _4 = attributes
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let x =                                                 ( _1 ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
      (
         let loc = mklocation _symbolstartpos _endpos in
         Te.rebind _1 _3 ~loc ~attrs:_4
      )}
| _1 = LBRACKET _2_inlined1 = RBRACKET _2 = EQUAL x = constr_longident _4 = attributes
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let (_endpos__2_, _2) = (_endpos__2_inlined1_, _2_inlined1) in
  let x =                                                 ( "[]" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
      (
         let loc = mklocation _symbolstartpos _endpos in
         Te.rebind _1 _3 ~loc ~attrs:_4
      )}
| _1 = LPAREN _2_inlined1 = RPAREN _2 = EQUAL x = constr_longident _4 = attributes
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let (_endpos__2_, _2) = (_endpos__2_inlined1_, _2_inlined1) in
  let x =                                                 ( "()" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__2_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
      (
         let loc = mklocation _symbolstartpos _endpos in
         Te.rebind _1 _3 ~loc ~attrs:_4
      )}
| _1 = COLONCOLON _2 = EQUAL x = constr_longident _4 = attributes
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let x =                                                 ( "::" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
      (
         let loc = mklocation _symbolstartpos _endpos in
         Te.rebind _1 _3 ~loc ~attrs:_4
      )}
| _1 = FALSE _2 = EQUAL x = constr_longident _4 = attributes
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let x =                                                 ( "false" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
      (
         let loc = mklocation _symbolstartpos _endpos in
         Te.rebind _1 _3 ~loc ~attrs:_4
      )}
| _1 = TRUE _2 = EQUAL x = constr_longident _4 = attributes
    {let _3 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _1 =
  let x =                                                 ( "true" ) in
  let (_endpos_x_, _startpos_x_) = (_endpos__1_, _startpos__1_) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
      (
         let loc = mklocation _symbolstartpos _endpos in
         Te.rebind _1 _3 ~loc ~attrs:_4
      )}

with_constraints:
  _1 = with_constraint
    {                                                ( [_1] )}
| _1 = with_constraints _2 = AND _3 = with_constraint
    {                                                ( _3 :: _1 )}

with_constraint:
  _1 = TYPE x = label_longident _3 = optional_type_parameters _4 = with_type_binder _5 = core_type _6 = constraints
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _endpos = _endpos__6_ in
let _symbolstartpos = _startpos__1_ in
      (
         let loc = mklocation _symbolstartpos _endpos in
         let core_type_loc = mklocation _startpos__5_ _endpos__5_ in
         Pwith_type
          (_2,
           (Type.mk {_2 with txt=Longident.last _2.txt}
              ~params:_3
              ~cstrs:(List.rev _6)
              ~manifest:(only_core_type _5 core_type_loc)
              ~priv:_4
              ~loc)) )}
| _1 = TYPE x = label_longident _3 = optional_type_parameters _4 = COLONEQUAL _5 = core_type
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let (_endpos__2_, _startpos__2_) = (_endpos_x_, _startpos_x_) in
let _endpos = _endpos__5_ in
let _symbolstartpos = _startpos__1_ in
    (
      let last = (
        match _2.txt with
            | Lident s -> s
            | _ -> not_expecting _startpos__2_ _endpos__2_ "Long type identifier"
      ) in
     let loc = mklocation _symbolstartpos _endpos in
     let core_type_loc = mklocation _startpos__5_ _endpos__5_ in
      Pwith_typesubst
          (Type.mk {_2 with txt=last}
             ~params:_3
             ~manifest:(only_core_type _5 core_type_loc)
             ~loc)
    )}
| _1 = MODULE x = mod_longident _3 = EQUAL x_inlined1 = mod_ext_longident
    {let _4 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( Pwith_module (_2, _4) )}
| _1 = MODULE x = UIDENT _3 = COLONEQUAL x_inlined1 = mod_ext_longident
    {let _4 =
  let (_endpos_x_, _startpos_x_, x) = (_endpos_x_inlined1_, _startpos_x_inlined1_, x_inlined1) in
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( Pwith_modsubst (_2, _4) )}

with_type_binder:
  _1 = EQUAL
    {                   ( Public )}
| _1 = EQUAL _2 = PRI
    {               ( Private )}

typevar_list:
  _1 = QUOTE _2 = ident
    {                                                ( [_2] )}
| _1 = typevar_list _2 = QUOTE _3 = ident
    {                                                ( _3 :: _1 )}

poly_type:
  _1 = mark_position_typ__poly_type_
    {                                         (_1)}

_poly_type:
  _1 = core_type
    {          ( only_core_type _1 (mklocation _startpos__1_ _endpos__1_))}
| _1 = typevar_list _2 = DOT _3 = core_type
    {          ( mktyp(Ptyp_poly(List.rev _1, only_core_type _3 (mklocation _startpos__3_ _endpos__3_))) )}

core_type:
  _1 = mark_position_typ2__core_type_
    {                                          (_1)}

_core_type:
  _1 = core_type2 %prec below_EQUALGREATER
    {      ( _1 )}
| _1 = core_type2 _2 = AS _3 = QUOTE _4 = ident
    {      (
        let core_type_loc = mklocation _startpos__1_ _endpos__1_ in
        let ct = only_core_type _1 core_type_loc in
        Core_type (mktyp(Ptyp_alias(ct, _4)))
      )}

core_type2:
  _1 = mark_position_typ2__core_type2_
    {                                            (_1)}

_core_type2:
  _1 = non_arrowed_core_type %prec below_LBRACKETAT
    {      ( _1 )}
| _1 = LIDENTCOLONCOLON _2 = non_arrowed_core_type _3 = QUESTION _4 = EQUALGREATER _5 = core_type2
    {      (
      match _2, _5 with
      | Core_type ct, Core_type ct2 -> Core_type (mktyp(Ptyp_arrow(Optional _1, ct, ct2)))
      | _ -> syntax_error()
      )}
| _1 = LIDENTCOLONCOLON _2 = non_arrowed_core_type _3 = EQUALGREATER _4 = core_type2
    {      (
      match _2, _4 with
      | Core_type ct, Core_type ct2 -> Core_type (mktyp(Ptyp_arrow(Labelled _1, ct, ct2)))
      | _ -> syntax_error()
      )}
| _1 = core_type2 _2 = EQUALGREATER _3 = core_type2
    {      (
      match _1, _3 with
            | Core_type ct, Core_type ct2 ->
                Core_type (mktyp(Ptyp_arrow(Nolabel, ct, ct2)))
            | _ -> syntax_error()
      )}

non_arrowed_core_type:
  _1 = non_arrowed_non_simple_core_type
    {    ( _1 )}
| _1 = non_arrowed_simple_core_type
    {    ( _1 )}

non_arrowed_non_simple_core_type:
  _1 = mark_position_typ2__non_arrowed_non_simple_core_type_
    {                                                                                        (_1)}

_non_arrowed_non_simple_core_type:
  x = type_longident _2 = non_arrowed_simple_core_type_list
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( Core_type (mktyp(Ptyp_constr(_1, List.rev _2))) )}
| _1 = SHARP x = class_longident _3 = non_arrowed_simple_core_type_list
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( Core_type (mktyp(Ptyp_class(_2, List.rev _3))) )}
| _1 = non_arrowed_core_type _2 = attribute
    {      (
        let core_type_loc = mklocation _startpos__1_ _endpos__1_ in
        let ct = only_core_type _1 core_type_loc in
        Core_type (Typ.attr ct _2)
      )}

non_arrowed_simple_core_type:
  _1 = mark_position_typ2__non_arrowed_simple_core_type_
    {                                                                                (_1)}

_non_arrowed_simple_core_type:
  _1 = LPAREN _2 = core_type_comma_list _3 = RPAREN
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
      (
        let loc = mklocation _symbolstartpos _endpos in
        match _2 with
        | [] -> raise (Syntaxerr.Error(Syntaxerr.Applicative_path loc))
        | one::[] -> Core_type one
        | moreThanOne -> Core_type (mktyp(Ptyp_tuple(List.rev moreThanOne))) )}
| _1 = QUOTE _2 = ident
    {      ( Core_type (mktyp(Ptyp_var _2)) )}
| _1 = SHARP x = class_longident
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( Core_type (mktyp(Ptyp_class(_2, []))) )}
| _1 = UNDERSCORE
    {      ( Core_type (mktyp(Ptyp_any)) )}
| x = type_longident
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      ( Core_type (mktyp(Ptyp_constr(_1, []))) )}
| _1 = object_record_type
    {      (
        let (labels, object_record) = _1 in
        match object_record with
        | Record -> Record_type(only_labels labels)
        | Object_open -> (
          Core_type(mktyp(Ptyp_object (List.map (fun l -> let (label, attr) = l in if label.pld_mutable == Mutable then syntax_error(); label.pld_name.txt, attr, label.pld_type ) labels, Open)))
        )
        | Object_closed -> Core_type(mktyp(Ptyp_object (List.map (fun l -> let (label, attr) = l in if label.pld_mutable == Mutable then syntax_error(); label.pld_name.txt, attr, label.pld_type ) labels, Closed)))
      )}
| _1 = LBRACKET _2 = tag_field _3 = RBRACKET
    {      ( Core_type(mktyp(Ptyp_variant([_2], Closed, None))) )}
| _1 = LBRACKET _2 = BAR _3 = row_field_list _4 = RBRACKET
    {      ( Core_type(mktyp(Ptyp_variant(List.rev _3, Closed, None))) )}
| _1 = LBRACKET _2 = row_field _3 = BAR _4 = row_field_list _5 = RBRACKET
    {      ( Core_type(mktyp(Ptyp_variant(_2 :: List.rev _4, Closed, None))) )}
| _1 = LBRACKETGREATER _2 = opt_bar _3 = row_field_list _4 = RBRACKET
    {      ( Core_type(mktyp(Ptyp_variant(List.rev _3, Open, None))) )}
| _1 = LBRACKETGREATER _2 = RBRACKET
    {      ( Core_type(mktyp(Ptyp_variant([], Open, None))) )}
| _1 = LBRACKETLESS _2 = opt_bar _3 = row_field_list _4 = RBRACKET
    {      ( Core_type(mktyp(Ptyp_variant(List.rev _3, Closed, Some []))) )}
| _1 = LBRACKETLESS _2 = opt_bar _3 = row_field_list _4 = GREATER _5 = name_tag_list _6 = RBRACKET
    {      ( Core_type(mktyp(Ptyp_variant(List.rev _3, Closed, Some (List.rev _5)))) )}
| _1 = LPAREN _2 = MODULE _3 = package_type _4 = RPAREN
    {      ( Core_type(mktyp(Ptyp_package _3)) )}
| _1 = extension
    {      ( Core_type(mktyp(Ptyp_extension _1)) )}

object_record_type:
  _1 = LBRACE _2 = RBRACE
    {      ( syntax_error () )}
| _1 = LBRACE _2 = DOT _3 = RBRACE
    {      ( [], Object_closed )}
| _1 = LBRACE _2 = DOTDOT _3 = RBRACE
    {      ( [], Object_open )}
| _1 = LBRACE _2 = label_declarations _3 = opt_comma _4 = RBRACE
    {      ( List.rev _2, Record )}
| _1 = LBRACE _2 = DOT _3 = label_declarations _4 = RBRACE
    {      ( List.rev _3, Object_closed )}
| _1 = LBRACE _2 = DOTDOT _3 = label_declarations _4 = RBRACE
    {      ( List.rev _3, Object_open )}

package_type:
  x = mty_longident
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
                          ( (_1, []) )}
| x = mty_longident _2 = WITH _3 = package_type_cstrs
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
                                                  ( (_1, _3) )}

package_type_cstr:
  _1 = TYPE x = label_longident _3 = EQUAL _4 = core_type
    {let _2 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
      (
        let core_type_loc = mklocation _startpos__4_ _endpos__4_ in
        let ct = only_core_type _4 core_type_loc in
        (_2, ct)
      )}

package_type_cstrs:
  _1 = package_type_cstr
    {                      ( [_1] )}
| _1 = package_type_cstr _2 = AND _3 = package_type_cstrs
    {                                             ( _1::_3 )}

row_field_list:
  _1 = row_field
    {                                                ( [_1] )}
| _1 = row_field_list _2 = BAR _3 = row_field
    {                                                ( _3 :: _1 )}

row_field:
  _1 = tag_field
    {                                                ( _1 )}
| _1 = non_arrowed_simple_core_type
    {      (
        let core_type_loc = mklocation _startpos__1_ _endpos__1_ in
        let ct = only_core_type _1 core_type_loc in
        Rinherit ct
      )}

tag_field:
  _1 = name_tag _2 = option_OF_ _3 = opt_ampersand _4 = amper_type_list _5 = attributes
    {      ( Rtag (_1, _5, _3, List.rev _4) )}
| _1 = name_tag _2 = attributes
    {      ( Rtag (_1, _2, true, []) )}

opt_ampersand:
  _1 = AMPERSAND
    {                                                ( true )}
| 
    {                                                ( false )}

amper_type_list:
  _1 = core_type
    {      (
        let core_type_loc = mklocation _startpos__1_ _endpos__1_ in
        let ct = only_core_type _1 core_type_loc in
        [ct]
      )}
| _1 = amper_type_list _2 = AMPERSAND _3 = core_type
    {      (
        let core_type_loc = mklocation _startpos__3_ _endpos__3_ in
        let ct = only_core_type _3 core_type_loc in
        ct :: _1
      )}

name_tag_list:
  _1 = name_tag
    {                                                ( [_1] )}
| _1 = name_tag_list _2 = name_tag
    {                                                ( _2 :: _1 )}

core_type_comma_list:
  _1 = core_type
    {      (
        let core_type_loc = mklocation _startpos__1_ _endpos__1_ in
        let ct = only_core_type _1 core_type_loc in
        [ct]
      )}
| _1 = core_type_comma_list _2 = COMMA _3 = core_type
    {      (
        let core_type_loc = mklocation _startpos__3_ _endpos__3_ in
        let ct = only_core_type _3 core_type_loc in
        ct :: _1
      )}

non_arrowed_simple_core_type_list:
  _1 = non_arrowed_simple_core_type
    {      (
        let core_type_loc = mklocation _startpos__1_ _endpos__1_ in
        let ct = only_core_type _1 core_type_loc in
        [ct]
      )}
| _1 = non_arrowed_simple_core_type_list _2 = non_arrowed_simple_core_type
    {      (
        let core_type_loc = mklocation _startpos__2_ _endpos__2_ in
        let ct = only_core_type _2 core_type_loc in
        ct :: _1
      )}

label:
  _1 = LIDENT
    {                                                ( _1 )}

constant:
  _1 = INT
    {                 ( let (n, m) = _1 in Pconst_integer (n, m) )}
| _1 = CHAR
    {                 ( Pconst_char _1 )}
| _1 = STRING
    {                 ( let (s, d) = _1 in Pconst_string (s, d) )}
| _1 = FLOAT
    {                 ( let (f, m) = _1 in Pconst_float (f, m) )}

signed_constant:
  _1 = constant
    {                 ( _1 )}
| _1 = MINUS _2 = INT
    {                 ( let (n, m) = _2 in Pconst_integer("-" ^ n, m) )}
| _1 = MINUS _2 = FLOAT
    {                 ( let (f, m) = _2 in Pconst_float("-" ^ f, m) )}
| _1 = PLUS _2 = INT
    {                 ( let (n, m) = _2 in Pconst_integer (n, m) )}
| _1 = PLUS _2 = FLOAT
    {                 ( let (f, m) = _2 in Pconst_float(f, m) )}

ident:
  _1 = UIDENT
    {                                                ( _1 )}
| _1 = LIDENT
    {                                                ( _1 )}

val_ident:
  _1 = LIDENT
    {                                                ( _1 )}
| _1 = LPAREN _2 = operator _3 = RPAREN
    {                                                ( _2 )}

operator:
  _1 = PREFIXOP
    {                                                ( _1 )}
| _1 = BANG
    {                                                ( "!" )}
| _1 = INFIXOP0
    {let _1 =                                                 ( _1 ) in
                                                ( _1 )}
| _1 = INFIXOP1
    {let _1 =                                                 ( _1 ) in
                                                ( _1 )}
| _1 = INFIXOP2
    {let _1 =                                                 ( _1 ) in
                                                ( _1 )}
| _1 = INFIXOP3
    {let _1 =                                                 ( _1 ) in
                                                ( _1 )}
| _1 = SLASHGREATER
    {let _1 =                                                 ( "/>" ) in
                                                ( _1 )}
| _1 = INFIXOP4
    {let _1 =                                                 ( _1 ) in
                                                ( _1 )}
| _1 = PLUS
    {let _1 =                                                 ( "+" ) in
                                                ( _1 )}
| _1 = PLUSDOT
    {let _1 =                                                 ( "+." ) in
                                                ( _1 )}
| _1 = MINUS
    {let _1 =                                                 ( "-" ) in
                                                ( _1 )}
| _1 = MINUSDOT
    {let _1 =                                                 ( "-." ) in
                                                ( _1 )}
| _1 = STAR
    {let _1 =                                                 ( "*" ) in
                                                ( _1 )}
| _1 = LESS
    {let _1 =                                                 ( "<" ) in
                                                ( _1 )}
| _1 = GREATER
    {let _1 =                                                 ( ">" ) in
                                                ( _1 )}
| _1 = OR
    {let _1 =                                                 ( "or" ) in
                                                ( _1 )}
| _1 = BARBAR
    {let _1 =                                                 ( "||" ) in
                                                ( _1 )}
| _1 = AMPERSAND
    {let _1 =                                                 ( "&" ) in
                                                ( _1 )}
| _1 = AMPERAMPER
    {let _1 =                                                 ( "&&" ) in
                                                ( _1 )}
| _1 = COLONEQUAL
    {let _1 =                                                 ( ":=" ) in
                                                ( _1 )}
| _1 = PLUSEQ
    {let _1 =                                                 ( "+=" ) in
                                                ( _1 )}
| _1 = PERCENT
    {let _1 =                                                 ( "%" ) in
                                                ( _1 )}
| _1 = LESSDOTDOTGREATER
    {let _1 =                                                 ( "<..>" ) in
                                                ( _1 )}
| _1 = GREATER _2 = GREATER
    {let _1 =                                                 ( ">>" ) in
                                                ( _1 )}

val_longident:
  _1 = val_ident
    {                                                ( Lident _1 )}
| _1 = mod_longident _2 = DOT _3 = val_ident
    {                                                ( Ldot(_1, _3) )}

constr_longident:
  _1 = mod_longident %prec below_DOT
    {                                                ( _1 )}
| _1 = LBRACKET _2 = RBRACKET
    {                                                ( Lident "[]" )}
| _1 = LPAREN _2 = RPAREN
    {                                                ( Lident "()" )}
| _1 = FALSE
    {                                                ( Lident "false" )}
| _1 = TRUE
    {                                                ( Lident "true" )}

label_longident:
  _1 = LIDENT
    {                                                ( Lident _1 )}
| _1 = mod_longident _2 = DOT _3 = LIDENT
    {                                                ( Ldot(_1, _3) )}

type_longident:
  _1 = LIDENT
    {                                                ( Lident _1 )}
| _1 = mod_ext_longident _2 = DOT _3 = LIDENT
    {                                                ( Ldot(_1, _3) )}

type_strictly_longident:
  _1 = mod_ext_longident _2 = DOT _3 = LIDENT
    {                                                ( Ldot(_1, _3) )}

mod_longident:
  _1 = UIDENT
    {                                                ( Lident _1 )}
| _1 = mod_longident _2 = DOT _3 = UIDENT
    {                                                ( Ldot(_1, _3) )}

mod_ext_longident:
  _1 = UIDENT
    {                                                ( Lident _1 )}
| _1 = mod_ext_longident _2 = DOT _3 = UIDENT
    {                                                ( Ldot(_1, _3) )}
| _1 = mod_ext2
    {             ( _1 )}

mod_ext2:
  _1 = mod_ext_longident _2 = DOT _3 = UIDENT _4 = LPAREN _5 = mod_ext_longident _6 = RPAREN
    {let _endpos = _endpos__6_ in
let _symbolstartpos = _startpos__1_ in
                                                                  (
     lapply ( Ldot(_1, _3)) _5 _symbolstartpos _endpos
   )}
| _1 = mod_ext2 _2 = LPAREN _3 = mod_ext_longident _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
                                              ( lapply _1 _3 _symbolstartpos _endpos )}
| _1 = UIDENT _2 = LPAREN _3 = mod_ext_longident _4 = RPAREN
    {let _endpos = _endpos__4_ in
let _symbolstartpos = _startpos__1_ in
                                            ( lapply (Lident(_1)) _3 _symbolstartpos _endpos )}

mty_longident:
  _1 = ident
    {                                                ( Lident _1 )}
| _1 = mod_ext_longident _2 = DOT _3 = ident
    {                                                ( Ldot(_1, _3) )}

clty_longident:
  _1 = LIDENT
    {                                                ( Lident _1 )}
| _1 = mod_ext_longident _2 = DOT _3 = LIDENT
    {                                                ( Ldot(_1, _3) )}

class_longident:
  _1 = LIDENT
    {                                                ( Lident _1 )}
| _1 = mod_longident _2 = DOT _3 = LIDENT
    {                                                ( Ldot(_1, _3) )}

toplevel_directive:
  _1 = SHARP _2 = ident
    {                                ( Ptop_dir(_2, Pdir_none) )}
| _1 = SHARP _2 = ident _3 = STRING
    {                                ( Ptop_dir(_2, Pdir_string (fst _3)) )}
| _1 = SHARP _2 = ident _3 = INT
    {                                ( let (n, m) = _3 in
                                  Ptop_dir(_2, Pdir_int (n, m)) )}
| _1 = SHARP _2 = ident _3 = val_longident
    {                                ( Ptop_dir(_2, Pdir_ident _3) )}
| _1 = SHARP _2 = ident _3 = mod_longident
    {                                ( Ptop_dir(_2, Pdir_ident _3) )}
| _1 = SHARP _2 = ident _3 = FALSE
    {                                ( Ptop_dir(_2, Pdir_bool false) )}
| _1 = SHARP _2 = ident _3 = TRUE
    {                                ( Ptop_dir(_2, Pdir_bool true) )}

opt_let_module:
  _1 = LET _2 = MODULE
    {                 ( () )}
| _1 = MODULE
    {             ( () )}

name_tag:
  _1 = BACKQUOTE _2 = ident
    {                                                ( _2 )}

rec_flag:
  
    {                                                ( Nonrecursive )}
| _1 = REC
    {                                                ( Recursive )}

nonrec_flag:
  
    {                                                ( Recursive )}
| _1 = NONREC
    {                                                ( Nonrecursive )}

direction_flag:
  _1 = TO
    {                                                ( Upto )}
| _1 = DOWNTO
    {                                                ( Downto )}

private_flag:
  
    {                                                ( Public )}
| _1 = PRI
    {                                            ( Private )}

mutable_flag:
  
    {                                                ( Immutable )}
| _1 = MUTABLE
    {                                                ( Mutable )}

virtual_flag:
  
    {                                                ( Concrete )}
| _1 = VIRTUAL
    {                                                ( Virtual )}

private_virtual_flags:
  
    {                 ( Concrete )}
| _1 = VIRTUAL
    {            ( Virtual )}

override_flag:
  
    {                                                ( Fresh )}
| _1 = BANG
    {                                                ( Override )}

opt_bar:
  
    {                                                ( () )}
| _1 = BAR
    {                                                ( () )}

opt_comma:
  
    {                                                ( () )}
| _1 = COMMA
    {                                                ( () )}

opt_semi:
  
    {                                                ( () )}
| _1 = SEMI
    {                                                ( () )}

subtractive:
  _1 = MINUS
    {                                                ( "-" )}
| _1 = MINUSDOT
    {                                                ( "-." )}

additive:
  _1 = PLUS
    {                                                ( "+" )}
| _1 = PLUSDOT
    {                                                ( "+." )}

single_attr_id:
  _1 = LIDENT
    {           ( _1 )}
| _1 = UIDENT
    {           ( _1 )}
| _1 = AND
    {        ( "and" )}
| _1 = AS
    {       ( "as" )}
| _1 = ASSERT
    {           ( "assert" )}
| _1 = BEGIN
    {          ( "begin" )}
| _1 = CLASS
    {          ( "class" )}
| _1 = CONSTRAINT
    {               ( "constraint" )}
| _1 = DO
    {       ( "do" )}
| _1 = DONE
    {         ( "done" )}
| _1 = DOWNTO
    {           ( "downto" )}
| _1 = ELSE
    {         ( "else" )}
| _1 = END
    {        ( "end" )}
| _1 = EXCEPTION
    {              ( "exception" )}
| _1 = EXTERNAL
    {             ( "external" )}
| _1 = FALSE
    {          ( "false" )}
| _1 = FOR
    {        ( "for" )}
| _1 = FUN
    {        ( "fun" )}
| _1 = FUNCTION
    {             ( "function" )}
| _1 = FUNCTOR
    {            ( "functor" )}
| _1 = IF
    {       ( "if" )}
| _1 = IN
    {       ( "in" )}
| _1 = INCLUDE
    {            ( "include" )}
| _1 = INHERIT
    {            ( "inherit" )}
| _1 = INITIALIZER
    {                ( "initializer" )}
| _1 = LAZY
    {         ( "lazy" )}
| _1 = LET
    {        ( "let" )}
| _1 = SWITCH
    {           ( "switch" )}
| _1 = MODULE
    {           ( "module" )}
| _1 = MUTABLE
    {            ( "mutable" )}
| _1 = NEW
    {        ( "new" )}
| _1 = NONREC
    {           ( "nonrec" )}
| _1 = OBJECT
    {           ( "object" )}
| _1 = OF
    {       ( "of" )}
| _1 = OPEN
    {         ( "open" )}
| _1 = OR
    {       ( "or" )}
| _1 = PRI
    {        ( "private" )}
| _1 = REC
    {        ( "rec" )}
| _1 = SIG
    {        ( "sig" )}
| _1 = STRUCT
    {           ( "struct" )}
| _1 = THEN
    {         ( "then" )}
| _1 = TO
    {       ( "to" )}
| _1 = TRUE
    {         ( "true" )}
| _1 = TRY
    {        ( "try" )}
| _1 = TYPE
    {         ( "type" )}
| _1 = VAL
    {        ( "val" )}
| _1 = VIRTUAL
    {            ( "virtual" )}
| _1 = WHEN
    {         ( "when" )}
| _1 = WHILE
    {          ( "while" )}
| _1 = WITH
    {         ( "with" )}

attr_id:
  x = single_attr_id
    {let _1 =
  let _endpos = _endpos_x_ in
  let _symbolstartpos = _startpos_x_ in
   ( mkloc x (mklocation _symbolstartpos _endpos) )
in
                           ( _1 )}
| _1 = single_attr_id _2 = DOT _3 = attr_id
    {let _endpos = _endpos__3_ in
let _symbolstartpos = _startpos__1_ in
                               ( mkloc (_1 ^ "." ^ _3.txt) (mklocation _symbolstartpos _endpos) )}

attribute:
  _1 = LBRACKETAT _2 = attr_id _3 = payload _4 = RBRACKET
    {                                      ( (_2, _3) )}

item_attribute:
  _1 = LBRACKETATAT _2 = attr_id _3 = payload _4 = RBRACKET
    {                                        ( (_2, _3) )}

floating_attribute:
  _1 = LBRACKETATATAT _2 = attr_id _3 = payload _4 = RBRACKET
    {                                            ((_2, _3))}

attributes:
  
    {               ( [] )}
| _1 = attribute _2 = attributes
    {                         ( _1 :: _2 )}

post_item_attributes:
  
    {               ( [] )}
| _1 = item_attribute _2 = post_item_attributes
    {                                        ( _1 :: _2 )}

item_extension_sugar:
  _1 = PERCENT _2 = attr_id
    {                    (
      ([], _2)
    )}

extension:
  _1 = LBRACKETPERCENT _2 = attr_id _3 = payload _4 = RBRACKET
    {                                           ( (_2, _3) )}

item_extension:
  _1 = LBRACKETPERCENTPERCENT _2 = attr_id _3 = payload _4 = RBRACKET
    {                                                  ( (_2, _3) )}

payload:
  _1 = structure
    {              ( PStr _1 )}
| _1 = COLON _2 = core_type
    {      (
        let core_type_loc = mklocation _startpos__2_ _endpos__2_ in
        let ct = only_core_type _2 core_type_loc in
        PTyp ct
      )}
| _1 = QUESTION _2 = pattern
    {                     ( PPat (_2, None) )}
| _1 = QUESTION _2 = pattern _3 = WHEN _4 = expr
    {                               ( PPat (_2, Some _4) )}

%%




