Grammar has 105 nonterminal symbols, among which 2 start symbols.
Grammar has 101 terminal symbols.
Grammar has 281 productions.
nullable(when_ck) = false
nullable(var_last) = false
nullable(val_or_empty) = true
nullable(unsafe) = true
nullable(type_dec) = false
nullable(ty_ident) = false
nullable(tuple_exp) = false
nullable(trunc_indexes) = false
nullable(switch_handlers) = false
nullable(switch_handler) = false
nullable(struct_ty_desc) = false
nullable(slist(SEMICOL,exp)) = true
nullable(slist(COMMA,exp)) = true
nullable(simple_exp) = false
nullable(sig_ck_annot) = true
nullable(separated_nonempty_list(POWER,simple_exp)) = false
nullable(separated_nonempty_list(COMMA,simple_exp)) = false
nullable(sblock(IN)) = true
nullable(returns) = false
nullable(qualname) = false
nullable(qualified(ident)) = false
nullable(qualified(Constructor)) = false
nullable(program_desc) = false
nullable(program) = false
nullable(present_handlers) = false
nullable(present_handler) = false
nullable(pat) = false
nullable(params_signature) = true
nullable(params) = true
nullable(param_signature) = false
nullable(param) = false
nullable(out_params) = true
nullable(optsnlist(SEMICOL,equ)) = false
nullable(optsnlist(COMMA,pat)) = false
nullable(opt_with) = true
nullable(opt_until_escapes) = true
nullable(opt_unless_escapes) = true
nullable(opt_semicolon) = true
nullable(opt_comma) = true
nullable(opt_block) = true
nullable(opt_bar) = true
nullable(opt_assume) = true
nullable(opens) = false
nullable(on_ck) = false
nullable(objective_kind) = false
nullable(objective) = false
nullable(nonmtexps) = false
nullable(nonmt_params_signature) = false
nullable(nonmt_params) = false
nullable(nonmt_out_params) = false
nullable(nonempty_list(objective)) = false
nullable(nonempty_list(merge_handler)) = false
nullable(node_params) = true
nullable(node_or_fun) = false
nullable(node_name) = false
nullable(node_dec) = false
nullable(modul) = false
nullable(merge_handlers) = false
nullable(merge_handler) = false
nullable(located_ty_ident) = false
nullable(loc_params) = false
nullable(list(program_desc)) = true
nullable(list(opens)) = true
nullable(list(interface_desc)) = true
nullable(label_ty_list) = false
nullable(label_ty) = false
nullable(iterator) = false
nullable(interface_desc) = false
nullable(interface) = false
nullable(infx) = false
nullable(indexes) = false
nullable(in_params) = true
nullable(ident_list) = false
nullable(ident) = false
nullable(field_exp_list) = false
nullable(field_exp) = false
nullable(extern) = true
nullable(exps) = true
nullable(exp) = false
nullable(escapes) = false
nullable(escape) = false
nullable(equs) = true
nullable(equ) = false
nullable(enum_ty_desc) = false
nullable(delim_slist(COMMA,LESS_LPAREN,RPAREN_GREATER,exp)) = true
nullable(ct_annot) = true
nullable(contract) = true
nullable(constructor_or_bool) = false
nullable(constructor) = false
nullable(constraints) = true
nullable(const_dec) = false
nullable(const) = false
nullable(ck_annot) = true
nullable(ck) = false
nullable(call_params) = true
nullable(block(LET)) = false
nullable(block(DO)) = false
nullable(automaton_handlers) = false
nullable(automaton_handler) = false
nullable(array_exp_list) = false
nullable(adelim_slist(COMMA,LPAREN,RPAREN,pat)) = false
nullable(_simple_exp) = false
nullable(_exp) = false
nullable(_equ) = false
nullable(_const) = false
first(when_ck) = NOT IDENT Constructor BOOL
first(var_last) = LAST IDENT
first(val_or_empty) = VAL
first(unsafe) = UNSAFE
first(type_dec) = TYPE
first(ty_ident) = LPAREN IDENT Constructor
first(tuple_exp) = SUBTRACTIVE STRING SPLIT REINIT PREFIX PRE NOT MERGE MAPI MAPFOLD MAP LPAREN LBRACKET LBRACE LAST INT INLINED IF IDENT FOLDI FOLD FLOAT Constructor BOOL
first(trunc_indexes) = LBRACKETGREATER
first(switch_handlers) = Constructor BOOL
first(switch_handler) = Constructor BOOL
first(struct_ty_desc) = LBRACE
first(slist(SEMICOL,exp)) = SUBTRACTIVE STRING SPLIT REINIT PREFIX PRE NOT MERGE MAPI MAPFOLD MAP LPAREN LBRACKET LBRACE LAST INT INLINED IF IDENT FOLDI FOLD FLOAT Constructor BOOL
first(slist(COMMA,exp)) = SUBTRACTIVE STRING SPLIT REINIT PREFIX PRE NOT MERGE MAPI MAPFOLD MAP LPAREN LBRACKET LBRACE LAST INT INLINED IF IDENT FOLDI FOLD FLOAT Constructor BOOL
first(simple_exp) = STRING LPAREN LBRACKET LBRACE INT IDENT FLOAT Constructor BOOL
first(sig_ck_annot) = ON COLONCOLON
first(separated_nonempty_list(POWER,simple_exp)) = STRING LPAREN LBRACKET LBRACE INT IDENT FLOAT Constructor BOOL
first(separated_nonempty_list(COMMA,simple_exp)) = STRING LPAREN LBRACKET LBRACE INT IDENT FLOAT Constructor BOOL
first(sblock(IN)) = VAR SWITCH RESET PRESENT LPAREN INIT IF IDENT DO AUTOMATON
first(returns) = RETURNS EQUAL
first(qualname) = LPAREN IDENT Constructor
first(qualified(ident)) = Constructor
first(qualified(Constructor)) = Constructor
first(program_desc) = UNSAFE TYPE PRAGMA NODE FUN CONST
first(program) = UNSAFE TYPE PRAGMA OPEN NODE FUN EOF CONST
first(present_handlers) = SUBTRACTIVE STRING SPLIT REINIT PREFIX PRE NOT MERGE MAPI MAPFOLD MAP LPAREN LBRACKET LBRACE LAST INT INLINED IF IDENT FOLDI FOLD FLOAT Constructor BOOL
first(present_handler) = SUBTRACTIVE STRING SPLIT REINIT PREFIX PRE NOT MERGE MAPI MAPFOLD MAP LPAREN LBRACKET LBRACE LAST INT INLINED IF IDENT FOLDI FOLD FLOAT Constructor BOOL
first(pat) = LPAREN INIT IDENT
first(params_signature) = THREE_DOTS LPAREN IDENT Constructor
first(params) = IDENT
first(param_signature) = THREE_DOTS LPAREN IDENT Constructor
first(param) = IDENT
first(out_params) = LAST IDENT
first(optsnlist(SEMICOL,equ)) = SWITCH RESET PRESENT LPAREN INIT IF IDENT DO AUTOMATON
first(optsnlist(COMMA,pat)) = LPAREN INIT IDENT
first(opt_with) = WITH
first(opt_until_escapes) = UNTIL
first(opt_unless_escapes) = UNLESS
first(opt_semicolon) = SEMICOL
first(opt_comma) = COMMA
first(opt_block) = VAR LET
first(opt_bar) = BAR
first(opt_assume) = ASSUME
first(opens) = OPEN
first(on_ck) = IDENT DOT Constructor BOOL
first(objective_kind) = REACHABLE ENFORCE ATTRACTIVE
first(objective) = REACHABLE ENFORCE ATTRACTIVE
first(nonmtexps) = SUBTRACTIVE STRING SPLIT REINIT PREFIX PRE NOT MERGE MAPI MAPFOLD MAP LPAREN LBRACKET LBRACE LAST INT INLINED IF IDENT FOLDI FOLD FLOAT Constructor BOOL
first(nonmt_params_signature) = THREE_DOTS LPAREN IDENT Constructor
first(nonmt_params) = IDENT
first(nonmt_out_params) = LAST IDENT
first(nonempty_list(objective)) = REACHABLE ENFORCE ATTRACTIVE
first(nonempty_list(merge_handler)) = LPAREN
first(node_params) = DOUBLE_LESS
first(node_or_fun) = NODE FUN
first(node_name) = LPAREN INLINED IDENT Constructor
first(node_dec) = UNSAFE NODE FUN
first(modul) = Constructor
first(merge_handlers) = STRING LPAREN LBRACKET LBRACE INT IDENT FLOAT Constructor BOOL
first(merge_handler) = LPAREN
first(located_ty_ident) = LPAREN IDENT Constructor
first(loc_params) = LAST IDENT
first(list(program_desc)) = UNSAFE TYPE PRAGMA NODE FUN CONST
first(list(opens)) = OPEN
first(list(interface_desc)) = VAL UNSAFE TYPE NODE FUN EXTERNAL CONST
first(label_ty_list) = IDENT
first(label_ty) = IDENT
first(iterator) = MAPI MAPFOLD MAP FOLDI FOLD
first(interface_desc) = VAL UNSAFE TYPE NODE FUN EXTERNAL CONST
first(interface) = VAL UNSAFE TYPE OPEN NODE FUN EXTERNAL EOF CONST
first(infx) = SUBTRACTIVE STAR PREFIX OR NOT INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 EQUALEQUAL EQUAL BARBAR AMPERSAND AMPERAMPER
first(indexes) = LBRACKET
first(in_params) = IDENT
first(ident_list) = IDENT
first(ident) = LPAREN IDENT
first(field_exp_list) = LPAREN IDENT Constructor
first(field_exp) = LPAREN IDENT Constructor
first(extern) = EXTERNAL
first(exps) = SUBTRACTIVE STRING SPLIT REINIT PREFIX PRE NOT MERGE MAPI MAPFOLD MAP LPAREN LBRACKET LBRACE LAST INT INLINED IF IDENT FOLDI FOLD FLOAT Constructor BOOL
first(exp) = SUBTRACTIVE STRING SPLIT REINIT PREFIX PRE NOT MERGE MAPI MAPFOLD MAP LPAREN LBRACKET LBRACE LAST INT INLINED IF IDENT FOLDI FOLD FLOAT Constructor BOOL
first(escapes) = SUBTRACTIVE STRING SPLIT REINIT PREFIX PRE NOT MERGE MAPI MAPFOLD MAP LPAREN LBRACKET LBRACE LAST INT INLINED IF IDENT FOLDI FOLD FLOAT Constructor BOOL
first(escape) = SUBTRACTIVE STRING SPLIT REINIT PREFIX PRE NOT MERGE MAPI MAPFOLD MAP LPAREN LBRACKET LBRACE LAST INT INLINED IF IDENT FOLDI FOLD FLOAT Constructor BOOL
first(equs) = SWITCH RESET PRESENT LPAREN INIT IF IDENT DO AUTOMATON
first(equ) = SWITCH RESET PRESENT LPAREN INIT IF IDENT DO AUTOMATON
first(enum_ty_desc) = Constructor BOOL
first(delim_slist(COMMA,LESS_LPAREN,RPAREN_GREATER,exp)) = LESS_LPAREN
first(ct_annot) = ON COLONCOLON
first(contract) = CONTRACT
first(constructor_or_bool) = Constructor BOOL
first(constructor) = Constructor
first(constraints) = BAR
first(const_dec) = CONST
first(const) = STRING INT FLOAT Constructor BOOL
first(ck_annot) = WHEN ON COLONCOLON
first(ck) = IDENT DOT Constructor BOOL
first(call_params) = DOUBLE_LESS
first(block(LET)) = VAR LET
first(block(DO)) = VAR DO
first(automaton_handlers) = STATE
first(automaton_handler) = STATE
first(array_exp_list) = SUBTRACTIVE STRING SPLIT REINIT PREFIX PRE NOT MERGE MAPI MAPFOLD MAP LPAREN LBRACKET LBRACE LAST INT INLINED IF IDENT FOLDI FOLD FLOAT Constructor BOOL
first(adelim_slist(COMMA,LPAREN,RPAREN,pat)) = LPAREN
first(_simple_exp) = STRING LPAREN LBRACKET LBRACE INT IDENT FLOAT Constructor BOOL
first(_exp) = SUBTRACTIVE STRING SPLIT REINIT PREFIX PRE NOT MERGE MAPI MAPFOLD MAP LPAREN LBRACKET LBRACE LAST INT INLINED IF IDENT FOLDI FOLD FLOAT Constructor BOOL
first(_equ) = SWITCH RESET PRESENT LPAREN INIT IF IDENT DO AUTOMATON
first(_const) = STRING INT FLOAT Constructor BOOL
minimal(when_ck) = (* 1 *) IDENT
minimal(var_last) = (* 3 *) IDENT COLON IDENT
minimal(val_or_empty) = (* 0 *) 
minimal(unsafe) = (* 0 *) 
minimal(type_dec) = (* 2 *) TYPE IDENT
minimal(ty_ident) = (* 1 *) IDENT
minimal(tuple_exp) = (* 3 *) IDENT COMMA IDENT
minimal(trunc_indexes) = (* 3 *) LBRACKETGREATER IDENT LESSRBRACKET
minimal(switch_handlers) = (* 2 *) BOOL DO
minimal(switch_handler) = (* 2 *) BOOL DO
minimal(struct_ty_desc) = (* 5 *) LBRACE IDENT COLON IDENT RBRACE
minimal(slist(SEMICOL,exp)) = (* 0 *) 
minimal(slist(COMMA,exp)) = (* 0 *) 
minimal(simple_exp) = (* 1 *) IDENT
minimal(sig_ck_annot) = (* 0 *) 
minimal(separated_nonempty_list(POWER,simple_exp)) = (* 1 *) IDENT
minimal(separated_nonempty_list(COMMA,simple_exp)) = (* 1 *) IDENT
minimal(sblock(IN)) = (* 0 *) 
minimal(returns) = (* 1 *) RETURNS
minimal(qualname) = (* 1 *) IDENT
minimal(qualified(ident)) = (* 3 *) Constructor DOT IDENT
minimal(qualified(Constructor)) = (* 3 *) Constructor DOT Constructor
minimal(program_desc) = (* 1 *) PRAGMA
minimal(program) = (* 1 *) EOF
minimal(present_handlers) = (* 2 *) IDENT DO
minimal(present_handler) = (* 2 *) IDENT DO
minimal(pat) = (* 1 *) IDENT
minimal(params_signature) = (* 0 *) 
minimal(params) = (* 0 *) 
minimal(param_signature) = (* 1 *) IDENT
minimal(param) = (* 3 *) IDENT COLON IDENT
minimal(out_params) = (* 0 *) 
minimal(optsnlist(SEMICOL,equ)) = (* 2 *) DO DONE
minimal(optsnlist(COMMA,pat)) = (* 1 *) IDENT
minimal(opt_with) = (* 0 *) 
minimal(opt_until_escapes) = (* 0 *) 
minimal(opt_unless_escapes) = (* 0 *) 
minimal(opt_semicolon) = (* 0 *) 
minimal(opt_comma) = (* 0 *) 
minimal(opt_block) = (* 0 *) 
minimal(opt_bar) = (* 0 *) 
minimal(opt_assume) = (* 0 *) 
minimal(opens) = (* 2 *) OPEN Constructor
minimal(on_ck) = (* 1 *) IDENT
minimal(objective_kind) = (* 1 *) ENFORCE
minimal(objective) = (* 2 *) ENFORCE IDENT
minimal(nonmtexps) = (* 1 *) IDENT
minimal(nonmt_params_signature) = (* 1 *) IDENT
minimal(nonmt_params) = (* 3 *) IDENT COLON IDENT
minimal(nonmt_out_params) = (* 3 *) IDENT COLON IDENT
minimal(nonempty_list(objective)) = (* 2 *) ENFORCE IDENT
minimal(nonempty_list(merge_handler)) = (* 5 *) LPAREN BOOL ARROW IDENT RPAREN
minimal(node_params) = (* 0 *) 
minimal(node_or_fun) = (* 1 *) NODE
minimal(node_name) = (* 1 *) IDENT
minimal(node_dec) = (* 9 *) NODE IDENT LPAREN RPAREN RETURNS LPAREN RPAREN LET TEL
minimal(modul) = (* 1 *) Constructor
minimal(merge_handlers) = (* 2 *) IDENT IDENT
minimal(merge_handler) = (* 5 *) LPAREN BOOL ARROW IDENT RPAREN
minimal(located_ty_ident) = (* 1 *) IDENT
minimal(loc_params) = (* 4 *) IDENT COLON IDENT SEMICOL
minimal(list(program_desc)) = (* 0 *) 
minimal(list(opens)) = (* 0 *) 
minimal(list(interface_desc)) = (* 0 *) 
minimal(label_ty_list) = (* 3 *) IDENT COLON IDENT
minimal(label_ty) = (* 3 *) IDENT COLON IDENT
minimal(iterator) = (* 1 *) MAP
minimal(interface_desc) = (* 2 *) TYPE IDENT
minimal(interface) = (* 1 *) EOF
minimal(infx) = (* 1 *) INFIX0
minimal(indexes) = (* 3 *) LBRACKET IDENT RBRACKET
minimal(in_params) = (* 0 *) 
minimal(ident_list) = (* 1 *) IDENT
minimal(ident) = (* 1 *) IDENT
minimal(field_exp_list) = (* 3 *) IDENT EQUAL IDENT
minimal(field_exp) = (* 3 *) IDENT EQUAL IDENT
minimal(extern) = (* 0 *) 
minimal(exps) = (* 0 *) 
minimal(exp) = (* 1 *) IDENT
minimal(escapes) = (* 3 *) IDENT THEN Constructor
minimal(escape) = (* 3 *) IDENT THEN Constructor
minimal(equs) = (* 0 *) 
minimal(equ) = (* 2 *) DO DONE
minimal(enum_ty_desc) = (* 1 *) Constructor
minimal(delim_slist(COMMA,LESS_LPAREN,RPAREN_GREATER,exp)) = (* 0 *) 
minimal(ct_annot) = (* 0 *) 
minimal(contract) = (* 0 *) 
minimal(constructor_or_bool) = (* 1 *) BOOL
minimal(constructor) = (* 1 *) Constructor
minimal(constraints) = (* 0 *) 
minimal(const_dec) = (* 6 *) CONST IDENT COLON IDENT EQUAL IDENT
minimal(const) = (* 1 *) INT
minimal(ck_annot) = (* 0 *) 
minimal(ck) = (* 1 *) DOT
minimal(call_params) = (* 0 *) 
minimal(block(LET)) = (* 1 *) LET
minimal(block(DO)) = (* 1 *) DO
minimal(automaton_handlers) = (* 3 *) STATE Constructor DO
minimal(automaton_handler) = (* 3 *) STATE Constructor DO
minimal(array_exp_list) = (* 1 *) IDENT
minimal(adelim_slist(COMMA,LPAREN,RPAREN,pat)) = (* 2 *) LPAREN RPAREN
minimal(_simple_exp) = (* 1 *) IDENT
minimal(_exp) = (* 2 *) LAST IDENT
minimal(_equ) = (* 2 *) DO DONE
minimal(_const) = (* 1 *) INT
follow(when_ck) = SEMICOL RPAREN EQUAL DOUBLE_GREATER BAR
follow(var_last) = SEMICOL RPAREN
follow(val_or_empty) = NODE FUN
follow(unsafe) = VAL NODE FUN
follow(type_dec) = VAL UNSAFE TYPE PRAGMA NODE FUN EXTERNAL EOF CONST
follow(ty_ident) = WHEN VAL UNSAFE TYPE SEMICOL RPAREN RBRACE PRAGMA POWER ON NODE FUN EXTERNAL EQUAL EOF DOUBLE_GREATER CONST COLONCOLON BAR AT
follow(tuple_exp) = RPAREN
follow(trunc_indexes) = WITH WHENOT WHEN VAR VAL UNTIL UNSAFE UNLESS TYPE THEN TEL SUBTRACTIVE STATE STAR SEMICOL RPAREN_GREATER RPAREN REACHABLE RBRACKET RBRACE PRAGMA POWER OR ON NODE LET LESS_GREATER LESSRBRACKET INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 FUN EXTERNAL EVERY EQUAL EOF ENFORCE END ELSE DOUBLE_GREATER DOUBLE_DOT DONE DO DEFAULT Constructor CONTINUE CONST COMMA COLONCOLON BOOL BAR ATTRACTIVE AROBASE AND AMPERSAND
follow(switch_handlers) = END BAR
follow(switch_handler) = END BAR
follow(struct_ty_desc) = VAL UNSAFE TYPE PRAGMA NODE FUN EXTERNAL EOF CONST
follow(slist(SEMICOL,exp)) = DOUBLE_GREATER
follow(slist(COMMA,exp)) = RPAREN_GREATER
follow(simple_exp) = WITH WHENOT WHEN VAR VAL UNTIL UNSAFE UNLESS TYPE THEN TEL SUBTRACTIVE STRING STATE STAR SEMICOL RPAREN_GREATER RPAREN REACHABLE RBRACKET RBRACE PRAGMA POWER OR ON NODE LPAREN LET LESS_GREATER LESSRBRACKET LBRACKETGREATER LBRACKET LBRACE INT INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 IDENT FUN FLOAT FBY EXTERNAL EVERY EQUAL EOF ENFORCE END ELSE DOUBLE_GREATER DOUBLE_DOT DOT DONE DO DEFAULT Constructor CONTINUE CONST COMMA COLONCOLON BOOL BAR ATTRACTIVE AT ARROW AROBASE AND AMPERSAND
follow(sig_ck_annot) = SEMICOL RPAREN
follow(separated_nonempty_list(POWER,simple_exp)) = WITH WHENOT WHEN VAR VAL UNTIL UNSAFE UNLESS TYPE THEN TEL SUBTRACTIVE STATE STAR SEMICOL RPAREN_GREATER RPAREN REACHABLE RBRACKET RBRACE PRAGMA POWER OR ON NODE LET LESS_GREATER LESSRBRACKET INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 FUN EXTERNAL EVERY EQUAL EOF ENFORCE END ELSE DOUBLE_GREATER DOUBLE_DOT DONE DO DEFAULT Constructor CONTINUE CONST COMMA COLONCOLON BOOL BAR ATTRACTIVE AROBASE AND AMPERSAND
follow(separated_nonempty_list(COMMA,simple_exp)) = DOUBLE_GREATER
follow(sblock(IN)) = EVERY END ELSE DONE
follow(returns) = LPAREN
follow(qualname) = WITH WHENOT WHEN VAR VAL UNTIL UNSAFE UNLESS TYPE THEN TEL SUBTRACTIVE STRING STATE STAR SEMICOL RPAREN_GREATER RPAREN REACHABLE RBRACKET RBRACE PRAGMA POWER OR ON NODE LPAREN LET LESS_LPAREN LESS_GREATER LESSRBRACKET LBRACKETGREATER LBRACKET LBRACE INT INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 IDENT FUN FLOAT FBY EXTERNAL EVERY EQUAL EOF ENFORCE END ELSE DOUBLE_LESS DOUBLE_GREATER DOUBLE_DOT DOT DONE DO DEFAULT Constructor CONTINUE CONST COMMA COLONCOLON BOOL BAR ATTRACTIVE AT ARROW AROBASE AND AMPERSAND
follow(qualified(ident)) = WITH WHENOT WHEN VAR VAL UNTIL UNSAFE UNLESS TYPE THEN TEL SUBTRACTIVE STRING STATE STAR SEMICOL RPAREN_GREATER RPAREN REACHABLE RBRACKET RBRACE PRAGMA POWER OR ON NODE LPAREN LET LESS_LPAREN LESS_GREATER LESSRBRACKET LBRACKETGREATER LBRACKET LBRACE INT INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 IDENT FUN FLOAT FBY EXTERNAL EVERY EQUAL EOF ENFORCE END ELSE DOUBLE_LESS DOUBLE_GREATER DOUBLE_DOT DOT DONE DO DEFAULT Constructor CONTINUE CONST COMMA COLONCOLON BOOL BAR ATTRACTIVE AT ARROW AROBASE AND AMPERSAND
follow(qualified(Constructor)) = WITH WHENOT WHEN VAR VAL UNTIL UNSAFE UNLESS TYPE THEN TEL SUBTRACTIVE STRING STATE STAR SEMICOL RPAREN_GREATER RPAREN REACHABLE RBRACKET RBRACE PRAGMA POWER OR ON NODE LPAREN LET LESS_GREATER LESSRBRACKET LBRACKETGREATER LBRACKET LBRACE INT INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 IDENT FUN FLOAT FBY EXTERNAL EVERY EQUAL EOF ENFORCE END ELSE DOUBLE_GREATER DOUBLE_DOT DOT DONE DO DEFAULT Constructor CONTINUE CONST COMMA COLONCOLON BOOL BAR ATTRACTIVE AT ARROW AROBASE AND AMPERSAND
follow(program_desc) = UNSAFE TYPE PRAGMA NODE FUN EOF CONST
follow(program) = #
follow(present_handlers) = END DEFAULT BAR
follow(present_handler) = END DEFAULT BAR
follow(pat) = RPAREN EQUAL COMMA
follow(params_signature) = RPAREN
follow(params) = RPAREN
follow(param_signature) = SEMICOL RPAREN
follow(param) = SEMICOL RPAREN DOUBLE_GREATER BAR
follow(out_params) = RPAREN
follow(optsnlist(SEMICOL,equ)) = UNTIL UNLESS TEL STATE EVERY END ELSE DONE DEFAULT BAR
follow(optsnlist(COMMA,pat)) = RPAREN
follow(opt_with) = VAR LET
follow(opt_until_escapes) = UNLESS STATE END
follow(opt_unless_escapes) = STATE END
follow(opt_semicolon) = VAR UNSAFE TYPE PRAGMA NODE LET FUN EOF CONTRACT CONST
follow(opt_comma) = RPAREN
follow(opt_block) = REACHABLE ENFORCE ATTRACTIVE ASSUME
follow(opt_bar) = SUBTRACTIVE STRING SPLIT REINIT PREFIX PRE NOT MERGE MAPI MAPFOLD MAP LPAREN LBRACKET LBRACE LAST INT INLINED IF IDENT FOLDI FOLD FLOAT Constructor BOOL
follow(opt_assume) = REACHABLE ENFORCE ATTRACTIVE
follow(opens) = VAL UNSAFE TYPE PRAGMA OPEN NODE FUN EXTERNAL EOF CONST
follow(on_ck) = SEMICOL RPAREN ONOT ON EQUAL DOUBLE_GREATER BAR
follow(objective_kind) = SUBTRACTIVE STRING SPLIT REINIT PREFIX PRE NOT MERGE MAPI MAPFOLD MAP LPAREN LBRACKET LBRACE LAST INT INLINED IF IDENT FOLDI FOLD FLOAT Constructor BOOL
follow(objective) = WITH VAR REACHABLE LET ENFORCE ATTRACTIVE
follow(nonmtexps) = RPAREN
follow(nonmt_params_signature) = RPAREN
follow(nonmt_params) = RPAREN DOUBLE_GREATER BAR
follow(nonmt_out_params) = RPAREN
follow(nonempty_list(objective)) = WITH VAR LET
follow(nonempty_list(merge_handler)) = WITH WHENOT WHEN VAR VAL UNTIL UNSAFE UNLESS TYPE THEN TEL SUBTRACTIVE STATE STAR SEMICOL RPAREN_GREATER RPAREN REACHABLE RBRACKET RBRACE PRAGMA POWER OR ON NODE LET LESS_GREATER LESSRBRACKET INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 FUN EXTERNAL EVERY EQUAL EOF ENFORCE END ELSE DOUBLE_GREATER DOUBLE_DOT DONE DO DEFAULT Constructor CONTINUE CONST COMMA COLONCOLON BOOL BAR ATTRACTIVE AROBASE AND AMPERSAND
follow(node_params) = LPAREN
follow(node_or_fun) = LPAREN IDENT
follow(node_name) = LPAREN
follow(node_dec) = UNSAFE TYPE PRAGMA NODE FUN EOF CONST
follow(modul) = VAL UNSAFE TYPE PRAGMA OPEN NODE FUN EXTERNAL EOF DOT CONST
follow(merge_handlers) = WITH WHENOT WHEN VAR VAL UNTIL UNSAFE UNLESS TYPE THEN TEL SUBTRACTIVE STATE STAR SEMICOL RPAREN_GREATER RPAREN REACHABLE RBRACKET RBRACE PRAGMA POWER OR ON NODE LET LESS_GREATER LESSRBRACKET INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 FUN EXTERNAL EVERY EQUAL EOF ENFORCE END ELSE DOUBLE_GREATER DOUBLE_DOT DONE DO DEFAULT Constructor CONTINUE CONST COMMA COLONCOLON BOOL BAR ATTRACTIVE AROBASE AND AMPERSAND
follow(merge_handler) = WITH WHENOT WHEN VAR VAL UNTIL UNSAFE UNLESS TYPE THEN TEL SUBTRACTIVE STATE STAR SEMICOL RPAREN_GREATER RPAREN REACHABLE RBRACKET RBRACE PRAGMA POWER OR ON NODE LPAREN LET LESS_GREATER LESSRBRACKET INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 FUN EXTERNAL EVERY EQUAL EOF ENFORCE END ELSE DOUBLE_GREATER DOUBLE_DOT DONE DO DEFAULT Constructor CONTINUE CONST COMMA COLONCOLON BOOL BAR ATTRACTIVE AROBASE AND AMPERSAND
follow(located_ty_ident) = WHEN SEMICOL RPAREN ON EQUAL DOUBLE_GREATER COLONCOLON BAR
follow(loc_params) = LET IN DO
follow(list(program_desc)) = EOF
follow(list(opens)) = VAL UNSAFE TYPE PRAGMA NODE FUN EXTERNAL EOF CONST
follow(list(interface_desc)) = EOF
follow(label_ty_list) = RBRACE
follow(label_ty) = SEMICOL RBRACE
follow(iterator) = DOUBLE_LESS
follow(interface_desc) = VAL UNSAFE TYPE NODE FUN EXTERNAL EOF CONST
follow(interface) = #
follow(infx) = RPAREN
follow(indexes) = WITH WHENOT WHEN VAR VAL UNTIL UNSAFE UNLESS TYPE THEN TEL SUBTRACTIVE STATE STAR SEMICOL RPAREN_GREATER RPAREN REACHABLE RBRACKET RBRACE PRAGMA POWER OR ON NODE LET LESS_GREATER LESSRBRACKET INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 FUN EXTERNAL EVERY EQUAL EOF ENFORCE END ELSE DOUBLE_GREATER DOUBLE_DOT DONE DO DEFAULT Constructor CONTINUE CONST COMMA COLONCOLON BOOL BAR ATTRACTIVE AROBASE AND AMPERSAND
follow(in_params) = RPAREN
follow(ident_list) = COLON
follow(ident) = WITH WHENOT WHEN VAR VAL UNTIL UNSAFE UNLESS TYPE THEN TEL SUBTRACTIVE STRING STATE STAR SEMICOL RPAREN_GREATER RPAREN REACHABLE RBRACKET RBRACE PRAGMA POWER OR ON NODE LPAREN LET LESS_LPAREN LESS_GREATER LESSRBRACKET LBRACKETGREATER LBRACKET LBRACE INT INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 IDENT FUN FLOAT FBY EXTERNAL EVERY EQUAL EOF ENFORCE END ELSE DOUBLE_LESS DOUBLE_GREATER DOUBLE_DOT DOT DONE DO DEFAULT Constructor CONTINUE CONST COMMA COLONCOLON BOOL BAR ATTRACTIVE AT ARROW AROBASE AND AMPERSAND
follow(field_exp_list) = RBRACE
follow(field_exp) = SEMICOL RBRACE
follow(extern) = VAL UNSAFE NODE FUN
follow(exps) = RPAREN
follow(exp) = WITH WHENOT WHEN VAR VAL UNTIL UNSAFE UNLESS TYPE THEN TEL SUBTRACTIVE STATE STAR SEMICOL RPAREN_GREATER RPAREN REACHABLE RBRACKET RBRACE PRAGMA POWER OR ON NODE LET LESS_GREATER LESSRBRACKET INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 FUN EXTERNAL EVERY EQUAL EOF ENFORCE END ELSE DOUBLE_GREATER DOUBLE_DOT DONE DO DEFAULT Constructor CONTINUE CONST COMMA COLONCOLON BOOL BAR ATTRACTIVE AROBASE AND AMPERSAND
follow(escapes) = UNLESS STATE END BAR
follow(escape) = UNLESS STATE END BAR
follow(equs) = UNTIL UNLESS TEL STATE EVERY END ELSE DONE DEFAULT BAR
follow(equ) = UNTIL UNLESS TEL STATE SEMICOL EVERY END ELSE DONE DEFAULT BAR
follow(enum_ty_desc) = VAL UNSAFE TYPE PRAGMA NODE FUN EXTERNAL EOF CONST
follow(delim_slist(COMMA,LESS_LPAREN,RPAREN_GREATER,exp)) = LPAREN
follow(ct_annot) = RPAREN
follow(contract) = VAR LET
follow(constructor_or_bool) = VAR LPAREN DO ARROW
follow(constructor) = WITH WHENOT WHEN VAR VAL UNTIL UNSAFE UNLESS TYPE THEN TEL SUBTRACTIVE STRING STATE STAR SEMICOL RPAREN_GREATER RPAREN REACHABLE RBRACKET RBRACE PRAGMA POWER OR ON NODE LPAREN LET LESS_GREATER LESSRBRACKET LBRACKETGREATER LBRACKET LBRACE INT INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 IDENT FUN FLOAT FBY EXTERNAL EVERY EQUAL EOF ENFORCE END ELSE DOUBLE_GREATER DOUBLE_DOT DOT DONE DO DEFAULT Constructor CONTINUE CONST COMMA COLONCOLON BOOL BAR ATTRACTIVE AT ARROW AROBASE AND AMPERSAND
follow(constraints) = DOUBLE_GREATER
follow(const_dec) = VAL UNSAFE TYPE PRAGMA NODE FUN EXTERNAL EOF CONST
follow(const) = WITH WHENOT WHEN VAR VAL UNTIL UNSAFE UNLESS TYPE THEN TEL SUBTRACTIVE STRING STATE STAR SEMICOL RPAREN_GREATER RPAREN REACHABLE RBRACKET RBRACE PRAGMA POWER OR ON NODE LPAREN LET LESS_GREATER LESSRBRACKET LBRACKETGREATER LBRACKET LBRACE INT INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 IDENT FUN FLOAT FBY EXTERNAL EVERY EQUAL EOF ENFORCE END ELSE DOUBLE_GREATER DOUBLE_DOT DOT DONE DO DEFAULT Constructor CONTINUE CONST COMMA COLONCOLON BOOL BAR ATTRACTIVE AT ARROW AROBASE AND AMPERSAND
follow(ck_annot) = SEMICOL RPAREN EQUAL DOUBLE_GREATER BAR
follow(ck) = SEMICOL RPAREN ONOT ON EQUAL DOUBLE_GREATER BAR
follow(call_params) = LPAREN
follow(block(LET)) = TEL
follow(block(DO)) = UNTIL UNLESS STATE END DEFAULT BAR
follow(automaton_handlers) = STATE END
follow(automaton_handler) = STATE END
follow(array_exp_list) = RBRACKET DOUBLE_GREATER
follow(adelim_slist(COMMA,LPAREN,RPAREN,pat)) = RPAREN EQUAL COMMA
follow(_simple_exp) = WITH WHENOT WHEN VAR VAL UNTIL UNSAFE UNLESS TYPE THEN TEL SUBTRACTIVE STRING STATE STAR SEMICOL RPAREN_GREATER RPAREN REACHABLE RBRACKET RBRACE PRAGMA POWER OR ON NODE LPAREN LET LESS_GREATER LESSRBRACKET LBRACKETGREATER LBRACKET LBRACE INT INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 IDENT FUN FLOAT FBY EXTERNAL EVERY EQUAL EOF ENFORCE END ELSE DOUBLE_GREATER DOUBLE_DOT DOT DONE DO DEFAULT Constructor CONTINUE CONST COMMA COLONCOLON BOOL BAR ATTRACTIVE AT ARROW AROBASE AND AMPERSAND
follow(_exp) = WITH WHENOT WHEN VAR VAL UNTIL UNSAFE UNLESS TYPE THEN TEL SUBTRACTIVE STATE STAR SEMICOL RPAREN_GREATER RPAREN REACHABLE RBRACKET RBRACE PRAGMA POWER OR ON NODE LET LESS_GREATER LESSRBRACKET INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 FUN EXTERNAL EVERY EQUAL EOF ENFORCE END ELSE DOUBLE_GREATER DOUBLE_DOT DONE DO DEFAULT Constructor CONTINUE CONST COMMA COLONCOLON BOOL BAR ATTRACTIVE AROBASE AND AMPERSAND
follow(_equ) = UNTIL UNLESS TEL STATE SEMICOL EVERY END ELSE DONE DEFAULT BAR
follow(_const) = WITH WHENOT WHEN VAR VAL UNTIL UNSAFE UNLESS TYPE THEN TEL SUBTRACTIVE STRING STATE STAR SEMICOL RPAREN_GREATER RPAREN REACHABLE RBRACKET RBRACE PRAGMA POWER OR ON NODE LPAREN LET LESS_GREATER LESSRBRACKET LBRACKETGREATER LBRACKET LBRACE INT INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 IDENT FUN FLOAT FBY EXTERNAL EVERY EQUAL EOF ENFORCE END ELSE DOUBLE_GREATER DOUBLE_DOT DOT DONE DO DEFAULT Constructor CONTINUE CONST COMMA COLONCOLON BOOL BAR ATTRACTIVE AT ARROW AROBASE AND AMPERSAND
Built an LR(0) automaton with 556 states.
The grammar is not SLR(1) -- 33 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 559 states.
336 shift/reduce conflicts were silently solved.
Warning: one state has shift/reduce conflicts.
Warning: 4 states have reduce/reduce conflicts.
4 conflicts could not be explained.
Warning: one shift/reduce conflict was arbitrarily resolved.
Warning: 4 reduce/reduce conflicts were arbitrarily resolved.
185 out of 559 states have a default reduction.
238 out of 559 states are represented.
60 out of 210 symbols keep track of their start position.
67 out of 210 symbols keep track of their end position.
143 out of 283 productions exploit shiftreduce optimization.
0 out of 559 states can peek at an error.
1513 functions before inlining, 250 functions after inlining.
