%{
(*
 * src: ocamlyaccified from Marcel Laverdet 'fbjs2' via emacs macros, itself
 * extracted from the official ECMAscript specification at:
 *  http://www.ecma-international.org/publications/standards/ecma-262.htm
 *
 * see also http://en.wikipedia.org/wiki/ECMAScript_syntax
 *
 * related work:
 *  - http://marijnhaverbeke.nl/parse-js/, js parser in common lisp
 *    (which has been since ported to javascript by nodejs people)
 *  - jslint
 *)

module J = Javascript
open Js_token

let var name = J.S {J.name;J.var=None}

(* This is need to fake menhir while using `--infer`. *)
let _tok = EOF Parse_info.zero

%}
%start program
%start standalone_expression
%token <Parse_info.t> EOF
%token <Parse_info.t> T_AND
%token <Parse_info.t> T_ASSIGN
%token <Parse_info.t> T_BIT_AND
%token <Parse_info.t> T_BIT_AND_ASSIGN
%token <Parse_info.t> T_BIT_NOT
%token <Parse_info.t> T_BIT_OR
%token <Parse_info.t> T_BIT_OR_ASSIGN
%token <Parse_info.t> T_BIT_XOR
%token <Parse_info.t> T_BIT_XOR_ASSIGN
%token <Parse_info.t> T_BREAK
%token <Parse_info.t> T_CASE
%token <Parse_info.t> T_CATCH
%token <Parse_info.t> T_COLON
%token <Parse_info.t> T_COMMA
%token <Parse_info.t> T_CONTINUE
%token <Parse_info.t> T_DEBUGGER
%token <Parse_info.t> T_DECR
%token <Parse_info.t> T_DECR_NB
%token <Parse_info.t> T_DEFAULT
%token <Parse_info.t> T_DELETE
%token <Parse_info.t> T_DIV
%token <Parse_info.t> T_DIV_ASSIGN
%token <Parse_info.t> T_DO
%token <Parse_info.t> T_ELSE
%token <Parse_info.t> T_EQUAL
%token <Parse_info.t> T_FALSE
%token <Parse_info.t> T_FINALLY
%token <Parse_info.t> T_FOR
%token <Parse_info.t> T_FUNCTION
%token <Parse_info.t> T_GREATER_THAN
%token <Parse_info.t> T_GREATER_THAN_EQUAL
%token <string * Parse_info.t> T_IDENTIFIER
%token <Parse_info.t> T_IF
%token <Parse_info.t> T_IN
%token <Parse_info.t> T_INCR
%token <Parse_info.t> T_INCR_NB
%token <Parse_info.t> T_INSTANCEOF
%token <Parse_info.t> T_LBRACKET
%token <Parse_info.t> T_LCURLY
%token <Parse_info.t> T_LESS_THAN
%token <Parse_info.t> T_LESS_THAN_EQUAL
%token <Parse_info.t> T_LPAREN
%token <Parse_info.t> T_LSHIFT
%token <Parse_info.t> T_LSHIFT_ASSIGN
%token <Parse_info.t> T_MINUS
%token <Parse_info.t> T_MINUS_ASSIGN
%token <Parse_info.t> T_MOD
%token <Parse_info.t> T_MOD_ASSIGN
%token <Parse_info.t> T_MULT
%token <Parse_info.t> T_MULT_ASSIGN
%token <Parse_info.t> T_NEW
%token <Parse_info.t> T_NOT
%token <Parse_info.t> T_NOT_EQUAL
%token <Parse_info.t> T_NULL
%token <string * float * Parse_info.t> T_NUMBER
%token <Parse_info.t> T_OR
%token <Parse_info.t> T_PERIOD
%token <Parse_info.t> T_PLING
%token <Parse_info.t> T_PLUS
%token <Parse_info.t> T_PLUS_ASSIGN
%token <Parse_info.t> T_RBRACKET
%token <Parse_info.t> T_RCURLY
%token <string * Parse_info.t> T_REGEX
%token <Parse_info.t> T_RETURN
%token <Parse_info.t> T_RPAREN
%token <Parse_info.t> T_RSHIFT
%token <Parse_info.t> T_RSHIFT3
%token <Parse_info.t> T_RSHIFT3_ASSIGN
%token <Parse_info.t> T_RSHIFT_ASSIGN
%token <Parse_info.t> T_SEMICOLON
%token <Parse_info.t> T_STRICT_EQUAL
%token <Parse_info.t> T_STRICT_NOT_EQUAL
%token <string * Parse_info.t> T_STRING
%token <Parse_info.t> T_SWITCH
%token <Parse_info.t> T_THIS
%token <Parse_info.t> T_THROW
%token <Parse_info.t> T_TRUE
%token <Parse_info.t> T_TRY
%token <Parse_info.t> T_TYPEOF
%token <Parse_info.t> T_VAR
%token <Parse_info.t> T_VIRTUAL_SEMICOLON
%token <Parse_info.t> T_VOID
%token <Parse_info.t> T_WHILE
%token <Parse_info.t> T_WITH
%nonassoc p_IF
%nonassoc T_ELSE
%left T_OR
%left T_AND
%left T_BIT_OR
%left T_BIT_XOR
%left T_BIT_AND
%left T_EQUAL T_NOT_EQUAL T_STRICT_EQUAL T_STRICT_NOT_EQUAL
%left T_GREATER_THAN T_GREATER_THAN_EQUAL T_IN T_INSTANCEOF T_LESS_THAN T_LESS_THAN_EQUAL
%left T_LSHIFT T_RSHIFT T_RSHIFT3
%left T_MINUS T_PLUS
%left T_DIV T_MOD T_MULT
%right T_BIT_NOT T_DECR T_DECR_NB T_DELETE T_INCR T_INCR_NB T_NOT T_TYPEOF T_VOID
%type <Javascript.program> program
%type <Javascript.expression> standalone_expression
%%

option_expression_:
  
    {    ( None )}
| x = expression
    {    ( Some x )}

option_expression_no_in_:
  
    {    ( None )}
| x = expression_no_in
    {    ( Some x )}

option_finally_:
  
    {    ( None )}
| x = finally
    {    ( Some x )}

option_initializer__:
  
    {    ( None )}
| x = initializer_
    {    ( Some x )}

option_initializer_no_in_:
  
    {    ( None )}
| x = initializer_no_in
    {    ( Some x )}

option_label_:
  
    {    ( None )}
| x = label
    {    ( Some x )}

option_pair_default_clause_list_case_clause___:
  
    {    ( None )}
| x = default_clause y = list_case_clause_
    {let x =     ( (x, y) ) in
    ( Some x )}

option_variable_:
  
    {    ( None )}
| x = variable
    {    ( Some x )}

loption_separated_nonempty_list_T_COMMA_assignment_expression__:
  
    {    ( [] )}
| x = separated_nonempty_list_T_COMMA_assignment_expression_
    {    ( x )}

loption_separated_nonempty_list_T_COMMA_variable__:
  
    {    ( [] )}
| x = separated_nonempty_list_T_COMMA_variable_
    {    ( x )}

list_case_clause_:
  
    {    ( [] )}
| x = case_clause xs = list_case_clause_
    {    ( x :: xs )}

list_source_element_:
  
    {    ( [] )}
| x = source_element xs = list_source_element_
    {    ( x :: xs )}

list_statement_:
  
    {    ( [] )}
| x = statement xs = list_statement_
    {    ( x :: xs )}

separated_nonempty_list_T_COMMA_assignment_expression_:
  x = assignment_expression
    {    ( [ x ] )}
| x = assignment_expression _2 = T_COMMA xs = separated_nonempty_list_T_COMMA_assignment_expression_
    {    ( x :: xs )}

separated_nonempty_list_T_COMMA_pair_variable_option_initializer____:
  x = variable y = option_initializer__
    {let x =     ( (x, y) ) in
    ( [ x ] )}
| x = variable y = option_initializer__ _2 = T_COMMA xs = separated_nonempty_list_T_COMMA_pair_variable_option_initializer____
    {let x =     ( (x, y) ) in
    ( x :: xs )}

separated_nonempty_list_T_COMMA_pair_variable_option_initializer_no_in___:
  x = variable y = option_initializer_no_in_
    {let x =     ( (x, y) ) in
    ( [ x ] )}
| x = variable y = option_initializer_no_in_ _2 = T_COMMA xs = separated_nonempty_list_T_COMMA_pair_variable_option_initializer_no_in___
    {let x =     ( (x, y) ) in
    ( x :: xs )}

separated_nonempty_list_T_COMMA_variable_:
  x = variable
    {    ( [ x ] )}
| x = variable _2 = T_COMMA xs = separated_nonempty_list_T_COMMA_variable_
    {    ( x :: xs )}

program:
  l = list_source_element_ _2 = EOF
    {                         ( l )}

standalone_expression:
  e = expression _2 = EOF
    {                    ( e )}

source_element:
  _1 = statement
    {   ( let statement, pi = _1 in J.Statement statement, pi )}
| _1 = function_declaration
    {   ( let declaration, pi = _1 in J.Function_declaration declaration, pi )}

statement_no_semi:
  block = curly_block_list_statement__
    {   ( let statements, pi_start, _pi_end = block in
     J.Block statements, J.Pi pi_start )}
| s = if_statement
    {                     ( s )}
| s = while_statement
    {                     ( s )}
| s = for_statement
    {                     ( s )}
| s = for_in_statement
    {                     ( s )}
| s = with_statement
    {                     ( s )}
| s = switch_statement
    {                     ( s )}
| s = try_statement
    {                     ( s )}
| s = labeled_statement
    {                     ( s )}
| s = empty_statement
    {                     ( s )}

statement_need_semi:
  s = variable_statement
    {                        ( s )}
| s = expression_statement
    {                        ( s )}
| s = do_while_statement
    {                        ( s )}
| s = continue_statement
    {                        ( s )}
| s = break_statement
    {                        ( s )}
| s = return_statement
    {                        ( s )}
| s = throw_statement
    {                        ( s )}
| s = debugger_statement
    {                        ( s )}

statement:
  s = statement_no_semi
    {                       ( s )}
| s = statement_need_semi _2 = either_T_SEMICOLON_T_VIRTUAL_SEMICOLON_
    {                                                                  ( s )}
| statement = statement_need_semi
    {                                 (
    (* 7.9.1 - 1 *)
    (* When, as the program is parsed from left to right, a token (called the offending token)
       is encountered that is not allowed by any production of the grammar, then a semicolon
       is automatically inserted before the offending token if one or more of the following
       conditions is true:
       - The offending token is }.
       - The offending token is separated from the previous
         token by at least one LineTerminator. *)

    (* 7.9.1 - 2 *)
    (* When, as the program is parsed from left to right, the end of the input stream of tokens *)
    (* is encountered and the parser is unable to parse the input token stream as a single *)
    (* complete ECMAScript Program, then a semicolon is automatically inserted at the end *)
    (* of the input stream. *)

    (* @@@@@@@@@ HACK @@@@@@@@@@ *)
    (* menhir internal's         *)
    (* look the current token:   *)
    (* - if it is on another line (linebreak inbetween), accept the statement *)
    (* - fail otherwise *)
    (* @@@@@@@@@ HACK @@@@@@@@@@ *)

    match _tok with
      | EOF _ | T_RCURLY _ -> statement
      | token ->
        let info = Js_token.info_of_tok token in
        match info.Parse_info.fol with
          | Some true -> statement
          | _ -> (raise _eRR)
  )}

labeled_statement:
  l = label _2 = T_COLON s = statement
    {                              ( J.Labelled_statement (l, s), J.N )}

block:
  block = curly_block_list_statement__
    {   ( let statements, _, _ = block in statements )}

variable_statement:
  pi = T_VAR list = separated_nonempty_list_T_COMMA_pair_variable_option_initializer____
    {   ( J.Variable_statement list, J.Pi pi )}

initializer_:
  pi = T_ASSIGN e = assignment_expression
    {                                       ( e, J.Pi pi )}

empty_statement:
  pi = T_SEMICOLON
    {                  ( J.Empty_statement, J.Pi pi )}

debugger_statement:
  pi = T_DEBUGGER
    {                 ( J.Debugger_statement, J.Pi pi )}

expression_statement:
  _1 = expression_no_statement
    {                           ( J.Expression_statement _1, J.N )}

if_statement:
  pi = T_IF _1 = T_LPAREN item = expression _3 = T_RPAREN t = statement _4 = T_ELSE e = statement
    {let condition =                                                          ( item ) in
     ( (J.If_statement (condition, t, Some e), J.Pi pi) )}
| pi = T_IF _1 = T_LPAREN item = expression _3 = T_RPAREN t = statement %prec p_IF
    {let condition =                                                          ( item ) in
     ( (J.If_statement (condition, t, None), J.Pi pi) )}

do_while_statement:
  pi = T_DO body = statement _3 = T_WHILE _1 = T_LPAREN item = expression _3_inlined1 = T_RPAREN
    {let condition =
  let _3 = _3_inlined1 in
                                                           ( item )
in
    ( (J.Do_while_statement (body, condition), J.Pi pi) )}

while_statement:
  pi = T_WHILE _1 = T_LPAREN item = expression _3 = T_RPAREN body = statement
    {let condition =                                                          ( item ) in
     ( (J.While_statement (condition, body), J.Pi pi) )}

for_statement:
  pi = T_FOR _2 = T_LPAREN initial = option_expression_no_in_ _4 = T_SEMICOLON condition = option_expression_ _6 = T_SEMICOLON increment = option_expression_ _8 = T_RPAREN statement = statement
    {   ( J.For_statement (J.Left initial, condition, increment, statement), J.Pi pi )}
| pi = T_FOR _2 = T_LPAREN _3 = T_VAR initial = separated_nonempty_list_T_COMMA_pair_variable_option_initializer_no_in___ _5 = T_SEMICOLON condition = option_expression_ _7 = T_SEMICOLON increment = option_expression_ _9 = T_RPAREN statement = statement
    {   ( J.For_statement (J.Right initial, condition, increment, statement), J.Pi pi )}

for_in_statement:
  pi = T_FOR _2 = T_LPAREN left = left_hand_side_expression _4 = T_IN right = expression _6 = T_RPAREN body = statement
    {   ( J.ForIn_statement (J.Left left, right, body), J.Pi pi )}
| pi = T_FOR _2 = T_LPAREN _3 = T_VAR x = variable y = option_initializer_no_in_ _5 = T_IN right = expression _7 = T_RPAREN body = statement
    {let left =     ( (x, y) ) in
   ( J.ForIn_statement (J.Right left, right, body), J.Pi pi )}

initializer_no_in:
  _1 = T_ASSIGN _2 = assignment_expression_no_in
    {                                        ( _2, J.Pi _1 )}

continue_statement:
  pi = T_CONTINUE _2 = option_label_
    {                        ( (J.Continue_statement _2,J.Pi pi) )}

break_statement:
  pi = T_BREAK _2 = option_label_
    {                     ( (J.Break_statement _2, J.Pi pi) )}

return_statement:
  pi = T_RETURN _2 = option_expression_
    {                           ( (J.Return_statement _2, J.Pi pi) )}

with_statement:
  _1 = T_WITH _1_inlined1 = T_LPAREN item = expression _3_inlined1 = T_RPAREN _3 = statement
    {let _2 =
  let (_3, _1) = (_3_inlined1, _1_inlined1) in
                                                           ( item )
in
                                              ( assert false )}

switch_statement:
  pi = T_SWITCH _1 = T_LPAREN item = expression _3_inlined1 = T_RPAREN _3 = T_LCURLY x = list_case_clause_ y = option_pair_default_clause_list_case_clause___ _5 = T_RCURLY
    {let pair =     ( (x, y) ) in
let subject =
  let _3 = _3_inlined1 in
                                                           ( item )
in
   ( let switch = match pair with
       | cases, None ->
         J.Switch_statement (subject, cases, None, [])
       | cases, Some (default, more_cases) ->
         J.Switch_statement (subject, cases, Some default, more_cases)
      in switch, J.Pi pi )}

throw_statement:
  pi = T_THROW _2 = expression
    {                         ( (J.Throw_statement _2, J.Pi pi) )}

try_statement:
  pi = T_TRY _2 = block _3 = catch _4 = option_finally_
    {                                 ( (J.Try_statement (_2, Some _3, _4), J.Pi pi) )}
| pi = T_TRY _2 = block _3 = finally
    {                                ( (J.Try_statement (_2, None, Some _3), J.Pi pi) )}

catch:
  _1 = T_CATCH _1_inlined1 = T_LPAREN item = variable _3 = T_RPAREN y = block
    {let pair =
  let _1 = _1_inlined1 in
  let x =                                                          ( item ) in
      ( (x, y) )
in
                                                     ( pair )}

finally:
  _1 = T_FINALLY _2 = block
    {                   ( _2 )}

case_clause:
  _1 = T_CASE x = expression _2 = T_COLON y = list_statement_
    {let pair =     ( (x, y) ) in
                                                               ( pair )}

default_clause:
  _1 = T_DEFAULT _2 = T_COLON list = list_statement_
    {                                     ( list )}

function_declaration:
  pi = T_FUNCTION name = variable _1 = T_LPAREN xs = loption_separated_nonempty_list_T_COMMA_variable__ _3 = T_RPAREN block = curly_block_list_source_element__
    {let args =
  let item =     ( xs ) in
                                                           ( item )
in
   ( let elements, _pi_start, pi_end = block in
     (name, args, elements, J.Pi pi_end), J.Pi pi )}

function_expression:
  pi = T_FUNCTION name = option_variable_ _1 = T_LPAREN xs = loption_separated_nonempty_list_T_COMMA_variable__ _3 = T_RPAREN block = curly_block_list_source_element__
    {let args =
  let item =     ( xs ) in
                                                           ( item )
in
   ( let elements, _pi_start, _pi_end = block in
     pi, J.EFun (name, args, elements, J.Pi pi) )}

expression:
  _1 = assignment_expression
    {                         ( _1 )}
| _1 = expression _2 = T_COMMA _3 = assignment_expression
    {                                            ( J.ESeq (_1, _3) )}

assignment_expression:
  _1 = conditional_expression
    {                          ( _1 )}
| _1 = left_hand_side_expression _2 = assignment_operator _3 = assignment_expression
    {   ( J.EBin (_2, _1, _3) )}

left_hand_side_expression:
  _1 = new_expression
    {                   ( snd _1 )}
| _1 = call_expression
    {                   ( snd _1 )}

conditional_expression:
  _1 = post_in_expression
    {                      ( _1 )}
| _1 = ternary_post_in_expression_assignment_expression_
    {                                                      ( _1 )}

ternary_post_in_expression_assignment_expression_:
  condition = post_in_expression _2 = T_PLING consequence = assignment_expression _4 = T_COLON alternative = assignment_expression
    {   ( J.ECond (condition, consequence, alternative) )}

ternary_post_in_expression_no_in_assignment_expression_no_in_:
  condition = post_in_expression_no_in _2 = T_PLING consequence = assignment_expression_no_in _4 = T_COLON alternative = assignment_expression_no_in
    {   ( J.ECond (condition, consequence, alternative) )}

ternary_post_in_expression_no_statement_assignment_expression_:
  condition = post_in_expression_no_statement _2 = T_PLING consequence = assignment_expression _4 = T_COLON alternative = assignment_expression
    {   ( J.ECond (condition, consequence, alternative) )}

post_in_expression:
  _1 = pre_in_expression
    {                     ( _1 )}
| left = post_in_expression _1 = T_LESS_THAN right = post_in_expression
    {let op =
  let op =                         ( J.Lt         ) in
                                                        ( op )
in
   ( J.EBin (op, left, right) )}
| left = post_in_expression _1 = T_GREATER_THAN right = post_in_expression
    {let op =
  let op =                         ( J.Gt         ) in
                                                        ( op )
in
   ( J.EBin (op, left, right) )}
| left = post_in_expression _1 = T_LESS_THAN_EQUAL right = post_in_expression
    {let op =
  let op =                         ( J.Le         ) in
                                                        ( op )
in
   ( J.EBin (op, left, right) )}
| left = post_in_expression _1 = T_GREATER_THAN_EQUAL right = post_in_expression
    {let op =
  let op =                         ( J.Ge         ) in
                                                        ( op )
in
   ( J.EBin (op, left, right) )}
| left = post_in_expression _1 = T_INSTANCEOF right = post_in_expression
    {let op =
  let op =                         ( J.InstanceOf ) in
                                                        ( op )
in
   ( J.EBin (op, left, right) )}
| left = post_in_expression _1 = T_EQUAL right = post_in_expression
    {let op =
  let op =                         ( J.EqEq       ) in
                                                        ( op )
in
   ( J.EBin (op, left, right) )}
| left = post_in_expression _1 = T_NOT_EQUAL right = post_in_expression
    {let op =
  let op =                         ( J.NotEq      ) in
                                                        ( op )
in
   ( J.EBin (op, left, right) )}
| left = post_in_expression _1 = T_STRICT_EQUAL right = post_in_expression
    {let op =
  let op =                         ( J.EqEqEq     ) in
                                                        ( op )
in
   ( J.EBin (op, left, right) )}
| left = post_in_expression _1 = T_STRICT_NOT_EQUAL right = post_in_expression
    {let op =
  let op =                         ( J.NotEqEq    ) in
                                                        ( op )
in
   ( J.EBin (op, left, right) )}
| left = post_in_expression _1 = T_BIT_AND right = post_in_expression
    {let op =
  let op =                         ( J.Band       ) in
                                                        ( op )
in
   ( J.EBin (op, left, right) )}
| left = post_in_expression _1 = T_BIT_XOR right = post_in_expression
    {let op =
  let op =                         ( J.Bxor       ) in
                                                        ( op )
in
   ( J.EBin (op, left, right) )}
| left = post_in_expression _1 = T_BIT_OR right = post_in_expression
    {let op =
  let op =                         ( J.Bor        ) in
                                                        ( op )
in
   ( J.EBin (op, left, right) )}
| left = post_in_expression _1 = T_AND right = post_in_expression
    {let op =
  let op =                         ( J.And        ) in
                                                        ( op )
in
   ( J.EBin (op, left, right) )}
| left = post_in_expression _1 = T_OR right = post_in_expression
    {let op =
  let op =                         ( J.Or         ) in
                                                        ( op )
in
   ( J.EBin (op, left, right) )}
| left = post_in_expression _1 = T_IN right = post_in_expression
    {let op =         ( J.In ) in
   ( J.EBin (op, left, right) )}

pre_in_expression:
  _1 = left_hand_side_expression
    {   ( _1 )}
| e = pre_in_expression op = postfix_operator
    {   ( J.EUn (op, e) )}
| _1 = T_DELETE e = pre_in_expression
    {let op =              ( J.Delete ) in
   ( J.EUn (op, e) )}
| _1 = T_VOID e = pre_in_expression
    {let op =              ( J.Void   ) in
   ( J.EUn (op, e) )}
| _1 = T_TYPEOF e = pre_in_expression
    {let op =              ( J.Typeof ) in
   ( J.EUn (op, e) )}
| _1 = T_INCR e = pre_in_expression
    {let op =              ( J.IncrB  ) in
   ( J.EUn (op, e) )}
| _1 = T_INCR_NB e = pre_in_expression
    {let op =              ( J.IncrB  ) in
   ( J.EUn (op, e) )}
| _1 = T_DECR e = pre_in_expression
    {let op =              ( J.DecrB  ) in
   ( J.EUn (op, e) )}
| _1 = T_DECR_NB e = pre_in_expression
    {let op =              ( J.DecrB  ) in
   ( J.EUn (op, e) )}
| _1 = T_PLUS e = pre_in_expression
    {let op =              ( J.Pl     ) in
   ( J.EUn (op, e) )}
| _1 = T_MINUS e = pre_in_expression
    {let op =              ( J.Neg    ) in
   ( J.EUn (op, e) )}
| _1 = T_BIT_NOT e = pre_in_expression
    {let op =              ( J.Bnot   ) in
   ( J.EUn (op, e) )}
| _1 = T_NOT e = pre_in_expression
    {let op =              ( J.Not    ) in
   ( J.EUn (op, e) )}
| left = pre_in_expression _1 = T_MULT right = pre_in_expression
    {let op =              ( J.Mul   ) in
   ( J.EBin (op, left, right) )}
| left = pre_in_expression _1 = T_DIV right = pre_in_expression
    {let op =              ( J.Div   ) in
   ( J.EBin (op, left, right) )}
| left = pre_in_expression _1 = T_MOD right = pre_in_expression
    {let op =              ( J.Mod   ) in
   ( J.EBin (op, left, right) )}
| left = pre_in_expression _1 = T_PLUS right = pre_in_expression
    {let op =              ( J.Plus  ) in
   ( J.EBin (op, left, right) )}
| left = pre_in_expression _1 = T_MINUS right = pre_in_expression
    {let op =              ( J.Minus ) in
   ( J.EBin (op, left, right) )}
| left = pre_in_expression _1 = T_LSHIFT right = pre_in_expression
    {let op =              ( J.Lsl   ) in
   ( J.EBin (op, left, right) )}
| left = pre_in_expression _1 = T_RSHIFT right = pre_in_expression
    {let op =              ( J.Asr   ) in
   ( J.EBin (op, left, right) )}
| left = pre_in_expression _1 = T_RSHIFT3 right = pre_in_expression
    {let op =              ( J.Lsr   ) in
   ( J.EBin (op, left, right) )}

call_expression:
  _1 = member_expression _2 = arguments
    {     ( let (start, e) = _1 in (start, J.ECall(e, _2, J.Pi start)) )}
| _1 = call_expression _2 = arguments
    {     ( let (start, e) = _1 in (start, J.ECall(e, _2, J.Pi start)) )}
| _1 = call_expression _2 = T_LBRACKET _3 = expression _4 = T_RBRACKET
    {     ( let (start, e) = _1 in (start, J.EAccess (e, _3)) )}
| _1 = call_expression _2 = T_PERIOD _3 = identifier
    {     ( let (start, e) = _1 in (start, J.EDot (e, _3)) )}

new_expression:
  _1 = member_expression
    {                        ( _1 )}
| pi = T_NEW _2 = new_expression
    {                           ( (pi, J.ENew (snd _2,None)) )}

member_expression:
  e = primary_expression
    {     ( e )}
| _1 = member_expression _2 = T_LBRACKET e2 = expression _4 = T_RBRACKET
    {     ( let (start, e1) = _1 in (start, J.EAccess (e1,e2)) )}
| _1 = member_expression _2 = T_PERIOD i = identifier
    {     ( let (start, e1) = _1 in (start, J.EDot(e1,i)) )}
| pi = T_NEW e1 = member_expression a = arguments
    {     ( (pi, J.ENew(snd e1, Some a)) )}

primary_expression:
  e = primary_expression_no_statement
    {                         ( e )}
| e = object_literal
    {                         ( e )}
| e = function_expression
    {                         ( e )}

primary_expression_no_statement:
  pi = T_THIS
    {                     ( (pi, J.EVar (var "this")) )}
| _1 = variable_with_loc
    {                     ( let (i, pi) = _1 in (pi, J.EVar (var i)) )}
| n = null_literal
    {                     ( n )}
| b = boolean_literal
    {                     ( b )}
| _1 = numeric_literal
    {                     ( let (start, n) = _1 in (start, J.ENum n) )}
| _1 = T_STRING
    {                     ( let (s, start) = _1 in (start, J.EStr (s, `Utf8)) )}
| r = regex_literal
    {                                  ( r )}
| a = array_literal
    {                                  ( a )}
| pi = T_LPAREN e = expression _3 = T_RPAREN
    {                                     ( (pi, e) )}

expression_no_in:
  _1 = assignment_expression_no_in
    {                               ( _1 )}
| _1 = expression_no_in _2 = T_COMMA _3 = assignment_expression_no_in
    {                                                        ( J.ESeq (_1, _3) )}

assignment_expression_no_in:
  _1 = conditional_expression_no_in
    {                                ( _1 )}
| _1 = left_hand_side_expression _2 = assignment_operator _3 = assignment_expression_no_in
    {     ( J.EBin(_2,_1,_3) )}

conditional_expression_no_in:
  _1 = post_in_expression_no_in
    {                            ( _1 )}
| _1 = ternary_post_in_expression_no_in_assignment_expression_no_in_
    {                                                                  ( _1 )}

post_in_expression_no_in:
  _1 = pre_in_expression
    {                     ( _1 )}
| left = post_in_expression_no_in _1 = T_LESS_THAN right = post_in_expression
    {let op =                         ( J.Lt         ) in
   ( J.EBin (op, left, right) )}
| left = post_in_expression_no_in _1 = T_GREATER_THAN right = post_in_expression
    {let op =                         ( J.Gt         ) in
   ( J.EBin (op, left, right) )}
| left = post_in_expression_no_in _1 = T_LESS_THAN_EQUAL right = post_in_expression
    {let op =                         ( J.Le         ) in
   ( J.EBin (op, left, right) )}
| left = post_in_expression_no_in _1 = T_GREATER_THAN_EQUAL right = post_in_expression
    {let op =                         ( J.Ge         ) in
   ( J.EBin (op, left, right) )}
| left = post_in_expression_no_in _1 = T_INSTANCEOF right = post_in_expression
    {let op =                         ( J.InstanceOf ) in
   ( J.EBin (op, left, right) )}
| left = post_in_expression_no_in _1 = T_EQUAL right = post_in_expression
    {let op =                         ( J.EqEq       ) in
   ( J.EBin (op, left, right) )}
| left = post_in_expression_no_in _1 = T_NOT_EQUAL right = post_in_expression
    {let op =                         ( J.NotEq      ) in
   ( J.EBin (op, left, right) )}
| left = post_in_expression_no_in _1 = T_STRICT_EQUAL right = post_in_expression
    {let op =                         ( J.EqEqEq     ) in
   ( J.EBin (op, left, right) )}
| left = post_in_expression_no_in _1 = T_STRICT_NOT_EQUAL right = post_in_expression
    {let op =                         ( J.NotEqEq    ) in
   ( J.EBin (op, left, right) )}
| left = post_in_expression_no_in _1 = T_BIT_AND right = post_in_expression
    {let op =                         ( J.Band       ) in
   ( J.EBin (op, left, right) )}
| left = post_in_expression_no_in _1 = T_BIT_XOR right = post_in_expression
    {let op =                         ( J.Bxor       ) in
   ( J.EBin (op, left, right) )}
| left = post_in_expression_no_in _1 = T_BIT_OR right = post_in_expression
    {let op =                         ( J.Bor        ) in
   ( J.EBin (op, left, right) )}
| left = post_in_expression_no_in _1 = T_AND right = post_in_expression
    {let op =                         ( J.And        ) in
   ( J.EBin (op, left, right) )}
| left = post_in_expression_no_in _1 = T_OR right = post_in_expression
    {let op =                         ( J.Or         ) in
   ( J.EBin (op, left, right) )}

expression_no_statement:
  _1 = assignment_expression_no_statement
    {                                      ( _1 )}
| _1 = expression_no_statement _2 = T_COMMA _3 = assignment_expression
    {                                                         ( J.ESeq(_1,_3) )}

assignment_expression_no_statement:
  _1 = conditional_expression_no_statement
    {                                       ( _1 )}
| _1 = left_hand_side_expression_no_statement _2 = assignment_operator _3 = assignment_expression
    {   ( J.EBin (_2,_1,_3) )}

conditional_expression_no_statement:
  _1 = post_in_expression_no_statement
    {                                   ( _1 )}
| _1 = ternary_post_in_expression_no_statement_assignment_expression_
    {                                                                   ( _1 )}

post_in_expression_no_statement:
  _1 = pre_in_expression_no_statement
    {                                  ( _1 )}
| left = post_in_expression_no_statement _1 = T_LESS_THAN right = post_in_expression
    {let op =
  let op =                         ( J.Lt         ) in
                                                        ( op )
in
   ( J.EBin (op, left, right) )}
| left = post_in_expression_no_statement _1 = T_GREATER_THAN right = post_in_expression
    {let op =
  let op =                         ( J.Gt         ) in
                                                        ( op )
in
   ( J.EBin (op, left, right) )}
| left = post_in_expression_no_statement _1 = T_LESS_THAN_EQUAL right = post_in_expression
    {let op =
  let op =                         ( J.Le         ) in
                                                        ( op )
in
   ( J.EBin (op, left, right) )}
| left = post_in_expression_no_statement _1 = T_GREATER_THAN_EQUAL right = post_in_expression
    {let op =
  let op =                         ( J.Ge         ) in
                                                        ( op )
in
   ( J.EBin (op, left, right) )}
| left = post_in_expression_no_statement _1 = T_INSTANCEOF right = post_in_expression
    {let op =
  let op =                         ( J.InstanceOf ) in
                                                        ( op )
in
   ( J.EBin (op, left, right) )}
| left = post_in_expression_no_statement _1 = T_EQUAL right = post_in_expression
    {let op =
  let op =                         ( J.EqEq       ) in
                                                        ( op )
in
   ( J.EBin (op, left, right) )}
| left = post_in_expression_no_statement _1 = T_NOT_EQUAL right = post_in_expression
    {let op =
  let op =                         ( J.NotEq      ) in
                                                        ( op )
in
   ( J.EBin (op, left, right) )}
| left = post_in_expression_no_statement _1 = T_STRICT_EQUAL right = post_in_expression
    {let op =
  let op =                         ( J.EqEqEq     ) in
                                                        ( op )
in
   ( J.EBin (op, left, right) )}
| left = post_in_expression_no_statement _1 = T_STRICT_NOT_EQUAL right = post_in_expression
    {let op =
  let op =                         ( J.NotEqEq    ) in
                                                        ( op )
in
   ( J.EBin (op, left, right) )}
| left = post_in_expression_no_statement _1 = T_BIT_AND right = post_in_expression
    {let op =
  let op =                         ( J.Band       ) in
                                                        ( op )
in
   ( J.EBin (op, left, right) )}
| left = post_in_expression_no_statement _1 = T_BIT_XOR right = post_in_expression
    {let op =
  let op =                         ( J.Bxor       ) in
                                                        ( op )
in
   ( J.EBin (op, left, right) )}
| left = post_in_expression_no_statement _1 = T_BIT_OR right = post_in_expression
    {let op =
  let op =                         ( J.Bor        ) in
                                                        ( op )
in
   ( J.EBin (op, left, right) )}
| left = post_in_expression_no_statement _1 = T_AND right = post_in_expression
    {let op =
  let op =                         ( J.And        ) in
                                                        ( op )
in
   ( J.EBin (op, left, right) )}
| left = post_in_expression_no_statement _1 = T_OR right = post_in_expression
    {let op =
  let op =                         ( J.Or         ) in
                                                        ( op )
in
   ( J.EBin (op, left, right) )}
| left = post_in_expression_no_statement _1 = T_IN right = post_in_expression
    {let op =         ( J.In ) in
   ( J.EBin (op, left, right) )}

pre_in_expression_no_statement:
  _1 = left_hand_side_expression_no_statement
    {   ( _1 )}
| e = pre_in_expression_no_statement op = postfix_operator
    {   ( J.EUn (op, e) )}
| _1 = T_DELETE e = pre_in_expression
    {let op =              ( J.Delete ) in
   ( J.EUn (op, e) )}
| _1 = T_VOID e = pre_in_expression
    {let op =              ( J.Void   ) in
   ( J.EUn (op, e) )}
| _1 = T_TYPEOF e = pre_in_expression
    {let op =              ( J.Typeof ) in
   ( J.EUn (op, e) )}
| _1 = T_INCR e = pre_in_expression
    {let op =              ( J.IncrB  ) in
   ( J.EUn (op, e) )}
| _1 = T_INCR_NB e = pre_in_expression
    {let op =              ( J.IncrB  ) in
   ( J.EUn (op, e) )}
| _1 = T_DECR e = pre_in_expression
    {let op =              ( J.DecrB  ) in
   ( J.EUn (op, e) )}
| _1 = T_DECR_NB e = pre_in_expression
    {let op =              ( J.DecrB  ) in
   ( J.EUn (op, e) )}
| _1 = T_PLUS e = pre_in_expression
    {let op =              ( J.Pl     ) in
   ( J.EUn (op, e) )}
| _1 = T_MINUS e = pre_in_expression
    {let op =              ( J.Neg    ) in
   ( J.EUn (op, e) )}
| _1 = T_BIT_NOT e = pre_in_expression
    {let op =              ( J.Bnot   ) in
   ( J.EUn (op, e) )}
| _1 = T_NOT e = pre_in_expression
    {let op =              ( J.Not    ) in
   ( J.EUn (op, e) )}
| left = pre_in_expression_no_statement _1 = T_MULT right = pre_in_expression
    {let op =              ( J.Mul   ) in
   ( J.EBin (op, left, right) )}
| left = pre_in_expression_no_statement _1 = T_DIV right = pre_in_expression
    {let op =              ( J.Div   ) in
   ( J.EBin (op, left, right) )}
| left = pre_in_expression_no_statement _1 = T_MOD right = pre_in_expression
    {let op =              ( J.Mod   ) in
   ( J.EBin (op, left, right) )}
| left = pre_in_expression_no_statement _1 = T_PLUS right = pre_in_expression
    {let op =              ( J.Plus  ) in
   ( J.EBin (op, left, right) )}
| left = pre_in_expression_no_statement _1 = T_MINUS right = pre_in_expression
    {let op =              ( J.Minus ) in
   ( J.EBin (op, left, right) )}
| left = pre_in_expression_no_statement _1 = T_LSHIFT right = pre_in_expression
    {let op =              ( J.Lsl   ) in
   ( J.EBin (op, left, right) )}
| left = pre_in_expression_no_statement _1 = T_RSHIFT right = pre_in_expression
    {let op =              ( J.Asr   ) in
   ( J.EBin (op, left, right) )}
| left = pre_in_expression_no_statement _1 = T_RSHIFT3 right = pre_in_expression
    {let op =              ( J.Lsr   ) in
   ( J.EBin (op, left, right) )}

left_hand_side_expression_no_statement:
  _1 = new_expression_no_statement
    {                               ( snd _1 )}
| _1 = call_expression_no_statement
    {                                ( snd _1 )}

new_expression_no_statement:
  _1 = member_expression_no_statement
    {                                  ( _1 )}
| pi = T_NEW _2 = new_expression
    {                           ( (pi, J.ENew (snd _2,None)) )}

call_expression_no_statement:
  _1 = member_expression_no_statement _2 = arguments
    {   ( let (start, e) = _1 in (start, J.ECall(e, _2, J.Pi start)) )}
| _1 = call_expression_no_statement _2 = arguments
    {   ( let (start, e) = _1 in (start, J.ECall(e, _2, J.Pi start)) )}
| _1 = call_expression_no_statement _2 = T_LBRACKET _3 = expression _4 = T_RBRACKET
    {   ( let (start, e) = _1 in (start, J.EAccess(e, _3)) )}
| _1 = call_expression_no_statement _2 = T_PERIOD _3 = identifier
    {   ( let (start, e) = _1 in (start, J.EDot(e,_3)) )}

member_expression_no_statement:
  e = primary_expression_no_statement
    {   ( e )}
| _1 = member_expression_no_statement _2 = T_LBRACKET e2 = expression _4 = T_RBRACKET
    {   ( let (start, e1) = _1 in (start, J.EAccess(e1, e2)) )}
| _1 = member_expression_no_statement _2 = T_PERIOD i = identifier
    {   ( let (start, e1) = _1 in (start, J.EDot(e1,i)) )}
| pi = T_NEW e = member_expression a = arguments
    {   ( (pi, J.ENew(snd e,Some a)) )}

null_literal:
  pi = T_NULL
    {             ( (pi, J.EVar (var "null")) )}

boolean_literal:
  pi = T_TRUE
    {              ( (pi, J.EBool true) )}
| pi = T_FALSE
    {              ( (pi, J.EBool false) )}

numeric_literal:
  _1 = T_NUMBER
    {            ( let (_, f, pi) = _1 in (pi, f) )}

regex_literal:
  _1 = T_REGEX
    {           (
   let (s, pi) = _1 in
   let len = String.length s in
   let regexp, option =
     if s.[len - 1] = '/'
     then String.sub s 1 (len - 2),None
     else
       let i = String.rindex s '/' in
       String.sub s 1 (i - 1),Some (String.sub s (i+1) (len - i - 1))
   in
   (pi, J.ERegexp (regexp, option)) )}

array_literal:
  pi = T_LBRACKET _2 = elison _3 = T_RBRACKET
    {     ( (pi, J.EArr _2) )}
| pi = T_LBRACKET _2 = T_RBRACKET
    {     ( (pi, J.EArr []) )}
| pi = T_LBRACKET _2 = element_list _3 = T_RBRACKET
    {     ( (pi, J.EArr _2) )}
| pi = T_LBRACKET _2 = element_list_rev _3 = elison_rev _4 = T_RBRACKET
    {     ( (pi, J.EArr (List.rev_append _2 (List.rev _3))) )}

element_list:
  _1 = element_list_rev
    {                    ( List.rev _1 )}

element_list_rev:
  _1 = elison_rev _2 = assignment_expression
    {                                    ( (Some _2)::_1 )}
| _1 = assignment_expression
    {                                    ( [Some _1] )}
| _1 = element_list_rev _2 = elison _3 = assignment_expression
    {                                                 ( (Some _3) :: (List.rev_append _2 _1) )}

object_literal:
  block = curly_block_empty_
    {   ( let _pairs, pi_start, _pi_end = block in pi_start, J.EObj [] )}
| block = curly_block_separated_or_terminated_list_T_COMMA_object_key_value__
    {   ( let pairs, pi_start, _pi_end = block in pi_start, J.EObj pairs )}

object_key_value:
  x = property_name _2 = T_COLON y = assignment_expression
    {let pair =     ( (x, y) ) in
                                                                      ( pair )}

arguments:
  _1 = T_LPAREN xs = loption_separated_nonempty_list_T_COMMA_assignment_expression__ _3 = T_RPAREN
    {let args =
  let item =     ( xs ) in
                                                           ( item )
in
                                                                      ( args )}

identifier:
  _1 = T_IDENTIFIER
    {                ( fst _1 )}

variable:
  i = identifier
    {                ( var i )}

variable_with_loc:
  _1 = T_IDENTIFIER
    {                ( _1 )}

label:
  _1 = identifier
    {              ( J.Label.of_string _1 )}

property_name:
  i = T_IDENTIFIER
    {                     ( J.PNI (fst i) )}
| s = T_STRING
    {                     ( J.PNS (fst s) )}
| n = numeric_literal
    {                     ( J.PNN (snd n) )}

elison_rev:
  _1 = T_COMMA
    {           ( [] )}
| _1 = elison _2 = T_COMMA
    {                  ( None :: _1 )}

elison:
  _1 = elison_rev
    {                   (_1)}

curly_block_empty_:
  pi1 = T_LCURLY x = empty pi2 = T_RCURLY
    {                                 ( (x, pi1, pi2) )}

curly_block_list_source_element__:
  pi1 = T_LCURLY x = list_source_element_ pi2 = T_RCURLY
    {                                 ( (x, pi1, pi2) )}

curly_block_list_statement__:
  pi1 = T_LCURLY x = list_statement_ pi2 = T_RCURLY
    {                                 ( (x, pi1, pi2) )}

curly_block_separated_or_terminated_list_T_COMMA_object_key_value__:
  pi1 = T_LCURLY x = separated_or_terminated_list_T_COMMA_object_key_value_ pi2 = T_RCURLY
    {                                 ( (x, pi1, pi2) )}

postfix_operator:
  _1 = T_INCR_NB
    {             ( J.IncrA )}
| _1 = T_DECR_NB
    {             ( J.DecrA )}

assignment_operator:
  _1 = T_ASSIGN
    {                    ( J.Eq )}
| _1 = T_MULT_ASSIGN
    {                    ( J.StarEq )}
| _1 = T_DIV_ASSIGN
    {                    ( J.SlashEq )}
| _1 = T_MOD_ASSIGN
    {                    ( J.ModEq )}
| _1 = T_PLUS_ASSIGN
    {                    ( J.PlusEq )}
| _1 = T_MINUS_ASSIGN
    {                    ( J.MinusEq )}
| _1 = T_LSHIFT_ASSIGN
    {                    ( J.LslEq )}
| _1 = T_RSHIFT_ASSIGN
    {                    ( J.AsrEq )}
| _1 = T_RSHIFT3_ASSIGN
    {                    ( J.LsrEq )}
| _1 = T_BIT_AND_ASSIGN
    {                    ( J.BandEq )}
| _1 = T_BIT_XOR_ASSIGN
    {                    ( J.BxorEq )}
| _1 = T_BIT_OR_ASSIGN
    {                    ( J.BorEq )}

either_T_SEMICOLON_T_VIRTUAL_SEMICOLON_:
  _1 = T_SEMICOLON
    {                ( _1 )}
| _1 = T_VIRTUAL_SEMICOLON
    {                           ( _1 )}

empty:
  
    {       ()}

separated_or_terminated_list_T_COMMA_object_key_value_:
  x = object_key_value
    {       ( [x] )}
| x = object_key_value _2 = T_COMMA
    {                 ( [x] )}
| x = object_key_value _2 = T_COMMA xs = separated_or_terminated_list_T_COMMA_object_key_value_
    {                                                               ( x :: xs )}

%%


