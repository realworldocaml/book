File "coercion-mini.mly", line 104, characters 28-32:
Warning: the token DATA is unused.
File "coercion-mini.mly", line 86, characters 28-34:
Warning: the token LANGLE is unused.
File "coercion-mini.mly", line 106, characters 28-35:
Warning: the token MUTABLE is unused.
File "coercion-mini.mly", line 87, characters 28-34:
Warning: the token RANGLE is unused.
File "coercion-mini.mly", line 103, characters 28-33:
Warning: the token SLASH is unused.
File "coercion-mini.mly", line 116, characters 28-32:
Warning: the token UNIT is unused.
File "coercion-mini.mly", line 77, characters 28-31:
Warning: the token VAL is unused.
Grammar has 48 nonterminal symbols, among which 1 start symbols.
Grammar has 53 terminal symbols.
Grammar has 119 productions.
nullable(value_definitions) = false
nullable(value_definition) = false
nullable(types) = false
nullable(type_definitions) = false
nullable(type_definition) = false
nullable(type2) = false
nullable(type10) = false
nullable(type1) = false
nullable(type00s) = false
nullable(type00) = false
nullable(type0) = false
nullable(typ) = false
nullable(star_types) = false
nullable(scheme) = false
nullable(record_bindings) = true
nullable(record_binding) = false
nullable(quantifiers) = false
nullable(quantifier) = false
nullable(program) = false
nullable(patterns) = false
nullable(pattern3) = false
nullable(pattern2) = false
nullable(pattern1s) = false
nullable(pattern10) = false
nullable(pattern1) = false
nullable(pattern0) = false
nullable(pattern) = false
nullable(localvars) = false
nullable(kind) = false
nullable(forall) = true
nullable(expressions) = false
nullable(expression50) = false
nullable(expression400) = false
nullable(expression300) = false
nullable(expression200) = false
nullable(expression100) = false
nullable(expression10) = false
nullable(expression0) = false
nullable(expression) = false
nullable(equal_expression) = false
nullable(clauses) = false
nullable(clause) = false
nullable(bindings) = true
nullable(binding) = false
nullable(attributes) = false
nullable(attribute) = false
nullable(algebraic_datatype_definitions) = false
nullable(algebraic_datatype_definition) = false
first(value_definitions) = WILD UID LPAREN LID INTEGER FORALL CHAR
first(value_definition) = WILD UID LPAREN LID INTEGER FORALL CHAR
first(types) = REF LPAREN LID LBRACE BACKSLASH
first(type_definitions) = LID
first(type_definition) = LID
first(type2) = REF LPAREN LID LBRACE BACKSLASH
first(type10) = REF LPAREN LID LBRACE BACKSLASH
first(type1) = REF LPAREN LID LBRACE BACKSLASH
first(type00s) = LPAREN LID LBRACE
first(type00) = LPAREN LID LBRACE
first(type0) = REF LPAREN LID LBRACE
first(typ) = REF LPAREN LID LBRACE BACKSLASH
first(star_types) = REF LPAREN LID LBRACE BACKSLASH
first(scheme) = REF LPAREN LID LBRACE FORALL BACKSLASH
first(record_bindings) = LID
first(record_binding) = LID
first(quantifiers) = LID
first(quantifier) = LID
first(program) = TYPE LET EOF
first(patterns) = WILD UID LPAREN LID INTEGER CHAR
first(pattern3) = WILD UID LPAREN LID INTEGER CHAR
first(pattern2) = WILD UID LPAREN LID INTEGER CHAR
first(pattern1s) = WILD UID LPAREN LID INTEGER CHAR
first(pattern10) = WILD UID LPAREN LID INTEGER CHAR
first(pattern1) = WILD UID LPAREN LID INTEGER CHAR
first(pattern0) = WILD UID LPAREN LID INTEGER CHAR
first(pattern) = WILD UID LPAREN LID INTEGER CHAR
first(localvars) = LBRACKET
first(kind) = STAR
first(forall) = FORALL
first(expressions) = UID TYPE REF MATCH LPAREN LONGID LID LET LBRACE INTEGER FORALL EXISTS CHAR BANG BACKSLASH ASSERT_FALSE
first(expression50) = UID REF LPAREN LONGID LID LBRACE INTEGER CHAR BANG ASSERT_FALSE
first(expression400) = UID TYPE REF MATCH LPAREN LONGID LID LET LBRACE INTEGER FORALL EXISTS CHAR BANG BACKSLASH ASSERT_FALSE
first(expression300) = UID REF LPAREN LONGID LID LBRACE INTEGER CHAR BANG ASSERT_FALSE
first(expression200) = UID REF LPAREN LONGID LID LBRACE INTEGER CHAR BANG ASSERT_FALSE
first(expression100) = UID REF LPAREN LONGID LID LBRACE INTEGER CHAR BANG ASSERT_FALSE
first(expression10) = UID REF LPAREN LONGID LID LBRACE INTEGER CHAR BANG ASSERT_FALSE
first(expression0) = UID LPAREN LONGID LID LBRACE INTEGER CHAR ASSERT_FALSE
first(expression) = UID TYPE REF MATCH LPAREN LONGID LID LET LBRACE INTEGER FORALL EXISTS CHAR BANG BACKSLASH ASSERT_FALSE
first(equal_expression) = WILD UID LPAREN LID INTEGER EQUAL COLON CHAR
first(clauses) = WILD UID LPAREN LID INTEGER CHAR
first(clause) = WILD UID LPAREN LID INTEGER CHAR
first(bindings) = TYPE LET
first(binding) = TYPE LET
first(attributes) = REF LPAREN LID LBRACE BACKSLASH
first(attribute) = LID
first(algebraic_datatype_definitions) = UID
first(algebraic_datatype_definition) = UID
minimal(value_definitions) = (* 3 *) LID EQUAL LID
minimal(value_definition) = (* 3 *) LID EQUAL LID
minimal(types) = (* 1 *) LID
minimal(type_definitions) = (* 7 *) LID COLON STAR EQUAL UID COLON LID
minimal(type_definition) = (* 7 *) LID COLON STAR EQUAL UID COLON LID
minimal(type2) = (* 1 *) LID
minimal(type10) = (* 1 *) LID
minimal(type1) = (* 1 *) LID
minimal(type00s) = (* 1 *) LID
minimal(type00) = (* 1 *) LID
minimal(type0) = (* 1 *) LID
minimal(typ) = (* 1 *) LID
minimal(star_types) = (* 1 *) LID
minimal(scheme) = (* 1 *) LID
minimal(record_bindings) = (* 0 *) 
minimal(record_binding) = (* 3 *) LID EQUAL LID
minimal(quantifiers) = (* 1 *) LID
minimal(quantifier) = (* 1 *) LID
minimal(program) = (* 1 *) EOF
minimal(patterns) = (* 1 *) LID
minimal(pattern3) = (* 1 *) LID
minimal(pattern2) = (* 1 *) LID
minimal(pattern1s) = (* 1 *) LID
minimal(pattern10) = (* 1 *) LID
minimal(pattern1) = (* 1 *) LID
minimal(pattern0) = (* 1 *) LID
minimal(pattern) = (* 1 *) LID
minimal(localvars) = (* 3 *) LBRACKET LID RBRACKET
minimal(kind) = (* 1 *) STAR
minimal(forall) = (* 0 *) 
minimal(expressions) = (* 1 *) LID
minimal(expression50) = (* 1 *) LID
minimal(expression400) = (* 1 *) LID
minimal(expression300) = (* 1 *) LID
minimal(expression200) = (* 1 *) LID
minimal(expression100) = (* 1 *) LID
minimal(expression10) = (* 1 *) LID
minimal(expression0) = (* 1 *) LID
minimal(expression) = (* 1 *) LID
minimal(equal_expression) = (* 2 *) EQUAL LID
minimal(clauses) = (* 3 *) LID DARROW LID
minimal(clause) = (* 3 *) LID DARROW LID
minimal(bindings) = (* 0 *) 
minimal(binding) = (* 4 *) LET LID EQUAL LID
minimal(attributes) = (* 1 *) LID
minimal(attribute) = (* 3 *) LID COLON LID
minimal(algebraic_datatype_definitions) = (* 3 *) UID COLON LID
minimal(algebraic_datatype_definition) = (* 3 *) UID COLON LID
follow(value_definitions) = TYPE LET IN EOF AND
follow(value_definition) = TYPE LET IN EOF AND
follow(types) = RPAREN
follow(type_definitions) = TYPE LET IN EOF AND
follow(type_definition) = TYPE LET IN EOF AND
follow(type2) = TYPE SEMI RPAREN RBRACE LET IN EQUAL EOF DOT DARROW COMMA COLON COERCE BAR AND
follow(type10) = TYPE SEMI RPAREN RBRACE LET IN EQUAL EOF DOT DARROW COMMA COLON COERCE BAR ARROW AND
follow(type1) = TYPE STAR SEMI RPAREN RBRACE LET IN EQUAL EOF DOT DARROW COMMA COLON COERCE BAR ARROW AND
follow(type00s) = TYPE STAR SEMI RPAREN RBRACE LET IN EQUAL EOF DOT DARROW COMMA COLON COERCE BAR ARROW AND
follow(type00) = TYPE STAR SEMI RPAREN RBRACE LPAREN LID LET LBRACE IN EQUAL EOF DOT DARROW COMMA COLON COERCE BAR ARROW AND
follow(type0) = TYPE STAR SEMI RPAREN RBRACE LET IN EQUAL EOF DOT DARROW COMMA COLON COERCE BAR ARROW AND
follow(typ) = TYPE SEMI RPAREN RBRACE LET IN EQUAL EOF DOT DARROW COMMA COLON COERCE BAR AND
follow(star_types) = TYPE SEMI RPAREN RBRACE LET IN EQUAL EOF DOT DARROW COMMA COLON COERCE BAR ARROW AND
follow(scheme) = TYPE LET IN EOF BAR AND
follow(record_bindings) = RBRACE
follow(record_binding) = RBRACE AND
follow(quantifiers) = RBRACKET DOT
follow(quantifier) = RBRACKET LID DOT
follow(program) = #
follow(patterns) = RPAREN
follow(pattern3) = RPAREN DOT DARROW COMMA COLON
follow(pattern2) = RPAREN DOT DARROW COMMA COLON
follow(pattern1s) = RPAREN DOT DARROW COMMA COLON BAR ANDC
follow(pattern10) = RPAREN DOT DARROW COMMA COLON BAR ANDC
follow(pattern1) = RPAREN DOT DARROW COMMA COLON
follow(pattern0) = WILD UID RPAREN LPAREN LID INTEGER EQUAL DOT DARROW COMMA COLON CHAR BAR ANDC
follow(pattern) = RPAREN DOT DARROW COMMA
follow(localvars) = WILD UID RPAREN LPAREN LID INTEGER EQUAL DOT DARROW COMMA COLON CHAR BAR ANDC
follow(kind) = EQUAL
follow(forall) = WILD UID REF LPAREN LID LBRACE INTEGER CHAR BACKSLASH
follow(expressions) = RPAREN
follow(expression50) = error WITH UID TYPE SEMI RPAREN RBRACE LPAREN LONGID LID LET LBRACE INTEGER INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN EQUAL EOF END DOT COMMA COLON CHAR BAR ASSERT_FALSE AND
follow(expression400) = error WITH TYPE RPAREN RBRACE LET IN EOF END COMMA COLON BAR AND
follow(expression300) = error WITH TYPE SEMI RPAREN RBRACE LET IN EOF END COMMA COLON BAR AND
follow(expression200) = error WITH TYPE SEMI RPAREN RBRACE LET INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN EQUAL EOF END COMMA COLON BAR AND
follow(expression100) = error WITH UID TYPE SEMI RPAREN RBRACE LPAREN LONGID LID LET LBRACE INTEGER INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN EQUAL EOF END COMMA COLON CHAR BAR ASSERT_FALSE AND
follow(expression10) = error WITH UID TYPE SEMI RPAREN RBRACE LPAREN LONGID LID LET LBRACE INTEGER INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN EQUAL EOF END DOT COMMA COLON CHAR BAR ASSERT_FALSE AND
follow(expression0) = error WITH UID TYPE SEMI RPAREN RBRACE LPAREN LONGID LID LET LBRACE INTEGER INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN EQUAL EOF END DOT COMMA COLON CHAR BAR ASSIGN ASSERT_FALSE AND
follow(expression) = error WITH TYPE RPAREN RBRACE LET IN EOF END COMMA COLON BAR AND
follow(equal_expression) = TYPE LET IN EOF AND
follow(clauses) = END BAR
follow(clause) = END BAR
follow(bindings) = TYPE LET EOF
follow(binding) = TYPE LET IN EOF
follow(attributes) = RBRACE
follow(attribute) = SEMI
follow(algebraic_datatype_definitions) = TYPE LET IN EOF AND
follow(algebraic_datatype_definition) = TYPE LET IN EOF BAR AND
Built an LR(0) automaton with 218 states.
The grammar is not SLR(1) -- 9 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 296 states.
72 shift/reduce conflicts were silently solved.
115 out of 296 states have a default reduction.
116 out of 296 states are represented.
0 out of 104 symbols keep track of their start position.
0 out of 104 symbols keep track of their end position.
63 out of 120 productions exploit shiftreduce optimization.
31 out of 296 states can peek at an error.
766 functions before inlining, 159 functions after inlining.
