File "K3Parser.mly", line 128, characters 12-21:
Warning: the token COLONGETS is unused.
File "K3Parser.mly", line 146, characters 7-13:
Warning: the token EFFECT is unused.
File "K3Parser.mly", line 106, characters 7-10:
Warning: the token EOF is unused.
File "K3Parser.mly", line 115, characters 42-46:
Warning: the token HASH is unused.
File "K3Parser.mly", line 121, characters 17-24:
Warning: the token LRARROW is unused.
File "K3Parser.mly", line 146, characters 14-22:
Warning: the token PARALLEL is unused.
File "K3Parser.mly", line 104, characters 7-12:
Warning: the token RANGE is unused.
File "K3Parser.mly", line 134, characters 12-16:
Warning: the token RANK is unused.
File "K3Parser.mly", line 97, characters 20-23:
Warning: the token TOP is unused.
File "K3Parser.mly", line 733, characters 0-15:
Warning: symbol identifier_list is unreachable from any of the start symbol(s).
File "K3Parser.mly", line 728, characters 0-12:
Warning: symbol integer_list is unreachable from any of the start symbol(s).
%{
  open Util
  open K3.AST
  open K3.Annotation
  open Tree
  open K3Helpers

  let uuid = ref 1

  let get_uuid () = let t = !uuid in uuid := !uuid + 1; t

  let globals = ref []

  let mkexpr tag children = match children with
    | [] -> Leaf(((get_uuid(), tag), []))
    | _  -> Node(((get_uuid(), tag), []), children)

  let rec build_collection exprs ctype = match exprs with
    | [] -> mkexpr (Empty(ctype)) []
    | [e] -> mkexpr (Singleton(ctype)) [e]
    | e :: es -> mkexpr Combine [mkexpr (Singleton(ctype)) [e]; build_collection es ctype]

  let mk_unknown_collection t_c = canonical @@ TCollection(t_c, canonical TUnknown)

  let parse_format s = match String.lowercase s with
    | "csv" -> CSV | "json" -> JSON
    | _ -> raise Parsing.Parse_error

  let numerrors = ref 0

  let print_error msg =
      incr numerrors;
      let pos = Parsing.symbol_start_pos() in
      let linenum = pos.Lexing.pos_lnum in
      let column = pos.Lexing.pos_cnum - pos.Lexing.pos_bol in
      Printf.printf "Error on line %d character %d : " linenum column;
      print_endline msg;
      if !numerrors > 20 then raise Exit else raise Parsing.Parse_error

  (* Predefined errors *)
  let missing_paren ?(side="left") = print_error ("Missing "^side^" parenthesis")

  let id_error () = print_error("Expected identifier")
  let type_error () = print_error("Expected type expression")

  let address_error ip port = print_error("Invalid address "^ip^":"^(string_of_int port))

  let op_error op_class i =
    let op_type = match i with 1 -> " unary" | 2 -> " binary" | 3 -> " ternary" | _ -> ""
    in print_error("Invalid"^op_type^" "^op_class^" operator syntax")

  let arith_error i = op_error "arithmetic" i
  let comp_error () = op_error "comparison" 2

  let cond_error cond_class =
    print_error ("Invalid conditional "^cond_class^" error")

  let case_error case_class =
    print_error ("Invalid case "^case_class^" error")

  let upsert_with_before_error c =
    print_error ("Invalid upsert_with_before "^c^" error")

  let bind_error bind_class =
    print_error ("Invalid bind "^bind_class^" error")

  let lambda_error error_class =
    print_error ("Invalid lambda "^error_class^" expression")

  let assign_error assign_class =
    print_error ("Invalid "^assign_class^" assignment RHS expression")

  let positional_error value_class i =
    let i_str = match i with
        | 1 -> "first"   | 2 -> "second" | 3 -> "third"
        | 4 -> "fourth"  | 5 -> "second" | 6 -> "third"
        | 7 -> "seventh" | 8 -> "eighth" | 9 -> "ninth"
        | _ -> string_of_int i
    in print_error ("Expected "^value_class^" as "^i_str^" argument")

  let coll_error i = positional_error "collection" i
  let coll_lambda_error fn_class i = positional_error (fn_class^" function") i
  let value_error i = positional_error "value" i

  let expr_error () = print_error("Expected expression")

  let flow_program_error () = print_error("Expected flow program")

%}
%start expr
%start expression_test
%start program
%start program_test
%token AGGREGATE
%token AGGREGATEV
%token AND
%token ANNOTATE
%token AS
%token AT_WITH
%token BACKSLASH
%token BAR
%token BIND
%token BINDFLOW
%token <bool> BOOL
%token CASE
%token COLON
%token COLONGETS
%token COMMA
%token CONCAT
%token CONSUME
%token DECLARE
%token DEFAULT
%token DELETE
%token DELETE_PREFIX
%token DIVIDE
%token DO
%token EFFECT
%token ELSE
%token EOF
%token EQ
%token EXPECTED
%token FILE
%token FILTER
%token FILTERGEQ
%token FLATTEN
%token <float> FLOAT
%token FOREIGN
%token GEQ
%token GETS
%token GROUPBYAGGREGATE
%token GT
%token HASH
%token <string> IDENTIFIER
%token IF
%token IGNORE
%token IN
%token INDIRECT
%token INSERT
%token <int> INTEGER
%token <string> IP
%token ITERATE
%token JUST
%token LARROW
%token LBRACE
%token LBRACEBAR
%token LBRACECOLON
%token LBRACELT
%token LBRACKET
%token LBRACKETBAR
%token LBRACKETCOLON
%token LBRACKETGEQ
%token LBRACKETHASH
%token LBRACKETLT
%token LEQ
%token LET
%token LPAREN
%token LRARROW
%token LT
%token MAP
%token MAYBE
%token MINUS
%token MIN_WITH
%token MODULO
%token MUT
%token NEG
%token NEQ
%token NETWORK
%token NOT
%token NOTHING
%token OF
%token OR
%token PARALLEL
%token PATTERN
%token PEEK
%token PEEK_WITH_VID
%token PERIOD
%token PLUS
%token QUESTION
%token RANDOM
%token RANGE
%token RANK
%token RARROW
%token RBRACE
%token RBRACEBAR
%token RBRACECOLON
%token RBRACELT
%token RBRACKET
%token RBRACKETBAR
%token RBRACKETCOLON
%token RBRACKETHASH
%token RBRACKETLT
%token ROLE
%token RPAREN
%token SEMICOLON
%token SEND
%token SINK
%token SIZE
%token SOCKET
%token SORT
%token SOURCE
%token STREAM
%token <string> STRING
%token THEN
%token TIMES
%token TOP
%token TRIGGER
%token <K3.AST.base_type_t> TYPE
%token UNIT
%token UNKNOWN
%token UPDATE
%token UPDATE_SUFFIX
%token UPSERT_WITH
%token UPSERT_WITH_BEFORE
%right RARROW
%right LRARROW
%right ELSE IF THEN
%right CASE OF
%right CONCAT
%left OR
%left AND
%left EQ GEQ GT LEQ LT NEQ
%left MINUS PLUS
%left DIVIDE MODULO TIMES
%left ANNOTATE
%right NEG NOT
%left COLON
%nonassoc UMINUS
%type <K3.AST.expr_t> expr
%type <K3.AST.program_test_t> expression_test
%type <K3.AST.program_t> program
%type <K3.AST.program_test_t> program_test
%%

program:
  _1 = declaration
    {                          ( if !numerrors>=1 then raise Exit else [_1, []] )}
| _1 = declaration _2 = program
    {                          ( (_1, []) :: _2 )}

declaration:
  _1 = DECLARE _2 = IDENTIFIER _3 = COLON _4 = type_expr
    {                                         ( Global(_2, _4, None) )}
| _1 = DECLARE _2 = IDENTIFIER _3 = COLON _4 = type_expr _5 = GETS _6 = anno_expr
    {                                                        ( Global(_2, _4, Some _6) )}
| _1 = FOREIGN _2 = IDENTIFIER _3 = COLON _4 = type_expr
    {                                         ( Foreign(_2, _4) )}
| _1 = flow_program
    {                    ( Flow(_1) )}
| _1 = ROLE _2 = IDENTIFIER _3 = LBRACE _4 = flow_program _5 = RBRACE
    {                                                   ( Role(_2, _4) )}
| _1 = ROLE _2 = IDENTIFIER _3 = LBRACE _4 = RBRACE
    {                                                   ( Role(_2, []) )}
| _1 = DEFAULT _2 = ROLE _3 = IDENTIFIER
    {                                                   ( DefaultRole(_3) )}
| _1 = DECLARE _2 = IDENTIFIER _3 = COLON _4 = type_expr _5 = GETS _6 = error
    {                                                    ( expr_error() )}
| _1 = DECLARE _2 = IDENTIFIER _3 = COLON _4 = error
    {                                                    ( type_error() )}
| _1 = DECLARE _2 = error
    {                                                    ( id_error() )}
| _1 = FOREIGN _2 = IDENTIFIER _3 = COLON _4 = error
    {                                     ( type_error() )}
| _1 = FOREIGN _2 = error
    {                                     ( id_error() )}
| _1 = ROLE _2 = IDENTIFIER _3 = LBRACE _4 = error
    {                                   ( flow_program_error() )}
| _1 = ROLE _2 = IDENTIFIER _3 = error
    {                                   ( flow_program_error() )}
| _1 = ROLE _2 = error
    {                                   ( id_error() )}
| _1 = DEFAULT _2 = ROLE _3 = error
    {                                   ( id_error() )}

flow_program:
  _1 = flow_statement
    {                     ( [_1, []] )}
| _1 = flow_statement _2 = flow_program
    {                                  ( (_1,[]) :: _2 )}

flow_statement:
  _1 = resource
    {                    ( _1 )}
| _1 = instruction
    {                    ( Instruction(_1) )}
| _1 = TRIGGER _2 = IDENTIFIER _3 = arg _4 = LBRACE _5 = RBRACE _6 = GETS _7 = anno_expr
    {                                                          ( Sink(Code(_2, _3, [], _7)) )}
| _1 = TRIGGER _2 = IDENTIFIER _3 = arg _4 = LBRACE _5 = value_typed_identifier_list _6 = RBRACE _7 = GETS _8 = anno_expr
    {                                                                                      (
      let locals = List.map (fun (id,t) -> (id,t,[])) _5
      in Sink(Code(_2, _3, locals, _8))
    )}
| _1 = BINDFLOW _2 = IDENTIFIER _3 = RARROW _4 = IDENTIFIER
    {                                                              ( BindFlow(_2, _4) )}
| _1 = BINDFLOW _2 = SOURCE _3 = IDENTIFIER _4 = RARROW _5 = TRIGGER _6 = IDENTIFIER
    {                                                              ( BindFlow(_3, _6) )}
| _1 = TRIGGER _2 = IDENTIFIER _3 = arg _4 = LBRACE _5 = RBRACE _6 = GETS _7 = error
    {                                                      ( print_error("Error in trigger body") )}
| _1 = TRIGGER _2 = IDENTIFIER _3 = arg _4 = LBRACE _5 = value_typed_identifier_list _6 = RBRACE _7 = GETS _8 = error
    {                                                                                  (
        print_error("Error in trigger body")
      )}
| _1 = TRIGGER _2 = IDENTIFIER _3 = arg _4 = LBRACE _5 = error
    {                                          ( print_error("Expected list of local declarations") )}
| _1 = TRIGGER _2 = error
    {                                          ( print_error("Invalid trigger") )}
| _1 = BIND _2 = IDENTIFIER _3 = RARROW _4 = error
    {                                                   ( print_error("Invalid bind target") )}
| _1 = BIND _2 = SOURCE _3 = IDENTIFIER _4 = RARROW _5 = TRIGGER _6 = error
    {                                                   ( print_error("Invalid bind target") )}
| _1 = BIND _2 = error
    {                                                   ( print_error("Invalid bind source") )}

instruction:
  _1 = CONSUME _2 = IDENTIFIER
    {                         ( Consume(_2) )}

resource:
  _1 = SOURCE _2 = IDENTIFIER _3 = COLON _4 = type_expr _5 = GETS _6 = handle
    {                                                    (
        let channel_type, channel_format = _6
        in Source(Resource(_2, Handle(_4, channel_type, channel_format)))
      )}
| _1 = SOURCE _2 = IDENTIFIER _3 = COLON _4 = type_expr _5 = GETS _6 = stream
    {                                                    (
        Source(Resource(_2, Stream(_4, _6)))
      )}
| _1 = SOURCE _2 = PATTERN _3 = IDENTIFIER _4 = GETS _5 = resource_pattern
    {                                                      (
        Source(Resource(_3, Pattern(_5)))
      )}
| _1 = SINK _2 = IDENTIFIER _3 = COLON _4 = type_expr _5 = GETS _6 = handle
    {                                                  (
        let channel_type, channel_format = _6
        in Sink(Resource(_2, Handle(_4, channel_type, channel_format)))
      )}
| _1 = SINK _2 = PATTERN _3 = IDENTIFIER _4 = GETS _5 = resource_pattern
    {                                                    (
        Sink(Resource(_3, Pattern(_5)))
      )}

handle:
  _1 = FILE _2 = LPAREN _3 = STRING _4 = COMMA _5 = IDENTIFIER _6 = RPAREN
    {      ( File(_3), parse_format _5 )}
| _1 = SOCKET _2 = LPAREN _3 = STRING _4 = COMMA _5 = INTEGER _6 = COMMA _7 = IDENTIFIER _8 = RPAREN
    {      ( Network(_3, _5), parse_format _7 )}

stream:
  _1 = STREAM _2 = LPAREN _3 = anno_expr _4 = RPAREN
    {                                      ( ConstStream(_3) )}
| _1 = RANDOM _2 = LPAREN _3 = INTEGER _4 = RPAREN
    {                                   ( RandomStream(_3) )}

resource_pattern:
  _1 = IDENTIFIER
    {                                       ( Terminal(_1) )}
| _1 = LPAREN _2 = resource_pattern _3 = RPAREN
    {                                         ( _2 )}
| _1 = resource_pattern _2 = QUESTION
    {                                         ( Optional(_1) )}
| _1 = resource_pattern _2 = TIMES
    {                                         ( Repeat(_1, UntilEOF) )}
| _1 = resource_pattern _2 = OR _3 = resource_pattern
    {                                           (
        let unwrap_choice x = match x with Choice(l) -> l | _ -> [x]
        in Choice((unwrap_choice _1)@(unwrap_choice _3))
      )}
| _1 = resource_pattern _2 = resource_pattern
    {                                        (
        let unwrap_seq x = match x with Sequence(l) -> l | _ -> [x]
        in Sequence((unwrap_seq _1)@(unwrap_seq _2))
      )}

annotations:
  _1 = annotation
    {                                       ( [_1] )}
| _1 = annotation _2 = SEMICOLON _3 = annotations
    {                                       ( _1::_3 )}

annotation:
  _1 = identifier_stream
    {                             ( Property(String.concat " " _1) )}

type_expr:
  _1 = type_expr _2 = RARROW _3 = fn_type_expr_list %prec UMINUS
    {                                                      ( let is, o = list_split (-1) (_1::_3) in
                                           match (hd o).typ with
                                           | TFunction(is', o') -> wrap_tfunc (is@is') o'
                                           | _ -> wrap_tfunc is (hd o)
                                         )}
| _1 = LPAREN _2 = type_expr _3 = RPAREN
    {                              ( _2 )}
| _1 = MUT _2 = type_expr
    {                         ( mut _2 )}
| _1 = LPAREN _2 = type_expr_tuple _3 = RPAREN
    {                                    ( _2 )}
| _1 = MAYBE _2 = type_expr
    {                                    ( wrap_tmaybe _2 )}
| _1 = INDIRECT _2 = type_expr
    {                                    ( wrap_tind _2 )}
| _1 = TYPE
    {                                    ( canonical _1 )}
| _1 = annotated_collection_type
    {                                    ( let c, anno = _1 in { (canonical c) with anno} )}

fn_type_expr_list:
  _1 = type_expr _2 = RARROW _3 = fn_type_expr_list
    {                                          ( _1 :: _3 )}
| _1 = type_expr
    {                                          ( [_1] )}

type_expr_tuple:
  _1 = type_expr_list
    {                     ( wrap_ttuple _1 )}

type_expr_list:
  _1 = type_expr
    {                                      ( [_1] )}
| _1 = type_expr _2 = COMMA _3 = type_expr_list
    {                                      ( _1 :: _3 )}

annotated_collection_type:
  _1 = collection_type
    {                                                          ( _1, [] )}
| _1 = collection_type _2 = ANNOTATE _3 = LBRACE _4 = annotations _5 = RBRACE
    {                                                          ( _1, _4 )}

collection_type:
  _1 = LBRACE _2 = type_expr _3 = RBRACE
    {                              ( TCollection(TSet, _2) )}
| _1 = LBRACE _2 = type_expr_tuple _3 = RBRACE
    {                                    ( TCollection(TSet, _2) )}
| _1 = LBRACEBAR _2 = type_expr _3 = RBRACEBAR
    {                                    ( TCollection(TBag, _2) )}
| _1 = LBRACEBAR _2 = type_expr_tuple _3 = RBRACEBAR
    {                                          ( TCollection(TBag, _2) )}
| _1 = LBRACKET _2 = type_expr _3 = RBRACKET
    {                                  ( TCollection(TList, _2) )}
| _1 = LBRACKET _2 = type_expr_tuple _3 = RBRACKET
    {                                        ( TCollection(TList, _2) )}
| _1 = LBRACKETCOLON _2 = type_expr _3 = RBRACKETCOLON
    {                                            ( TCollection(TMap, _2) )}
| _1 = LBRACKETCOLON _2 = type_expr_tuple _3 = RBRACKETCOLON
    {                                                  ( TCollection(TMap, _2) )}
| _1 = LBRACKETLT _2 = type_expr _3 = BAR _4 = int_list_list _5 = RBRACKETLT
    {                                                        ( TCollection(TVMap(Some(intsetset_of_list _4)), _2) )}
| _1 = LBRACKETLT _2 = type_expr_tuple _3 = BAR _4 = int_list_list _5 = RBRACKETLT
    {                                                              ( TCollection(TVMap(Some(intsetset_of_list _4)), _2) )}
| _1 = LBRACKETLT _2 = type_expr _3 = RBRACKETLT
    {                                      ( TCollection(TVMap None, _2) )}
| _1 = LBRACKETLT _2 = type_expr_tuple _3 = RBRACKETLT
    {                                            ( TCollection(TVMap None, _2) )}
| _1 = LBRACKETHASH _2 = type_expr _3 = RBRACKETHASH
    {                                          ( TCollection(TVector, _2) )}
| _1 = LBRACKETHASH _2 = type_expr_tuple _3 = RBRACKETHASH
    {                                                ( TCollection(TVector, _2) )}
| _1 = LBRACELT _2 = type_expr _3 = RBRACELT
    {                                  ( TCollection(TSortedMap, _2) )}
| _1 = LBRACELT _2 = type_expr_tuple _3 = RBRACELT
    {                                        ( TCollection(TSortedMap, _2) )}
| _1 = LBRACECOLON _2 = type_expr _3 = RBRACECOLON
    {                                        ( TCollection(TSortedSet, _2) )}
| _1 = LBRACECOLON _2 = type_expr_tuple _3 = RBRACECOLON
    {                                              ( TCollection(TSortedSet, _2) )}

int_list_list:
  _1 = int_list
    {               ([_1])}
| _1 = int_list _2 = SEMICOLON _3 = int_list_list
    {                                       ( _1::_3 )}

int_list:
  _1 = INTEGER
    {              ([_1])}
| _1 = INTEGER _2 = COMMA _3 = int_list
    {                             ( _1::_3 )}

anno_expr:
  _1 = expr _2 = ANNOTATE _3 = LBRACE _4 = annotations _5 = RBRACE
    {                                                  ( K3Util.add_annos _4 _1 )}
| _1 = expr
    {                                                  ( _1 )}

expr:
  _1 = LPAREN _2 = tuple _3 = RPAREN
    {                          ( _2 )}
| _1 = block
    {            ( _1 )}
| _1 = INDIRECT _2 = anno_expr
    {                                   ( mk_ind _2 )}
| _1 = JUST _2 = anno_expr
    {                                   ( mk_just _2 )}
| _1 = NOTHING _2 = COLON _3 = type_expr
    {                              ( mk_nothing _3 )}
| _1 = IGNORE _2 = LPAREN _3 = anno_expr _4 = RPAREN
    {                                     ( mk_ignore _3 )}
| _1 = constant
    {                   ( mk_const _1 )}
| _1 = collection
    {                   ( _1 )}
| _1 = range
    {                   ( _1 )}
| _1 = variable
    {                   ( mk_var _1 )}
| _1 = arithmetic
    {                   ( _1 )}
| _1 = predicate
    {                   ( _1 )}
| _1 = conditional
    {                   ( _1 )}
| _1 = case
    {                   ( _1 )}
| _1 = bind
    {                   ( _1 )}
| _1 = letin
    {                   ( _1 )}
| _1 = lambda
    {                   ( _1 )}
| _1 = tuple_index
    {                   ( _1 )}
| _1 = access
    {                   ( _1 )}
| _1 = transformers
    {                   ( _1 )}
| _1 = mutation
    {                   ( _1 )}
| _1 = SEND _2 = LPAREN _3 = IDENTIFIER _4 = COMMA _5 = address _6 = COMMA _7 = tuple _8 = RPAREN
    {                                                              (
        mkexpr Send [mkexpr (Const(CTarget(_3))) []; mkexpr (Const(_5)) []; _7]
      )}
| _1 = SEND _2 = LPAREN _3 = IDENTIFIER _4 = COMMA _5 = access _6 = COMMA _7 = tuple _8 = RPAREN
    {                                                             (
        mkexpr Send [mkexpr (Const(CTarget(_3))) []; _5; _7]
      )}
| _1 = SEND _2 = LPAREN _3 = IDENTIFIER _4 = COMMA _5 = variable _6 = COMMA _7 = tuple _8 = RPAREN
    {                                                               (
        mkexpr Send [mkexpr (Const(CTarget(_3))) []; mkexpr (Var _5) []; _7]
      )}
| _1 = anno_expr _2 = LPAREN _3 = expr_list _4 = RPAREN
    {                                                             ( mk_apply _1 _3 )}
| _1 = SEND _2 = LPAREN _3 = IDENTIFIER _4 = COMMA _5 = address _6 = COMMA _7 = error
    {                                                       ( print_error "Invalid send argument" )}
| _1 = SEND _2 = LPAREN _3 = IDENTIFIER _4 = COMMA _5 = error
    {                                         ( print_error "Invalid send address" )}
| _1 = SEND _2 = LPAREN _3 = error
    {                        ( print_error "Invalid send target" )}
| _1 = SEND _2 = error
    {                 ( print_error "Invalid send syntax" )}
| _1 = anno_expr _2 = LPAREN _3 = error
    {                             ( print_error("Function application error") )}

id_unknown:
  _1 = UNKNOWN
    {              ( "_" )}
| _1 = IDENTIFIER
    {                 ( _1 )}

id_list:
  _1 = id_unknown
    {                 ( [_1] )}
| _1 = id_unknown _2 = COMMA _3 = id_list
    {                               ( _1 :: _3 )}

expr_list:
  _1 = anno_expr
    {                                ( [_1] )}
| _1 = anno_expr _2 = COMMA _3 = expr_list
    {                                ( _1 :: _3 )}

expr_seq:
  _1 = tuple
    {                               ( [_1] )}
| _1 = tuple _2 = SEMICOLON _3 = expr_seq
    {                               ( _1 :: _3 )}

tuple:
  _1 = expr_list
    {                ( if List.length _1 = 1 then List.hd _1 else mkexpr Tuple _1 )}

value_typed_identifier:
  _1 = IDENTIFIER _2 = COLON _3 = type_expr
    {                                                ( (_1, _3) )}
| _1 = IDENTIFIER _2 = COLON _3 = error
    {                                                ( type_error() )}

value_typed_identifier_list:
  _1 = value_typed_identifier
    {                                                               ( [_1] )}
| _1 = value_typed_identifier _2 = COMMA _3 = value_typed_identifier_list
    {                                                               ( _1 :: _3 )}

arg:
  _1 = LPAREN _2 = arg_list _3 = RPAREN
    {                              ( ATuple(_2) )}
| _1 = UNKNOWN
    {              ( AIgnored )}
| _1 = value_typed_identifier
    {                              ( AVar(fst _1, snd _1) )}

arg_list:
  _1 = arg
    {                         ( [(_1)] )}
| _1 = arg _2 = COMMA _3 = arg_list
    {                         ( _1 :: _3 )}

constant:
  _1 = UNKNOWN
    {                ( CUnknown )}
| _1 = UNIT
    {                ( CUnit )}
| _1 = BOOL
    {                ( CBool(_1) )}
| _1 = INTEGER
    {                ( CInt(_1) )}
| _1 = FLOAT
    {                ( CFloat(_1) )}
| _1 = STRING
    {                ( CString(_1) )}
| _1 = address
    {                ( _1 )}

range:
  _1 = LBRACE _2 = anno_expr _3 = COLON _4 = COLON _5 = anno_expr _6 = COLON _7 = COLON _8 = anno_expr _9 = RBRACE
    {                                                                          ( mkexpr (Range(TSet)) [_2; _5; _8] )}
| _1 = LBRACEBAR _2 = anno_expr _3 = COLON _4 = COLON _5 = anno_expr _6 = COLON _7 = COLON _8 = anno_expr _9 = RBRACEBAR
    {                                                                                ( mkexpr (Range(TBag)) [_2; _5; _8] )}
| _1 = LBRACKET _2 = anno_expr _3 = COLON _4 = COLON _5 = anno_expr _6 = COLON _7 = COLON _8 = anno_expr _9 = RBRACKET
    {                                                                              ( mkexpr (Range(TList)) [_2; _5; _8] )}
| _1 = LBRACKETHASH _2 = anno_expr _3 = COLON _4 = COLON _5 = anno_expr _6 = COLON _7 = COLON _8 = anno_expr _9 = RBRACKETHASH
    {                                                                                      ( mkexpr (Range(TVector)) [_2; _5; _8] )}

collection:
  _1 = LBRACE _2 = RBRACE _3 = COLON _4 = type_expr
    {                                                  ( build_collection [] _4 )}
| _1 = LBRACEBAR _2 = RBRACEBAR _3 = COLON _4 = type_expr
    {                                                  ( build_collection [] _4 )}
| _1 = LBRACKETBAR _2 = RBRACKETBAR _3 = COLON _4 = type_expr
    {                                                  ( build_collection [] _4 )}
| _1 = LBRACKET _2 = RBRACKET _3 = COLON _4 = type_expr
    {                                                  ( build_collection [] _4 )}
| _1 = LBRACKETCOLON _2 = RBRACKETCOLON _3 = COLON _4 = type_expr
    {                                                  ( build_collection [] _4 )}
| _1 = LBRACECOLON _2 = RBRACECOLON _3 = COLON _4 = type_expr
    {                                                  ( build_collection [] _4 )}
| _1 = LBRACELT _2 = RBRACELT _3 = COLON _4 = type_expr
    {                                                  ( build_collection [] _4 )}
| _1 = LBRACKETLT _2 = RBRACKETLT _3 = COLON _4 = type_expr
    {                                                  ( build_collection [] _4 )}
| _1 = LBRACE _2 = RBRACE _3 = error
    {                                ( print_error "missing type for empty set")}
| _1 = LBRACEBAR _2 = RBRACEBAR _3 = error
    {                                ( print_error "missing type for empty bag")}
| _1 = LBRACKET _2 = RBRACKET _3 = error
    {                                ( print_error "missing type for empty list")}
| _1 = LBRACKETCOLON _2 = RBRACKETCOLON _3 = error
    {                                          ( print_error "missing type for empty map")}
| _1 = LBRACECOLON _2 = RBRACECOLON _3 = error
    {                                      ( print_error "missing type for empty sortedmap")}
| _1 = LBRACKETLT _2 = RBRACKETLT _3 = error
    {                                    ( print_error "missing type for empty vmap")}
| _1 = LBRACE _2 = expr_seq _3 = RBRACE
    {                                                       ( build_collection _2 (mk_unknown_collection TSet) )}
| _1 = LBRACEBAR _2 = expr_seq _3 = RBRACEBAR
    {                                                       ( build_collection _2 (mk_unknown_collection TBag) )}
| _1 = LBRACKET _2 = expr_seq _3 = RBRACKET
    {                                                       ( build_collection _2 (mk_unknown_collection TList) )}
| _1 = LBRACKETHASH _2 = expr_seq _3 = RBRACKETHASH
    {                                                       ( build_collection _2 (mk_unknown_collection TVector) )}
| _1 = LBRACKETCOLON _2 = expr_seq _3 = RBRACKETCOLON
    {                                                       ( build_collection _2 (mk_unknown_collection TMap) )}
| _1 = LBRACELT _2 = expr_seq _3 = RBRACELT
    {                                                       ( build_collection _2 (mk_unknown_collection TSortedMap) )}
| _1 = LBRACECOLON _2 = expr_seq _3 = RBRACECOLON
    {                                                       ( build_collection _2 (mk_unknown_collection TSortedSet) )}
| _1 = LBRACKETLT _2 = expr_seq _3 = BAR _4 = int_list_list _5 = RBRACKETLT
    {                                                       ( build_collection _2 (mk_unknown_collection (TVMap(Some(intsetset_of_list _4)))) )}
| _1 = LBRACKETLT _2 = expr_seq _3 = RBRACKETLT
    {                                                       ( build_collection _2 (mk_unknown_collection (TVMap None)) )}

variable:
  _1 = IDENTIFIER
    {                 ( _1 )}

address:
  _1 = IDENTIFIER _2 = COLON _3 = INTEGER
    {                               ( CAddress(_1,_3) )}
| _1 = IP _2 = COLON _3 = INTEGER
    {                       (
        let parts = Str.split (Str.regexp_string ".") _1 in
        let valid = List.for_all (fun x -> (int_of_string x) < 256) parts in
        if valid then CAddress(String.concat "." parts, _3)
        else address_error _1 _3
      )}

arithmetic:
  _1 = NEG _2 = anno_expr
    {                    ( mkexpr Neg [_2] )}
| _1 = anno_expr _2 = PLUS _3 = anno_expr
    {                               ( mkexpr Add [_1; _3] )}
| _1 = anno_expr _2 = NEG _3 = anno_expr %prec MINUS
    {                                          ( mkexpr Add [_1; mkexpr Neg [_3]] )}
| _1 = anno_expr _2 = TIMES _3 = anno_expr
    {                                ( mkexpr Mult [_1; _3] )}
| _1 = anno_expr _2 = DIVIDE _3 = anno_expr
    {                                 ( mkexpr Apply [mkexpr (Var("/")) []; mkexpr Tuple [_1; _3]] )}
| _1 = anno_expr _2 = MODULO _3 = anno_expr
    {                                 ( mkexpr Apply [mkexpr (Var("%")) []; mkexpr Tuple [_1; _3]] )}
| _1 = NEG _2 = error
    {                        ( arith_error 1 )}
| _1 = anno_expr _2 = PLUS _3 = error
    {                             ( arith_error 2 )}
| _1 = anno_expr _2 = TIMES _3 = error
    {                             ( arith_error 2 )}
| _1 = anno_expr _2 = DIVIDE _3 = error
    {                             ( arith_error 2 )}
| _1 = anno_expr _2 = MODULO _3 = error
    {                             ( arith_error 2 )}

predicate:
  _1 = NOT _2 = anno_expr
    {                    ( mkexpr Neg [_2] )}
| _1 = anno_expr _2 = AND _3 = anno_expr
    {                              ( mkexpr Mult [_1; _3] )}
| _1 = anno_expr _2 = OR _3 = anno_expr
    {                             ( mkexpr Add [_1; _3] )}
| _1 = anno_expr _2 = LT _3 = anno_expr
    {                             ( mkexpr Lt [_1; _3] )}
| _1 = anno_expr _2 = EQ _3 = anno_expr
    {                             ( mkexpr Eq [_1; _3] )}
| _1 = anno_expr _2 = LEQ _3 = anno_expr
    {                              ( mkexpr Leq [_1; _3] )}
| _1 = anno_expr _2 = NEQ _3 = anno_expr
    {                              ( mkexpr Neq [_1; _3] )}
| _1 = anno_expr _2 = GT _3 = anno_expr
    {                             ( mkexpr Neg [mkexpr Leq [_1; _3]] )}
| _1 = anno_expr _2 = GEQ _3 = anno_expr
    {                              ( mkexpr Neg [mkexpr Lt [_1; _3]] )}
| _1 = anno_expr _2 = LT _3 = error
    {                          ( comp_error() )}
| _1 = anno_expr _2 = EQ _3 = error
    {                          ( comp_error() )}
| _1 = anno_expr _2 = LEQ _3 = error
    {                          ( comp_error() )}
| _1 = anno_expr _2 = NEQ _3 = error
    {                          ( comp_error() )}
| _1 = anno_expr _2 = GT _3 = error
    {                          ( comp_error() )}
| _1 = anno_expr _2 = GEQ _3 = error
    {                          ( comp_error() )}

conditional:
  _1 = IF _2 = anno_expr _3 = THEN _4 = anno_expr _5 = ELSE _6 = anno_expr
    {                                                 ( mkexpr IfThenElse [_2; _4; _6] )}
| _1 = IF _2 = anno_expr _3 = THEN _4 = anno_expr _5 = ELSE _6 = error
    {                                             ( cond_error "else branch" )}
| _1 = IF _2 = anno_expr _3 = THEN _4 = error
    {                                        ( cond_error "then branch" )}
| _1 = IF _2 = error
    {                                   ( cond_error "predicate" )}

case:
  _1 = CASE _2 = anno_expr _3 = OF _4 = LBRACE _5 = JUST _6 = id_unknown _7 = RARROW _8 = anno_expr _9 = RBRACE _10 = LBRACE _11 = NOTHING _12 = RARROW _13 = anno_expr _14 = RBRACE
    {      ( mk_case_sn _2 _6 _8 _13 )}
| _1 = CASE _2 = anno_expr _3 = OF _4 = LBRACE _5 = NOTHING _6 = RARROW _7 = anno_expr _8 = RBRACE _9 = LBRACE _10 = JUST _11 = id_unknown _12 = RARROW _13 = anno_expr _14 = RBRACE
    {      ( mk_case_sn _2 _11 _7 _13 )}
| _1 = CASE _2 = anno_expr _3 = OF _4 = LBRACE _5 = JUST _6 = id_unknown _7 = RARROW _8 = anno_expr
    {                                                                ( case_error "nothing case" )}
| _1 = CASE _2 = anno_expr _3 = OF _4 = LBRACE _5 = NOTHING _6 = RARROW _7 = anno_expr
    {                                                        ( case_error "just case" )}
| _1 = CASE _2 = anno_expr _3 = OF _4 = error
    {                              ( case_error "expr" )}
| _1 = CASE _2 = error
    {                 ( case_error "predicate" )}

letin:
  _1 = LET _2 = LPAREN _3 = id_list _4 = RPAREN _5 = GETS _6 = anno_expr _7 = IN _8 = anno_expr
    {                                                              ( mk_let _3 _6 _8 )}
| _1 = LET _2 = IDENTIFIER _3 = GETS _4 = anno_expr _5 = IN _6 = anno_expr
    {                                                              ( mk_let [_2] _4 _6 )}
| _1 = LET _2 = LPAREN _3 = id_list _4 = RPAREN _5 = GETS _6 = anno_expr _7 = IN _8 = error
    {                                                          ( print_error "Let body error" )}
| _1 = LET _2 = IDENTIFIER _3 = GETS _4 = anno_expr _5 = IN _6 = error
    {                                                          ( print_error "Let body error" )}
| _1 = LET _2 = LPAREN _3 = id_list _4 = RPAREN _5 = GETS _6 = error
    {                                                     ( print_error "Let binding target error" )}
| _1 = LET _2 = IDENTIFIER _3 = GETS _4 = error
    {                                                     ( print_error "Let binding target error" )}
| _1 = LET _2 = error
    {                                                     ( print_error "Let binding error" )}

bind:
  _1 = BIND _2 = anno_expr _3 = AS _4 = IDENTIFIER _5 = IN _6 = anno_expr
    {                                                ( mk_bind _2 _4 _6 )}
| _1 = BIND _2 = anno_expr _3 = AS _4 = IDENTIFIER _5 = IN _6 = error
    {                                            ( bind_error "expr" )}
| _1 = BIND _2 = anno_expr _3 = AS _4 = IDENTIFIER _5 = error
    {                                         ( bind_error "missing 'in'" )}
| _1 = BIND _2 = anno_expr _3 = AS _4 = error
    {                              ( bind_error "id" )}
| _1 = BIND _2 = anno_expr _3 = error
    {                              ( bind_error "missing of" )}
| _1 = BIND _2 = error
    {                         ( bind_error "predicate" )}

lambda:
  _1 = BACKSLASH _2 = arg _3 = RARROW _4 = anno_expr
    {                                      ( mkexpr (Lambda(_2)) [_4] )}
| _1 = BACKSLASH _2 = arg _3 = RARROW _4 = error
    {                                  ( lambda_error "body" )}
| _1 = BACKSLASH _2 = error
    {                                  ( lambda_error "argument" )}

tuple_index:
  _1 = anno_expr _2 = PERIOD _3 = LBRACKET _4 = INTEGER _5 = RBRACKET
    {                                                 ( mkexpr (Subscript _4) [_1] )}

access:
  _1 = anno_expr _2 = LBRACKET _3 = tuple _4 = RBRACKET
    {                                        ( mkexpr Slice [_1; _3] )}
| _1 = anno_expr _2 = LBRACKETLT _3 = tuple _4 = RBRACKET
    {                                          ( mkexpr SliceFrontier [_1; _3] )}
| _1 = anno_expr _2 = LBRACKETGEQ _3 = tuple _4 = RBRACKET
    {                                           ( mkexpr SliceUpperEq [_1; _3] )}
| _1 = PEEK _2 = LPAREN _3 = anno_expr _4 = RPAREN
    {                                   ( mkexpr Peek [_3] )}
| _1 = PEEK_WITH_VID _2 = LPAREN _3 = anno_expr _4 = COMMA _5 = anno_expr _6 = COMMA _7 = anno_expr _8 = RPAREN
    {                                                                            ( mkexpr PeekWithVid [_3; _5; _7] )}
| _1 = AT_WITH _2 = LPAREN _3 = anno_expr _4 = COMMA _5 = anno_expr _6 = COMMA _7 = anno_expr _8 = COMMA _9 = anno_expr _10 = RPAREN
    {                                                                                      ( mkexpr AtWith [_3; _5; _7; _9] )}
| _1 = MIN_WITH _2 = LPAREN _3 = anno_expr _4 = COMMA _5 = anno_expr _6 = COMMA _7 = anno_expr _8 = RPAREN
    {                                                                       ( mkexpr MinWith [_3; _5; _7] )}

mutation:
  _1 = INSERT _2 = LPAREN _3 = variable _4 = COMMA _5 = tuple _6 = RPAREN
    {                                                ( mkexpr Insert [mk_var _3; _5] )}
| _1 = UPSERT_WITH _2 = LPAREN _3 = variable _4 = COMMA _5 = LPAREN _6 = tuple _7 = RPAREN _8 = COMMA _9 = anno_expr _10 = COMMA _11 = anno_expr _12 = RPAREN
    {                                                                                                   ( mkexpr UpsertWith [mk_var _3; _6; _9; _11] )}
| _1 = UPSERT_WITH_BEFORE _2 = LPAREN _3 = variable _4 = COMMA _5 = LPAREN _6 = tuple _7 = RPAREN _8 = COMMA _9 = anno_expr _10 = COMMA _11 = anno_expr _12 = RPAREN
    {                                                                                                          ( mkexpr UpsertWithBefore [mk_var _3; _6; _9; _11] )}
| _1 = DELETE _2 = LPAREN _3 = variable _4 = COMMA _5 = tuple _6 = RPAREN
    {                                                ( mkexpr Delete [mk_var _3; _5] )}
| _1 = DELETE_PREFIX _2 = LPAREN _3 = variable _4 = COMMA _5 = tuple _6 = RPAREN
    {                                                       ( mkexpr DeletePrefix [mk_var _3; _5] )}
| _1 = UPDATE _2 = LPAREN _3 = variable _4 = COMMA _5 = anno_expr _6 = COMMA _7 = anno_expr _8 = RPAREN
    {                                                                    ( mkexpr Update [mk_var _3; _5; _7] )}
| _1 = UPDATE_SUFFIX _2 = LPAREN _3 = variable _4 = COMMA _5 = anno_expr _6 = COMMA _7 = anno_expr _8 = RPAREN
    {                                                                           ( mkexpr UpdateSuffix [mk_var _3; _5; _7] )}
| _1 = variable _2 = LARROW _3 = anno_expr
    {                                ( mkexpr Assign [mk_var _1; _3] )}
| _1 = UPSERT_WITH_BEFORE _2 = LPAREN _3 = variable _4 = COMMA _5 = tuple _6 = COMMA _7 = anno_expr _8 = COMMA _9 = error
    {                                                                                 ( upsert_with_before_error "lambda some")}
| _1 = UPSERT_WITH_BEFORE _2 = LPAREN _3 = variable _4 = COMMA _5 = tuple _6 = COMMA _7 = error
    {                                                                 ( upsert_with_before_error "lambda none")}
| _1 = UPSERT_WITH_BEFORE _2 = LPAREN _3 = variable _4 = COMMA _5 = error
    {                                                     ( upsert_with_before_error "pattern" )}
| _1 = UPSERT_WITH_BEFORE _2 = LPAREN _3 = error
    {                                      ( upsert_with_before_error "collection" )}
| _1 = INSERT _2 = LPAREN _3 = anno_expr _4 = error
    {                                    ( value_error 2 )}
| _1 = INSERT _2 = LPAREN _3 = error
    {                               ( coll_error 1 )}
| _1 = UPDATE _2 = LPAREN _3 = anno_expr _4 = error
    {                                    ( value_error 2 )}
| _1 = UPDATE _2 = LPAREN _3 = error
    {                               ( coll_error 1 )}
| _1 = DELETE _2 = LPAREN _3 = anno_expr _4 = error
    {                                    ( value_error 2 )}
| _1 = DELETE _2 = LPAREN _3 = error
    {                               ( coll_error 1 )}
| _1 = anno_expr _2 = LARROW _3 = error
    {                                    ( assign_error "reference" )}

transformers:
  _1 = anno_expr _2 = CONCAT _3 = anno_expr
    {                                                                    ( mkexpr Combine [_1; _3] )}
| _1 = MAP _2 = LPAREN _3 = anno_expr _4 = COMMA _5 = anno_expr _6 = RPAREN
    {                                                                    ( mkexpr Map [_3; _5] )}
| _1 = ITERATE _2 = LPAREN _3 = anno_expr _4 = COMMA _5 = anno_expr _6 = RPAREN
    {                                                                    ( mkexpr Iterate [_3; _5] )}
| _1 = FILTER _2 = LPAREN _3 = anno_expr _4 = COMMA _5 = anno_expr _6 = RPAREN
    {                                                                    ( mkexpr Filter [_3; _5] )}
| _1 = FLATTEN _2 = LPAREN _3 = anno_expr _4 = RPAREN
    {                                                               ( mkexpr Flatten [_3] )}
| _1 = AGGREGATE _2 = LPAREN _3 = anno_expr _4 = COMMA _5 = anno_expr _6 = COMMA _7 = anno_expr _8 = RPAREN
    {                                                                         ( mkexpr Aggregate [_3; _5; _7] )}
| _1 = AGGREGATEV _2 = LPAREN _3 = anno_expr _4 = COMMA _5 = anno_expr _6 = COMMA _7 = anno_expr _8 = RPAREN
    {                                                                          ( mkexpr AggregateV [_3; _5; _7] )}
| _1 = GROUPBYAGGREGATE _2 = LPAREN _3 = anno_expr _4 = COMMA _5 = anno_expr _6 = COMMA _7 = anno_expr _8 = COMMA _9 = anno_expr _10 = RPAREN
    {                                                                                               (
        mkexpr GroupByAggregate [_3; _5; _7; _9]
    )}
| _1 = SORT _2 = LPAREN _3 = anno_expr _4 = COMMA _5 = anno_expr _6 = RPAREN
    {                                                   ( mkexpr Sort [_3; _5] )}
| _1 = SIZE _2 = LPAREN _3 = anno_expr _4 = RPAREN
    {                                              ( mkexpr Size [_3] )}
| _1 = FILTERGEQ _2 = LPAREN _3 = anno_expr _4 = COMMA _5 = anno_expr _6 = RPAREN
    {                                                        ( mkexpr FilterGEQ [_3; _5] )}
| _1 = anno_expr _2 = CONCAT _3 = error
    {                             ( print_error("Expected expression for combine") )}
| _1 = MAP _2 = LPAREN _3 = anno_expr _4 = error
    {                                 ( coll_error 2 )}
| _1 = MAP _2 = LPAREN _3 = error
    {                            ( coll_lambda_error "map" 1 )}
| _1 = MAP _2 = error
    {                            ( print_error("Invalid map syntax") )}
| _1 = ITERATE _2 = LPAREN _3 = anno_expr _4 = error
    {                                     ( coll_error 2 )}
| _1 = ITERATE _2 = LPAREN _3 = error
    {                                ( coll_lambda_error "iterate" 1 )}
| _1 = ITERATE _2 = error
    {                                ( print_error("Invalid iterate syntax") )}
| _1 = FILTER _2 = LPAREN _3 = anno_expr _4 = error
    {                                    ( coll_error 2 )}
| _1 = FILTER _2 = LPAREN _3 = error
    {                               ( coll_lambda_error "filter" 1 )}
| _1 = FILTER _2 = error
    {                               ( print_error("Invalid filterhsyntax") )}
| _1 = FLATTEN _2 = LPAREN _3 = error
    {                           ( print_error("Expected a nested collection") )}
| _1 = AGGREGATE _2 = LPAREN _3 = anno_expr _4 = COMMA _5 = anno_expr _6 = error
    {                                                       ( coll_error 3 )}
| _1 = AGGREGATE _2 = LPAREN _3 = anno_expr _4 = error
    {                                                  ( value_error 2 )}
| _1 = AGGREGATE _2 = LPAREN _3 = error
    {                                             ( coll_lambda_error "aggregate" 1 )}
| _1 = AGGREGATE _2 = error
    {                                             ( print_error("Invalid fold syntax") )}
| _1 = GROUPBYAGGREGATE _2 = LPAREN _3 = anno_expr _4 = COMMA _5 = anno_expr _6 = COMMA _7 = anno_expr _8 = error
    {                                                                              ( coll_error 4 )}
| _1 = GROUPBYAGGREGATE _2 = LPAREN _3 = anno_expr _4 = COMMA _5 = anno_expr _6 = error
    {                                                                         ( value_error 3 )}
| _1 = GROUPBYAGGREGATE _2 = LPAREN _3 = anno_expr _4 = error
    {                                                                    ( coll_lambda_error "group-by aggregate" 2 )}
| _1 = GROUPBYAGGREGATE _2 = LPAREN _3 = error
    {                                                               ( coll_lambda_error "grouping" 1 )}
| _1 = GROUPBYAGGREGATE _2 = error
    {                                                               ( print_error("Invalid groupby syntax") )}

block:
  _1 = DO _2 = LBRACE _3 = expr_seq _4 = RBRACE
    {                                ( mkexpr Block _3 )}

identifier_stream:
  _1 = IDENTIFIER
    {                                     ([_1])}
| _1 = IDENTIFIER _2 = identifier_stream
    {                                     ( _1::_2 )}

program_test:
  _1 = program _2 = EXPECTED _3 = named_expr_list
    {                                           ( ProgTest (_1, _3) )}
| _1 = program _2 = NETWORK _3 = EXPECTED _4 = named_expr_list
    {                                               ( NetworkTest (_1, _4) )}
| _1 = program _2 = EXPECTED _3 = error
    {                                           ( print_error "invalid expected value list" )}
| _1 = program _2 = NETWORK _3 = EXPECTED _4 = error
    {                                           ( print_error "invalid expected value list" )}
| _1 = program _2 = error
    {                                           ( print_error "no expected values specified for program test" )}

expression_test_list:
  _1 = anno_expr _2 = EXPECTED _3 = check_expr
    {                                                          ( [[], _1, _3] )}
| _1 = program _2 = anno_expr _3 = EXPECTED _4 = check_expr
    {                                                          ( [_1, _2, _4] )}
| _1 = expression_test_list _2 = SEMICOLON _3 = expression_test_list
    {                                                          ( _1@_3 )}
| _1 = anno_expr _2 = EXPECTED _3 = error
    {                                                ( print_error "invalid expected expression")}

expression_test:
  _1 = expression_test_list
    {                                                    ( ExprTest _1 )}

named_expr_list:
  _1 = anno_expr _2 = GETS _3 = check_expr
    {                                                         ( [_1, _3] )}
| _1 = anno_expr _2 = GETS _3 = check_expr _4 = COMMA _5 = named_expr_list
    {                                                         ( _5@[_1, _3] )}
| _1 = anno_expr _2 = GETS _3 = error
    {                           ( print_error "invalid check expression")}

check_expr:
  _1 = IDENTIFIER _2 = COLON _3 = anno_expr
    {                                          ( InlineExpr(_1, _3) )}

%%


