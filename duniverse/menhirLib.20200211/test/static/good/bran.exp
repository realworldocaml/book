Grammar has 78 nonterminal symbols, among which 1 start symbols.
Grammar has 77 terminal symbols.
Grammar has 233 productions.
nullable(value_name) = false
nullable(typedef) = false
nullable(type_params_opt) = true
nullable(type_params) = false
nullable(type_param) = false
nullable(type_expr_tuple) = false
nullable(type_expr) = false
nullable(type_constr_params) = false
nullable(type_constr) = false
nullable(tuple_pattern) = false
nullable(tuple) = false
nullable(term) = false
nullable(stmt) = false
nullable(simple_type_expr) = false
nullable(simple_expr) = false
nullable(sigdef) = false
nullable(segment) = false
nullable(rev_type_params) = false
nullable(rev_type_expr_tuple_tail) = false
nullable(rev_type_constr_params) = false
nullable(rev_tuple_pattern) = false
nullable(rev_tuple) = false
nullable(rev_stmts) = false
nullable(rev_pattern_matching_elts) = false
nullable(rev_pattern_matching) = false
nullable(rev_mutual_fundefs) = false
nullable(rev_module_path) = false
nullable(rev_list_pattern_elts) = false
nullable(rev_list_elts) = false
nullable(rev_formal_args) = false
nullable(rev_field_patterns) = false
nullable(rev_field_decls) = false
nullable(rev_definitions) = false
nullable(rev_constr_path) = false
nullable(rev_constr_decls) = false
nullable(rev_bitstring) = false
nullable(rev_bits_spec_list) = false
nullable(prog) = false
nullable(primary) = false
nullable(pattern_matching_elt) = false
nullable(pattern_matching) = false
nullable(pattern) = false
nullable(nl_opt) = true
nullable(mutual_fundefs_opt) = true
nullable(mutual_fundef) = false
nullable(multi_exps_block) = false
nullable(module_path) = false
nullable(list_pattern) = true
nullable(list_) = true
nullable(if_exp) = false
nullable(fundef) = false
nullable(formal_arg) = false
nullable(fields_tail) = true
nullable(fields) = false
nullable(field_patterns) = false
nullable(field_pattern) = false
nullable(field_expr) = false
nullable(field_decls) = false
nullable(field_decl) = false
nullable(field) = false
nullable(ext_sigdef) = false
nullable(expr) = false
nullable(do_block) = false
nullable(definitions) = true
nullable(definition) = false
nullable(constr_name) = false
nullable(constr_decls) = false
nullable(constr_decl_type) = true
nullable(constr_decl) = false
nullable(constr) = false
nullable(block) = false
nullable(bitstring) = true
nullable(bits_value) = false
nullable(bits_spec_list) = false
nullable(bits_spec) = false
nullable(binding) = false
nullable(array_expr) = false
nullable(actual_args) = false
first(value_name) = IDENT
first(typedef) = QIDENT LPAREN IDENT
first(type_params_opt) = QIDENT LPAREN
first(type_params) = QIDENT LPAREN
first(type_param) = QIDENT
first(type_expr_tuple) = UIDENT QIDENT LPAREN IDENT
first(type_expr) = UIDENT QIDENT LPAREN IDENT
first(type_constr_params) = UIDENT QIDENT LPAREN IDENT
first(type_constr) = UIDENT IDENT
first(tuple_pattern) = UIDENT STRING LPAREN LBRACK LBRACE INT IDENT FLOAT BOOL ATOM
first(tuple) = LPAREN
first(term) = SEMI NL
first(stmt) = VAR UIDENT TRY STRING RETURN RECEIVE RAISE PERFORM NOT MINUS MATCH LPAREN LESS_LESS LBRACK LBRACE INT IF IDENT FUN FOR FLOAT EXCL DEF CHAR BOOL ATOM ASSERT
first(simple_type_expr) = UIDENT QIDENT LPAREN IDENT
first(simple_expr) = UIDENT STRING LPAREN LESS_LESS LBRACK INT IDENT FLOAT EXCL CHAR BOOL ATOM
first(sigdef) = IDENT
first(segment) = STRING INT IDENT FLOAT
first(rev_type_params) = QIDENT LPAREN
first(rev_type_expr_tuple_tail) = AST
first(rev_type_constr_params) = UIDENT QIDENT LPAREN IDENT
first(rev_tuple_pattern) = UIDENT STRING LPAREN LBRACK LBRACE INT IDENT FLOAT BOOL ATOM
first(rev_tuple) = VAR UIDENT TRY STRING RETURN RECEIVE RAISE PERFORM NOT MINUS MATCH LPAREN LESS_LESS LBRACK LBRACE INT IF IDENT FUN FOR FLOAT EXCL DEF CHAR BOOL ATOM ASSERT
first(rev_stmts) = VAR UIDENT TRY STRING RETURN RECEIVE RAISE PERFORM NOT MINUS MATCH LPAREN LESS_LESS LBRACK LBRACE INT IF IDENT FUN FOR FLOAT EXCL DEF CHAR BOOL ATOM ASSERT
first(rev_pattern_matching_elts) = UIDENT STRING LPAREN LBRACK LBRACE INT IDENT FLOAT BOOL ATOM
first(rev_pattern_matching) = UIDENT STRING PIPE LPAREN LBRACK LBRACE INT IDENT FLOAT BOOL ATOM
first(rev_mutual_fundefs) = AND
first(rev_module_path) = UIDENT
first(rev_list_pattern_elts) = UIDENT STRING LPAREN LBRACK LBRACE INT IDENT FLOAT BOOL ATOM
first(rev_list_elts) = VAR UIDENT TRY STRING RETURN RECEIVE RAISE PERFORM NOT MINUS MATCH LPAREN LESS_LESS LBRACK LBRACE INT IF IDENT FUN FOR FLOAT EXCL DEF CHAR BOOL ATOM ASSERT
first(rev_formal_args) = UIDENT STRING LPAREN LBRACK LBRACE INT IDENT FLOAT BOOL ATOM
first(rev_field_patterns) = IDENT
first(rev_field_decls) = IDENT
first(rev_definitions) = error TYPE TOPVAR TOPDEF NL EXTERNAL EXCEPTION AND
first(rev_constr_path) = UIDENT
first(rev_constr_decls) = UIDENT
first(rev_bitstring) = STRING INT IDENT FLOAT
first(rev_bits_spec_list) = IDENT
first(prog) = error TYPE TOPVAR TOPDEF NL EXTERNAL EXCEPTION EOF AND
first(primary) = UIDENT STRING LPAREN LESS_LESS LBRACK INT IDENT FLOAT CHAR BOOL ATOM
first(pattern_matching_elt) = UIDENT STRING LPAREN LBRACK LBRACE INT IDENT FLOAT BOOL ATOM
first(pattern_matching) = UIDENT STRING PIPE LPAREN LBRACK LBRACE INT IDENT FLOAT BOOL ATOM
first(pattern) = UIDENT STRING LPAREN LBRACK LBRACE INT IDENT FLOAT BOOL ATOM
first(nl_opt) = NL
first(mutual_fundefs_opt) = AND
first(mutual_fundef) = AND
first(multi_exps_block) = VAR UIDENT TRY STRING RETURN RECEIVE RAISE PERFORM NOT MINUS MATCH LPAREN LESS_LESS LBRACK LBRACE INT IF IDENT FUN FOR FLOAT EXCL DEF CHAR BOOL ATOM ASSERT
first(module_path) = UIDENT
first(list_pattern) = UIDENT STRING LPAREN LBRACK LBRACE INT IDENT FLOAT BOOL ATOM
first(list_) = VAR UIDENT TRY STRING RETURN RECEIVE RAISE PERFORM NOT MINUS MATCH LPAREN LESS_LESS LBRACK LBRACE INT IF IDENT FUN FOR FLOAT EXCL DEF CHAR BOOL ATOM ASSERT
first(if_exp) = IF
first(fundef) = IDENT
first(formal_arg) = UIDENT STRING LPAREN LBRACK LBRACE INT IDENT FLOAT BOOL ATOM
first(fields_tail) = SEMI
first(fields) = IDENT
first(field_patterns) = IDENT
first(field_pattern) = IDENT
first(field_expr) = UIDENT STRING LPAREN LESS_LESS LBRACK INT IDENT FLOAT CHAR BOOL ATOM
first(field_decls) = NL IDENT
first(field_decl) = IDENT
first(field) = IDENT
first(ext_sigdef) = IDENT
first(expr) = VAR UIDENT TRY STRING RETURN RECEIVE RAISE PERFORM NOT MINUS MATCH LPAREN LESS_LESS LBRACK LBRACE INT IF IDENT FUN FOR FLOAT EXCL DEF CHAR BOOL ATOM ASSERT
first(do_block) = DO
first(definitions) = error TYPE TOPVAR TOPDEF NL EXTERNAL EXCEPTION AND
first(definition) = error TYPE TOPVAR TOPDEF NL EXTERNAL EXCEPTION AND
first(constr_name) = UIDENT
first(constr_decls) = UIDENT
first(constr_decl_type) = OF
first(constr_decl) = UIDENT
first(constr) = UIDENT IDENT
first(block) = VAR UIDENT TRY STRING RETURN RECEIVE RAISE PERFORM NOT MINUS MATCH LPAREN LESS_LESS LBRACK LBRACE INT IF IDENT FUN FOR FLOAT EXCL DEF CHAR BOOL ATOM ASSERT
first(bitstring) = STRING INT IDENT FLOAT
first(bits_value) = STRING INT IDENT FLOAT
first(bits_spec_list) = IDENT
first(bits_spec) = IDENT
first(binding) = UIDENT IDENT
first(array_expr) = UIDENT STRING LPAREN LESS_LESS LBRACK INT IDENT FLOAT CHAR BOOL ATOM
first(actual_args) = UIDENT STRING LPAREN LESS_LESS LBRACK INT IDENT FLOAT EXCL CHAR BOOL ATOM
minimal(value_name) = (* 1 *) IDENT
minimal(typedef) = (* 3 *) IDENT EQUAL QIDENT
minimal(type_params_opt) = (* 0 *) 
minimal(type_params) = (* 1 *) QIDENT
minimal(type_param) = (* 1 *) QIDENT
minimal(type_expr_tuple) = (* 3 *) QIDENT AST QIDENT
minimal(type_expr) = (* 1 *) QIDENT
minimal(type_constr_params) = (* 1 *) QIDENT
minimal(type_constr) = (* 1 *) IDENT
minimal(tuple_pattern) = (* 3 *) IDENT COMMA IDENT
minimal(tuple) = (* 5 *) LPAREN IDENT COMMA IDENT RPAREN
minimal(term) = (* 1 *) SEMI
minimal(stmt) = (* 1 *) IDENT
minimal(simple_type_expr) = (* 1 *) QIDENT
minimal(simple_expr) = (* 1 *) IDENT
minimal(sigdef) = (* 3 *) IDENT COLON QIDENT
minimal(segment) = (* 1 *) INT
minimal(rev_type_params) = (* 1 *) QIDENT
minimal(rev_type_expr_tuple_tail) = (* 2 *) AST QIDENT
minimal(rev_type_constr_params) = (* 1 *) QIDENT
minimal(rev_tuple_pattern) = (* 3 *) IDENT COMMA IDENT
minimal(rev_tuple) = (* 3 *) IDENT COMMA IDENT
minimal(rev_stmts) = (* 1 *) IDENT
minimal(rev_pattern_matching_elts) = (* 3 *) IDENT RARROW IDENT
minimal(rev_pattern_matching) = (* 3 *) IDENT RARROW IDENT
minimal(rev_mutual_fundefs) = (* 5 *) AND IDENT IDENT EQUAL IDENT
minimal(rev_module_path) = (* 2 *) UIDENT DOT
minimal(rev_list_pattern_elts) = (* 1 *) IDENT
minimal(rev_list_elts) = (* 1 *) IDENT
minimal(rev_formal_args) = (* 1 *) IDENT
minimal(rev_field_patterns) = (* 3 *) IDENT EQUAL IDENT
minimal(rev_field_decls) = (* 3 *) IDENT COLON QIDENT
minimal(rev_definitions) = (* 1 *) NL
minimal(rev_constr_path) = (* 1 *) UIDENT
minimal(rev_constr_decls) = (* 1 *) UIDENT
minimal(rev_bitstring) = (* 1 *) INT
minimal(rev_bits_spec_list) = (* 1 *) IDENT
minimal(prog) = (* 1 *) EOF
minimal(primary) = (* 1 *) IDENT
minimal(pattern_matching_elt) = (* 3 *) IDENT RARROW IDENT
minimal(pattern_matching) = (* 3 *) IDENT RARROW IDENT
minimal(pattern) = (* 1 *) IDENT
minimal(nl_opt) = (* 0 *) 
minimal(mutual_fundefs_opt) = (* 0 *) 
minimal(mutual_fundef) = (* 5 *) AND IDENT IDENT EQUAL IDENT
minimal(multi_exps_block) = (* 3 *) IDENT SEMI IDENT
minimal(module_path) = (* 3 *) UIDENT DOT IDENT
minimal(list_pattern) = (* 0 *) 
minimal(list_) = (* 0 *) 
minimal(if_exp) = (* 6 *) IF IDENT THEN IDENT ELSE IDENT
minimal(fundef) = (* 4 *) IDENT IDENT EQUAL IDENT
minimal(formal_arg) = (* 1 *) IDENT
minimal(fields_tail) = (* 0 *) 
minimal(fields) = (* 3 *) IDENT EQUAL IDENT
minimal(field_patterns) = (* 7 *) IDENT EQUAL IDENT COMMA IDENT EQUAL IDENT
minimal(field_pattern) = (* 3 *) IDENT EQUAL IDENT
minimal(field_expr) = (* 3 *) IDENT DOT IDENT
minimal(field_decls) = (* 3 *) IDENT COLON QIDENT
minimal(field_decl) = (* 3 *) IDENT COLON QIDENT
minimal(field) = (* 3 *) IDENT EQUAL IDENT
minimal(ext_sigdef) = (* 5 *) IDENT COLON QIDENT EQUAL STRING
minimal(expr) = (* 1 *) IDENT
minimal(do_block) = (* 5 *) DO IDENT RARROW IDENT END
minimal(definitions) = (* 0 *) 
minimal(definition) = (* 1 *) NL
minimal(constr_name) = (* 1 *) UIDENT
minimal(constr_decls) = (* 1 *) UIDENT
minimal(constr_decl_type) = (* 0 *) 
minimal(constr_decl) = (* 1 *) UIDENT
minimal(constr) = (* 1 *) IDENT
minimal(block) = (* 1 *) IDENT
minimal(bitstring) = (* 0 *) 
minimal(bits_value) = (* 1 *) INT
minimal(bits_spec_list) = (* 1 *) IDENT
minimal(bits_spec) = (* 1 *) IDENT
minimal(binding) = (* 1 *) IDENT
minimal(array_expr) = (* 5 *) IDENT DOT LPAREN IDENT RPAREN
minimal(actual_args) = (* 1 *) IDENT
follow(value_name) = error WITH UIDENT UARROW TYPE TOPVAR TOPDEF TO THEN STRING SLASH_DOT SLASH SEMI RPAREN RBRACK RBRACE RARROW PLUS_DOT PLUS PIPE NL MOD MINUS_DOT MINUS LPAREN LOR LESS_LESS LESS_GREATER LESS_EQUAL LESS LBRACK LBRACE LARROW LAND INT IN IDENT GREATER_EQUAL GREATER FLOAT EXTERNAL EXCL EXCEPTION EQUAL EOF END ELSE DOT DOL DO CONS COMMA COLON CHAR BOOL ATOM AST_DOT AST ASSIGN AS AND
follow(typedef) = error TYPE TOPVAR TOPDEF NL EXTERNAL EXCEPTION EOF AND
follow(type_params_opt) = IDENT
follow(type_params) = IDENT COMMA
follow(type_param) = RPAREN IDENT COMMA
follow(type_expr_tuple) = error UIDENT TYPE TOPVAR TOPDEF RPAREN RBRACE RARROW PIPE NL IDENT EXTERNAL EXCEPTION EQUAL EOF COMMA AND
follow(type_expr) = error UIDENT TYPE TOPVAR TOPDEF RPAREN RBRACE RARROW PIPE NL IDENT EXTERNAL EXCEPTION EQUAL EOF COMMA AND
follow(type_constr_params) = RPAREN
follow(type_constr) = error UIDENT TYPE TOPVAR TOPDEF RPAREN RBRACE RARROW PIPE NL IDENT EXTERNAL EXCEPTION EQUAL EOF COMMA AST AND
follow(tuple_pattern) = RPAREN
follow(tuple) = error WITH UIDENT UARROW TYPE TOPVAR TOPDEF TO THEN STRING SLASH_DOT SLASH SEMI RPAREN RBRACK RBRACE PLUS_DOT PLUS PIPE NL MOD MINUS_DOT MINUS LPAREN LOR LESS_LESS LESS_GREATER LESS_EQUAL LESS LBRACK LAND INT IN IDENT GREATER_EQUAL GREATER FLOAT EXTERNAL EXCL EXCEPTION EQUAL EOF END ELSE DOL DO CONS COMMA CHAR BOOL ATOM AST_DOT AST AND
follow(term) = VAR UIDENT TRY STRING RETURN RECEIVE RAISE PERFORM NOT MINUS MATCH LPAREN LESS_LESS LBRACK LBRACE INT IF IDENT FUN FOR FLOAT EXCL DEF CHAR BOOL ATOM ASSERT
follow(stmt) = error WITH UIDENT UARROW TYPE TOPVAR TOPDEF TO THEN STRING SLASH_DOT SLASH SEMI RPAREN RBRACK RBRACE PLUS_DOT PLUS PIPE NL MOD MINUS_DOT MINUS LPAREN LOR LESS_LESS LESS_GREATER LESS_EQUAL LESS LBRACK LAND INT IN IDENT GREATER_EQUAL GREATER FLOAT EXTERNAL EXCL EXCEPTION EQUAL EOF END ELSE DOL DO CONS COMMA CHAR BOOL ATOM AST_DOT AST AND
follow(simple_type_expr) = error UIDENT TYPE TOPVAR TOPDEF RPAREN RBRACE RARROW PIPE NL IDENT EXTERNAL EXCEPTION EQUAL EOF COMMA AST AND
follow(simple_expr) = error WITH UIDENT UARROW TYPE TOPVAR TOPDEF TO THEN STRING SLASH_DOT SLASH SEMI RPAREN RBRACK RBRACE PLUS_DOT PLUS PIPE NL MOD MINUS_DOT MINUS LPAREN LOR LESS_LESS LESS_GREATER LESS_EQUAL LESS LBRACK LAND INT IN IDENT GREATER_EQUAL GREATER FLOAT EXTERNAL EXCL EXCEPTION EQUAL EOF END ELSE DOL DO CONS COMMA CHAR BOOL ATOM AST_DOT AST AND
follow(sigdef) = error TYPE TOPVAR TOPDEF NL EXTERNAL EXCEPTION EQUAL EOF AND
follow(segment) = GREATER_GREATER COMMA
follow(rev_type_params) = RPAREN
follow(rev_type_expr_tuple_tail) = error UIDENT TYPE TOPVAR TOPDEF RPAREN RBRACE RARROW PIPE NL IDENT EXTERNAL EXCEPTION EQUAL EOF COMMA AST AND
follow(rev_type_constr_params) = RPAREN COMMA
follow(rev_tuple_pattern) = RPAREN COMMA
follow(rev_tuple) = RPAREN COMMA
follow(rev_stmts) = error WITH UIDENT UARROW TYPE TOPVAR TOPDEF TO THEN STRING SLASH_DOT SLASH SEMI RPAREN RBRACK RBRACE PLUS_DOT PLUS PIPE NL MOD MINUS_DOT MINUS LPAREN LOR LESS_LESS LESS_GREATER LESS_EQUAL LESS LBRACK LAND INT IN IDENT GREATER_EQUAL GREATER FLOAT EXTERNAL EXCL EXCEPTION EQUAL EOF END ELSE DOL DO CONS COMMA CHAR BOOL ATOM AST_DOT AST AND
follow(rev_pattern_matching_elts) = PIPE END
follow(rev_pattern_matching) = END
follow(rev_mutual_fundefs) = error TYPE TOPVAR TOPDEF NL EXTERNAL EXCEPTION EOF AND
follow(rev_module_path) = UIDENT IDENT
follow(rev_list_pattern_elts) = RBRACK PIPE COMMA
follow(rev_list_elts) = RBRACK PIPE COMMA
follow(rev_formal_args) = UIDENT STRING RARROW LPAREN LBRACK LBRACE INT IDENT FLOAT EQUAL BOOL ATOM
follow(rev_field_patterns) = RBRACE COMMA
follow(rev_field_decls) = RBRACE NL COMMA
follow(rev_definitions) = error TYPE TOPVAR TOPDEF NL EXTERNAL EXCEPTION EOF AND
follow(rev_constr_path) = IDENT DOT
follow(rev_constr_decls) = error TYPE TOPVAR TOPDEF PIPE NL EXTERNAL EXCEPTION EOF AND
follow(rev_bitstring) = GREATER_GREATER COMMA
follow(rev_bits_spec_list) = MINUS GREATER_GREATER COMMA
follow(prog) = #
follow(primary) = error WITH UIDENT UARROW TYPE TOPVAR TOPDEF TO THEN STRING SLASH_DOT SLASH SEMI RPAREN RBRACK RBRACE PLUS_DOT PLUS PIPE NL MOD MINUS_DOT MINUS LPAREN LOR LESS_LESS LESS_GREATER LESS_EQUAL LESS LBRACK LAND INT IN IDENT GREATER_EQUAL GREATER FLOAT EXTERNAL EXCL EXCEPTION EQUAL EOF END ELSE DOT DOL DO CONS COMMA CHAR BOOL ATOM AST_DOT AST AND
follow(pattern_matching_elt) = PIPE END
follow(pattern_matching) = END
follow(pattern) = UIDENT STRING RPAREN RBRACK RBRACE RARROW PIPE LPAREN LBRACK LBRACE INT IDENT FLOAT EQUAL CONS COMMA COLON BOOL ATOM AS
follow(nl_opt) = error WITH VAR UIDENT TYPE TRY TOPVAR TOPDEF STRING RETURN RECEIVE RBRACE RAISE QIDENT PIPE PERFORM NOT NL MINUS MATCH LPAREN LESS_LESS LBRACK LBRACE INT IF IDENT FUN FOR FLOAT EXTERNAL EXCL EXCEPTION EOF ELSE DO DEF CHAR BOOL ATOM ASSERT AND
follow(mutual_fundefs_opt) = error TYPE TOPVAR TOPDEF NL EXTERNAL EXCEPTION EOF AND
follow(mutual_fundef) = error TYPE TOPVAR TOPDEF NL EXTERNAL EXCEPTION EOF AND
follow(multi_exps_block) = END ELSE
follow(module_path) = error WITH UIDENT UARROW TYPE TOPVAR TOPDEF TO THEN STRING SLASH_DOT SLASH SEMI RPAREN RBRACK RBRACE PLUS_DOT PLUS PIPE NL MOD MINUS_DOT MINUS LPAREN LOR LESS_LESS LESS_GREATER LESS_EQUAL LESS LBRACK LARROW LAND INT IN IDENT GREATER_EQUAL GREATER FLOAT EXTERNAL EXCL EXCEPTION EQUAL EOF END ELSE DOT DOL DO CONS COMMA CHAR BOOL ATOM AST_DOT AST ASSIGN AND
follow(list_pattern) = RBRACK PIPE
follow(list_) = RBRACK PIPE
follow(if_exp) = error WITH UIDENT UARROW TYPE TOPVAR TOPDEF TO THEN STRING SLASH_DOT SLASH SEMI RPAREN RBRACK RBRACE PLUS_DOT PLUS PIPE NL MOD MINUS_DOT MINUS LPAREN LOR LESS_LESS LESS_GREATER LESS_EQUAL LESS LBRACK LAND INT IN IDENT GREATER_EQUAL GREATER FLOAT EXTERNAL EXCL EXCEPTION EQUAL EOF END ELSE DOL DO CONS COMMA CHAR BOOL ATOM AST_DOT AST AND
follow(fundef) = error TYPE TOPVAR TOPDEF NL IN EXTERNAL EXCEPTION EOF AND
follow(formal_arg) = UIDENT STRING RARROW LPAREN LBRACK LBRACE INT IDENT FLOAT EQUAL BOOL ATOM
follow(fields_tail) = RBRACE
follow(fields) = RBRACE
follow(field_patterns) = RBRACE
follow(field_pattern) = RBRACE COMMA
follow(field_expr) = error WITH UIDENT UARROW TYPE TOPVAR TOPDEF TO THEN STRING SLASH_DOT SLASH SEMI RPAREN RBRACK RBRACE PLUS_DOT PLUS PIPE NL MOD MINUS_DOT MINUS LPAREN LOR LESS_LESS LESS_GREATER LESS_EQUAL LESS LBRACK LARROW LAND INT IN IDENT GREATER_EQUAL GREATER FLOAT EXTERNAL EXCL EXCEPTION EQUAL EOF END ELSE DOL DO CONS COMMA CHAR BOOL ATOM AST_DOT AST ASSIGN AND
follow(field_decls) = RBRACE
follow(field_decl) = RBRACE NL COMMA
follow(field) = SEMI RBRACE
follow(ext_sigdef) = error TYPE TOPVAR TOPDEF NL EXTERNAL EXCEPTION EOF AND
follow(expr) = error WITH UIDENT UARROW TYPE TOPVAR TOPDEF TO THEN STRING SLASH_DOT SLASH SEMI RPAREN RBRACK RBRACE PLUS_DOT PLUS PIPE NL MOD MINUS_DOT MINUS LPAREN LOR LESS_LESS LESS_GREATER LESS_EQUAL LESS LBRACK LAND INT IN IDENT GREATER_EQUAL GREATER FLOAT EXTERNAL EXCL EXCEPTION EQUAL EOF END ELSE DOL DO CONS COMMA CHAR BOOL ATOM AST_DOT AST AND
follow(do_block) = error WITH UIDENT UARROW TYPE TOPVAR TOPDEF TO THEN STRING SLASH_DOT SLASH SEMI RPAREN RBRACK RBRACE PLUS_DOT PLUS PIPE NL MOD MINUS_DOT MINUS LPAREN LOR LESS_LESS LESS_GREATER LESS_EQUAL LESS LBRACK LAND INT IN IDENT GREATER_EQUAL GREATER FLOAT EXTERNAL EXCL EXCEPTION EQUAL EOF END ELSE DOL DO CONS COMMA CHAR BOOL ATOM AST_DOT AST AND
follow(definitions) = EOF
follow(definition) = error TYPE TOPVAR TOPDEF NL EXTERNAL EXCEPTION EOF AND
follow(constr_name) = UIDENT STRING RPAREN RBRACK RBRACE RARROW PIPE LPAREN LBRACK LBRACE INT IDENT FLOAT EQUAL CONS COMMA COLON BOOL ATOM AS
follow(constr_decls) = error TYPE TOPVAR TOPDEF NL EXTERNAL EXCEPTION EOF AND
follow(constr_decl_type) = error TYPE TOPVAR TOPDEF PIPE NL EXTERNAL EXCEPTION EOF AND
follow(constr_decl) = error TYPE TOPVAR TOPDEF PIPE NL EXTERNAL EXCEPTION EOF AND
follow(constr) = error UIDENT TYPE TOPVAR TOPDEF RPAREN RBRACE RARROW PIPE NL IDENT EXTERNAL EXCEPTION EQUAL EOF COMMA AST AND
follow(block) = error WITH UIDENT UARROW TYPE TOPVAR TOPDEF TO THEN STRING SLASH_DOT SLASH SEMI RPAREN RBRACK RBRACE PLUS_DOT PLUS PIPE NL MOD MINUS_DOT MINUS LPAREN LOR LESS_LESS LESS_GREATER LESS_EQUAL LESS LBRACK LAND INT IN IDENT GREATER_EQUAL GREATER FLOAT EXTERNAL EXCL EXCEPTION EQUAL EOF END ELSE DOL DO CONS COMMA CHAR BOOL ATOM AST_DOT AST AND
follow(bitstring) = GREATER_GREATER
follow(bits_value) = SLASH GREATER_GREATER COMMA COLON
follow(bits_spec_list) = GREATER_GREATER COMMA
follow(bits_spec) = MINUS GREATER_GREATER COMMA
follow(binding) = error WITH UIDENT UARROW TYPE TOPVAR TOPDEF TO THEN STRING SLASH_DOT SLASH SEMI RPAREN RBRACK RBRACE PLUS_DOT PLUS PIPE NL MOD MINUS_DOT MINUS LPAREN LOR LESS_LESS LESS_GREATER LESS_EQUAL LESS LBRACK LARROW LAND INT IN IDENT GREATER_EQUAL GREATER FLOAT EXTERNAL EXCL EXCEPTION EQUAL EOF END ELSE DOT DOL DO CONS COMMA CHAR BOOL ATOM AST_DOT AST ASSIGN AND
follow(array_expr) = error WITH UIDENT UARROW TYPE TOPVAR TOPDEF TO THEN STRING SLASH_DOT SLASH SEMI RPAREN RBRACK RBRACE PLUS_DOT PLUS PIPE NL MOD MINUS_DOT MINUS LPAREN LOR LESS_LESS LESS_GREATER LESS_EQUAL LESS LBRACK LARROW LAND INT IN IDENT GREATER_EQUAL GREATER FLOAT EXTERNAL EXCL EXCEPTION EQUAL EOF END ELSE DOL DO CONS COMMA CHAR BOOL ATOM AST_DOT AST AND
follow(actual_args) = error WITH UIDENT UARROW TYPE TOPVAR TOPDEF TO THEN STRING SLASH_DOT SLASH SEMI RPAREN RBRACK RBRACE PLUS_DOT PLUS PIPE NL MOD MINUS_DOT MINUS LPAREN LOR LESS_LESS LESS_GREATER LESS_EQUAL LESS LBRACK LAND INT IN IDENT GREATER_EQUAL GREATER FLOAT EXTERNAL EXCL EXCEPTION EQUAL EOF END ELSE DOL DO CONS COMMA CHAR BOOL ATOM AST_DOT AST AND
Built an LR(0) automaton with 457 states.
The grammar is not SLR(1) -- 84 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 697 states.
2098 shift/reduce conflicts were silently solved.
203 out of 697 states have a default reduction.
373 out of 697 states are represented.
1 out of 158 symbols keep track of their start position.
1 out of 158 symbols keep track of their end position.
109 out of 234 productions exploit shiftreduce optimization.
188 out of 697 states can peek at an error.
The generated parser cannot raise Error.
1712 functions before inlining, 374 functions after inlining.
