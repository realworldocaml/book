Grammar has 78 nonterminal symbols, among which 2 start symbols.
Grammar has 54 terminal symbols.
Grammar has 186 productions.
nullable(variant) = false
nullable(upperName_aux) = false
nullable(upperName) = false
nullable(typeExprUnclosed) = false
nullable(typeExprStrictlyUnclosed) = false
nullable(typeExprProtectedPermissive) = false
nullable(typeExprNonStrictlyUnclosed) = false
nullable(typeExprClosed) = false
nullable(typeExpr) = false
nullable(typeAlias) = false
nullable(tyclassInstance) = false
nullable(tyclassAppArg) = false
nullable(tyclass) = false
nullable(tyAppAux) = false
nullable(tyApp) = false
nullable(termUnclosed) = false
nullable(termStrictlyUnclosed) = false
nullable(termProtectedPermissive) = false
nullable(termNonStrictlyUnclosed) = false
nullable(termClosed) = false
nullable(term) = false
nullable(sum) = true
nullable(separated_nonempty_list(Pipe,variant)) = false
nullable(separated_nonempty_list(Pipe,typeExpr)) = false
nullable(separated_nonempty_list(Pipe,pattern)) = false
nullable(separated_nonempty_list(Comma,typeExpr)) = false
nullable(pattern) = false
nullable(patUnclosed) = false
nullable(patStrictlyUnclosed) = false
nullable(patProtectedPermissive) = false
nullable(patNonStrictlyUnclosed) = false
nullable(patClosed) = false
nullable(pat) = false
nullable(option(Pipe)) = true
nullable(nonempty_list(typeExprClosed)) = false
nullable(nonempty_list(patClosed)) = false
nullable(nonempty_list(let_case)) = false
nullable(nonempty_list(letSig)) = false
nullable(nonempty_list(kind_and_name)) = false
nullable(nonempty_args(lambda_aux)) = false
nullable(newUpperName) = false
nullable(mainInterface) = false
nullable(main) = false
nullable(lowerName_aux) = false
nullable(lowerName) = false
nullable(loption(separated_nonempty_list(Pipe,typeExpr))) = true
nullable(loption(separated_nonempty_list(Comma,typeExpr))) = true
nullable(list(typeExprClosed)) = true
nullable(list(kind_and_name_in_value)) = true
nullable(list(kind_and_name)) = true
nullable(list(import)) = true
nullable(let_case) = false
nullable(let_aux) = false
nullable(letSig) = false
nullable(lambda_aux) = false
nullable(kindopt) = true
nullable(kind_and_name_in_value) = false
nullable(kind_and_name) = false
nullable(kindUnclosed) = false
nullable(kindClosed) = false
nullable(kind) = false
nullable(instanceName) = true
nullable(import_module) = false
nullable(import) = false
nullable(exceptionArgs) = true
nullable(entry(bodyInterface)) = false
nullable(entry(body)) = false
nullable(eff) = true
nullable(datatype) = false
nullable(body_list(bodyInterface)) = false
nullable(body_list(body)) = false
nullable(bodyInterface) = false
nullable(body) = false
nullable(args(let_aux)) = false
nullable(args(lambda_aux)) = false
nullable(arg) = false
nullable(appAux) = false
nullable(app) = false
first(variant) = UpperName
first(upperName_aux) = UpperName
first(upperName) = UpperName
first(typeExprUnclosed) = UpperName Underscore LowerName Lambda LParen LBracketUp LBracket LBrace Forall
first(typeExprStrictlyUnclosed) = UpperName Underscore LowerName Lambda LParen LBracketUp LBracket LBrace Forall
first(typeExprProtectedPermissive) = UpperName Underscore LowerName LParen LBracketUp LBracket
first(typeExprNonStrictlyUnclosed) = UpperName Underscore LowerName LParen LBracketUp LBracket
first(typeExprClosed) = UpperName Underscore LowerName LParen LBracketUp LBracket
first(typeExpr) = UpperName Underscore LowerName Lambda LParen LBracketUp LBracket LBrace Forall
first(typeAlias) = Type
first(tyclassInstance) = UpperName
first(tyclassAppArg) = UpperName LowerName
first(tyclass) = UpperName
first(tyAppAux) = UpperName Underscore LowerName LParen LBracketUp LBracket
first(tyApp) = UpperName Underscore LowerName LParen LBracketUp LBracket
first(termUnclosed) = UpperName Try String Match LowerName Let Lambda LParen Int Float Fail Char
first(termStrictlyUnclosed) = UpperName Try String Match LowerName Let Lambda LParen Int Float Fail Char
first(termProtectedPermissive) = UpperName Try String Match LowerName LParen Int Float Fail Char
first(termNonStrictlyUnclosed) = UpperName Try String Match LowerName LParen Int Float Fail Char
first(termClosed) = UpperName Try String Match LowerName LParen Int Float Char
first(term) = UpperName Try String Match LowerName Let Lambda LParen Int Float Fail Char
first(sum) = UpperName Underscore LowerName Lambda LParen LBracketUp LBracket LBrace Forall
first(separated_nonempty_list(Pipe,variant)) = UpperName
first(separated_nonempty_list(Pipe,typeExpr)) = UpperName Underscore LowerName Lambda LParen LBracketUp LBracket LBrace Forall
first(separated_nonempty_list(Pipe,pattern)) = UpperName Underscore LowerName LParen
first(separated_nonempty_list(Comma,typeExpr)) = UpperName Underscore LowerName Lambda LParen LBracketUp LBracket LBrace Forall
first(pattern) = UpperName Underscore LowerName LParen
first(patUnclosed) = UpperName Underscore LowerName LParen
first(patStrictlyUnclosed) = UpperName Underscore LowerName LParen
first(patProtectedPermissive) = UpperName Underscore LowerName LParen
first(patNonStrictlyUnclosed) = UpperName Underscore LowerName LParen
first(patClosed) = UpperName Underscore LowerName LParen
first(pat) = UpperName Underscore LowerName LParen
first(option(Pipe)) = Pipe
first(nonempty_list(typeExprClosed)) = UpperName Underscore LowerName LParen LBracketUp LBracket
first(nonempty_list(patClosed)) = UpperName Underscore LowerName LParen
first(nonempty_list(let_case)) = Let
first(nonempty_list(letSig)) = Let
first(nonempty_list(kind_and_name)) = Underscore LowerName LParen
first(nonempty_args(lambda_aux)) = LQMarkParen LParen LBrace
first(newUpperName) = UpperName
first(mainInterface) = Type Open Let Instance Import Exception EOF Class
first(main) = Type Open Let Instance Import Foreign Exception EOF Class
first(lowerName_aux) = UpperName LowerName
first(lowerName) = UpperName LowerName
first(loption(separated_nonempty_list(Pipe,typeExpr))) = UpperName Underscore LowerName Lambda LParen LBracketUp LBracket LBrace Forall
first(loption(separated_nonempty_list(Comma,typeExpr))) = UpperName Underscore LowerName Lambda LParen LBracketUp LBracket LBrace Forall
first(list(typeExprClosed)) = UpperName Underscore LowerName LParen LBracketUp LBracket
first(list(kind_and_name_in_value)) = LBrace
first(list(kind_and_name)) = Underscore LowerName LParen
first(list(import)) = Import
first(let_case) = Let
first(let_aux) = Equal Colon
first(letSig) = Let
first(lambda_aux) = Colon Arrow
first(kindopt) = Colon
first(kind_and_name_in_value) = LBrace
first(kind_and_name) = Underscore LowerName LParen
first(kindUnclosed) = Star LParen Eff Caret
first(kindClosed) = Star LParen Eff Caret
first(kind) = Star LParen Eff Caret
first(instanceName) = LBracket
first(import_module) = UpperName Library
first(import) = Import
first(exceptionArgs) = UpperName Underscore LowerName LParen LBracketUp LBracket
first(entry(bodyInterface)) = Type Open Let Instance Import Exception EOF Class
first(entry(body)) = Type Open Let Instance Import Foreign Exception EOF Class
first(eff) = UpperName Underscore LowerName Lambda LParen LBracketUp LBracket LBrace Forall
first(datatype) = Type
first(body_list(bodyInterface)) = Type Open Let Instance Exception EOF Class
first(body_list(body)) = Type Open Let Instance Foreign Exception EOF Class
first(bodyInterface) = Type Open Let Instance Exception Class
first(body) = Type Open Let Instance Foreign Exception Class
first(args(let_aux)) = LQMarkParen LParen LBrace Equal Colon
first(args(lambda_aux)) = LQMarkParen LParen LBrace Colon Arrow
first(arg) = LQMarkParen LParen LBrace
first(appAux) = UpperName Try String Match LowerName LParen Int Float Char
first(app) = UpperName Try String Match LowerName LParen Int Float Char
minimal(variant) = (* 1 *) UpperName
minimal(upperName_aux) = (* 1 *) UpperName
minimal(upperName) = (* 1 *) UpperName
minimal(typeExprUnclosed) = (* 2 *) UpperName UpperName
minimal(typeExprStrictlyUnclosed) = (* 3 *) UpperName Arrow UpperName
minimal(typeExprProtectedPermissive) = (* 1 *) UpperName
minimal(typeExprNonStrictlyUnclosed) = (* 2 *) UpperName UpperName
minimal(typeExprClosed) = (* 1 *) UpperName
minimal(typeExpr) = (* 1 *) UpperName
minimal(typeAlias) = (* 5 *) Type Alias UpperName Equal UpperName
minimal(tyclassInstance) = (* 2 *) UpperName UpperName
minimal(tyclassAppArg) = (* 1 *) LowerName
minimal(tyclass) = (* 2 *) UpperName UpperName
minimal(tyAppAux) = (* 1 *) UpperName
minimal(tyApp) = (* 2 *) UpperName UpperName
minimal(termUnclosed) = (* 2 *) LowerName LowerName
minimal(termStrictlyUnclosed) = (* 3 *) LowerName Semicolon LowerName
minimal(termProtectedPermissive) = (* 1 *) LowerName
minimal(termNonStrictlyUnclosed) = (* 2 *) LowerName LowerName
minimal(termClosed) = (* 1 *) LowerName
minimal(term) = (* 1 *) LowerName
minimal(sum) = (* 0 *) 
minimal(separated_nonempty_list(Pipe,variant)) = (* 1 *) UpperName
minimal(separated_nonempty_list(Pipe,typeExpr)) = (* 1 *) UpperName
minimal(separated_nonempty_list(Pipe,pattern)) = (* 3 *) LowerName Arrow LowerName
minimal(separated_nonempty_list(Comma,typeExpr)) = (* 1 *) UpperName
minimal(pattern) = (* 3 *) LowerName Arrow LowerName
minimal(patUnclosed) = (* 2 *) UpperName LowerName
minimal(patStrictlyUnclosed) = (* 3 *) LowerName Pipe LowerName
minimal(patProtectedPermissive) = (* 1 *) LowerName
minimal(patNonStrictlyUnclosed) = (* 2 *) UpperName LowerName
minimal(patClosed) = (* 1 *) LowerName
minimal(pat) = (* 1 *) LowerName
minimal(option(Pipe)) = (* 0 *) 
minimal(nonempty_list(typeExprClosed)) = (* 1 *) UpperName
minimal(nonempty_list(patClosed)) = (* 1 *) LowerName
minimal(nonempty_list(let_case)) = (* 4 *) Let LowerName Equal LowerName
minimal(nonempty_list(letSig)) = (* 4 *) Let LowerName Colon UpperName
minimal(nonempty_list(kind_and_name)) = (* 1 *) LowerName
minimal(nonempty_args(lambda_aux)) = (* 4 *) LParen RParen Arrow LowerName
minimal(newUpperName) = (* 1 *) UpperName
minimal(mainInterface) = (* 1 *) EOF
minimal(main) = (* 1 *) EOF
minimal(lowerName_aux) = (* 1 *) LowerName
minimal(lowerName) = (* 1 *) LowerName
minimal(loption(separated_nonempty_list(Pipe,typeExpr))) = (* 0 *) 
minimal(loption(separated_nonempty_list(Comma,typeExpr))) = (* 0 *) 
minimal(list(typeExprClosed)) = (* 0 *) 
minimal(list(kind_and_name_in_value)) = (* 0 *) 
minimal(list(kind_and_name)) = (* 0 *) 
minimal(list(import)) = (* 0 *) 
minimal(let_case) = (* 4 *) Let LowerName Equal LowerName
minimal(let_aux) = (* 2 *) Equal LowerName
minimal(letSig) = (* 4 *) Let LowerName Colon UpperName
minimal(lambda_aux) = (* 2 *) Arrow LowerName
minimal(kindopt) = (* 0 *) 
minimal(kind_and_name_in_value) = (* 3 *) LBrace LowerName RBrace
minimal(kind_and_name) = (* 1 *) LowerName
minimal(kindUnclosed) = (* 3 *) Star Arrow Star
minimal(kindClosed) = (* 1 *) Star
minimal(kind) = (* 1 *) Star
minimal(instanceName) = (* 0 *) 
minimal(import_module) = (* 1 *) UpperName
minimal(import) = (* 2 *) Import UpperName
minimal(exceptionArgs) = (* 0 *) 
minimal(entry(bodyInterface)) = (* 1 *) EOF
minimal(entry(body)) = (* 1 *) EOF
minimal(eff) = (* 0 *) 
minimal(datatype) = (* 4 *) Type UpperName Equal UpperName
minimal(body_list(bodyInterface)) = (* 1 *) EOF
minimal(body_list(body)) = (* 1 *) EOF
minimal(bodyInterface) = (* 2 *) Type UpperName
minimal(body) = (* 2 *) Type UpperName
minimal(args(let_aux)) = (* 2 *) Equal LowerName
minimal(args(lambda_aux)) = (* 2 *) Arrow LowerName
minimal(arg) = (* 2 *) LParen RParen
minimal(appAux) = (* 1 *) LowerName
minimal(app) = (* 2 *) LowerName LowerName
follow(variant) = Type Pipe Open Let Instance Foreign Exception EOF Class
follow(upperName_aux) = With UpperName Underscore Type Try String Semicolon RParen RDoubleArrowEff RBracketUp RBracket RBrace RArrowEff Pipe Open Match LowerName Let LQMarkBracket LParen LBracketUp LBracket LBrace LArrowEff Int Instance In Import Hash Foreign Float Exception Equal End EOF Comma Colon Class Char As Arrow
follow(upperName) = With UpperName Underscore Type Try String Semicolon RParen RDoubleArrowEff RBracketUp RBracket RBrace RArrowEff Pipe Open Match LowerName Let LQMarkBracket LParen LBracketUp LBracket LBrace LArrowEff Int Instance In Import Hash Foreign Float Exception Equal End EOF Comma Colon Class Char As Arrow
follow(typeExprUnclosed) = With Type RParen RDoubleArrowEff RBracketUp RBracket RArrowEff Pipe Open Let Instance In Hash Foreign Exception Equal End EOF Comma Class
follow(typeExprStrictlyUnclosed) = With Type RParen RDoubleArrowEff RBracketUp RBracket RArrowEff Pipe Open Let Instance In Hash Foreign Exception Equal End EOF Comma Class
follow(typeExprProtectedPermissive) = LArrowEff Hash Arrow
follow(typeExprNonStrictlyUnclosed) = With Type RParen RDoubleArrowEff RBracketUp RBracket RArrowEff Pipe Open Let LArrowEff Instance In Hash Foreign Exception Equal End EOF Comma Class Arrow
follow(typeExprClosed) = With UpperName Underscore Type RParen RDoubleArrowEff RBracketUp RBracket RBrace RArrowEff Pipe Open LowerName Let LParen LBracketUp LBracket LArrowEff Instance In Hash Foreign Exception Equal End EOF Comma Class Arrow
follow(typeExpr) = With Type RParen RDoubleArrowEff RBracketUp RBracket RArrowEff Pipe Open Let Instance In Hash Foreign Exception Equal End EOF Comma Class
follow(typeAlias) = Type Open Let Instance Foreign Exception EOF Class
follow(tyclassInstance) = Type RBracket Open Let Instance Exception Equal EOF Class
follow(tyclassAppArg) = RBracket
follow(tyclass) = RParen RBrace
follow(tyAppAux) = UpperName Underscore LowerName LParen LBracketUp LBracket
follow(tyApp) = With UpperName Underscore Type RParen RDoubleArrowEff RBracketUp RBracket RArrowEff Pipe Open LowerName Let LParen LBracketUp LBracket LArrowEff Instance In Hash Foreign Exception Equal End EOF Comma Class Arrow
follow(termUnclosed) = With Type RParen Pipe Open Let Instance In Foreign Exception End EOF Class
follow(termStrictlyUnclosed) = With Type RParen Pipe Open Let Instance In Foreign Exception End EOF Class
follow(termProtectedPermissive) = Semicolon Colon
follow(termNonStrictlyUnclosed) = With Type Semicolon RParen Pipe Open Let Instance In Foreign Exception End EOF Colon Class
follow(termClosed) = With UpperName Type Try String Semicolon RParen Pipe Open Match LowerName Let LQMarkBracket LParen LBracket Int Instance In Foreign Float Exception End EOF Colon Class Char
follow(term) = With Type RParen Pipe Open Let Instance In Foreign Exception End EOF Class
follow(sum) = RBracketUp
follow(separated_nonempty_list(Pipe,variant)) = Type Open Let Instance Foreign Exception EOF Class
follow(separated_nonempty_list(Pipe,typeExpr)) = RBracketUp
follow(separated_nonempty_list(Pipe,pattern)) = End
follow(separated_nonempty_list(Comma,typeExpr)) = RDoubleArrowEff RBracket RArrowEff
follow(pattern) = Pipe End
follow(patUnclosed) = RParen Arrow
follow(patStrictlyUnclosed) = RParen Arrow
follow(patProtectedPermissive) = Pipe As
follow(patNonStrictlyUnclosed) = RParen Pipe As Arrow
follow(patClosed) = UpperName Underscore RParen Pipe LowerName LParen As Arrow
follow(pat) = RParen Arrow
follow(option(Pipe)) = UpperName Underscore LowerName LParen
follow(nonempty_list(typeExprClosed)) = Type RParen RBracket RBrace Open Let Instance Exception Equal EOF Class
follow(nonempty_list(patClosed)) = RParen Pipe As Arrow
follow(nonempty_list(let_case)) = End
follow(nonempty_list(letSig)) = End
follow(nonempty_list(kind_and_name)) = Equal Comma
follow(nonempty_args(lambda_aux)) = With Type RParen Pipe Open Let Instance In Foreign Exception End EOF Class
follow(newUpperName) = UpperName Underscore Type Pipe Open LowerName Let LParen LBracketUp LBracket Instance Foreign Exception Equal EOF Colon Class
follow(mainInterface) = #
follow(main) = #
follow(lowerName_aux) = With UpperName Type Try String Semicolon RParen RBracket Pipe Open Match LowerName Let LQMarkBracket LParen LBracket Int Instance In Foreign Float Exception End EOF Colon Class Char
follow(lowerName) = With UpperName Type Try String Semicolon RParen RBracket Pipe Open Match LowerName Let LQMarkBracket LParen LBracket Int Instance In Foreign Float Exception End EOF Colon Class Char
follow(loption(separated_nonempty_list(Pipe,typeExpr))) = RBracketUp
follow(loption(separated_nonempty_list(Comma,typeExpr))) = RDoubleArrowEff RBracket RArrowEff
follow(list(typeExprClosed)) = Type Pipe Open Let Instance Foreign Exception EOF Class
follow(list(kind_and_name_in_value)) = UpperName Underscore LowerName LParen LBracketUp LBracket
follow(list(kind_and_name)) = Equal
follow(list(import)) = Type Open Let Instance Foreign Exception EOF Class
follow(let_case) = Type Open Let Instance In Foreign Exception End EOF Class
follow(let_aux) = Type Open Let Instance In Foreign Exception End EOF Class
follow(letSig) = Type Open Let Instance Exception End EOF Class
follow(lambda_aux) = With Type RParen Pipe Open Let Instance In Foreign Exception End EOF Class
follow(kindopt) = Type Open Let Instance Foreign Exception EOF Class
follow(kind_and_name_in_value) = UpperName Underscore LowerName LQMarkParen LParen LBracketUp LBracket LBrace Equal Colon Arrow
follow(kind_and_name) = Underscore LowerName LParen Equal Comma
follow(kindUnclosed) = Type RParen RBrace Open Let Instance Foreign Exception EOF Class
follow(kindClosed) = Type RParen RBrace Open Let Instance Foreign Exception EOF Class Arrow
follow(kind) = Type RParen RBrace Open Let Instance Foreign Exception EOF Class
follow(instanceName) = UpperName
follow(import_module) = Type Open Let Instance Import Foreign Exception EOF Class
follow(import) = Type Open Let Instance Import Foreign Exception EOF Class
follow(exceptionArgs) = Type Open Let Instance Foreign Exception EOF Class
follow(entry(bodyInterface)) = #
follow(entry(body)) = #
follow(eff) = RDoubleArrowEff RBracket RArrowEff
follow(datatype) = Type Open Let Instance Foreign Exception EOF Class
follow(body_list(bodyInterface)) = #
follow(body_list(body)) = #
follow(bodyInterface) = Type Open Let Instance Exception EOF Class
follow(body) = Type Open Let Instance Foreign Exception EOF Class
follow(args(let_aux)) = Type Open Let Instance In Foreign Exception End EOF Class
follow(args(lambda_aux)) = With Type RParen Pipe Open Let Instance In Foreign Exception End EOF Class
follow(arg) = LQMarkParen LParen LBrace Equal Colon Arrow
follow(appAux) = UpperName Try String Match LowerName LQMarkBracket LParen LBracket Int Float Char
follow(app) = With UpperName Type Try String Semicolon RParen Pipe Open Match LowerName Let LQMarkBracket LParen LBracket Int Instance In Foreign Float Exception End EOF Colon Class Char
Built an LR(0) automaton with 357 states.
The grammar is not SLR(1) -- 3 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 357 states.
149 out of 357 states have a default reduction.
121 out of 357 states are represented.
44 out of 136 symbols keep track of their start position.
44 out of 136 symbols keep track of their end position.
104 out of 188 productions exploit shiftreduce optimization.
0 out of 357 states can peek at an error.
987 functions before inlining, 136 functions after inlining.
