File "jocaml.mly", line 257, characters 7-16:
Warning: the token BARRBRACE is unused.
File "jocaml.mly", line 256, characters 7-16:
Warning: the token LBRACEBAR is unused.
File "jocaml.mly", line 258, characters 7-29:
Warning: the token LESSLESSGREATERGREATER is unused.
File "jocaml.mly", line 291, characters 6-15:
Warning: the token prec_expr is unused.
File "jocaml.mly", line 292, characters 6-15:
Warning: the token prec_proc is unused.
File "jocaml.mly", line 718, characters 0-14:
Warning: symbol def_parameters is unreachable from any of the start symbol(s).
Grammar has 134 nonterminal symbols, among which 4 start symbols.
Grammar has 111 terminal symbols.
Grammar has 498 productions.
nullable(with_constraints) = false
nullable(with_constraint) = false
nullable(virtual_method) = false
nullable(virtual_flag) = true
nullable(value_type) = false
nullable(value) = false
nullable(val_longident) = false
nullable(val_ident) = false
nullable(use_file_tail) = false
nullable(use_file) = false
nullable(type_parameters) = true
nullable(type_parameter_list) = false
nullable(type_parameter) = false
nullable(type_longident) = false
nullable(type_list) = false
nullable(type_kind) = true
nullable(type_declarations) = false
nullable(type_declaration) = false
nullable(type_constraint) = false
nullable(toplevel_phrase) = false
nullable(toplevel_directive) = false
nullable(top_structure) = false
nullable(to_ident) = true
nullable(tag_constructor_declarations) = false
nullable(tag_constructor_declaration) = false
nullable(structure_tail) = true
nullable(structure_item) = false
nullable(structure) = true
nullable(stream_pattern_component) = false
nullable(stream_pattern) = false
nullable(stream_expr_component) = false
nullable(stream_expr) = false
nullable(simple_pattern_list) = false
nullable(simple_pattern) = false
nullable(simple_expr_list) = false
nullable(simple_expr) = false
nullable(simple_def_binding) = false
nullable(simple_core_type) = false
nullable(simple_chan_expr) = false
nullable(signed_constant) = false
nullable(signature_item) = false
nullable(signature) = true
nullable(seq_expr) = false
nullable(self_type) = true
nullable(self) = true
nullable(rec_flag) = true
nullable(protected_flag) = true
nullable(process0) = false
nullable(process) = true
nullable(proc_expr) = false
nullable(private_flag) = true
nullable(primitive_declaration) = false
nullable(pattern_semi_list) = false
nullable(pattern_comma_list) = false
nullable(pattern) = false
nullable(parser_cases) = false
nullable(parser_case) = false
nullable(opt_semi) = true
nullable(opt_pat) = true
nullable(opt_err) = true
nullable(opt_bar) = true
nullable(operator) = false
nullable(mutable_flag) = true
nullable(mty_longident) = false
nullable(module_type) = false
nullable(module_expr) = false
nullable(module_declaration) = false
nullable(module_binding) = false
nullable(mod_longident) = false
nullable(mod_ext_longident) = false
nullable(method_type) = false
nullable(method_def) = false
nullable(meth_list) = false
nullable(meth_binding) = false
nullable(match_cases) = false
nullable(match_action) = false
nullable(loc_modules) = true
nullable(loc_init) = true
nullable(loc_defs) = true
nullable(loc_bindings) = false
nullable(loc_binding) = false
nullable(list_of_modules) = false
nullable(lident_comma_list) = false
nullable(let_bindings) = false
nullable(let_binding) = false
nullable(lbl_pattern_list) = false
nullable(lbl_expr_list) = false
nullable(label_longident) = false
nullable(label_expr_list) = false
nullable(label_declarations) = false
nullable(label_declaration) = false
nullable(label) = false
nullable(join_pattern) = false
nullable(join_match_cases) = false
nullable(join_match_action) = false
nullable(interface) = false
nullable(implementation) = false
nullable(ident) = false
nullable(fun_def) = false
nullable(fun_binding) = false
nullable(field) = false
nullable(ext_constructor_arguments) = true
nullable(expr_semi_list) = false
nullable(expr_comma_list) = false
nullable(expr0) = false
nullable(expr) = false
nullable(direction_flag) = false
nullable(def_pattern) = false
nullable(def_bindings) = false
nullable(def_binding) = false
nullable(core_type_tuple) = false
nullable(core_type_list) = false
nullable(core_type_comma_list) = false
nullable(core_type) = false
nullable(constructor_declarations_ext) = false
nullable(constructor_declarations) = false
nullable(constructor_declaration) = false
nullable(constructor_arguments) = true
nullable(constraints) = true
nullable(constrain) = false
nullable(constr_longident) = false
nullable(constr_ident) = false
nullable(constant) = false
nullable(closed_flag) = true
nullable(class_type_parameters) = true
nullable(class_type_list) = false
nullable(class_type_fields) = true
nullable(class_type) = false
nullable(class_longident) = false
nullable(class_list) = false
nullable(class_fields) = true
nullable(class_def) = false
nullable(ancestor_type) = false
nullable(ancestor) = false
first(with_constraints) = TYPE MODULE
first(with_constraint) = TYPE MODULE
first(virtual_method) = VIRTUAL
first(virtual_flag) = VIRTUAL
first(value_type) = PRIVATE MUTABLE LIDENT
first(value) = PRIVATE MUTABLE LIDENT
first(val_longident) = UIDENT LPAREN LIDENT
first(val_ident) = LPAREN LIDENT
first(use_file_tail) = TYPE SHARP SEMISEMI OPEN MODULE LET EXTERNAL EXCEPTION EOF CLASS
first(use_file) = WHILE VARTYPE UIDENT TYPE TRY TRUE SUBTRACTIVE STRING SPAWN SHARP SEMISEMI RELOCINFO PREFIXOP PARSER OPEN NEW MODULE MATCH LPAREN LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION EOF CLASS CHAR BEGIN ASSERT
first(type_parameters) = QUOTE LPAREN
first(type_parameter_list) = QUOTE
first(type_parameter) = QUOTE
first(type_longident) = UIDENT LIDENT
first(type_list) = LPAREN
first(type_kind) = EQUAL
first(type_declarations) = QUOTE LPAREN LIDENT
first(type_declaration) = QUOTE LPAREN LIDENT
first(type_constraint) = COLONGREATER COLON
first(toplevel_phrase) = WHILE VARTYPE UIDENT TYPE TRY TRUE SUBTRACTIVE STRING SPAWN SHARP RELOCINFO PREFIXOP PARSER OPEN NEW MODULE MATCH LPAREN LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION EOF CLASS CHAR BEGIN ASSERT
first(toplevel_directive) = SHARP
first(top_structure) = TYPE OPEN MODULE LET EXTERNAL EXCEPTION CLASS
first(to_ident) = TO
first(tag_constructor_declarations) = UIDENT TRUE LPAREN LBRACKET FALSE COLONCOLON
first(tag_constructor_declaration) = UIDENT TRUE LPAREN LBRACKET FALSE COLONCOLON
first(structure_tail) = TYPE SEMISEMI OPEN MODULE LET EXTERNAL EXCEPTION CLASS
first(structure_item) = TYPE OPEN MODULE LET EXTERNAL EXCEPTION CLASS
first(structure) = WHILE VARTYPE UIDENT TYPE TRY TRUE SUBTRACTIVE STRING SPAWN SEMISEMI RELOCINFO PREFIXOP PARSER OPEN NEW MODULE MATCH LPAREN LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION CLASS CHAR BEGIN ASSERT
first(stream_pattern_component) = UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING QUOTE LPAREN LIDENT LBRACKET LBRACE INT FLOAT FALSE CHAR
first(stream_pattern) = UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING QUOTE LPAREN LIDENT LBRACKET LBRACE INT FLOAT FALSE CHAR
first(stream_expr_component) = WHILE VARTYPE UIDENT TRY TRUE SUBTRACTIVE STRING SPAWN RELOCINFO QUOTE PREFIXOP PARSER NEW MATCH LPAREN LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE CHAR BEGIN ASSERT
first(stream_expr) = WHILE VARTYPE UIDENT TRY TRUE SUBTRACTIVE STRING SPAWN RELOCINFO QUOTE PREFIXOP PARSER NEW MATCH LPAREN LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE CHAR BEGIN ASSERT
first(simple_pattern_list) = UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING LPAREN LIDENT LBRACKET LBRACE INT FLOAT FALSE CHAR
first(simple_pattern) = UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING LPAREN LIDENT LBRACKET LBRACE INT FLOAT FALSE CHAR
first(simple_expr_list) = VARTYPE UIDENT TRUE STRING RELOCINFO PREFIXOP NEW LPAREN LIDENT LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE INT FLOAT FALSE CHAR BEGIN
first(simple_expr) = VARTYPE UIDENT TRUE STRING RELOCINFO PREFIXOP NEW LPAREN LIDENT LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE INT FLOAT FALSE CHAR BEGIN
first(simple_def_binding) = UIDENT LIDENT
first(simple_core_type) = UNDERSCORE UIDENT SHARP QUOTE LPAREN LIDENT LESSLESS LESS
first(simple_chan_expr) = UIDENT STRING LPAREN LIDENT INT FLOAT CHAR BEGIN
first(signed_constant) = SUBTRACTIVE STRING INT FLOAT CHAR
first(signature_item) = VAL TYPE OPEN MODULE INCLUDE EXTERNAL EXCEPTION CLASS
first(signature) = VAL TYPE OPEN MODULE INCLUDE EXTERNAL EXCEPTION CLASS
first(seq_expr) = WHILE VARTYPE UIDENT TRY TRUE SUBTRACTIVE STRING SPAWN RELOCINFO PREFIXOP PARSER NEW MATCH LPAREN LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE CHAR BEGIN ASSERT
first(self_type) = COLON
first(self) = AS
first(rec_flag) = REC
first(protected_flag) = PROTECTED
first(process0) = UIDENT STRING REPLY MATCH LPAREN LOC LIDENT LBRACERBRACE LBRACE INT IF FLOAT CHAR BEGIN
first(process) = WHILE UIDENT STRING SPAWN REPLY MATCH LPAREN LOC LIDENT LET LBRACERBRACE LBRACE LAZY INT IF FOR FLOAT CHAR BEGIN ASSERT
first(proc_expr) = WHILE UIDENT STRING LPAREN LIDENT LAZY INT IF FOR FLOAT CHAR BEGIN ASSERT
first(private_flag) = PRIVATE
first(primitive_declaration) = STRING
first(pattern_semi_list) = UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING LPAREN LIDENT LBRACKET LBRACE INT FLOAT FALSE CHAR
first(pattern_comma_list) = UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING LPAREN LIDENT LBRACKET LBRACE INT FLOAT FALSE CHAR
first(pattern) = UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING LPAREN LIDENT LBRACKET LBRACE INT FLOAT FALSE CHAR
first(parser_cases) = LBRACKETLESS
first(parser_case) = LBRACKETLESS
first(opt_semi) = SEMI
first(opt_pat) = UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING LPAREN LIDENT LBRACKET LBRACE INT FLOAT FALSE CHAR
first(opt_err) = QUESTION
first(opt_bar) = BAR
first(operator) = SUBTRACTIVE STAR PREFIXOP LESSGREATER LESS INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 GREATER EQUAL COLONEQUAL BARBAR AMPERSAND AMPERAMPER
first(mutable_flag) = MUTABLE
first(mty_longident) = UIDENT LIDENT
first(module_type) = UIDENT SIG LPAREN LIDENT FUNCTOR
first(module_expr) = UIDENT STRUCT LPAREN FUNCTOR
first(module_declaration) = LPAREN COLON
first(module_binding) = LPAREN EQUAL COLON
first(mod_longident) = UIDENT
first(mod_ext_longident) = UIDENT
first(method_type) = METHOD
first(method_def) = METHOD
first(meth_list) = LIDENT DOTDOT
first(meth_binding) = UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING LPAREN LIDENT LBRACKET LBRACE INT FLOAT FALSE EQUAL COLONGREATER COLON CHAR
first(match_cases) = UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING LPAREN LIDENT LBRACKET LBRACE INT FLOAT FALSE CHAR
first(match_action) = WHEN MINUSGREATER
first(loc_modules) = LBRACKET
first(loc_init) = DO
first(loc_defs) = JOINDEF
first(loc_bindings) = LIDENT
first(loc_binding) = LIDENT
first(list_of_modules) = UIDENT
first(lident_comma_list) = LIDENT
first(let_bindings) = UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING LPAREN LIDENT LBRACKET LBRACE INT FLOAT FALSE CHAR
first(let_binding) = UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING LPAREN LIDENT LBRACKET LBRACE INT FLOAT FALSE CHAR
first(lbl_pattern_list) = UIDENT LIDENT
first(lbl_expr_list) = UIDENT LIDENT
first(label_longident) = UIDENT LIDENT
first(label_expr_list) = LIDENT
first(label_declarations) = MUTABLE LIDENT
first(label_declaration) = MUTABLE LIDENT
first(label) = LIDENT
first(join_pattern) = UIDENT LIDENT
first(join_match_cases) = UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING LPAREN LIDENT LBRACKET LBRACE INT FLOAT FALSE CHAR
first(join_match_action) = WHEN MINUSGREATER
first(interface) = VAL TYPE OPEN MODULE INCLUDE EXTERNAL EXCEPTION EOF CLASS
first(implementation) = WHILE VARTYPE UIDENT TYPE TRY TRUE SUBTRACTIVE STRING SPAWN SEMISEMI RELOCINFO PREFIXOP PARSER OPEN NEW MODULE MATCH LPAREN LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE EXTERNAL EXCEPTION EOF CLASS CHAR BEGIN ASSERT
first(ident) = UIDENT LIDENT
first(fun_def) = WHEN UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING MINUSGREATER LPAREN LIDENT LBRACKET LBRACE INT FLOAT FALSE CHAR
first(fun_binding) = UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING LPAREN LIDENT LBRACKET LBRACE INT FLOAT FALSE EQUAL COLONGREATER COLON CHAR
first(field) = LIDENT
first(ext_constructor_arguments) = OF
first(expr_semi_list) = WHILE VARTYPE UIDENT TRY TRUE SUBTRACTIVE STRING SPAWN RELOCINFO PREFIXOP PARSER NEW MATCH LPAREN LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE CHAR BEGIN ASSERT
first(expr_comma_list) = WHILE VARTYPE UIDENT TRY TRUE SUBTRACTIVE STRING SPAWN RELOCINFO PREFIXOP PARSER NEW MATCH LPAREN LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE CHAR BEGIN ASSERT
first(expr0) = WHILE VARTYPE UIDENT TRY TRUE SUBTRACTIVE STRING SPAWN RELOCINFO PREFIXOP PARSER NEW MATCH LPAREN LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE CHAR BEGIN ASSERT
first(expr) = WHILE VARTYPE UIDENT TRY TRUE SUBTRACTIVE STRING SPAWN RELOCINFO PREFIXOP PARSER NEW MATCH LPAREN LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE CHAR BEGIN ASSERT
first(direction_flag) = TO DOWNTO
first(def_pattern) = UIDENT LIDENT
first(def_bindings) = UIDENT LIDENT
first(def_binding) = UIDENT LIDENT
first(core_type_tuple) = UNDERSCORE UIDENT SHARP QUOTE LPAREN LIDENT LESSLESS LESS
first(core_type_list) = UNDERSCORE UIDENT SHARP QUOTE LPAREN LIDENT LESSLESS LESS
first(core_type_comma_list) = UNDERSCORE UIDENT SHARP QUOTE LPAREN LIDENT LESSLESS LESS
first(core_type) = UNDERSCORE UIDENT SHARP QUOTE LPAREN LIDENT LESSLESS LESS
first(constructor_declarations_ext) = UIDENT TRUE LPAREN LBRACKET FALSE COLONCOLON
first(constructor_declarations) = UIDENT TRUE LPAREN LBRACKET FALSE COLONCOLON
first(constructor_declaration) = UIDENT TRUE LPAREN LBRACKET FALSE COLONCOLON
first(constructor_arguments) = OF
first(constraints) = CONSTRAINT
first(constrain) = QUOTE
first(constr_longident) = UIDENT TRUE LPAREN LBRACKET FALSE
first(constr_ident) = UIDENT TRUE LPAREN LBRACKET FALSE COLONCOLON
first(constant) = STRING INT FLOAT CHAR
first(closed_flag) = CLOSED
first(class_type_parameters) = QUOTE LPAREN
first(class_type_list) = VIRTUAL QUOTE LPAREN LIDENT CLOSED
first(class_type_fields) = VIRTUAL VAL METHOD INHERIT
first(class_type) = VIRTUAL QUOTE LPAREN LIDENT CLOSED
first(class_longident) = UIDENT LIDENT
first(class_list) = VIRTUAL QUOTE LPAREN LIDENT CLOSED
first(class_fields) = VIRTUAL VAL METHOD INHERIT
first(class_def) = VIRTUAL QUOTE LPAREN LIDENT CLOSED
first(ancestor_type) = UIDENT LPAREN LIDENT
first(ancestor) = UIDENT LPAREN LIDENT
minimal(with_constraints) = (* 4 *) TYPE LIDENT EQUAL UNDERSCORE
minimal(with_constraint) = (* 4 *) TYPE LIDENT EQUAL UNDERSCORE
minimal(virtual_method) = (* 4 *) VIRTUAL LIDENT COLON UNDERSCORE
minimal(virtual_flag) = (* 0 *) 
minimal(value_type) = (* 1 *) LIDENT
minimal(value) = (* 1 *) LIDENT
minimal(val_longident) = (* 1 *) LIDENT
minimal(val_ident) = (* 1 *) LIDENT
minimal(use_file_tail) = (* 1 *) EOF
minimal(use_file) = (* 1 *) EOF
minimal(type_parameters) = (* 0 *) 
minimal(type_parameter_list) = (* 2 *) QUOTE UIDENT
minimal(type_parameter) = (* 2 *) QUOTE UIDENT
minimal(type_longident) = (* 1 *) LIDENT
minimal(type_list) = (* 3 *) LPAREN UNDERSCORE RPAREN
minimal(type_kind) = (* 0 *) 
minimal(type_declarations) = (* 1 *) LIDENT
minimal(type_declaration) = (* 1 *) LIDENT
minimal(type_constraint) = (* 2 *) COLON UNDERSCORE
minimal(toplevel_phrase) = (* 1 *) EOF
minimal(toplevel_directive) = (* 2 *) SHARP UIDENT
minimal(top_structure) = (* 2 *) TYPE LIDENT
minimal(to_ident) = (* 0 *) 
minimal(tag_constructor_declarations) = (* 4 *) UIDENT LBRACKET INT RBRACKET
minimal(tag_constructor_declaration) = (* 4 *) UIDENT LBRACKET INT RBRACKET
minimal(structure_tail) = (* 0 *) 
minimal(structure_item) = (* 2 *) TYPE LIDENT
minimal(structure) = (* 0 *) 
minimal(stream_pattern_component) = (* 1 *) LIDENT
minimal(stream_pattern) = (* 1 *) LIDENT
minimal(stream_expr_component) = (* 1 *) LIDENT
minimal(stream_expr) = (* 1 *) LIDENT
minimal(simple_pattern_list) = (* 1 *) LIDENT
minimal(simple_pattern) = (* 1 *) LIDENT
minimal(simple_expr_list) = (* 1 *) LIDENT
minimal(simple_expr) = (* 1 *) LIDENT
minimal(simple_def_binding) = (* 3 *) LIDENT LIDENT EQUAL
minimal(simple_core_type) = (* 1 *) UNDERSCORE
minimal(simple_chan_expr) = (* 1 *) LIDENT
minimal(signed_constant) = (* 1 *) INT
minimal(signature_item) = (* 2 *) TYPE LIDENT
minimal(signature) = (* 0 *) 
minimal(seq_expr) = (* 1 *) LIDENT
minimal(self_type) = (* 0 *) 
minimal(self) = (* 0 *) 
minimal(rec_flag) = (* 0 *) 
minimal(protected_flag) = (* 0 *) 
minimal(process0) = (* 1 *) REPLY
minimal(process) = (* 0 *) 
minimal(proc_expr) = (* 1 *) LIDENT
minimal(private_flag) = (* 0 *) 
minimal(primitive_declaration) = (* 1 *) STRING
minimal(pattern_semi_list) = (* 1 *) LIDENT
minimal(pattern_comma_list) = (* 3 *) LIDENT COMMA LIDENT
minimal(pattern) = (* 1 *) LIDENT
minimal(parser_cases) = (* 3 *) LBRACKETLESS LIDENT error
minimal(parser_case) = (* 3 *) LBRACKETLESS LIDENT error
minimal(opt_semi) = (* 0 *) 
minimal(opt_pat) = (* 0 *) 
minimal(opt_err) = (* 0 *) 
minimal(opt_bar) = (* 0 *) 
minimal(operator) = (* 1 *) PREFIXOP
minimal(mutable_flag) = (* 0 *) 
minimal(mty_longident) = (* 1 *) UIDENT
minimal(module_type) = (* 1 *) UIDENT
minimal(module_expr) = (* 1 *) UIDENT
minimal(module_declaration) = (* 2 *) COLON UIDENT
minimal(module_binding) = (* 2 *) EQUAL UIDENT
minimal(mod_longident) = (* 1 *) UIDENT
minimal(mod_ext_longident) = (* 1 *) UIDENT
minimal(method_type) = (* 2 *) METHOD LIDENT
minimal(method_def) = (* 4 *) METHOD LIDENT EQUAL LIDENT
minimal(meth_list) = (* 1 *) DOTDOT
minimal(meth_binding) = (* 2 *) EQUAL LIDENT
minimal(match_cases) = (* 3 *) LIDENT MINUSGREATER LIDENT
minimal(match_action) = (* 2 *) MINUSGREATER LIDENT
minimal(loc_modules) = (* 0 *) 
minimal(loc_init) = (* 0 *) 
minimal(loc_defs) = (* 0 *) 
minimal(loc_bindings) = (* 1 *) LIDENT
minimal(loc_binding) = (* 1 *) LIDENT
minimal(list_of_modules) = (* 1 *) UIDENT
minimal(lident_comma_list) = (* 1 *) LIDENT
minimal(let_bindings) = (* 3 *) LIDENT EQUAL LIDENT
minimal(let_binding) = (* 3 *) LIDENT EQUAL LIDENT
minimal(lbl_pattern_list) = (* 3 *) LIDENT EQUAL LIDENT
minimal(lbl_expr_list) = (* 3 *) LIDENT EQUAL LIDENT
minimal(label_longident) = (* 1 *) LIDENT
minimal(label_expr_list) = (* 3 *) LIDENT EQUAL LIDENT
minimal(label_declarations) = (* 3 *) LIDENT COLON UNDERSCORE
minimal(label_declaration) = (* 3 *) LIDENT COLON UNDERSCORE
minimal(label) = (* 1 *) LIDENT
minimal(join_pattern) = (* 2 *) LIDENT LIDENT
minimal(join_match_cases) = (* 3 *) LIDENT MINUSGREATER REPLY
minimal(join_match_action) = (* 2 *) MINUSGREATER REPLY
minimal(interface) = (* 1 *) EOF
minimal(implementation) = (* 1 *) EOF
minimal(ident) = (* 1 *) UIDENT
minimal(fun_def) = (* 2 *) MINUSGREATER LIDENT
minimal(fun_binding) = (* 2 *) EQUAL LIDENT
minimal(field) = (* 3 *) LIDENT COLON UNDERSCORE
minimal(ext_constructor_arguments) = (* 0 *) 
minimal(expr_semi_list) = (* 1 *) LIDENT
minimal(expr_comma_list) = (* 3 *) LIDENT COMMA LIDENT
minimal(expr0) = (* 1 *) LIDENT
minimal(expr) = (* 1 *) LIDENT
minimal(direction_flag) = (* 1 *) TO
minimal(def_pattern) = (* 3 *) LIDENT LIDENT EQUAL
minimal(def_bindings) = (* 3 *) LIDENT LIDENT EQUAL
minimal(def_binding) = (* 3 *) LIDENT LIDENT EQUAL
minimal(core_type_tuple) = (* 3 *) UNDERSCORE STAR UNDERSCORE
minimal(core_type_list) = (* 1 *) UNDERSCORE
minimal(core_type_comma_list) = (* 3 *) UNDERSCORE COMMA UNDERSCORE
minimal(core_type) = (* 1 *) UNDERSCORE
minimal(constructor_declarations_ext) = (* 1 *) UIDENT
minimal(constructor_declarations) = (* 1 *) UIDENT
minimal(constructor_declaration) = (* 1 *) UIDENT
minimal(constructor_arguments) = (* 0 *) 
minimal(constraints) = (* 0 *) 
minimal(constrain) = (* 4 *) QUOTE UIDENT EQUAL UNDERSCORE
minimal(constr_longident) = (* 1 *) UIDENT
minimal(constr_ident) = (* 1 *) UIDENT
minimal(constant) = (* 1 *) INT
minimal(closed_flag) = (* 0 *) 
minimal(class_type_parameters) = (* 0 *) 
minimal(class_type_list) = (* 5 *) LIDENT LPAREN UNDERSCORE RPAREN EQUAL
minimal(class_type_fields) = (* 0 *) 
minimal(class_type) = (* 5 *) LIDENT LPAREN UNDERSCORE RPAREN EQUAL
minimal(class_longident) = (* 1 *) LIDENT
minimal(class_list) = (* 3 *) LIDENT LIDENT EQUAL
minimal(class_fields) = (* 0 *) 
minimal(class_def) = (* 3 *) LIDENT LIDENT EQUAL
minimal(ancestor_type) = (* 1 *) LIDENT
minimal(ancestor) = (* 2 *) LIDENT LIDENT
follow(with_constraints) = error WITH VAL TYPE SHARP SEMISEMI RPAREN OPEN MODULE LET INCLUDE EXTERNAL EXCEPTION EQUAL EOF END CLASS AND
follow(with_constraint) = error WITH VAL TYPE SHARP SEMISEMI RPAREN OPEN MODULE LET INCLUDE EXTERNAL EXCEPTION EQUAL EOF END CLASS AND
follow(virtual_method) = error VIRTUAL VAL METHOD INHERIT END AND
follow(virtual_flag) = QUOTE LPAREN LIDENT CLOSED
follow(value_type) = VIRTUAL VAL METHOD INHERIT END AND
follow(value) = error VIRTUAL VAL METHOD INHERIT END AND
follow(val_longident) = error WITH VIRTUAL VARTYPE VAL UIDENT TYPE TRUE TO THEN SUBTRACTIVE STRING STAR SHARP SEMISEMI SEMI RPAREN RELOCINFO RBRACKET RBRACE QUESTION PREFIXOP OR OPEN NEW MODULE MINUSGREATER METHOD LPAREN LIDENT LET LESSGREATER LESS LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE INT INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN GREATERRBRACKET GREATERRBRACE GREATER FLOAT FALSE EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DOT DONE DO COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS CHAR BEGIN BARRBRACKET BARBAR BAR AS AND AMPERSAND AMPERAMPER
follow(val_ident) = error WITH WHEN VIRTUAL VARTYPE VAL UNDERSCORE UIDENT TYPE TRUE TO THEN SUBTRACTIVE STRING STAR SHARP SEMISEMI SEMI RPAREN RELOCINFO RBRACKET RBRACE QUESTION PREFIXOP OR OPEN NEW MODULE MINUSGREATER METHOD LPAREN LIDENT LET LESSGREATER LESS LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE INT INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN GREATERRBRACKET GREATERRBRACE GREATER FLOAT FALSE EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DOT DONE DO COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS CHAR BEGIN BARRBRACKET BARBAR BAR AS AND AMPERSAND AMPERAMPER
follow(use_file_tail) = #
follow(use_file) = #
follow(type_parameters) = UIDENT LIDENT
follow(type_parameter_list) = RPAREN COMMA
follow(type_parameter) = error WITH VIRTUAL VAL UIDENT TYPE SHARP SEMISEMI SEMI RPAREN RBRACE OPEN MODULE MINUSGREATER METHOD LIDENT LET INHERIT INCLUDE GREATERGREATER GREATER EXTERNAL EXCEPTION EQUAL EOF END CONSTRAINT COMMA COLONGREATER CLASS AS AND
follow(type_longident) = error WITH VIRTUAL VAL UIDENT TYPE STAR SHARP SEMISEMI SEMI RPAREN RBRACE OPEN MODULE MINUSGREATER METHOD LIDENT LET INHERIT INCLUDE GREATERGREATER GREATER EXTERNAL EXCEPTION EQUAL EOF END CONSTRAINT COMMA COLONGREATER CLASS BAR AS AND
follow(type_list) = EQUAL COLON
follow(type_kind) = error VAL TYPE SHARP SEMISEMI OPEN MODULE LET INCLUDE EXTERNAL EXCEPTION EOF END CONSTRAINT CLASS AND
follow(type_declarations) = error VAL TYPE SHARP SEMISEMI OPEN MODULE LET INCLUDE EXTERNAL EXCEPTION EOF END CLASS AND
follow(type_declaration) = error VAL TYPE SHARP SEMISEMI OPEN MODULE LET INCLUDE EXTERNAL EXCEPTION EOF END CLASS AND
follow(type_constraint) = RPAREN EQUAL
follow(toplevel_phrase) = #
follow(toplevel_directive) = TYPE SHARP SEMISEMI OPEN MODULE LET EXTERNAL EXCEPTION EOF CLASS
follow(top_structure) = SEMISEMI
follow(to_ident) = error TYPE SHARP SEMISEMI RBRACE OR OPEN MODULE LET IN EXTERNAL EXCEPTION EOF END ELSE DO CLASS BAR AND
follow(tag_constructor_declarations) = error VAL TYPE SHARP SEMISEMI OPEN MODULE LET INCLUDE EXTERNAL EXCEPTION EOF END CONSTRAINT CLASS BAR AND
follow(tag_constructor_declaration) = error VAL TYPE SHARP SEMISEMI OPEN MODULE LET INCLUDE EXTERNAL EXCEPTION EOF END CONSTRAINT CLASS BAR AND
follow(structure_tail) = error EOF END
follow(structure_item) = error TYPE SHARP SEMISEMI OPEN MODULE LET EXTERNAL EXCEPTION EOF END CLASS
follow(structure) = error EOF END
follow(stream_pattern_component) = error SEMI QUESTION GREATERRBRACKET
follow(stream_pattern) = error SEMI GREATERRBRACKET
follow(stream_expr_component) = error SEMI GREATERRBRACKET
follow(stream_expr) = error SEMI GREATERRBRACKET
follow(simple_pattern_list) = UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING LPAREN LIDENT LBRACKET LBRACE INT FLOAT FALSE EQUAL COLON CHAR AS
follow(simple_pattern) = error WHEN UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING SEMI RPAREN RBRACKET RBRACE QUESTION MINUSGREATER LPAREN LIDENT LBRACKETLESS LBRACKET LBRACE INT GREATERRBRACKET FLOAT FALSE EQUAL COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CHAR BAR AS
follow(simple_expr_list) = error WITH VIRTUAL VARTYPE VAL UIDENT TYPE TRUE TO THEN SUBTRACTIVE STRING STAR SHARP SEMISEMI SEMI RPAREN RELOCINFO RBRACKET RBRACE QUESTION PREFIXOP OR OPEN NEW MODULE MINUSGREATER METHOD LPAREN LIDENT LET LESSGREATER LESS LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE INT INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN GREATERRBRACKET GREATERRBRACE GREATER FLOAT FALSE EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DONE DO COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS CHAR BEGIN BARRBRACKET BARBAR BAR AS AND AMPERSAND AMPERAMPER
follow(simple_expr) = error WITH VIRTUAL VARTYPE VAL UIDENT TYPE TRUE TO THEN SUBTRACTIVE STRING STAR SHARP SEMISEMI SEMI RPAREN RELOCINFO RBRACKET RBRACE QUESTION PREFIXOP OR OPEN NEW MODULE MINUSGREATER METHOD LPAREN LIDENT LET LESSGREATER LESS LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE INT INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN GREATERRBRACKET GREATERRBRACE GREATER FLOAT FALSE EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DOT DONE DO COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS CHAR BEGIN BARRBRACKET BARBAR BAR AS AND AMPERSAND AMPERAMPER
follow(simple_def_binding) = error TYPE SHARP SEMISEMI RBRACE OR OPEN MODULE LET IN EXTERNAL EXCEPTION EOF END ELSE DO CLASS BAR AND
follow(simple_core_type) = error WITH VIRTUAL VAL UIDENT TYPE STAR SHARP SEMISEMI SEMI RPAREN RBRACE OPEN MODULE MINUSGREATER METHOD LIDENT LET INHERIT INCLUDE GREATERGREATER GREATER EXTERNAL EXCEPTION EQUAL EOF END CONSTRAINT COMMA COLONGREATER CLASS BAR AS AND
follow(simple_chan_expr) = VARTYPE UIDENT TRUE STRING SHARP SEMI RELOCINFO PREFIXOP NEW LPAREN LIDENT LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE INT FLOAT FALSE ELSE DOT COLONEQUAL CHAR BEGIN
follow(signed_constant) = error WHEN UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING SEMI RPAREN RBRACKET RBRACE QUESTION MINUSGREATER LPAREN LIDENT LBRACKETLESS LBRACKET LBRACE INT GREATERRBRACKET FLOAT FALSE EQUAL COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CHAR BAR AS
follow(signature_item) = error VAL TYPE SEMISEMI OPEN MODULE INCLUDE EXTERNAL EXCEPTION EOF END CLASS
follow(signature) = error VAL TYPE OPEN MODULE INCLUDE EXTERNAL EXCEPTION EOF END CLASS
follow(seq_expr) = error WITH VIRTUAL VAL TYPE TO THEN SUBTRACTIVE STAR SHARP SEMISEMI SEMI RPAREN RBRACKET RBRACE QUESTION OR OPEN MODULE MINUSGREATER METHOD LET LESSGREATER LESS INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN GREATERRBRACKET GREATERRBRACE GREATER EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DONE DO COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS BARRBRACKET BARBAR BAR AND AMPERSAND AMPERAMPER
follow(self_type) = EQUAL
follow(self) = error VIRTUAL VAL METHOD INHERIT EQUAL END COLON AND
follow(rec_flag) = UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING LPAREN LIDENT LBRACKET LBRACE INT FLOAT FALSE CHAR
follow(protected_flag) = LIDENT
follow(process0) = error TYPE SHARP SEMISEMI RBRACE OR OPEN MODULE LET IN EXTERNAL EXCEPTION EOF END ELSE DO CLASS BAR AND
follow(process) = error TYPE SHARP SEMISEMI RBRACE OR OPEN MODULE LET IN EXTERNAL EXCEPTION EOF END ELSE DO CLASS BAR AND
follow(proc_expr) = SEMI ELSE COLONEQUAL
follow(private_flag) = MUTABLE LIDENT
follow(primitive_declaration) = error VAL TYPE SHARP SEMISEMI OPEN MODULE LET INCLUDE EXTERNAL EXCEPTION EOF END CLASS
follow(pattern_semi_list) = error SEMI RBRACKET
follow(pattern_comma_list) = error WHEN SEMI RPAREN RBRACKET RBRACE QUESTION MINUSGREATER GREATERRBRACKET EQUAL COMMA COLONEQUAL COLONCOLON COLON BAR AS
follow(pattern) = error WHEN SEMI RPAREN RBRACKET RBRACE QUESTION MINUSGREATER GREATERRBRACKET EQUAL COMMA COLONEQUAL COLONCOLON COLON BAR AS
follow(parser_cases) = error WITH VIRTUAL VAL TYPE TO THEN SUBTRACTIVE STAR SHARP SEMISEMI SEMI RPAREN RBRACKET RBRACE QUESTION OR OPEN MODULE MINUSGREATER METHOD LET LESSGREATER LESS INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN GREATERRBRACKET GREATERRBRACE GREATER EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DONE DO COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS BARRBRACKET BARBAR BAR AND AMPERSAND AMPERAMPER
follow(parser_case) = error WITH VIRTUAL VAL TYPE TO THEN SUBTRACTIVE STAR SHARP SEMISEMI SEMI RPAREN RBRACKET RBRACE QUESTION OR OPEN MODULE MINUSGREATER METHOD LET LESSGREATER LESS INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN GREATERRBRACKET GREATERRBRACE GREATER EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DONE DO COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS BARRBRACKET BARBAR BAR AND AMPERSAND AMPERAMPER
follow(opt_semi) = error RBRACKET RBRACE GREATERRBRACKET GREATERRBRACE GREATER BARRBRACKET
follow(opt_pat) = MINUSGREATER LBRACKETLESS BAR
follow(opt_err) = error SEMI GREATERRBRACKET
follow(opt_bar) = UNDERSCORE UIDENT TRUE SUBTRACTIVE STRING LPAREN LIDENT LBRACKETLESS LBRACKET LBRACE INT FLOAT FALSE COLONCOLON CHAR
follow(operator) = RPAREN
follow(mutable_flag) = LIDENT
follow(mty_longident) = error WITH VAL TYPE SHARP SEMISEMI RPAREN OPEN MODULE LET INCLUDE EXTERNAL EXCEPTION EQUAL EOF END CLASS
follow(module_type) = error WITH VAL TYPE SHARP SEMISEMI RPAREN OPEN MODULE LET INCLUDE EXTERNAL EXCEPTION EQUAL EOF END CLASS
follow(module_expr) = error TYPE SHARP SEMISEMI RPAREN OPEN MODULE LPAREN LET EXTERNAL EXCEPTION EOF END COLON CLASS
follow(module_declaration) = error VAL TYPE SEMISEMI OPEN MODULE INCLUDE EXTERNAL EXCEPTION EOF END CLASS
follow(module_binding) = error TYPE SHARP SEMISEMI OPEN MODULE LET EXTERNAL EXCEPTION EOF END CLASS
follow(mod_longident) = error WITH WHEN VIRTUAL VARTYPE VAL UNDERSCORE UIDENT TYPE TRUE TO THEN SUBTRACTIVE STRING STAR SHARP SEMISEMI SEMI RPAREN RELOCINFO RBRACKET RBRACE QUESTION PREFIXOP OR OPEN NEW MODULE MINUSGREATER METHOD LPAREN LIDENT LET LESSGREATER LESS LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE INT INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 INCLUDE IN GREATERRBRACKET GREATERRBRACE GREATER FLOAT FALSE EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DOT DONE DO COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS CHAR BEGIN BARRBRACKET BARBAR BAR AS AND AMPERSAND AMPERAMPER
follow(mod_ext_longident) = error WITH VAL TYPE SHARP SEMISEMI RPAREN OPEN MODULE LPAREN LET INCLUDE EXTERNAL EXCEPTION EQUAL EOF END DOT CLASS AND
follow(method_type) = VIRTUAL VAL METHOD INHERIT END AND
follow(method_def) = error VIRTUAL VAL METHOD INHERIT END AND
follow(meth_list) = GREATER
follow(meth_binding) = error VIRTUAL VAL METHOD INHERIT END AND
follow(match_cases) = error WITH VIRTUAL VAL TYPE TO THEN SUBTRACTIVE STAR SHARP SEMISEMI SEMI RPAREN RBRACKET RBRACE QUESTION OR OPEN MODULE MINUSGREATER METHOD LET LESSGREATER LESS INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN GREATERRBRACKET GREATERRBRACE GREATER EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DONE DO COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS BARRBRACKET BARBAR BAR AND AMPERSAND AMPERAMPER
follow(match_action) = error WITH VIRTUAL VAL TYPE TO THEN SUBTRACTIVE STAR SHARP SEMISEMI SEMI RPAREN RBRACKET RBRACE QUESTION OR OPEN MODULE MINUSGREATER METHOD LET LESSGREATER LESS INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN GREATERRBRACKET GREATERRBRACE GREATER EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DONE DO COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS BARRBRACKET BARBAR BAR AND AMPERSAND AMPERAMPER
follow(loc_modules) = error TYPE SHARP SEMISEMI RBRACE OR OPEN MODULE LET JOINDEF IN EXTERNAL EXCEPTION EOF END ELSE DO CLASS BAR AND
follow(loc_init) = error TYPE SHARP SEMISEMI RBRACE OR OPEN MODULE LET IN EXTERNAL EXCEPTION EOF END ELSE DO CLASS BAR AND
follow(loc_defs) = error TYPE SHARP SEMISEMI RBRACE OR OPEN MODULE LET IN EXTERNAL EXCEPTION EOF END ELSE DO CLASS BAR AND
follow(loc_bindings) = error TYPE SHARP SEMISEMI RBRACE OR OPEN MODULE LET IN EXTERNAL EXCEPTION EOF END ELSE DO CLASS BAR AND
follow(loc_binding) = error TYPE SHARP SEMISEMI RBRACE OR OPEN MODULE LET IN EXTERNAL EXCEPTION EOF END ELSE DO CLASS BAR AND
follow(list_of_modules) = RBRACKET
follow(lident_comma_list) = RBRACKET
follow(let_bindings) = error TYPE SHARP SEMISEMI OPEN MODULE LET IN EXTERNAL EXCEPTION EOF END CLASS AND
follow(let_binding) = error TYPE SHARP SEMISEMI OPEN MODULE LET IN EXTERNAL EXCEPTION EOF END CLASS AND
follow(lbl_pattern_list) = error SEMI RBRACE
follow(lbl_expr_list) = error SEMI RBRACE
follow(label_longident) = error WITH VIRTUAL VARTYPE VAL UIDENT TYPE TRUE TO THEN SUBTRACTIVE STRING STAR SHARP SEMISEMI SEMI RPAREN RELOCINFO RBRACKET RBRACE QUESTION PREFIXOP OR OPEN NEW MODULE MINUSGREATER METHOD LPAREN LIDENT LET LESSMINUS LESSGREATER LESS LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE INT INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN GREATERRBRACKET GREATERRBRACE GREATER FLOAT FALSE EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DOT DONE DO COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS CHAR BEGIN BARRBRACKET BARBAR BAR AS AND AMPERSAND AMPERAMPER
follow(label_expr_list) = error SEMI GREATERRBRACE
follow(label_declarations) = SEMI RBRACE
follow(label_declaration) = SEMI RBRACE
follow(label) = error WITH VIRTUAL VARTYPE VAL UNDERSCORE UIDENT TYPE TRUE TO THEN SUBTRACTIVE STRING STAR SHARP SEMISEMI SEMI RPAREN RELOCINFO RBRACKET RBRACE QUESTION PREFIXOP OR OPEN NEW MODULE MINUSGREATER METHOD LPAREN LIDENT LET LESSMINUS LESSGREATER LESS LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE INT INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN GREATERRBRACKET GREATERRBRACE GREATER FLOAT FALSE EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DOT DONE DO COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS CHAR BEGIN BARRBRACKET BARBAR BAR AS AND AMPERSAND AMPERAMPER
follow(join_pattern) = EQUAL BAR
follow(join_match_cases) = error TYPE SHARP SEMISEMI RBRACE OR OPEN MODULE LET IN EXTERNAL EXCEPTION EOF END ELSE DO CLASS BAR AND
follow(join_match_action) = error TYPE SHARP SEMISEMI RBRACE OR OPEN MODULE LET IN EXTERNAL EXCEPTION EOF END ELSE DO CLASS BAR AND
follow(interface) = #
follow(implementation) = #
follow(ident) = error WITH VIRTUAL VAL UIDENT TYPE STRING STAR SHARP SEMISEMI SEMI RPAREN RBRACE OPEN MODULE MINUSGREATER METHOD LPAREN LIDENT LET INT INHERIT INCLUDE GREATERGREATER GREATER EXTERNAL EXCEPTION EQUAL EOF END CONSTRAINT COMMA COLONGREATER CLASS BAR AS AND
follow(fun_def) = error WITH VIRTUAL VAL TYPE TO THEN SUBTRACTIVE STAR SHARP SEMISEMI SEMI RPAREN RBRACKET RBRACE QUESTION OR OPEN MODULE MINUSGREATER METHOD LET LESSGREATER LESS INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN GREATERRBRACKET GREATERRBRACE GREATER EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DONE DO COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS BARRBRACKET BARBAR BAR AND AMPERSAND AMPERAMPER
follow(fun_binding) = error TYPE SHARP SEMISEMI OPEN MODULE LET IN EXTERNAL EXCEPTION EOF END CLASS AND
follow(field) = SEMI GREATER
follow(ext_constructor_arguments) = error VAL TYPE SHARP SEMISEMI OPEN MODULE LET INCLUDE EXTERNAL EXCEPTION EOF END CONSTRAINT CLASS BAR AND
follow(expr_semi_list) = error SEMI RBRACKET BARRBRACKET
follow(expr_comma_list) = error WITH VIRTUAL VAL TYPE TO THEN SUBTRACTIVE STAR SHARP SEMISEMI SEMI RPAREN RBRACKET RBRACE QUESTION OR OPEN MODULE MINUSGREATER METHOD LET LESSGREATER LESS INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN GREATERRBRACKET GREATERRBRACE GREATER EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DONE DO COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS BARRBRACKET BARBAR BAR AND AMPERSAND AMPERAMPER
follow(expr0) = error WITH VIRTUAL VAL TYPE TO THEN SUBTRACTIVE STAR SHARP SEMISEMI SEMI RPAREN RBRACKET RBRACE QUESTION OR OPEN MODULE MINUSGREATER METHOD LET LESSGREATER LESS INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN GREATERRBRACKET GREATERRBRACE GREATER EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DONE DO COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS BARRBRACKET BARBAR BAR AND AMPERSAND AMPERAMPER
follow(expr) = error WITH VIRTUAL VAL TYPE TO THEN SUBTRACTIVE STAR SHARP SEMISEMI SEMI RPAREN RBRACKET RBRACE QUESTION OR OPEN MODULE MINUSGREATER METHOD LET LESSGREATER LESS INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN GREATERRBRACKET GREATERRBRACE GREATER EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DONE DO COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS BARRBRACKET BARBAR BAR AND AMPERSAND AMPERAMPER
follow(direction_flag) = WHILE VARTYPE UIDENT TRY TRUE SUBTRACTIVE STRING SPAWN RELOCINFO PREFIXOP PARSER NEW MATCH LPAREN LIDENT LET LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE LAZY INT IF FUNCTION FUN FOR FLOAT FALSE CHAR BEGIN ASSERT
follow(def_pattern) = error TYPE SHARP SEMISEMI RBRACE OR OPEN MODULE LET IN EXTERNAL EXCEPTION EOF END ELSE DO CLASS BAR AND
follow(def_bindings) = error TYPE SHARP SEMISEMI RBRACE OR OPEN MODULE LET IN EXTERNAL EXCEPTION EOF END ELSE DO CLASS BAR AND
follow(def_binding) = error TYPE SHARP SEMISEMI RBRACE OR OPEN MODULE LET IN EXTERNAL EXCEPTION EOF END ELSE DO CLASS BAR AND
follow(core_type_tuple) = error WITH VIRTUAL VAL TYPE STAR SHARP SEMISEMI SEMI RPAREN RBRACE OPEN MODULE MINUSGREATER METHOD LET INHERIT INCLUDE GREATERGREATER GREATER EXTERNAL EXCEPTION EQUAL EOF END CONSTRAINT COMMA COLONGREATER CLASS AS AND
follow(core_type_list) = error VAL TYPE STAR SHARP SEMISEMI OPEN MODULE LET INCLUDE EXTERNAL EXCEPTION EOF END CONSTRAINT CLASS BAR AND
follow(core_type_comma_list) = RPAREN COMMA
follow(core_type) = error WITH VIRTUAL VAL TYPE SHARP SEMISEMI SEMI RPAREN RBRACE OPEN MODULE MINUSGREATER METHOD LET INHERIT INCLUDE GREATERGREATER GREATER EXTERNAL EXCEPTION EQUAL EOF END CONSTRAINT COMMA COLONGREATER CLASS AS AND
follow(constructor_declarations_ext) = error VAL TYPE SHARP SEMISEMI OPEN MODULE LET INCLUDE EXTERNAL EXCEPTION EOF END CONSTRAINT CLASS AND
follow(constructor_declarations) = error VAL TYPE SHARP SEMISEMI OPEN MODULE LET INCLUDE EXTERNAL EXCEPTION EOF END CONSTRAINT CLASS BAR AND
follow(constructor_declaration) = error VAL TYPE SHARP SEMISEMI OPEN MODULE LET INCLUDE EXTERNAL EXCEPTION EOF END CONSTRAINT CLASS BAR AND
follow(constructor_arguments) = error VAL TYPE SHARP SEMISEMI OPEN MODULE LET INCLUDE EXTERNAL EXCEPTION EOF END CLASS
follow(constraints) = error WITH VIRTUAL VAL TYPE SHARP SEMISEMI RPAREN OPEN MODULE METHOD LET INHERIT INCLUDE EXTERNAL EXCEPTION EQUAL EOF END CONSTRAINT CLASS AND
follow(constrain) = error WITH VIRTUAL VAL TYPE SHARP SEMISEMI RPAREN OPEN MODULE METHOD LET INHERIT INCLUDE EXTERNAL EXCEPTION EQUAL EOF END CONSTRAINT CLASS AND
follow(constr_longident) = error WITH WHEN VIRTUAL VARTYPE VAL UNDERSCORE UIDENT TYPE TRUE TO THEN SUBTRACTIVE STRING STAR SHARP SEMISEMI SEMI RPAREN RELOCINFO RBRACKET RBRACE QUESTION PREFIXOP OR OPEN NEW MODULE MINUSGREATER METHOD LPAREN LIDENT LET LESSGREATER LESS LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE INT INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN GREATERRBRACKET GREATERRBRACE GREATER FLOAT FALSE EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DOT DONE DO COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS CHAR BEGIN BARRBRACKET BARBAR BAR AS AND AMPERSAND AMPERAMPER
follow(constr_ident) = error VAL TYPE SHARP SEMISEMI OPEN OF MODULE LET LBRACKET INCLUDE EXTERNAL EXCEPTION EOF END CONSTRAINT CLASS BAR AND
follow(constant) = error WITH WHEN VIRTUAL VARTYPE VAL UNDERSCORE UIDENT TYPE TRUE TO THEN SUBTRACTIVE STRING STAR SHARP SEMISEMI SEMI RPAREN RELOCINFO RBRACKET RBRACE QUESTION PREFIXOP OR OPEN NEW MODULE MINUSGREATER METHOD LPAREN LIDENT LET LESSGREATER LESS LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE INT INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 IN GREATERRBRACKET GREATERRBRACE GREATER FLOAT FALSE EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DOT DONE DO COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS CHAR BEGIN BARRBRACKET BARBAR BAR AS AND AMPERSAND AMPERAMPER
follow(closed_flag) = QUOTE LPAREN LIDENT
follow(class_type_parameters) = LIDENT
follow(class_type_list) = END AND
follow(class_type_fields) = VIRTUAL VAL METHOD INHERIT END AND
follow(class_type) = END AND
follow(class_longident) = error WITH VIRTUAL VARTYPE VAL UIDENT TYPE TRUE TO THEN SUBTRACTIVE STRING STAR SHARP SEMISEMI SEMI RPAREN RELOCINFO RBRACKET RBRACE QUESTION PREFIXOP OR OPEN NEW MODULE MINUSGREATER METHOD LPAREN LIDENT LET LESSGREATER LESS LBRACKETLESS LBRACKETBAR LBRACKET LBRACELESS LBRACE INT INHERIT INFIXOP4 INFIXOP3 INFIXOP2 INFIXOP1 INFIXOP0 INCLUDE IN GREATERRBRACKET GREATERRBRACE GREATERGREATER GREATER FLOAT FALSE EXTERNAL EXCEPTION EQUAL EOF END ELSE DOWNTO DOT DONE DO CONSTRAINT COMMA COLONGREATER COLONEQUAL COLONCOLON COLON CLASS CHAR BEGIN BARRBRACKET BARBAR BAR AS AND AMPERSAND AMPERAMPER
follow(class_list) = error END AND
follow(class_fields) = error VIRTUAL VAL METHOD INHERIT END AND
follow(class_def) = error END AND
follow(ancestor_type) = VIRTUAL VAL METHOD INHERIT END AND
follow(ancestor) = error VIRTUAL VAL METHOD INHERIT END AND
Built an LR(0) automaton with 1077 states.
The grammar is not SLR(1) -- 104 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 1824 states.
636 shift/reduce conflicts were silently solved.
File "jocaml.mly", line 291, characters 0-5:
Warning: the precedence level assigned to prec_expr is never useful.
File "jocaml.mly", line 266, characters 0-6:
Warning: the precedence level assigned to prec_let is never useful.
File "jocaml.mly", line 270, characters 0-6:
Warning: the precedence level assigned to prec_list is never useful.
File "jocaml.mly", line 292, characters 0-5:
Warning: the precedence level assigned to prec_proc is never useful.
File "jocaml.mly", line 267, characters 0-6:
Warning: the precedence level assigned to prec_type_def is never useful.
File "jocaml.mly", line 491, characters 39-48:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 493, characters 44-52:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 495, characters 41-49:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 497, characters 47-55:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 499, characters 41-49:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 501, characters 38-46:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 503, characters 44-52:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 505, characters 48-56:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 507, characters 45-53:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 509, characters 42-50:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 523, characters 37-45:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 531, characters 34-42:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 533, characters 29-37:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 968, characters 15-24:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 969, characters 35-44:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 886, characters 25-33:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 888, characters 41-49:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 962, characters 27-36:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 964, characters 48-57:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 956, characters 37-46:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 958, characters 56-65:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 878, characters 33-41:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 880, characters 38-46:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 1099, characters 26-34:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 1101, characters 42-50:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 350, characters 10-18:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 430, characters 10-18:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 929, characters 24-33:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 797, characters 44-53:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 825, characters 29-38:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 827, characters 27-36:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 762, characters 46-54:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 764, characters 43-51:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 766, characters 47-55:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 768, characters 34-41:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 859, characters 47-54:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 1304, characters 42-58:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 1307, characters 12-28:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 1317, characters 49-65:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 1320, characters 12-28:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 936, characters 21-30:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 937, characters 15-24:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 916, characters 34-43:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 1194, characters 26-39:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 1202, characters 69-82:
Warning: this %prec declaration is never useful.
File "jocaml.mly", line 1205, characters 10-23:
Warning: this %prec declaration is never useful.
Warning: 80 states have shift/reduce conflicts.
Warning: one state has reduce/reduce conflicts.
Warning: 148 shift/reduce conflicts were arbitrarily resolved.
Warning: one reduce/reduce conflict was arbitrarily resolved.
569 out of 1824 states have a default reduction.
1002 out of 1824 states are represented.
0 out of 251 symbols keep track of their start position.
0 out of 251 symbols keep track of their end position.
245 out of 502 productions exploit shiftreduce optimization.
511 out of 1824 states can peek at an error.
4293 functions before inlining, 1047 functions after inlining.
