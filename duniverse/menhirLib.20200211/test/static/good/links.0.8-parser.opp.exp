File "links.0.8-parser.mly", line 175, characters 41-52:
Warning: the token MINUSLBRACE is unused.
%{

open Utility
open Sugartypes

(* Generation of fresh type variables *)

let type_variable_counter = ref 0

let fresh_type_variable : subkind option -> datatype =
  function subkind ->
    incr type_variable_counter; `TypeVar ("_" ^ string_of_int (!type_variable_counter), subkind, `Flexible)

let fresh_rigid_type_variable : subkind option -> datatype =
  function subkind ->
    incr type_variable_counter; `TypeVar ("_" ^ string_of_int (!type_variable_counter), subkind, `Rigid)

let fresh_row_variable : subkind option -> row_var =
  function subkind ->
    incr type_variable_counter; `Open ("_" ^ string_of_int (!type_variable_counter), subkind, `Flexible)

let fresh_rigid_row_variable : subkind option -> row_var =
  function subkind ->
    incr type_variable_counter; `Open ("_" ^ string_of_int (!type_variable_counter), subkind, `Rigid)

let fresh_presence_variable : subkind option -> fieldspec =
  function subkind ->
    incr type_variable_counter; `Var ("_" ^ string_of_int (!type_variable_counter), subkind, `Flexible)

let fresh_rigid_presence_variable : subkind option -> fieldspec =
  function subkind ->
    incr type_variable_counter; `Var ("_" ^ string_of_int (!type_variable_counter), subkind, `Rigid)

let ensure_match (start, finish, _) (opening : string) (closing : string) = function
  | result when opening = closing -> result
  | _ -> raise (ConcreteSyntaxError ("Closing tag '" ^ closing ^ "' does not match start tag '" ^ opening ^ "'.",
                                     (start, finish, None)))

let pos () : Sugartypes.position = Parsing.symbol_start_pos (), Parsing.symbol_end_pos (), None

let default_fixity = 9

let annotate (signame, datatype) : _ -> binding =
  let checksig (signame, _) name =
    if signame <> name then
      raise (ConcreteSyntaxError
               ("Signature for `" ^ signame ^ "' should precede definition of `"
                ^ signame ^ "', not `"^ name ^"'.",
                pos ())) in
    function
      | `Fun ((name, bpos), lin, phrase, location, dpos) ->
          let _ = checksig signame name in
            `Fun ((name, None, bpos), lin, ([], phrase), location, Some datatype), dpos
      | `Var (((name, bpos), phrase, location), dpos) ->
          let _ = checksig signame name in
          `Val ([], (`Variable (name, None, bpos), dpos), phrase, location, Some datatype), dpos
      | `Handler ((name,_,_) as b, hnlit, dpos) ->
	 let _ = checksig signame name in
	 `Handler (b, hnlit, Some datatype), dpos

let primary_kind_of_string pos =
  function
  | "Type" -> `Type
  | "Row" -> `Row
  | "Presence" -> `Presence
  | pk -> raise (ConcreteSyntaxError ("Invalid primary kind: " ^ pk, pos))

let linearity_of_string pos =
  function
  | "Any" -> `Any
  | "Unl" -> `Unl
  | lin -> raise (ConcreteSyntaxError ("Invalid kind linearity: " ^ lin, pos))

let restriction_of_string pos =
  function
  | "Any" -> `Any
  | "Base" -> `Base
  | "Session" -> `Session
  | rest -> raise (ConcreteSyntaxError ("Invalid kind restriction: " ^ rest, pos))

let full_kind_of pos prim lin rest =
  let p = primary_kind_of_string pos prim in
  let l = linearity_of_string pos lin in
  let r = restriction_of_string pos rest in
  p, Some (l, r)

let full_subkind_of pos lin rest =
  let l = linearity_of_string pos lin in
  let r = restriction_of_string pos rest in
  Some (l, r)

(* In kind and subkind abbreviations, we aim to provide the most
common case. For everything except session types, the default
linearity is `Unl and the default restriction is `Any. For session
types the default linearity is `Any. *)

(* Currently "Any" means `Any,`Any, but it is probably advisable to
change "Any" to something more evocative of linearity - "Lin"
perhaps. *)

let kind_of pos =
  function
  (* primary kind abbreviation  *)
  | "Type" -> `Type, None
  | "Row" -> `Row, None
  | "Presence" -> `Presence, None
  (* subkind of type abbreviations *)
  | "Any" -> `Type, Some (`Any, `Any)
  | "Base" -> `Type, Some (`Unl, `Base)
  | "Session" -> `Type, Some (`Any, `Session)
  | "Eff"     -> `Row, Some (`Unl, `Effect)
  | k -> raise (ConcreteSyntaxError ("Invalid kind: " ^ k, pos))

let subkind_of pos =
  function
  (* subkind abbreviations *)
  | "Any" -> Some (`Any, `Any)
  | "Base" -> Some (`Unl, `Base)
  | "Session" -> Some (`Any, `Session)
  | "Eff"  -> Some (`Unl, `Effect)
  | sk -> raise (ConcreteSyntaxError ("Invalid subkind: " ^ sk, pos))

let attach_kind _pos (t, k) = (t, k, `Rigid)

let attach_subkind_helper update _pos sk = update sk

let attach_subkind pos (t, subkind) =
  let update sk =
    match t with
    | `TypeVar (x, _, freedom) ->
       `TypeVar (x, sk, freedom)
    | _ -> assert false
  in
    attach_subkind_helper update pos subkind

let attach_row_subkind pos (r, subkind) =
  let update sk =
    match r with
    | `Open (x, _, freedom) ->
       `Open (x, sk, freedom)
    | _ -> assert false
  in
    attach_subkind_helper update pos subkind

let row_with field (fields, row_var) = field::fields, row_var

(* this preserves 1-tuples *)
let make_tuple pos =
  function
    | [e] -> `RecordLit ([("1", e)], None), pos
    | es -> `TupleLit es, pos

let labels = List.map fst

let parseRegexFlags f =
  let rec asList f i l =
    if (i == String.length f) then
      List.rev l
    else
      asList f (i+1) ((String.get f i)::l) in
    List.map (function
                'l' -> `RegexList
              | 'n' -> `RegexNative
              | 'g' -> `RegexGlobal
              | _ -> assert false) (asList f 0 [])

let datatype d = d, None

let cp_unit p = `Unquote ([], (`TupleLit [], p)), p
%}
%start file
%start interactive
%start just_datatype
%token ALIEN
%token ALTERNATE
%token AMPAMP
%token AS
%token BANG
%token BARAMPRBRACKET
%token BARBAR
%token BARPLUSRBRACKET
%token BARRBRACE
%token BARRBRACKET
%token BY
%token CARET
%token CASE
%token <string> CDATA
%token <char> CHAR
%token CLIENT
%token COLON
%token COLONCOLON
%token COMMA
%token <string> CONSTRUCTOR
%token DATABASE
%token DEFAULT
%token DELETE
%token DELETE_LEFT
%token DETERMINED
%token DOLLAR
%token DOOP
%token DOT
%token DOTDOT
%token ELSE
%token END
%token <string> ENDTAG
%token EQ
%token EQUALSTILDE
%token ESCAPE
%token FALSE
%token FATRARROW
%token FOR
%token FORALL
%token FORMLET
%token FROM
%token FUN
%token HANDLE
%token HANDLER
%token IF
%token IN
%token <[`Left|`Right|`None|`Pre|`Post] -> int -> string -> unit> INFIX
%token <string> INFIX0
%token <string> INFIX1
%token <string> INFIX2
%token <string> INFIX3
%token <string> INFIX4
%token <string> INFIX5
%token <string> INFIX6
%token <string> INFIX7
%token <string> INFIX8
%token <string> INFIX9
%token <[`Left|`Right|`None|`Pre|`Post] -> int -> string -> unit> INFIXL
%token <string> INFIXL0
%token <string> INFIXL1
%token <string> INFIXL2
%token <string> INFIXL3
%token <string> INFIXL4
%token <string> INFIXL5
%token <string> INFIXL6
%token <string> INFIXL7
%token <string> INFIXL8
%token <string> INFIXL9
%token <[`Left|`Right|`None|`Pre|`Post] -> int -> string -> unit> INFIXR
%token <string> INFIXR0
%token <string> INFIXR1
%token <string> INFIXR2
%token <string> INFIXR3
%token <string> INFIXR4
%token <string> INFIXR5
%token <string> INFIXR6
%token <string> INFIXR7
%token <string> INFIXR8
%token <string> INFIXR9
%token INSERT
%token <string> KEYWORD
%token LARROW
%token LBRACE
%token LBRACEBAR
%token LBRACKET
%token LBRACKETAMPBAR
%token LBRACKETBAR
%token LBRACKETPLUSBAR
%token LEFTTRIANGLE
%token LENS
%token LENSDROP
%token LENSGET
%token LENSJOIN
%token LENSPUT
%token LENSSELECT
%token LINFUN
%token LLARROW
%token LOLLI
%token LPAREN
%token LQUOTE
%token LRARROW
%token <string> LXML
%token MINUS
%token MINUSDOT
%token MINUSLBRACE
%token MODULE
%token MU
%token NATIVE
%token NU
%token OFFER
%token ON
%token OP
%token OPEN
%token ORDERBY
%token OTHERWISE
%token PAGE
%token PERCENT
%token <string> PERCENTVAR
%token PLUS
%token <[`Left|`Right|`None|`Pre|`Post] -> int -> string -> unit> POSTFIX
%token <string> POSTFIXOP
%token <[`Left|`Right|`None|`Pre|`Post] -> int -> string -> unit> PREFIX
%token <string> PREFIXOP
%token PRESENCE
%token QUERY
%token QUESTION
%token <string> QUOTEDMETA
%token RAISE
%token <char*char> RANGE
%token RARROW
%token RBRACE
%token RBRACKET
%token READONLY
%token RECEIVE
%token <string> REGEXREPL
%token RETURNING
%token RIGHTTRIANGLE
%token ROW
%token RPAREN
%token RQUOTE
%token RXML
%token SELECT
%token SEMICOLON
%token SERVER
%token SET
%token SHALLOWHANDLE
%token SHALLOWHANDLER
%token SIG
%token SLASH
%token <string> SLASHFLAGS
%token SLASHRXML
%token SPAWN
%token SPAWNANGEL
%token SPAWNANGELAT
%token SPAWNAT
%token SPAWNCLIENT
%token SPAWNWAIT
%token SQUIGLOLLI
%token SQUIGRARROW
%token SSLASH
%token STAR
%token <string> STRING
%token SWITCH
%token TABLE
%token TABLEHANDLE
%token TABLEKEYS
%token TILDE
%token TRUE
%token TRY
%token TYPE
%token TYPENAME
%token <float> UFLOAT
%token <int> UINTEGER
%token UNDERSCORE
%token UPDATE
%token VALUES
%token VAR
%token <string> VARIABLE
%token VBAR
%token WHERE
%token WITH
%token YIELDS
%type <Sugartypes.phrase> atomic_expression
%type <(string * Sugartypes.phrase list) list> attr_list
%type <Sugartypes.phrase list> attr_val
%type <Sugartypes.binding> binding
%type <Sugartypes.constant * Sugartypes.position> constant
%type <Sugartypes.datatype> datatype
%type <Sugartypes.binding list * Sugartypes.phrase option> file
%type <Sugartypes.sentence> interactive
%type <Sugartypes.datatype> just_datatype
%type <Sugartypes.pattern> pattern
%type <Sugartypes.phrase> postfix_expression
%type <Sugartypes.phrase> primary_expression
%type <Sugartypes.regex> regex_pattern
%type <Sugartypes.regex> regex_pattern_alternate
%type <Sugartypes.regex list> regex_pattern_sequence
%type <(Sugartypes.name * Sugartypes.position) * Sugartypes.declared_linearity * Sugartypes.funlit * Sugartypes.location * Sugartypes.position> tlfunbinding
%%

interactive:
  _1 = nofun_declaration
    {                                                               ( `Definitions [_1] )}
| _1 = fun_declarations _2 = SEMICOLON
    {                                                               ( `Definitions _1 )}
| _1 = SEMICOLON
    {                                                               ( `Definitions [] )}
| _1 = exp _2 = SEMICOLON
    {                                                               ( `Expression _1 )}
| _1 = directive
    {                                                               ( `Directive _1 )}
| _1 = END
    {                                                               ( `Directive ("quit", []) (* rather hackish *) )}

file:
  _1 = preamble _2 = declarations _3 = exp _4 = END
    {                                                               ( _1 @ _2, Some _3 )}
| _1 = preamble _2 = exp _3 = END
    {                                                               ( _1, Some _2 )}
| _1 = preamble _2 = declarations _3 = END
    {                                                               ( _1 @ _2, None )}

directive:
  _1 = KEYWORD _2 = args _3 = SEMICOLON
    {                                                               ( (_1, _2) )}

args:
  
    {                                                               ( [] )}
| _1 = arg _2 = args
    {                                                               ( _1 :: _2 )}

arg:
  _1 = STRING
    {                                                               ( _1 )}
| _1 = VARIABLE
    {                                                               ( _1 )}
| _1 = CONSTRUCTOR
    {                                                               ( _1 )}
| _1 = UINTEGER
    {                                                               ( string_of_int _1 )}
| _1 = UFLOAT
    {                                                               ( string_of_float' _1 )}
| _1 = TRUE
    {                                                               ( "true" )}
| _1 = FALSE
    {                                                               ( "false" )}

var:
  _1 = VARIABLE
    {                                                               ( _1, pos() )}

preamble:
  
    {                                                               ( [] )}

declarations:
  _1 = declarations _2 = declaration
    {                                                               ( _1 @ [_2] )}
| _1 = declaration
    {                                                               ( [_1] )}

declaration:
  _1 = fun_declaration
    {                                                               ( _1 )}
| _1 = nofun_declaration
    {                                                               ( _1 )}

nofun_declaration:
  _1 = alien_block
    {                                                               ( _1 )}
| _1 = ALIEN _2 = VARIABLE _3 = STRING _4 = var _5 = COLON _6 = datatype _7 = SEMICOLON
    {                                                               ( let (name, name_pos) = _4 in
                                                                   `Foreign ((name, None, name_pos), name, _2, _3, datatype _6), pos() )}
| _1 = fixity _2 = perhaps_uinteger _3 = op _4 = SEMICOLON
    {                                                               ( let assoc, set = _1 in
                                                                   set assoc (from_option default_fixity _2) (fst _3);
                                                                   (`Infix, pos()) )}
| _1 = tlvarbinding _2 = SEMICOLON
    {                                                               ( let ((d,dpos),p,l), pos = _1
                                                                 in `Val ([], (`Variable (d, None, dpos), pos),p,l,None), pos )}
| _1 = signature _2 = tlvarbinding _3 = SEMICOLON
    {                                                               ( annotate _1 (`Var _2) )}
| _1 = typedecl _2 = SEMICOLON
    {                                                               ( _1 )}
| _1 = links_module
    {                                                               ( _1 )}
| _1 = links_open
    {                                                               ( _1 )}

alien_datatype:
  _1 = var _2 = COLON _3 = datatype _4 = SEMICOLON
    {                                                               ( let (name, name_pos) = _1 in
                                                                 ((name, None, name_pos), datatype _3) )}

alien_datatypes:
  _1 = alien_datatype
    {                                                               ( [_1] )}
| _1 = alien_datatype _2 = alien_datatypes
    {                                                               ( _1 :: _2 )}

links_module:
  _1 = MODULE _2 = module_name _3 = moduleblock
    {                                                               ( let (mod_name, name_pos) = _2 in
                                                                 `Module (mod_name, _3), name_pos )}

alien_block:
  _1 = ALIEN _2 = VARIABLE _3 = STRING _4 = LBRACE _5 = alien_datatypes _6 = RBRACE
    {                                                               ( let language = _2 in
                                                                 let library_name = _3 in
                                                                 `AlienBlock (language, library_name, _5), pos () )}

module_name:
  _1 = CONSTRUCTOR
    {                                                               ( _1 , pos () )}

fun_declarations:
  _1 = fun_declarations _2 = fun_declaration
    {                                                               ( _1 @ [_2] )}
| _1 = fun_declaration
    {                                                               ( [_1] )}

fun_declaration:
  _1 = tlfunbinding
    {                                                               ( let ((d,dpos),lin,p,l,pos) = _1
                                                                 in `Fun ((d, None, dpos),lin,([],p),l,None), pos )}
| _1 = signature _2 = tlfunbinding
    {                                                               ( annotate _1 (`Fun _2) )}
| _1 = signature _2 = typed_handler_binding
    {                                                               ( annotate _1 (`Handler _2) )}
| _1 = typed_handler_binding
    {                                                               ( let (b, hnlit, pos) = _1 in
								 `Handler (b, hnlit, None), pos )}

typed_handler_binding:
  _1 = handler_depth _2 = optional_computation_parameter _3 = var _4 = handler_parameterization
    {                                                                            ( let binder = (fst _3, None, snd _3) in
			   						      let hnlit  = (_1, _2, fst _4, snd _4) in
 									      (binder, hnlit, pos()) )}

optional_computation_parameter:
  
    {                                                              ( (`Any, pos()) )}
| _1 = LBRACKET _2 = pattern _3 = RBRACKET
    {                                                              ( _2 )}

perhaps_uinteger:
  
    {                                                               ( None )}
| _1 = UINTEGER
    {                                                               ( Some _1 )}

prefixop:
  _1 = PREFIXOP
    {                                                               ( _1, pos() )}

postfixop:
  _1 = POSTFIXOP
    {                                                               ( _1, pos() )}

tlfunbinding:
  _1 = FUN _2 = var _3 = arg_lists _4 = perhaps_location _5 = block
    {                                                               ( (_2, `Unl, (_3, (`Block _5, pos ())), _4, pos ()) )}
| _1 = LINFUN _2 = var _3 = arg_lists _4 = perhaps_location _5 = block
    {                                                               ( (_2, `Lin, (_3, (`Block _5, pos ())), _4, pos ()) )}
| _1 = OP _2 = pattern _3 = op _4 = pattern _5 = perhaps_location _6 = block
    {                                                               ( (_3, `Unl, ([[_2; _4]], (`Block _6, pos ())), _5, pos ()) )}
| _1 = OP _2 = prefixop _3 = pattern _4 = perhaps_location _5 = block
    {                                                               ( (_2, `Unl, ([[_3]], (`Block _5, pos ())), _4, pos ()) )}
| _1 = OP _2 = pattern _3 = postfixop _4 = perhaps_location _5 = block
    {                                                               ( (_3, `Unl, ([[_2]], (`Block _5, pos ())), _4, pos ()) )}

tlvarbinding:
  _1 = VAR _2 = var _3 = perhaps_location _4 = EQ _5 = exp
    {                                                               ( (_2, _5, _3), pos() )}

signature:
  _1 = SIG _2 = var _3 = COLON _4 = datatype
    {                                                               ( _2, datatype _4 )}
| _1 = SIG _2 = op _3 = COLON _4 = datatype
    {                                                               ( _2, datatype _4 )}

typedecl:
  _1 = TYPENAME _2 = CONSTRUCTOR _3 = typeargs_opt _4 = EQ _5 = datatype
    {                                                               ( `Type (_2, _3, datatype _5), pos()  )}

typeargs_opt:
  
    {                                                               ( [] )}
| _1 = LPAREN _2 = varlist _3 = RPAREN
    {                                                               ( _2 )}

kind:
  _1 = COLONCOLON _2 = CONSTRUCTOR _3 = LPAREN _4 = CONSTRUCTOR _5 = COMMA _6 = CONSTRUCTOR _7 = RPAREN
    {                                                               ( full_kind_of (pos()) _2 _4 _6 )}
| _1 = COLONCOLON _2 = CONSTRUCTOR
    {                                                               ( kind_of (pos()) _2 )}

subkind:
  _1 = COLONCOLON _2 = LPAREN _3 = CONSTRUCTOR _4 = COMMA _5 = CONSTRUCTOR _6 = RPAREN
    {                                                               ( full_subkind_of (pos()) _3 _5 )}
| _1 = COLONCOLON _2 = CONSTRUCTOR
    {                                                               ( subkind_of (pos()) _2 )}

typearg:
  _1 = VARIABLE
    {                                                               ( ((_1, (`Type, None), `Rigid), None) )}
| _1 = VARIABLE _2 = kind
    {                                                               ( (attach_kind (pos()) (_1, _2), None) )}

varlist:
  _1 = typearg
    {                                                               ( [_1] )}
| _1 = typearg _2 = COMMA _3 = varlist
    {                                                               ( _1 :: _3 )}

fixity:
  _1 = INFIX
    {                                                               ( `None, _1 )}
| _1 = INFIXL
    {                                                               ( `Left, _1 )}
| _1 = INFIXR
    {                                                               ( `Right, _1 )}
| _1 = PREFIX
    {                                                               ( `Pre, _1 )}
| _1 = POSTFIX
    {                                                               ( `Post, _1 )}

perhaps_location:
  _1 = SERVER
    {                                                               ( `Server )}
| _1 = CLIENT
    {                                                               ( `Client )}
| _1 = NATIVE
    {                                                               ( `Native )}
| 
    {                                                               ( `Unknown )}

constant:
  _1 = UINTEGER
    {                                                               ( `Int _1    , pos() )}
| _1 = UFLOAT
    {                                                               ( `Float _1  , pos() )}
| _1 = STRING
    {                                                               ( `String _1 , pos() )}
| _1 = TRUE
    {                                                               ( `Bool true , pos() )}
| _1 = FALSE
    {                                                               ( `Bool false, pos() )}
| _1 = CHAR
    {                                                               ( `Char _1   , pos() )}

qualified_name:
  _1 = CONSTRUCTOR _2 = DOT _3 = qualified_name_inner
    {                                                               ( _1 :: _3 )}

qualified_name_inner:
  _1 = CONSTRUCTOR _2 = DOT _3 = qualified_name_inner
    {                                                               ( _1 :: _3 )}
| _1 = VARIABLE
    {                                                               ( [_1] )}

qualified_type_name:
  _1 = CONSTRUCTOR _2 = DOT _3 = qualified_type_name_inner
    {                                                               ( _1 :: _3 )}

qualified_type_name_inner:
  _1 = CONSTRUCTOR _2 = DOT _3 = qualified_type_name_inner
    {                                                               ( _1 :: _3 )}
| _1 = CONSTRUCTOR
    {                                                               ( [_1] )}

atomic_expression:
  _1 = qualified_name
    {                                                               ( `QualifiedVar _1, pos() )}
| _1 = VARIABLE
    {                                                               ( `Var _1, pos() )}
| _1 = constant
    {                                                               ( let c, p = _1 in `Constant c, p )}
| _1 = parenthesized_thing
    {                                                               ( _1 )}
| _1 = RECEIVE
    {                                                               ( `Var "receive", pos() )}

cp_name:
  _1 = VARIABLE
    {                                                               ( _1, None, pos () )}

cp_label:
  _1 = CONSTRUCTOR
    {                                                               ( _1 )}

cp_case:
  _1 = CASE _2 = cp_label _3 = RARROW _4 = cp_expression
    {                                                               ( _2, _4 )}

cp_cases:
  _1 = cp_case
    {                                                               ( [_1] )}
| _1 = cp_case _2 = cp_cases
    {                                                               ( _1 :: _2 )}

perhaps_cp_cases:
  
    {                                                               ( [] )}
| _1 = cp_cases
    {                                                               ( _1 )}

perhaps_name:
  
    {                                                               ( None )}
| _1 = cp_name
    {                                                               ( Some _1 )}

cp_expression:
  _1 = LBRACE _2 = block_contents _3 = RBRACE
    {                                                               ( `Unquote _2, pos () )}
| _1 = cp_name _2 = LPAREN _3 = perhaps_name _4 = RPAREN _5 = DOT _6 = cp_expression
    {                                                               ( `Grab ((fst3 _1, None), _3, _6), pos () )}
| _1 = cp_name _2 = LPAREN _3 = perhaps_name _4 = RPAREN
    {                                                               ( `Grab ((fst3 _1, None), _3, cp_unit(pos())), pos () )}
| _1 = cp_name _2 = LBRACKET _3 = exp _4 = RBRACKET _5 = DOT _6 = cp_expression
    {                                                               ( `Give ((fst3 _1, None), Some _3, _6), pos () )}
| _1 = cp_name _2 = LBRACKET _3 = exp _4 = RBRACKET
    {                                                               ( `Give ((fst3 _1, None), Some _3, cp_unit(pos())), pos () )}
| _1 = cp_name _2 = LBRACKET _3 = RBRACKET
    {                                                               ( `GiveNothing _1, pos () )}
| _1 = OFFER _2 = cp_name _3 = LBRACE _4 = perhaps_cp_cases _5 = RBRACE
    {                                                               ( `Offer (_2, _4), pos () )}
| _1 = cp_label _2 = cp_name _3 = DOT _4 = cp_expression
    {                                                               ( `Select (_2, _1, _4), pos () )}
| _1 = cp_label _2 = cp_name
    {                                                               ( `Select (_2, _1, cp_unit(pos())), pos () )}
| _1 = cp_name _2 = LRARROW _3 = cp_name
    {                                                               ( `Link (_1, _3), pos () )}
| _1 = NU _2 = cp_name _3 = DOT _4 = LPAREN _5 = cp_expression _6 = VBAR _7 = cp_expression _8 = RPAREN
    {                                                                ( `Comp (_2, _5, _7), pos () )}

primary_expression:
  _1 = atomic_expression
    {                                                               ( _1 )}
| _1 = LBRACKET _2 = RBRACKET
    {                                                               ( `ListLit ([], None), pos() )}
| _1 = LBRACKET _2 = exps _3 = RBRACKET
    {                                                               ( `ListLit (_2, None), pos() )}
| _1 = LBRACKET _2 = exp _3 = DOTDOT _4 = exp _5 = RBRACKET
    {                                                               ( `RangeLit(_2, _4), pos() )}
| _1 = xml
    {                                                               ( _1 )}
| _1 = FUN _2 = arg_lists _3 = block
    {                                                               ( `FunLit (None, `Unl, (_2, (`Block _3, pos ())), `Unknown), pos() )}
| _1 = LINFUN _2 = arg_lists _3 = block
    {                                                               ( `FunLit (None, `Lin, (_2, (`Block _3, pos ())), `Unknown), pos() )}
| _1 = LEFTTRIANGLE _2 = cp_expression _3 = RIGHTTRIANGLE
    {                                                               ( `CP _2, pos () )}
| _1 = handler_depth _2 = optional_computation_parameter _3 = handler_parameterization
    {                                                                                     (  let (body, args) = _3 in
										      let hnlit = (_1, _2, body, args) in
											`HandlerLit hnlit, pos() )}

handler_parameterization:
  _1 = handler_body
    {                                       ( (_1, None) )}
| _1 = arg_lists _2 = handler_body
    {                                       ( (_2, Some _1) )}

handler_depth:
  _1 = HANDLER
    {                             ( `Deep )}
| _1 = SHALLOWHANDLER
    {                             ( `Shallow )}

handler_body:
  _1 = LBRACE _2 = cases _3 = RBRACE
    {                                                         ( _2 )}

constructor_expression:
  _1 = CONSTRUCTOR
    {                                                               ( `ConstructorLit(_1, None, None), pos() )}
| _1 = CONSTRUCTOR _2 = parenthesized_thing
    {                                                               ( `ConstructorLit(_1, Some _2, None), pos() )}

parenthesized_thing:
  _1 = LPAREN _2 = binop _3 = RPAREN
    {                                                               ( `Section _2, pos() )}
| _1 = LPAREN _2 = DOT _3 = record_label _4 = RPAREN
    {                                                               ( `Section (`Project _3), pos() )}
| _1 = LPAREN _2 = RPAREN
    {                                                               ( `RecordLit ([], None), pos() )}
| _1 = LPAREN _2 = labeled_exps _3 = VBAR _4 = exp _5 = RPAREN
    {                                                               ( `RecordLit (_2, Some _4), pos() )}
| _1 = LPAREN _2 = labeled_exps _3 = RPAREN
    {                                                               ( `RecordLit (_2, None),               pos() )}
| _1 = LPAREN _2 = exps _3 = RPAREN
    {                                                               ( `TupleLit (_2), pos() )}
| _1 = LPAREN _2 = exp _3 = WITH _4 = labeled_exps _5 = RPAREN
    {                                                               ( `With (_2, _4), pos() )}

binop:
  _1 = MINUS
    {                                                               ( `Minus )}
| _1 = MINUSDOT
    {                                                               ( `FloatMinus )}
| _1 = op
    {                                                               ( `Name (fst _1) )}

op:
  _1 = INFIX0
    {                                                               ( _1, pos() )}
| _1 = INFIXL0
    {                                                               ( _1, pos() )}
| _1 = INFIXR0
    {                                                               ( _1, pos() )}
| _1 = INFIX1
    {                                                               ( _1, pos() )}
| _1 = INFIXL1
    {                                                               ( _1, pos() )}
| _1 = INFIXR1
    {                                                               ( _1, pos() )}
| _1 = INFIX2
    {                                                               ( _1, pos() )}
| _1 = INFIXL2
    {                                                               ( _1, pos() )}
| _1 = INFIXR2
    {                                                               ( _1, pos() )}
| _1 = INFIX3
    {                                                               ( _1, pos() )}
| _1 = INFIXL3
    {                                                               ( _1, pos() )}
| _1 = INFIXR3
    {                                                               ( _1, pos() )}
| _1 = INFIX4
    {                                                               ( _1, pos() )}
| _1 = INFIXL4
    {                                                               ( _1, pos() )}
| _1 = INFIXR4
    {                                                               ( _1, pos() )}
| _1 = INFIX5
    {                                                               ( _1, pos() )}
| _1 = INFIXL5
    {                                                               ( _1, pos() )}
| _1 = INFIXR5
    {                                                               ( _1, pos() )}
| _1 = INFIX6
    {                                                               ( _1, pos() )}
| _1 = INFIXL6
    {                                                               ( _1, pos() )}
| _1 = INFIXR6
    {                                                               ( _1, pos() )}
| _1 = INFIX7
    {                                                               ( _1, pos() )}
| _1 = INFIXL7
    {                                                               ( _1, pos() )}
| _1 = INFIXR7
    {                                                               ( _1, pos() )}
| _1 = INFIX8
    {                                                               ( _1, pos() )}
| _1 = INFIXL8
    {                                                               ( _1, pos() )}
| _1 = INFIXR8
    {                                                               ( _1, pos() )}
| _1 = INFIX9
    {                                                               ( _1, pos() )}
| _1 = INFIXL9
    {                                                               ( _1, pos() )}
| _1 = INFIXR9
    {                                                               ( _1, pos() )}

spawn_expression:
  _1 = SPAWNAT _2 = LPAREN _3 = exp _4 = COMMA _5 = block _6 = RPAREN
    {                                                               ( `Spawn (`Demon, (`ExplicitSpawnLocation _3), (`Block _5, pos()), None), pos () )}
| _1 = SPAWN _2 = block
    {                                                               ( `Spawn (`Demon, `NoSpawnLocation, (`Block _2, pos()), None), pos () )}
| _1 = SPAWNANGELAT _2 = LPAREN _3 = exp _4 = COMMA _5 = block _6 = RPAREN
    {                                                               ( `Spawn (`Angel, (`ExplicitSpawnLocation _3), (`Block _5, pos()), None), pos () )}
| _1 = SPAWNANGEL _2 = block
    {                                                               ( `Spawn (`Angel, `NoSpawnLocation, (`Block _2, pos()), None), pos () )}
| _1 = SPAWNCLIENT _2 = block
    {                                                               ( `Spawn (`Demon, (`SpawnClient), (`Block _2, pos()), None), pos () )}
| _1 = SPAWNWAIT _2 = block
    {                                                               ( `Spawn (`Wait, `NoSpawnLocation, (`Block _2, pos ()), None), pos () )}

postfix_expression:
  _1 = primary_expression
    {                                                               ( _1 )}
| _1 = primary_expression _2 = POSTFIXOP
    {                                                               ( `UnaryAppl (([], `Name _2), _1), pos() )}
| _1 = block
    {                                                               ( `Block _1, pos () )}
| _1 = spawn_expression
    {                                                               ( _1 )}
| _1 = QUERY _2 = block
    {                                                               ( `Query (None, (`Block _2, pos ()), None), pos () )}
| _1 = QUERY _2 = LBRACKET _3 = exp _4 = RBRACKET _5 = block
    {                                                               ( `Query (Some (_3,
                                                                               (`Constant (`Int 0), pos ())),
                                                                         (`Block _5, pos ()), None), pos () )}
| _1 = QUERY _2 = LBRACKET _3 = exp _4 = COMMA _5 = exp _6 = RBRACKET _7 = block
    {                                                               ( `Query (Some (_3, _5), (`Block _7, pos ()), None), pos () )}
| _1 = postfix_expression _2 = arg_spec
    {                                                               ( `FnAppl (_1, _2), pos() )}
| _1 = postfix_expression _2 = DOT _3 = record_label
    {                                                               ( `Projection (_1, _3), pos() )}

arg_spec:
  _1 = LPAREN _2 = RPAREN
    {                                                               ( [] )}
| _1 = LPAREN _2 = exps _3 = RPAREN
    {                                                               ( _2 )}

exps:
  _1 = exp _2 = COMMA _3 = exps
    {                                                               ( _1 :: _3 )}
| _1 = exp
    {                                                               ( [_1] )}

unary_expression:
  _1 = MINUS _2 = unary_expression
    {                                                               ( `UnaryAppl (([], `Minus),      _2), pos() )}
| _1 = MINUSDOT _2 = unary_expression
    {                                                               ( `UnaryAppl (([], `FloatMinus), _2), pos() )}
| _1 = PREFIXOP _2 = unary_expression
    {                                                               ( `UnaryAppl (([], `Name _1), _2), pos() )}
| _1 = postfix_expression
    {                                                               ( _1 )}
| _1 = constructor_expression
    {                                                               ( _1 )}
| _1 = DOOP _2 = CONSTRUCTOR _3 = arg_spec
    {                                                    ( `DoOperation (_2, _3, None), pos() )}
| _1 = DOOP _2 = CONSTRUCTOR
    {                                                               ( `DoOperation (_2, [], None), pos() )}

infixr_9:
  _1 = unary_expression
    {                                                               ( _1 )}
| _1 = unary_expression _2 = INFIX9 _3 = unary_expression
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}
| _1 = unary_expression _2 = INFIXR9 _3 = infixr_9
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}

infixl_9:
  _1 = infixr_9
    {                                                               ( _1 )}
| _1 = infixl_9 _2 = INFIXL9 _3 = infixr_9
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}

infixr_8:
  _1 = infixl_9
    {                                                               ( _1 )}
| _1 = infixl_9 _2 = INFIX8 _3 = infixl_9
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}
| _1 = infixl_9 _2 = INFIXR8 _3 = infixr_8
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}
| _1 = infixl_9 _2 = COLONCOLON _3 = infixr_8
    {                                                               ( `InfixAppl (([], `Cons), _1, _3), pos() )}

infixl_8:
  _1 = infixr_8
    {                                                               ( _1 )}
| _1 = infixl_8 _2 = INFIXL8 _3 = infixr_8
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}

infixr_7:
  _1 = infixl_8
    {                                                               ( _1 )}
| _1 = infixl_8 _2 = INFIX7 _3 = infixl_8
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}
| _1 = infixl_8 _2 = INFIXR7 _3 = infixr_7
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}

infixl_7:
  _1 = infixr_7
    {                                                               ( _1 )}
| _1 = infixl_7 _2 = INFIXL7 _3 = infixr_7
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}

infixr_6:
  _1 = infixl_7
    {                                                               ( _1 )}
| _1 = infixl_7 _2 = INFIX6 _3 = infixl_7
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}
| _1 = infixl_7 _2 = INFIXR6 _3 = infixr_6
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}

infixl_6:
  _1 = infixr_6
    {                                                               ( _1 )}
| _1 = infixl_6 _2 = INFIXL6 _3 = infixr_6
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}
| _1 = infixl_6 _2 = MINUS _3 = infixr_6
    {                                                               ( `InfixAppl (([], `Minus), _1, _3), pos() )}
| _1 = infixl_6 _2 = MINUSDOT _3 = infixr_6
    {                                                               ( `InfixAppl (([], `FloatMinus), _1, _3), pos() )}
| _1 = infixl_6 _2 = BANG _3 = infixr_6
    {                                                               ( `InfixAppl (([], `Name "!"), _1, _3), pos() )}

infixr_5:
  _1 = infixl_6
    {                                                               ( _1 )}
| _1 = infixl_6 _2 = INFIX5 _3 = infixl_6
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}
| _1 = infixl_6 _2 = INFIXR5 _3 = infixr_5
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}

infixl_5:
  _1 = infixr_5
    {                                                               ( _1 )}
| _1 = infixl_5 _2 = INFIXL5 _3 = infixr_5
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}

infixr_4:
  _1 = infixl_5
    {                                                               ( _1 )}
| _1 = infixl_5 _2 = INFIX4 _3 = infixl_5
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}
| _1 = infixl_5 _2 = INFIXR4 _3 = infixr_4
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}
| _1 = infixr_5 _2 = EQUALSTILDE _3 = regex
    {                                                               ( let r, flags = _3 in `InfixAppl (([], `RegexMatch flags), _1, r), pos() )}

infixl_4:
  _1 = infixr_4
    {                                                               ( _1 )}
| _1 = infixl_4 _2 = INFIXL4 _3 = infixr_4
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}

infixr_3:
  _1 = infixl_4
    {                                                               ( _1 )}
| _1 = infixl_4 _2 = INFIX3 _3 = infixl_4
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}
| _1 = infixl_4 _2 = INFIXR3 _3 = infixr_3
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}

infixl_3:
  _1 = infixr_3
    {                                                               ( _1 )}
| _1 = infixl_3 _2 = INFIXL3 _3 = infixr_3
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}

infixr_2:
  _1 = infixl_3
    {                                                               ( _1 )}
| _1 = infixl_3 _2 = INFIX2 _3 = infixl_3
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}
| _1 = infixl_3 _2 = INFIXR2 _3 = infixr_2
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}

infixl_2:
  _1 = infixr_2
    {                                                               ( _1 )}
| _1 = infixl_2 _2 = INFIXL2 _3 = infixr_2
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}

infixr_1:
  _1 = infixl_2
    {                                                               ( _1 )}
| _1 = infixl_2 _2 = INFIX1 _3 = infixl_2
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}
| _1 = infixl_2 _2 = INFIXR1 _3 = infixr_1
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}

infixl_1:
  _1 = infixr_1
    {                                                               ( _1 )}
| _1 = infixl_1 _2 = INFIXL1 _3 = infixr_1
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}

infixr_0:
  _1 = infixl_1
    {                                                               ( _1 )}
| _1 = infixl_1 _2 = INFIX0 _3 = infixl_1
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}
| _1 = infixl_1 _2 = INFIXR0 _3 = infixr_0
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}

infixl_0:
  _1 = infixr_0
    {                                                               ( _1 )}
| _1 = infixl_0 _2 = INFIXL0 _3 = infixr_0
    {                                                               ( `InfixAppl (([], `Name _2), _1, _3), pos() )}

logical_expression:
  _1 = infixl_0
    {                                                               ( _1 )}
| _1 = logical_expression _2 = BARBAR _3 = infixl_0
    {                                                               ( `InfixAppl (([], `Or), _1, _3), pos() )}
| _1 = logical_expression _2 = AMPAMP _3 = infixl_0
    {                                                               ( `InfixAppl (([], `And), _1, _3), pos() )}

typed_expression:
  _1 = logical_expression
    {                                                               ( _1 )}
| _1 = typed_expression _2 = COLON _3 = datatype
    {                                                               ( `TypeAnnotation (_1, datatype _3), pos() )}
| _1 = typed_expression _2 = COLON _3 = datatype _4 = LARROW _5 = datatype
    {                                                               ( `Upcast (_1, datatype _3, datatype _5), pos() )}

db_expression:
  _1 = typed_expression
    {                                                               ( _1 )}
| _1 = DELETE _2 = LPAREN _3 = table_generator _4 = RPAREN _5 = perhaps_where
    {                                                               ( let pat, phrase = _3 in `DBDelete (pat, phrase, _5), pos() )}
| _1 = UPDATE _2 = LPAREN _3 = table_generator _4 = RPAREN _5 = perhaps_where _6 = SET _7 = LPAREN _8 = labeled_exps _9 = RPAREN
    {                                                               ( let pat, phrase = _3 in `DBUpdate(pat, phrase, _5, _8), pos() )}

xml:
  _1 = xml_tree
    {                                                               ( _1 )}

xmlid:
  _1 = VARIABLE
    {                                                               ( _1 )}

attrs:
  _1 = block
    {                                                               ( [], Some (`Block _1, pos ()) )}
| _1 = attr_list
    {                                                               ( _1, None )}
| _1 = attr_list _2 = block
    {                                                               ( _1, Some (`Block _2, pos ()) )}

attr_list:
  _1 = attr
    {                                                               ( [_1] )}
| _1 = attr_list _2 = attr
    {                                                               ( _2 :: _1 )}

attr:
  _1 = xmlid _2 = EQ _3 = LQUOTE _4 = attr_val _5 = RQUOTE
    {                                                               ( (_1, _4) )}
| _1 = xmlid _2 = EQ _3 = LQUOTE _4 = RQUOTE
    {                                                               ( (_1, [(`Constant (`String ""), pos() : Sugartypes.phrase)]) )}

attr_val:
  _1 = block
    {                                                               ( [`Block _1, pos ()] )}
| _1 = STRING
    {                                                               ( [`Constant (`String _1), pos()] )}
| _1 = block _2 = attr_val
    {                                                               ( (`Block _1, pos ()) :: _2 )}
| _1 = STRING _2 = attr_val
    {                                                               ( (`Constant (`String _1), pos()) :: _2)}

xml_tree:
  _1 = LXML _2 = SLASHRXML
    {                                                               ( `Xml (_1, [], None, []), pos() )}
| _1 = LXML _2 = RXML _3 = ENDTAG
    {                                                               ( ensure_match (pos()) _1 _3 (`Xml (_1, [], None, []), pos()) )}
| _1 = LXML _2 = RXML _3 = xml_contents_list _4 = ENDTAG
    {                                                               ( ensure_match (pos()) _1 _4 (`Xml (_1, [], None, _3), pos()) )}
| _1 = LXML _2 = attrs _3 = RXML _4 = ENDTAG
    {                                                               ( ensure_match (pos()) _1 _4 (`Xml (_1, fst _2, snd _2, []), pos()) )}
| _1 = LXML _2 = attrs _3 = SLASHRXML
    {                                                               ( `Xml (_1, fst _2, snd _2, []), pos() )}
| _1 = LXML _2 = attrs _3 = RXML _4 = xml_contents_list _5 = ENDTAG
    {                                                               ( ensure_match (pos()) _1 _5 (`Xml (_1, fst _2, snd _2, _4), pos()) )}

xml_contents_list:
  _1 = xml_contents
    {                                                               ( [_1] )}
| _1 = xml_contents _2 = xml_contents_list
    {                                                               ( _1 :: _2 )}

xml_contents:
  _1 = block
    {                                                               ( `Block _1, pos () )}
| _1 = formlet_binding
    {                                                               ( _1 )}
| _1 = formlet_placement
    {                                                               ( _1 )}
| _1 = page_placement
    {                                                               ( _1 )}
| _1 = xml_tree
    {                                                               ( _1 )}
| _1 = CDATA
    {                                                               ( `TextNode (Utility.xml_unescape _1), pos() )}

formlet_binding:
  _1 = LBRACE _2 = logical_expression _3 = RARROW _4 = pattern _5 = RBRACE
    {                                                               ( `FormBinding(_2, _4), pos())}

formlet_placement:
  _1 = LBRACE _2 = logical_expression _3 = FATRARROW _4 = logical_expression _5 = RBRACE
    {                                                               ( `FormletPlacement (_2, _4, (`ListLit ([], None), pos())), pos () )}
| _1 = LBRACE _2 = logical_expression _3 = FATRARROW _4 = logical_expression _5 = WITH _6 = logical_expression _7 = RBRACE
    {                                                               ( `FormletPlacement (_2, _4, _6), pos () )}

page_placement:
  _1 = LBRACEBAR _2 = exp _3 = BARRBRACE
    {                                                               ( `PagePlacement _2, pos() )}

session_expression:
  _1 = db_expression
    {                                                               ( _1 )}
| _1 = SELECT _2 = field_label _3 = exp
    {                                                               ( `Select (_2, _3) , pos() )}
| _1 = OFFER _2 = LPAREN _3 = exp _4 = RPAREN _5 = LBRACE _6 = perhaps_cases _7 = RBRACE
    {                                                               ( `Offer (_3, _6, None) , pos() )}

conditional_expression:
  _1 = session_expression
    {                                                               ( _1 )}
| _1 = IF _2 = LPAREN _3 = exp _4 = RPAREN _5 = exp _6 = ELSE _7 = exp
    {                                                               ( `Conditional (_3, _5, _7), pos() )}

cases:
  _1 = case
    {                                                               ( [_1] )}
| _1 = case _2 = cases
    {                                                               ( _1 :: _2 )}

case:
  _1 = CASE _2 = pattern _3 = RARROW _4 = block_contents
    {                                                               ( _2, (`Block (_4), pos()) )}

perhaps_cases:
  
    {                                                               ( [] )}
| _1 = cases
    {                                                               ( _1 )}

case_expression:
  _1 = conditional_expression
    {                                                               ( _1 )}
| _1 = SWITCH _2 = LPAREN _3 = exp _4 = RPAREN _5 = LBRACE _6 = perhaps_cases _7 = RBRACE
    {                                                               ( `Switch (_3, _6, None), pos() )}
| _1 = RECEIVE _2 = LBRACE _3 = perhaps_cases _4 = RBRACE
    {                                                               ( `Receive (_3, None), pos() )}
| _1 = SHALLOWHANDLE _2 = LPAREN _3 = exp _4 = RPAREN _5 = LBRACE _6 = cases _7 = RBRACE
    {                                                               ( `Handle (make_untyped_handler _3 _6 `Shallow), pos() )}
| _1 = HANDLE _2 = LPAREN _3 = exp _4 = RPAREN _5 = LBRACE _6 = perhaps_cases _7 = RBRACE
    {                                                                       ( `Handle (make_untyped_handler _3 _6 `Deep), pos() )}
| _1 = HANDLE _2 = LPAREN _3 = exp _4 = RPAREN _5 = LPAREN _6 = handle_params _7 = RPAREN _8 = LBRACE _9 = perhaps_cases _10 = RBRACE
    {                                                                                   ( `Handle (make_untyped_handler ~parameters:(List.rev _6) _3 _9 `Deep), pos() )}
| _1 = RAISE
    {                                                               ( `Raise, pos () )}
| _1 = TRY _2 = exp _3 = AS _4 = pattern _5 = IN _6 = exp _7 = OTHERWISE _8 = exp
    {                                                               ( `TryInOtherwise (_2, _4, _6, _8, None), pos () )}

handle_params:
  _1 = logical_expression _2 = RARROW _3 = pattern
    {                                    ( [(_1, _3)] )}
| _1 = handle_params _2 = COMMA _3 = logical_expression _4 = RARROW _5 = pattern
    {                                                         ( (_3,_5) :: _1 )}

iteration_expression:
  _1 = case_expression
    {                                                               ( _1 )}
| _1 = FOR _2 = LPAREN _3 = perhaps_generators _4 = RPAREN _5 = perhaps_where _6 = perhaps_orderby _7 = exp
    {                                                               ( `Iteration (_3, _7, _5, _6), pos() )}

perhaps_generators:
  
    {                                                               ( [] )}
| _1 = generators
    {                                                               ( _1 )}

generators:
  _1 = generator
    {                                                               ( [_1] )}
| _1 = generator _2 = COMMA _3 = generators
    {                                                               ( _1 :: _3 )}

generator:
  _1 = list_generator
    {                                                               ( `List _1 )}
| _1 = table_generator
    {                                                               ( `Table _1 )}

list_generator:
  _1 = pattern _2 = LARROW _3 = exp
    {                                                               ( (_1, _3) )}

table_generator:
  _1 = pattern _2 = LLARROW _3 = exp
    {                                                               ( (_1, _3) )}

perhaps_where:
  
    {                                                               ( None )}
| _1 = WHERE _2 = LPAREN _3 = exp _4 = RPAREN
    {                                                               ( Some _3 )}

perhaps_orderby:
  
    {                                                               ( None )}
| _1 = ORDERBY _2 = LPAREN _3 = exps _4 = RPAREN
    {                                                               ( Some (make_tuple (pos()) _3) )}

escape_expression:
  _1 = iteration_expression
    {                                                               ( _1 )}
| _1 = ESCAPE _2 = var _3 = IN _4 = postfix_expression
    {                                                               ( `Escape ((fst _2, None, snd _2), _4), pos() )}

formlet_expression:
  _1 = escape_expression
    {                                                               ( _1 )}
| _1 = FORMLET _2 = xml _3 = YIELDS _4 = exp
    {                                                               ( `Formlet (_2, _4), pos() )}
| _1 = PAGE _2 = xml
    {                                                               ( `Page (_2), pos() )}

table_expression:
  _1 = formlet_expression
    {                                                               ( _1 )}
| _1 = TABLE _2 = exp _3 = WITH _4 = datatype _5 = perhaps_table_constraints _6 = FROM _7 = exp
    {                                                               ( `TableLit (_2, datatype _4, _5, (`ListLit ([], None),pos()), _7), pos())}
| _1 = TABLE _2 = exp _3 = WITH _4 = datatype _5 = perhaps_table_constraints _6 = TABLEKEYS _7 = exp _8 = FROM _9 = exp
    {                                                                             ( `TableLit (_2, datatype _4, _5, _7, _9), pos())}

perhaps_table_constraints:
  _1 = WHERE _2 = table_constraints
    {                                                               ( _2 )}
| 
    {                                                               ( [] )}

table_constraints:
  _1 = record_label _2 = field_constraints
    {                                                               ( [(_1, _2)] )}
| _1 = record_label _2 = field_constraints _3 = COMMA _4 = table_constraints
    {                                                               ( (_1, _2) :: _4 )}

field_constraints:
  _1 = field_constraint
    {                                                               ( [_1] )}
| _1 = field_constraint _2 = field_constraints
    {                                                               ( _1 :: _2 )}

field_constraint:
  _1 = READONLY
    {                                                               ( `Readonly )}
| _1 = DEFAULT
    {                                                               ( `Default )}

perhaps_db_args:
  _1 = atomic_expression
    {                                                               ( Some _1 )}
| 
    {                                                               ( None )}

perhaps_db_driver:
  _1 = atomic_expression _2 = perhaps_db_args
    {                                                               ( Some _1, _2 )}
| 
    {                                                               ( None, None )}

database_expression:
  _1 = table_expression
    {                                                               ( _1 )}
| _1 = INSERT _2 = exp _3 = VALUES _4 = LPAREN _5 = RPAREN _6 = exp
    {                                                               ( `DBInsert (_2, [], _6, None), pos() )}
| _1 = INSERT _2 = exp _3 = VALUES _4 = LPAREN _5 = record_labels _6 = RPAREN _7 = exp
    {                                                               ( `DBInsert (_2, _5, _7, None), pos() )}
| _1 = INSERT _2 = exp _3 = VALUES _4 = LBRACKET _5 = LPAREN _6 = labeled_exps _7 = RPAREN _8 = RBRACKET
    {                                                               ( `DBInsert (_2,
                                                                            labels _6,
                                                                            (`ListLit ([`RecordLit (_6, None), pos()], None), pos()),
                                                                            None),
                                                                 pos() )}
| _1 = INSERT _2 = exp _3 = VALUES _4 = LPAREN _5 = RPAREN _6 = db_expression _7 = RETURNING _8 = VARIABLE
    {                                                               ( `DBInsert (_2, [], _6, Some (`Constant (`String _8), pos())), pos() )}
| _1 = INSERT _2 = exp _3 = VALUES _4 = LPAREN _5 = record_labels _6 = RPAREN _7 = db_expression _8 = RETURNING _9 = VARIABLE
    {                                                               ( `DBInsert (_2, _5, _7, Some (`Constant (`String _9), pos())), pos() )}
| _1 = INSERT _2 = exp _3 = VALUES _4 = LBRACKET _5 = LPAREN _6 = RPAREN _7 = RBRACKET _8 = RETURNING _9 = VARIABLE
    {                                                               ( `DBInsert (_2,
                                                                            [],
                                                                            (`ListLit ([`RecordLit ([], None), pos()], None), pos()),
                                                                            Some (`Constant (`String _9), pos())),
                                                                 pos() )}
| _1 = INSERT _2 = exp _3 = VALUES _4 = LBRACKET _5 = LPAREN _6 = labeled_exps _7 = RPAREN _8 = RBRACKET _9 = RETURNING _10 = VARIABLE
    {                                                               ( `DBInsert (_2,
                                                                            labels _6,
                                                                            (`ListLit ([`RecordLit (_6, None), pos()], None), pos()),
                                                                            Some (`Constant (`String _10), pos())),
                                                                 pos() )}
| _1 = DATABASE _2 = atomic_expression _3 = perhaps_db_driver
    {                                                               ( `DatabaseLit (_2, _3), pos() )}

fn_dep_cols:
  _1 = VARIABLE
    {                                                               ( [_1] )}
| _1 = VARIABLE _2 = fn_dep_cols
    {                                                               ( _1 :: _2 )}

fn_dep:
  _1 = fn_dep_cols _2 = RARROW _3 = fn_dep_cols
    {                                                               ( (_1, _3) )}

fn_deps:
  _1 = fn_dep
    {                                                               ( [ _1 ] )}
| _1 = fn_dep _2 = COMMA _3 = fn_deps
    {                                                               ( _1 :: _3 )}

lens_expression:
  _1 = database_expression
    {                                                               ( _1 )}
| _1 = LENS _2 = exp _3 = DEFAULT
    {                                                               ( `LensLit (_2, None), pos())}
| _1 = LENS _2 = exp _3 = TABLEKEYS _4 = exp
    {                                                               ( `LensKeysLit (_2, _4, None), pos())}
| _1 = LENS _2 = exp _3 = WITH _4 = LBRACE _5 = fn_deps _6 = RBRACE
    {                                                               ( `LensFunDepsLit (_2, _5, None), pos())}
| _1 = LENSDROP _2 = VARIABLE _3 = DETERMINED _4 = BY _5 = VARIABLE _6 = DEFAULT _7 = exp _8 = FROM _9 = exp
    {                                                               ( `LensDropLit (_9, _2, _5, _7, None), pos() )}
| _1 = LENSSELECT _2 = FROM _3 = exp _4 = BY _5 = exp
    {                                                            ( `LensSelectLit (_3, _5, None), pos() )}
| _1 = LENSJOIN _2 = exp _3 = WITH _4 = exp _5 = ON _6 = exp _7 = DELETE _8 = LBRACE _9 = exp _10 = COMMA _11 = exp _12 = RBRACE
    {                                                                   ( `LensJoinLit (_2, _4, _6, _9, _11, None), pos() )}
| _1 = LENSJOIN _2 = exp _3 = WITH _4 = exp _5 = ON _6 = exp _7 = DELETE_LEFT
    {                                                               ( `LensJoinLit (_2, _4, _6, (`Constant (`Bool true), pos()), (`Constant (`Bool false), pos()), None), pos() )}
| _1 = LENSGET _2 = exp
    {                                                               ( `LensGetLit (_2, None), pos() )}
| _1 = LENSPUT _2 = exp _3 = WITH _4 = exp
    {                                                               ( `LensPutLit (_2, _4, None), pos() )}

record_labels:
  _1 = record_label _2 = COMMA _3 = record_labels
    {                                                               ( _1 :: _3 )}
| _1 = record_label
    {                                                               ( [_1] )}

links_open:
  _1 = OPEN _2 = qualified_type_name
    {                                                               ( `QualifiedImport _2, pos () )}
| _1 = OPEN _2 = CONSTRUCTOR
    {                                                               ( `QualifiedImport [_2], pos () )}

binding:
  _1 = VAR _2 = pattern _3 = EQ _4 = exp _5 = SEMICOLON
    {                                                               ( `Val ([], _2, _4, `Unknown, None), pos () )}
| _1 = exp _2 = SEMICOLON
    {                                                               ( `Exp _1, pos () )}
| _1 = signature _2 = FUN _3 = var _4 = arg_lists _5 = block
    {                                                               (  annotate _1 (`Fun (_3, `Unl, (_4, (`Block _5, pos ())), `Unknown, pos ())) )}
| _1 = signature _2 = LINFUN _3 = var _4 = arg_lists _5 = block
    {                                                               (  annotate _1 (`Fun (_3, `Lin, (_4, (`Block _5, pos ())), `Unknown, pos ())) )}
| _1 = FUN _2 = var _3 = arg_lists _4 = block
    {                                                               ( `Fun ((fst _2, None, snd _2), `Unl, ([], (_3, (`Block _4, pos ()))), `Unknown, None), pos () )}
| _1 = LINFUN _2 = var _3 = arg_lists _4 = block
    {                                                               ( `Fun ((fst _2, None, snd _2), `Lin, ([], (_3, (`Block _4, pos ()))), `Unknown, None), pos () )}
| _1 = typedecl _2 = SEMICOLON
    {                                                               ( _1 )}
| _1 = typed_handler_binding
    {                                                               ( let (b, hnlit, pos) = _1 in
                                                                 `Handler (b, hnlit, None), pos )}
| _1 = links_module
    {                                                               ( _1 )}
| _1 = alien_block
    {                                                               ( _1 )}
| _1 = links_open
    {                                                               ( _1 )}

bindings:
  _1 = binding
    {                                                               ( [_1] )}
| _1 = bindings _2 = binding
    {                                                               ( _1 @ [_2] )}

moduleblock:
  _1 = LBRACE _2 = declarations _3 = RBRACE
    {                                                               ( _2 )}

block:
  _1 = LBRACE _2 = block_contents _3 = RBRACE
    {                                                               ( _2 )}

block_contents:
  _1 = bindings _2 = exp _3 = SEMICOLON
    {                                                               ( (_1 @ [`Exp _2, pos ()], (`RecordLit ([], None), pos())) )}
| _1 = bindings _2 = exp
    {                                                               ( (_1, _2) )}
| _1 = exp _2 = SEMICOLON
    {                                                               ( ([`Exp _1, pos ()], (`RecordLit ([], None), pos())) )}
| _1 = exp
    {                                                               ( [], _1 )}
| _1 = perhaps_semi
    {                                                               ( ([], (`TupleLit [], pos())) )}

perhaps_semi:
  _1 = SEMICOLON
    {                                                               ()}
| 
    {                                                               ()}

exp:
  _1 = lens_expression
    {                                                               ( _1 )}

labeled_exps:
  _1 = record_label _2 = EQ _3 = exp
    {                                                               ( [_1, _3] )}
| _1 = record_label _2 = EQ _3 = exp _4 = COMMA _5 = labeled_exps
    {                                                               ( (_1, _3) :: _5 )}

just_datatype:
  _1 = datatype _2 = END
    {                                                               ( _1 )}

datatype:
  _1 = mu_datatype
    {                                                               ( _1 )}
| _1 = straight_arrow
    {                                                               ( _1 )}
| _1 = squiggly_arrow
    {                                                               ( _1 )}

arrow_prefix:
  _1 = LBRACE _2 = RBRACE
    {                                                               ( ([], `Closed) )}
| _1 = LBRACE _2 = efields _3 = RBRACE
    {                                                               ( _2 )}

straight_arrow_prefix:
  _1 = arrow_prefix
    {                                                               ( _1 )}
| _1 = MINUS _2 = nonrec_row_var
    {                                                               ( ([], _2) )}
| _1 = MINUS _2 = kinded_nonrec_row_var
    {                                                               ( ([], _2) )}

squig_arrow_prefix:
  _1 = hear_arrow_prefix
    {                                                               ( _1 )}
| _1 = arrow_prefix
    {                                                               ( _1 )}
| _1 = TILDE _2 = nonrec_row_var
    {                                                               ( ([], _2) )}
| _1 = TILDE _2 = kinded_nonrec_row_var
    {                                                               ( ([], _2) )}

hear_arrow_prefix:
  _1 = LBRACE _2 = COLON _3 = datatype _4 = COMMA _5 = efields _6 = RBRACE
    {                                                               ( row_with
                                                                   ("wild", `Present `Unit)
                                                                   (row_with
                                                                      ("hear", `Present _3)
                                                                      _5) )}
| _1 = LBRACE _2 = COLON _3 = datatype _4 = RBRACE
    {                                                               ( ([("wild", `Present `Unit);
                                                                   ("hear", `Present _3)],
                                                                  `Closed) )}
| _1 = LBRACE _2 = COLON _3 = datatype _4 = VBAR _5 = nonrec_row_var _6 = RBRACE
    {                                                               ( ([("wild", `Present `Unit);
                                                                   ("hear", `Present _3)],
                                                                  _5) )}
| _1 = LBRACE _2 = COLON _3 = datatype _4 = VBAR _5 = kinded_nonrec_row_var _6 = RBRACE
    {                                                               ( ([("wild", `Present `Unit);
                                                                   ("hear", `Present _3)],
                                                                  _5) )}

straight_arrow:
  _1 = parenthesized_datatypes _2 = straight_arrow_prefix _3 = RARROW _4 = datatype
    {                                                               ( `Function (_1, _2, _4) )}
| _1 = parenthesized_datatypes _2 = straight_arrow_prefix _3 = LOLLI _4 = datatype
    {                                                               ( `Lolli (_1, _2, _4) )}
| _1 = parenthesized_datatypes _2 = RARROW _3 = datatype
    {                                                               ( `Function (_1,
                                                                               ([], fresh_rigid_row_variable None),
                                                                               _3) )}
| _1 = parenthesized_datatypes _2 = LOLLI _3 = datatype
    {                                                               ( `Lolli (_1, ([], fresh_rigid_row_variable None), _3) )}

squiggly_arrow:
  _1 = parenthesized_datatypes _2 = squig_arrow_prefix _3 = SQUIGRARROW _4 = datatype
    {                                                               ( `Function (_1,
                                                                               row_with
                                                                                 ("wild", `Present `Unit)
                                                                                 _2,
                                                                               _4) )}
| _1 = parenthesized_datatypes _2 = squig_arrow_prefix _3 = SQUIGLOLLI _4 = datatype
    {                                                               ( `Lolli (_1,
                                                                            row_with
                                                                              ("wild", `Present `Unit)
                                                                            _2,
                                                                            _4) )}
| _1 = parenthesized_datatypes _2 = SQUIGRARROW _3 = datatype
    {                                                               ( `Function (_1,
                                                                               ([("wild", `Present `Unit)],
                                                                                 fresh_rigid_row_variable None),
                                                                                _3) )}
| _1 = parenthesized_datatypes _2 = SQUIGLOLLI _3 = datatype
    {                                                               ( `Lolli (_1,
                                                                            ([("wild", `Present `Unit)],
                                                                             fresh_rigid_row_variable None),
                                                                            _3) )}

mu_datatype:
  _1 = MU _2 = VARIABLE _3 = DOT _4 = mu_datatype
    {                                                               ( `Mu (_2, _4) )}
| _1 = forall_datatype
    {                                                               ( _1 )}

forall_datatype:
  _1 = FORALL _2 = varlist _3 = DOT _4 = datatype
    {                                                               ( `Forall (List.map fst _2, _4) )}
| _1 = session_datatype
    {                                                               ( _1 )}

session_datatype:
  _1 = BANG _2 = datatype _3 = DOT _4 = datatype
    {                                                               ( `Output (_2, _4) )}
| _1 = QUESTION _2 = datatype _3 = DOT _4 = datatype
    {                                                               ( `Input (_2, _4) )}
| _1 = LBRACKETPLUSBAR _2 = row _3 = BARPLUSRBRACKET
    {                                                               ( `Select _2 )}
| _1 = LBRACKETAMPBAR _2 = row _3 = BARAMPRBRACKET
    {                                                               ( `Choice _2 )}
| _1 = TILDE _2 = datatype
    {                                                               ( `Dual _2 )}
| _1 = END
    {                                                               ( `End )}
| _1 = primary_datatype
    {                                                               ( _1 )}

parenthesized_datatypes:
  _1 = LPAREN _2 = RPAREN
    {                                                               ( [] )}
| _1 = LPAREN _2 = qualified_type_name _3 = RPAREN
    {                                                               ( [`QualifiedTypeApplication (_2, [])] )}
| _1 = LPAREN _2 = datatypes _3 = RPAREN
    {                                                               ( _2 )}

primary_datatype:
  _1 = parenthesized_datatypes
    {                                                               ( match _1 with
                                                                   | [] -> `Unit
                                                                   | [t] -> t
                                                                   | ts  -> `Tuple ts )}
| _1 = LPAREN _2 = rfields _3 = RPAREN
    {                                                               ( `Record _2 )}
| _1 = TABLEHANDLE _2 = LPAREN _3 = datatype _4 = COMMA _5 = datatype _6 = COMMA _7 = datatype _8 = RPAREN
    {                                                               ( `Table (_3, _5, _7) )}
| _1 = LBRACKETBAR _2 = vrow _3 = BARRBRACKET
    {                                                               ( `Variant _2 )}
| _1 = LBRACKET _2 = datatype _3 = RBRACKET
    {                                                               ( `List _2 )}
| _1 = type_var
    {                                                               ( _1 )}
| _1 = kinded_type_var
    {                                                               ( _1 )}
| _1 = CONSTRUCTOR
    {                                                               ( match _1 with
                                                                   | "Bool"    -> `Primitive `Bool
                                                                   | "Int"     -> `Primitive `Int
                                                                   | "Char"    -> `Primitive `Char
                                                                   | "Float"   -> `Primitive `Float
                                                                   | "XmlItem" -> `Primitive `XmlItem
                                                                   | "String"  -> `Primitive `String
                                                                   | "Database"-> `DB
                                                                   | t         -> `TypeApplication (t, [])
                                                               )}
| _1 = CONSTRUCTOR _2 = LPAREN _3 = type_arg_list _4 = RPAREN
    {                                                               ( `TypeApplication (_1, _3) )}

type_var:
  _1 = VARIABLE
    {                                                               ( `TypeVar (_1, None, `Rigid) )}
| _1 = PERCENTVAR
    {                                                               ( `TypeVar (_1, None, `Flexible) )}
| _1 = UNDERSCORE
    {                                                               ( fresh_rigid_type_variable None )}
| _1 = PERCENT
    {                                                               ( fresh_type_variable None )}

kinded_type_var:
  _1 = type_var _2 = subkind
    {                                                               ( attach_subkind (pos()) (_1, _2) )}

type_arg_list:
  _1 = type_arg
    {                                                               ( [_1] )}
| _1 = type_arg _2 = COMMA _3 = type_arg_list
    {                                                               ( _1 :: _3 )}

type_arg:
  _1 = datatype
    {                                                               ( `Type _1 )}
| _1 = TYPE _2 = LPAREN _3 = datatype _4 = RPAREN
    {                                                               ( `Type _3 )}
| _1 = ROW _2 = LPAREN _3 = row _4 = RPAREN
    {                                                               ( `Row _3 )}
| _1 = PRESENCE _2 = LPAREN _3 = fieldspec _4 = RPAREN
    {                                                               ( `Presence _3 )}
| _1 = LBRACE _2 = row _3 = RBRACE
    {                                                               ( `Row _2 )}

vrow:
  _1 = vfields
    {                                                               ( _1 )}
| 
    {                                                               ( [], `Closed )}

datatypes:
  _1 = datatype
    {                                                               ( [_1] )}
| _1 = datatype _2 = COMMA _3 = datatypes
    {                                                               ( _1 :: _3 )}

row:
  _1 = fields
    {                                                               ( _1 )}
| 
    {                                                               ( [], `Closed )}

fields:
  _1 = field
    {                                                               ( [_1], `Closed )}
| _1 = field _2 = VBAR _3 = row_var
    {                                                               ( [_1], _3 )}
| _1 = field _2 = VBAR _3 = kinded_row_var
    {                                                               ( [_1], _3 )}
| _1 = VBAR _2 = row_var
    {                                                               ( [], _2 )}
| _1 = VBAR _2 = kinded_row_var
    {                                                               ( [], _2 )}
| _1 = field _2 = COMMA _3 = fields
    {                                                               ( _1 :: fst _3, snd _3 )}

field:
  _1 = field_label
    {                                                               ( _1, `Present `Unit )}
| _1 = field_label _2 = fieldspec
    {                                                               ( _1, _2 )}

field_label:
  _1 = CONSTRUCTOR
    {                                                               ( _1 )}
| _1 = VARIABLE
    {                                                               ( _1 )}
| _1 = STRING
    {                                                               ( _1 )}
| _1 = UINTEGER
    {                                                               ( string_of_int _1 )}

rfields:
  _1 = rfield
    {                                                               ( [_1], `Closed )}
| _1 = rfield _2 = VBAR _3 = row_var
    {                                                               ( [_1], _3 )}
| _1 = rfield _2 = VBAR _3 = kinded_row_var
    {                                                               ( [_1], _3 )}
| _1 = VBAR _2 = row_var
    {                                                               ( [], _2 )}
| _1 = VBAR _2 = kinded_row_var
    {                                                               ( [], _2 )}
| _1 = rfield _2 = COMMA _3 = rfields
    {                                                               ( _1 :: fst _3, snd _3 )}

rfield:
  _1 = record_label _2 = fieldspec
    {                                                               ( _1, _2 )}

record_label:
  _1 = field_label
    {                                                               ( _1 )}

vfields:
  _1 = vfield
    {                                                               ( [_1], `Closed )}
| _1 = row_var
    {                                                               ( [], _1 )}
| _1 = kinded_row_var
    {                                                               ( [], _1 )}
| _1 = vfield _2 = VBAR _3 = vfields
    {                                                               ( _1 :: fst _3, snd _3 )}

vfield:
  _1 = CONSTRUCTOR
    {                                                               ( _1, `Present `Unit )}
| _1 = CONSTRUCTOR _2 = fieldspec
    {                                                               ( _1, _2 )}

efields:
  _1 = efield
    {                                                               ( [_1], `Closed )}
| _1 = efield _2 = VBAR _3 = nonrec_row_var
    {                                                               ( [_1], _3 )}
| _1 = efield _2 = VBAR _3 = kinded_nonrec_row_var
    {                                                               ( [_1], _3 )}
| _1 = VBAR _2 = nonrec_row_var
    {                                                               ( [], _2 )}
| _1 = VBAR _2 = kinded_nonrec_row_var
    {                                                               ( [], _2 )}
| _1 = efield _2 = COMMA _3 = efields
    {                                                               ( _1 :: fst _3, snd _3 )}

efield:
  _1 = effect_label
    {                                                               ( _1, `Present `Unit )}
| _1 = effect_label _2 = fieldspec
    {                                                               ( _1, _2 )}

effect_label:
  _1 = CONSTRUCTOR
    {                                                               ( _1 )}
| _1 = VARIABLE
    {                                                               ( _1 )}

fieldspec:
  _1 = COLON _2 = datatype
    {                                                               ( `Present _2 )}
| _1 = LBRACE _2 = COLON _3 = datatype _4 = RBRACE
    {                                                               ( `Present _3 )}
| _1 = MINUS
    {                                                               ( `Absent )}
| _1 = LBRACE _2 = MINUS _3 = RBRACE
    {                                                               ( `Absent )}
| _1 = LBRACE _2 = VARIABLE _3 = RBRACE
    {                                                               ( `Var (_2, None, `Rigid) )}
| _1 = LBRACE _2 = PERCENTVAR _3 = RBRACE
    {                                                               ( `Var (_2, None, `Flexible) )}
| _1 = LBRACE _2 = UNDERSCORE _3 = RBRACE
    {                                                               ( fresh_rigid_presence_variable None )}
| _1 = LBRACE _2 = PERCENT _3 = RBRACE
    {                                                               ( fresh_presence_variable None )}

nonrec_row_var:
  _1 = VARIABLE
    {                                                               ( `Open (_1, None, `Rigid) )}
| _1 = PERCENTVAR
    {                                                               ( `Open (_1, None, `Flexible) )}
| _1 = UNDERSCORE
    {                                                               ( fresh_rigid_row_variable None )}
| _1 = PERCENT
    {                                                               ( fresh_row_variable None )}

row_var:
  _1 = nonrec_row_var
    {                                                               ( _1 )}
| _1 = LPAREN _2 = MU _3 = VARIABLE _4 = DOT _5 = vfields _6 = RPAREN
    {                                                               ( `Recursive (_3, _5) )}

kinded_nonrec_row_var:
  _1 = nonrec_row_var _2 = subkind
    {                                                               ( attach_row_subkind (pos()) (_1, _2) )}

kinded_row_var:
  _1 = row_var _2 = subkind
    {                                                               ( attach_row_subkind (pos()) (_1, _2) )}

regex:
  _1 = SLASH _2 = regex_pattern_alternate _3 = regex_flags_opt
    {                                                                                 ( (`Regex _2, pos()), _3 )}
| _1 = SLASH _2 = regex_flags_opt
    {                                                                                 ( (`Regex (`Simply ""), pos()), _2 )}
| _1 = SSLASH _2 = regex_pattern_alternate _3 = SLASH _4 = regex_replace _5 = regex_flags_opt
    {                                                                                 ( (`Regex (`Replace (_2, _4)), pos()), `RegexReplace :: _5 )}

regex_flags_opt:
  _1 = SLASH
    {                                                               ([])}
| _1 = SLASHFLAGS
    {                                                               (parseRegexFlags _1)}

regex_replace:
  
    {                                                               ( `Literal "")}
| _1 = REGEXREPL
    {                                                               ( `Literal _1)}
| _1 = block
    {                                                               ( `Splice (`Block _1, pos ()) )}

regex_pattern:
  _1 = RANGE
    {                                                               ( `Range _1 )}
| _1 = STRING
    {                                                               ( `Simply _1 )}
| _1 = QUOTEDMETA
    {                                                               ( `Quote (`Simply _1) )}
| _1 = DOT
    {                                                               ( `Any )}
| _1 = CARET
    {                                                               ( `StartAnchor )}
| _1 = DOLLAR
    {                                                               ( `EndAnchor )}
| _1 = LPAREN _2 = regex_pattern_alternate _3 = RPAREN
    {                                                               ( `Group _2 )}
| _1 = regex_pattern _2 = STAR
    {                                                               ( `Repeat (Regex.Star, _1) )}
| _1 = regex_pattern _2 = PLUS
    {                                                               ( `Repeat (Regex.Plus, _1) )}
| _1 = regex_pattern _2 = QUESTION
    {                                                               ( `Repeat (Regex.Question, _1) )}
| _1 = block
    {                                                               ( `Splice (`Block _1, pos ()) )}

regex_pattern_alternate:
  _1 = regex_pattern_sequence
    {                                                               ( `Seq _1 )}
| _1 = regex_pattern_sequence _2 = ALTERNATE _3 = regex_pattern_alternate
    {                                                               ( `Alternate (`Seq _1, _3) )}

regex_pattern_sequence:
  _1 = regex_pattern
    {                                                               ( [_1] )}
| _1 = regex_pattern _2 = regex_pattern_sequence
    {                                                               ( _1 :: _2 )}

pattern:
  _1 = typed_pattern
    {                                                            ( _1 )}
| _1 = typed_pattern _2 = COLON _3 = primary_datatype
    {                                                            ( (`HasType (_1, datatype _3), pos()) )}

typed_pattern:
  _1 = cons_pattern
    {                                                            ( _1 )}
| _1 = cons_pattern _2 = AS _3 = var
    {                                                            ( `As ((fst _3, None, snd _3), _1), pos() )}

cons_pattern:
  _1 = constructor_pattern
    {                                                            ( _1 )}
| _1 = constructor_pattern _2 = COLONCOLON _3 = cons_pattern
    {                                                            ( `Cons (_1, _3), pos() )}

constructor_pattern:
  _1 = negative_pattern
    {                                                            ( _1 )}
| _1 = CONSTRUCTOR
    {                                                            ( `Variant (_1, None), pos() )}
| _1 = CONSTRUCTOR _2 = parenthesized_pattern
    {                                                            ( `Variant (_1, Some _2), pos() )}

constructors:
  _1 = CONSTRUCTOR
    {                                                            ( [_1] )}
| _1 = CONSTRUCTOR _2 = COMMA _3 = constructors
    {                                                            ( _1 :: _3 )}

negative_pattern:
  _1 = primary_pattern
    {                                                            ( _1 )}
| _1 = MINUS _2 = CONSTRUCTOR
    {                                                            ( `Negative [_2], pos() )}
| _1 = MINUS _2 = LPAREN _3 = constructors _4 = RPAREN
    {                                                            ( `Negative _3, pos() )}

parenthesized_pattern:
  _1 = LPAREN _2 = RPAREN
    {                                                            ( `Tuple [], pos() )}
| _1 = LPAREN _2 = pattern _3 = RPAREN
    {                                                            ( _2 )}
| _1 = LPAREN _2 = pattern _3 = COMMA _4 = patterns _5 = RPAREN
    {                                                            ( `Tuple (_2 :: _4), pos() )}
| _1 = LPAREN _2 = labeled_patterns _3 = VBAR _4 = pattern _5 = RPAREN
    {                                                            ( `Record (_2, Some _4), pos() )}
| _1 = LPAREN _2 = labeled_patterns _3 = RPAREN
    {                                                            ( `Record (_2, None), pos() )}

primary_pattern:
  _1 = VARIABLE
    {                                                            ( `Variable (_1, None, pos()), pos() )}
| _1 = UNDERSCORE
    {                                                            ( `Any, pos() )}
| _1 = constant
    {                                                            ( let c, p = _1 in `Constant c, p )}
| _1 = LBRACKET _2 = RBRACKET
    {                                                            ( `Nil, pos() )}
| _1 = LBRACKET _2 = patterns _3 = RBRACKET
    {                                                            ( `List _2, pos() )}
| _1 = parenthesized_pattern
    {                                                            ( _1 )}

patterns:
  _1 = pattern
    {                                                            ( [_1] )}
| _1 = pattern _2 = COMMA _3 = patterns
    {                                                            ( _1 :: _3 )}

labeled_patterns:
  _1 = record_label _2 = EQ _3 = pattern
    {                                                            ( [(_1, _3)] )}
| _1 = record_label _2 = EQ _3 = pattern _4 = COMMA _5 = labeled_patterns
    {                                                            ( (_1, _3) :: _5 )}

multi_args:
  _1 = LPAREN _2 = patterns _3 = RPAREN
    {                                                            ( _2 )}
| _1 = LPAREN _2 = RPAREN
    {                                                            ( [] )}

arg_lists:
  _1 = multi_args
    {                                                            ( [_1] )}
| _1 = multi_args _2 = arg_lists
    {                                                            ( _1 :: _2 )}

%%


