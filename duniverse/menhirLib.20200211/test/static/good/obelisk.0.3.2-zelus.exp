Grammar has 90 nonterminal symbols, among which 2 start symbols.
Grammar has 86 terminal symbols.
Grammar has 285 productions.
nullable(type_var) = false
nullable(type_star_list) = false
nullable(type_params) = true
nullable(type_expression) = false
nullable(type_declaration) = true
nullable(type_comma_list) = false
nullable(state_pat) = false
nullable(state) = false
nullable(simple_type_desc) = false
nullable(simple_type) = false
nullable(simple_pattern) = false
nullable(simple_expression_desc) = false
nullable(simple_expression) = false
nullable(simple_equation_desc) = false
nullable(seq_expression) = false
nullable(scondpat) = false
nullable(qual_ident) = false
nullable(present_handlers(expression)) = false
nullable(present_handlers(block_of_equation)) = false
nullable(present_handler(expression)) = false
nullable(present_handler(block_of_equation)) = false
nullable(phase) = true
nullable(period_expression) = false
nullable(period) = false
nullable(pattern_label_list) = true
nullable(pattern_label) = false
nullable(pattern_comma_list) = false
nullable(pattern) = false
nullable(optional_init) = true
nullable(optional(default_or_init)) = true
nullable(opt_semi_semi) = true
nullable(opt_end) = true
nullable(opt_combine) = true
nullable(opt_bar) = true
nullable(one_local) = false
nullable(one_let) = false
nullable(match_handlers(expression)) = false
nullable(match_handlers(block_of_equation)) = false
nullable(match_handler(expression)) = false
nullable(match_handler(block_of_equation)) = false
nullable(localized(simple_equation_desc)) = false
nullable(localized(interface)) = false
nullable(localized(implementation)) = false
nullable(localized(expression_desc)) = false
nullable(localized(equation_desc)) = false
nullable(local_list) = true
nullable(list_of(COMMA,type_var)) = false
nullable(list_of(COMMA,one_local)) = false
nullable(list_of(COMMA,IDENT)) = false
nullable(list_of(BAR,CONSTRUCTOR)) = false
nullable(list_of(AND,localized(equation_desc))) = false
nullable(let_list) = true
nullable(label_type) = false
nullable(label_list(label_type)) = false
nullable(label_expression_list) = false
nullable(label_expression) = false
nullable(kind) = false
nullable(is_rec) = true
nullable(is_let) = true
nullable(is_atomic) = true
nullable(interface_file) = false
nullable(interface) = false
nullable(infx) = false
nullable(implementation_file) = false
nullable(implementation) = false
nullable(ide) = false
nullable(fun_params) = false
nullable(ext_ident) = false
nullable(expression_desc) = false
nullable(expression_comma_list) = false
nullable(expression) = false
nullable(escape_list) = false
nullable(escape) = false
nullable(equation_empty_list) = true
nullable(equation_desc) = false
nullable(emission) = false
nullable(default_or_init) = false
nullable(decl_list(localized(interface))) = false
nullable(decl_list(localized(implementation))) = false
nullable(constructor) = false
nullable(constant) = false
nullable(block_of_equation) = false
nullable(block(expression)) = false
nullable(block(equation_empty_list)) = false
nullable(automaton_handlers(expression)) = false
nullable(automaton_handlers(equation_empty_list)) = false
nullable(automaton_handler(expression)) = false
nullable(automaton_handler(equation_empty_list)) = false
nullable(atomic_constant) = false
nullable(arrow) = false
first(type_var) = QUOTE
first(type_star_list) = QUOTE LPAREN IDENT CONSTRUCTOR
first(type_params) = QUOTE LPAREN
first(type_expression) = QUOTE LPAREN IDENT CONSTRUCTOR
first(type_declaration) = EQUAL
first(type_comma_list) = QUOTE LPAREN IDENT CONSTRUCTOR
first(state_pat) = CONSTRUCTOR
first(state) = CONSTRUCTOR
first(simple_type_desc) = QUOTE LPAREN IDENT CONSTRUCTOR
first(simple_type) = QUOTE LPAREN IDENT CONSTRUCTOR
first(simple_pattern) = UNDERSCORE SUBTRACTIVE STRING LPAREN LBRACE INT IDENT FLOAT CONSTRUCTOR CHAR BOOL
first(simple_expression_desc) = STRING LPAREN LBRACE INT IDENT FLOAT CONSTRUCTOR CHAR BOOL
first(simple_expression) = STRING LPAREN LBRACE INT IDENT FLOAT CONSTRUCTOR CHAR BOOL
first(simple_equation_desc) = RESET PRESENT MATCH LOCAL LET IF DO AUTOMATON
first(seq_expression) = UP TEST SUBTRACTIVE STRING RESET PRESENT PREFIX PRE PERIOD MATCH LPAREN LOCAL LET LBRACE LAST INT INLINE INIT IF IDENT FLOAT DO DISC CONSTRUCTOR CHAR BOOL AUTOMATON
first(scondpat) = UP STRING LPAREN LBRACE INT IDENT FLOAT CONSTRUCTOR CHAR BOOL
first(qual_ident) = CONSTRUCTOR
first(present_handlers(expression)) = UP STRING LPAREN LBRACE INT IDENT FLOAT CONSTRUCTOR CHAR BOOL
first(present_handlers(block_of_equation)) = UP STRING LPAREN LBRACE INT IDENT FLOAT CONSTRUCTOR CHAR BOOL
first(present_handler(expression)) = UP STRING LPAREN LBRACE INT IDENT FLOAT CONSTRUCTOR CHAR BOOL
first(present_handler(block_of_equation)) = UP STRING LPAREN LBRACE INT IDENT FLOAT CONSTRUCTOR CHAR BOOL
first(phase) = FLOAT
first(period_expression) = LPAREN FLOAT
first(period) = FLOAT
first(pattern_label_list) = UNDERSCORE LPAREN IDENT CONSTRUCTOR
first(pattern_label) = LPAREN IDENT CONSTRUCTOR
first(pattern_comma_list) = UNDERSCORE SUBTRACTIVE STRING LPAREN LBRACE INT IDENT FLOAT CONSTRUCTOR CHAR BOOL
first(pattern) = UNDERSCORE SUBTRACTIVE STRING LPAREN LBRACE INT IDENT FLOAT CONSTRUCTOR CHAR BOOL
first(optional_init) = INIT
first(optional(default_or_init)) = INIT DEFAULT
first(opt_semi_semi) = SEMISEMI
first(opt_end) = END
first(opt_combine) = WITH
first(opt_bar) = BAR
first(one_local) = LPAREN IDENT
first(one_let) = LET
first(match_handlers(expression)) = UNDERSCORE SUBTRACTIVE STRING LPAREN LBRACE INT IDENT FLOAT CONSTRUCTOR CHAR BOOL
first(match_handlers(block_of_equation)) = UNDERSCORE SUBTRACTIVE STRING LPAREN LBRACE INT IDENT FLOAT CONSTRUCTOR CHAR BOOL
first(match_handler(expression)) = UNDERSCORE SUBTRACTIVE STRING LPAREN LBRACE INT IDENT FLOAT CONSTRUCTOR CHAR BOOL
first(match_handler(block_of_equation)) = UNDERSCORE SUBTRACTIVE STRING LPAREN LBRACE INT IDENT FLOAT CONSTRUCTOR CHAR BOOL
first(localized(simple_equation_desc)) = RESET PRESENT MATCH LOCAL LET IF DO AUTOMATON
first(localized(interface)) = VAL TYPE OPEN
first(localized(implementation)) = TYPE OPEN NODE LET HYBRID FUN DISCRETE ATOMIC
first(localized(expression_desc)) = UP TEST SUBTRACTIVE STRING RESET PRESENT PREFIX PRE PERIOD MATCH LPAREN LOCAL LET LBRACE LAST INT INLINE INIT IF IDENT FLOAT DO DISC CONSTRUCTOR CHAR BOOL AUTOMATON
first(localized(equation_desc)) = UNDERSCORE SUBTRACTIVE STRING RESET PRESENT PERIOD NEXT MATCH LPAREN LOCAL LET LBRACE INT INIT IF IDENT FLOAT EMIT DO DER CONSTRUCTOR CHAR BOOL AUTOMATON
first(local_list) = LOCAL
first(list_of(COMMA,type_var)) = QUOTE
first(list_of(COMMA,one_local)) = LPAREN IDENT
first(list_of(COMMA,IDENT)) = IDENT
first(list_of(BAR,CONSTRUCTOR)) = CONSTRUCTOR
first(list_of(AND,localized(equation_desc))) = UNDERSCORE SUBTRACTIVE STRING RESET PRESENT PERIOD NEXT MATCH LPAREN LOCAL LET LBRACE INT INIT IF IDENT FLOAT EMIT DO DER CONSTRUCTOR CHAR BOOL AUTOMATON
first(let_list) = LET
first(label_type) = IDENT
first(label_list(label_type)) = IDENT
first(label_expression_list) = LPAREN IDENT CONSTRUCTOR
first(label_expression) = LPAREN IDENT CONSTRUCTOR
first(kind) = NODE HYBRID FUN DISCRETE
first(is_rec) = REC
first(is_let) = LET
first(is_atomic) = ATOMIC
first(interface_file) = VAL TYPE OPEN EOF
first(interface) = VAL TYPE OPEN
first(infx) = SUBTRACTIVE STAR PREFIX OR ON INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 EQUALEQUAL EQUAL BARBAR AMPERSAND AMPERAMPER
first(implementation_file) = TYPE OPEN NODE LET HYBRID FUN EOF DISCRETE ATOMIC
first(implementation) = TYPE OPEN NODE LET HYBRID FUN DISCRETE ATOMIC
first(ide) = LPAREN IDENT
first(fun_params) = UNDERSCORE SUBTRACTIVE STRING LPAREN LBRACE INT IDENT FLOAT CONSTRUCTOR CHAR BOOL
first(ext_ident) = LPAREN IDENT CONSTRUCTOR
first(expression_desc) = UP TEST SUBTRACTIVE STRING RESET PRESENT PREFIX PRE PERIOD MATCH LPAREN LOCAL LET LBRACE LAST INT INLINE INIT IF IDENT FLOAT DO DISC CONSTRUCTOR CHAR BOOL AUTOMATON
first(expression_comma_list) = UP TEST SUBTRACTIVE STRING RESET PRESENT PREFIX PRE PERIOD MATCH LPAREN LOCAL LET LBRACE LAST INT INLINE INIT IF IDENT FLOAT DO DISC CONSTRUCTOR CHAR BOOL AUTOMATON
first(expression) = UP TEST SUBTRACTIVE STRING RESET PRESENT PREFIX PRE PERIOD MATCH LPAREN LOCAL LET LBRACE LAST INT INLINE INIT IF IDENT FLOAT DO DISC CONSTRUCTOR CHAR BOOL AUTOMATON
first(escape_list) = UP STRING LPAREN LBRACE INT IDENT FLOAT CONSTRUCTOR CHAR BOOL
first(escape) = UP STRING LPAREN LBRACE INT IDENT FLOAT CONSTRUCTOR CHAR BOOL
first(equation_empty_list) = UNDERSCORE SUBTRACTIVE STRING RESET PRESENT PERIOD NEXT MATCH LPAREN LOCAL LET LBRACE INT INIT IF IDENT FLOAT EMIT DO DER CONSTRUCTOR CHAR BOOL AUTOMATON
first(equation_desc) = UNDERSCORE SUBTRACTIVE STRING RESET PRESENT PERIOD NEXT MATCH LPAREN LOCAL LET LBRACE INT INIT IF IDENT FLOAT EMIT DO DER CONSTRUCTOR CHAR BOOL AUTOMATON
first(emission) = LOCAL LET DO
first(default_or_init) = INIT DEFAULT
first(decl_list(localized(interface))) = VAL TYPE OPEN
first(decl_list(localized(implementation))) = TYPE OPEN NODE LET HYBRID FUN DISCRETE ATOMIC
first(constructor) = CONSTRUCTOR
first(constant) = STRING LPAREN INT IDENT FLOAT CONSTRUCTOR CHAR BOOL
first(block_of_equation) = RESET PRESENT MATCH LOCAL LET IF DO AUTOMATON
first(block(expression)) = LOCAL LET DO
first(block(equation_empty_list)) = LOCAL LET DO
first(automaton_handlers(expression)) = CONSTRUCTOR
first(automaton_handlers(equation_empty_list)) = CONSTRUCTOR
first(automaton_handler(expression)) = CONSTRUCTOR
first(automaton_handler(equation_empty_list)) = CONSTRUCTOR
first(atomic_constant) = STRING INT FLOAT CHAR BOOL
first(arrow) = MINUSGREATER DFUN CFUN AFUN ADFUN
minimal(type_var) = (* 2 *) QUOTE IDENT
minimal(type_star_list) = (* 3 *) IDENT STAR IDENT
minimal(type_params) = (* 0 *) 
minimal(type_expression) = (* 1 *) IDENT
minimal(type_declaration) = (* 0 *) 
minimal(type_comma_list) = (* 1 *) IDENT
minimal(state_pat) = (* 1 *) CONSTRUCTOR
minimal(state) = (* 1 *) CONSTRUCTOR
minimal(simple_type_desc) = (* 1 *) IDENT
minimal(simple_type) = (* 1 *) IDENT
minimal(simple_pattern) = (* 1 *) INT
minimal(simple_expression_desc) = (* 1 *) CONSTRUCTOR
minimal(simple_expression) = (* 1 *) CONSTRUCTOR
minimal(simple_equation_desc) = (* 2 *) DO DONE
minimal(seq_expression) = (* 1 *) CONSTRUCTOR
minimal(scondpat) = (* 1 *) CONSTRUCTOR
minimal(qual_ident) = (* 3 *) CONSTRUCTOR DOT IDENT
minimal(present_handlers(expression)) = (* 3 *) CONSTRUCTOR MINUSGREATER CONSTRUCTOR
minimal(present_handlers(block_of_equation)) = (* 4 *) CONSTRUCTOR MINUSGREATER DO DONE
minimal(present_handler(expression)) = (* 3 *) CONSTRUCTOR MINUSGREATER CONSTRUCTOR
minimal(present_handler(block_of_equation)) = (* 4 *) CONSTRUCTOR MINUSGREATER DO DONE
minimal(phase) = (* 0 *) 
minimal(period_expression) = (* 3 *) LPAREN FLOAT RPAREN
minimal(period) = (* 1 *) FLOAT
minimal(pattern_label_list) = (* 0 *) 
minimal(pattern_label) = (* 3 *) IDENT EQUAL INT
minimal(pattern_comma_list) = (* 3 *) INT COMMA INT
minimal(pattern) = (* 1 *) INT
minimal(optional_init) = (* 0 *) 
minimal(optional(default_or_init)) = (* 0 *) 
minimal(opt_semi_semi) = (* 0 *) 
minimal(opt_end) = (* 0 *) 
minimal(opt_combine) = (* 0 *) 
minimal(opt_bar) = (* 0 *) 
minimal(one_local) = (* 1 *) IDENT
minimal(one_let) = (* 3 *) LET DO DONE
minimal(match_handlers(expression)) = (* 3 *) INT MINUSGREATER CONSTRUCTOR
minimal(match_handlers(block_of_equation)) = (* 4 *) INT MINUSGREATER DO DONE
minimal(match_handler(expression)) = (* 3 *) INT MINUSGREATER CONSTRUCTOR
minimal(match_handler(block_of_equation)) = (* 4 *) INT MINUSGREATER DO DONE
minimal(localized(simple_equation_desc)) = (* 2 *) DO DONE
minimal(localized(interface)) = (* 2 *) OPEN CONSTRUCTOR
minimal(localized(implementation)) = (* 2 *) OPEN CONSTRUCTOR
minimal(localized(expression_desc)) = (* 1 *) CONSTRUCTOR
minimal(localized(equation_desc)) = (* 2 *) DO DONE
minimal(local_list) = (* 0 *) 
minimal(list_of(COMMA,type_var)) = (* 2 *) QUOTE IDENT
minimal(list_of(COMMA,one_local)) = (* 1 *) IDENT
minimal(list_of(COMMA,IDENT)) = (* 1 *) IDENT
minimal(list_of(BAR,CONSTRUCTOR)) = (* 1 *) CONSTRUCTOR
minimal(list_of(AND,localized(equation_desc))) = (* 2 *) DO DONE
minimal(let_list) = (* 0 *) 
minimal(label_type) = (* 3 *) IDENT COLON IDENT
minimal(label_list(label_type)) = (* 3 *) IDENT COLON IDENT
minimal(label_expression_list) = (* 3 *) IDENT EQUAL CONSTRUCTOR
minimal(label_expression) = (* 3 *) IDENT EQUAL CONSTRUCTOR
minimal(kind) = (* 1 *) NODE
minimal(is_rec) = (* 0 *) 
minimal(is_let) = (* 0 *) 
minimal(is_atomic) = (* 0 *) 
minimal(interface_file) = (* 1 *) EOF
minimal(interface) = (* 2 *) OPEN CONSTRUCTOR
minimal(infx) = (* 1 *) INFIX0
minimal(implementation_file) = (* 1 *) EOF
minimal(implementation) = (* 2 *) OPEN CONSTRUCTOR
minimal(ide) = (* 1 *) IDENT
minimal(fun_params) = (* 1 *) INT
minimal(ext_ident) = (* 1 *) IDENT
minimal(expression_desc) = (* 1 *) CONSTRUCTOR
minimal(expression_comma_list) = (* 3 *) CONSTRUCTOR COMMA CONSTRUCTOR
minimal(expression) = (* 1 *) CONSTRUCTOR
minimal(escape_list) = (* 3 *) CONSTRUCTOR THEN CONSTRUCTOR
minimal(escape) = (* 3 *) CONSTRUCTOR THEN CONSTRUCTOR
minimal(equation_empty_list) = (* 0 *) 
minimal(equation_desc) = (* 2 *) DO DONE
minimal(emission) = (* 2 *) DO IN
minimal(default_or_init) = (* 2 *) DEFAULT INT
minimal(decl_list(localized(interface))) = (* 2 *) OPEN CONSTRUCTOR
minimal(decl_list(localized(implementation))) = (* 2 *) OPEN CONSTRUCTOR
minimal(constructor) = (* 1 *) CONSTRUCTOR
minimal(constant) = (* 1 *) INT
minimal(block_of_equation) = (* 2 *) DO DONE
minimal(block(expression)) = (* 2 *) DO CONSTRUCTOR
minimal(block(equation_empty_list)) = (* 1 *) DO
minimal(automaton_handlers(expression)) = (* 5 *) CONSTRUCTOR MINUSGREATER DO CONSTRUCTOR DONE
minimal(automaton_handlers(equation_empty_list)) = (* 4 *) CONSTRUCTOR MINUSGREATER DO DONE
minimal(automaton_handler(expression)) = (* 5 *) CONSTRUCTOR MINUSGREATER DO CONSTRUCTOR DONE
minimal(automaton_handler(equation_empty_list)) = (* 4 *) CONSTRUCTOR MINUSGREATER DO DONE
minimal(atomic_constant) = (* 1 *) INT
minimal(arrow) = (* 1 *) MINUSGREATER
follow(type_var) = VAL TYPE STAR SEMISEMI SEMI RPAREN RBRACE OPEN NODE MINUSGREATER LPAREN LET IDENT HYBRID FUN EOF DISCRETE DFUN CONSTRUCTOR COMMA CFUN ATOMIC AFUN ADFUN
follow(type_star_list) = VAL TYPE STAR SEMISEMI SEMI RPAREN RBRACE OPEN NODE MINUSGREATER LET HYBRID FUN EOF DISCRETE DFUN COMMA CFUN ATOMIC AFUN ADFUN
follow(type_params) = IDENT
follow(type_expression) = VAL TYPE SEMISEMI SEMI RPAREN RBRACE OPEN NODE MINUSGREATER LET HYBRID FUN EOF DISCRETE DFUN COMMA CFUN ATOMIC AFUN ADFUN
follow(type_declaration) = VAL TYPE SEMISEMI OPEN NODE LET HYBRID FUN EOF DISCRETE ATOMIC
follow(type_comma_list) = RPAREN
follow(state_pat) = MINUSGREATER
follow(state) = WITH WHERE UNTIL UNLESS TYPE THEN SUBTRACTIVE STAR SEMISEMI SEMI RPAREN RESET RBRACE OR OPEN NODE MINUSGREATER LET INIT INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 IN HYBRID FUN FBY EVERY EQUAL EOF END ELSE DOT DONE DISCRETE CONTINUE COMMA BARBAR BAR ATOMIC AND AMPERSAND AMPERAMPER AFTER
follow(simple_type_desc) = VAL TYPE STAR SEMISEMI SEMI RPAREN RBRACE OPEN NODE MINUSGREATER LPAREN LET IDENT HYBRID FUN EOF DISCRETE DFUN CONSTRUCTOR COMMA CFUN ATOMIC AFUN ADFUN
follow(simple_type) = VAL TYPE STAR SEMISEMI SEMI RPAREN RBRACE OPEN NODE MINUSGREATER LPAREN LET IDENT HYBRID FUN EOF DISCRETE DFUN CONSTRUCTOR COMMA CFUN ATOMIC AFUN ADFUN
follow(simple_pattern) = THEN SEMI RPAREN RBRACE ON MINUSGREATER EQUAL CONTINUE COMMA COLON BAR AS AMPERSAND
follow(simple_expression_desc) = WITH WHERE UNTIL UNLESS UNDERSCORE TYPE THEN SUBTRACTIVE STRING STAR SEMISEMI SEMI RPAREN RESET RBRACE OR OPEN ON NODE MINUSGREATER LPAREN LET LBRACE INT INIT INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 IN IDENT HYBRID FUN FLOAT FBY EVERY EQUAL EOF END ELSE DOT DONE DISCRETE CONTINUE CONSTRUCTOR COMMA COLON CHAR BOOL BARBAR BAR ATOMIC AND AMPERSAND AMPERAMPER AFTER
follow(simple_expression) = WITH WHERE UNTIL UNLESS UNDERSCORE TYPE THEN SUBTRACTIVE STRING STAR SEMISEMI SEMI RPAREN RESET RBRACE OR OPEN ON NODE MINUSGREATER LPAREN LET LBRACE INT INIT INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 IN IDENT HYBRID FUN FLOAT FBY EVERY EQUAL EOF END ELSE DOT DONE DISCRETE CONTINUE CONSTRUCTOR COMMA COLON CHAR BOOL BARBAR BAR ATOMIC AND AMPERSAND AMPERAMPER AFTER
follow(simple_equation_desc) = UNTIL UNLESS TYPE THEN SEMISEMI OPEN NODE LET IN HYBRID FUN EVERY EOF END ELSE DONE DISCRETE CONTINUE BAR ATOMIC AND
follow(seq_expression) = WITH WHERE UNTIL UNLESS TYPE THEN SUBTRACTIVE STAR SEMISEMI SEMI RPAREN RESET RBRACE OR OPEN NODE MINUSGREATER LET INIT INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 IN HYBRID FUN FBY EVERY EQUAL EOF END ELSE DOT DONE DISCRETE CONTINUE COMMA BARBAR BAR ATOMIC AND AMPERSAND AMPERAMPER AFTER
follow(scondpat) = THEN ON MINUSGREATER CONTINUE BAR AMPERSAND
follow(qual_ident) = WITH WHERE VAL UNTIL UNLESS UNDERSCORE TYPE THEN SUBTRACTIVE STRING STAR SEMISEMI SEMI RPAREN RESET RBRACE OR OPEN ON NODE MINUSGREATER LPAREN LET LBRACE INT INIT INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 IN IDENT HYBRID FUN FLOAT FBY EVERY EQUAL EOF END ELSE DOT DONE DISCRETE DFUN CONTINUE CONSTRUCTOR COMMA COLON CHAR CFUN BOOL BARBAR BAR ATOMIC AND AMPERSAND AMPERAMPER AFUN AFTER ADFUN
follow(present_handlers(expression)) = WITH WHERE UNTIL UNLESS TYPE THEN SUBTRACTIVE STAR SEMISEMI SEMI RPAREN RESET RBRACE OR OPEN NODE MINUSGREATER LET INIT INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 IN HYBRID FUN FBY EVERY EQUAL EOF END ELSE DOT DONE DISCRETE CONTINUE COMMA BARBAR BAR ATOMIC AND AMPERSAND AMPERAMPER AFTER
follow(present_handlers(block_of_equation)) = UNTIL UNLESS TYPE THEN SEMISEMI OPEN NODE LET IN HYBRID FUN EVERY EOF END ELSE DONE DISCRETE CONTINUE BAR ATOMIC AND
follow(present_handler(expression)) = WITH WHERE UNTIL UNLESS TYPE THEN SUBTRACTIVE STAR SEMISEMI SEMI RPAREN RESET RBRACE OR OPEN NODE MINUSGREATER LET INIT INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 IN HYBRID FUN FBY EVERY EQUAL EOF END ELSE DOT DONE DISCRETE CONTINUE COMMA BARBAR BAR ATOMIC AND AMPERSAND AMPERAMPER AFTER
follow(present_handler(block_of_equation)) = UNTIL UNLESS TYPE THEN SEMISEMI OPEN NODE LET IN HYBRID FUN EVERY EOF END ELSE DONE DISCRETE CONTINUE BAR ATOMIC AND
follow(phase) = LPAREN
follow(period_expression) = WITH WHERE UNTIL UNLESS TYPE THEN SUBTRACTIVE STAR SEMISEMI SEMI RPAREN RESET RBRACE OR OPEN NODE MINUSGREATER LET INIT INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 IN HYBRID FUN FBY EVERY EQUAL EOF END ELSE DOT DONE DISCRETE CONTINUE COMMA BARBAR BAR ATOMIC AND AMPERSAND AMPERAMPER AFTER
follow(period) = RPAREN
follow(pattern_label_list) = RBRACE
follow(pattern_label) = SEMI RBRACE
follow(pattern_comma_list) = SEMI RPAREN RBRACE MINUSGREATER EQUAL COMMA COLON BAR AS
follow(pattern) = SEMI RPAREN RBRACE MINUSGREATER EQUAL COMMA COLON BAR AS
follow(optional_init) = UNTIL UNLESS TYPE THEN SEMISEMI RESET OPEN NODE LET IN HYBRID FUN EVERY EOF DONE DISCRETE CONTINUE ATOMIC AND
follow(optional(default_or_init)) = WITH IN COMMA
follow(opt_semi_semi) = VAL TYPE OPEN NODE LET HYBRID FUN EOF DISCRETE ATOMIC
follow(opt_end) = WITH WHERE UNTIL UNLESS TYPE THEN SUBTRACTIVE STAR SEMISEMI SEMI RPAREN RESET RBRACE OR OPEN NODE MINUSGREATER LET INIT INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 IN HYBRID FUN FBY EVERY EQUAL EOF END ELSE DOT DONE DISCRETE CONTINUE COMMA BARBAR BAR ATOMIC AND AMPERSAND AMPERAMPER AFTER
follow(opt_combine) = IN COMMA
follow(opt_bar) = UP UNDERSCORE SUBTRACTIVE STRING LPAREN LBRACE INT IDENT FLOAT CONSTRUCTOR CHAR BOOL
follow(one_local) = IN COMMA
follow(one_let) = IN
follow(match_handlers(expression)) = WITH WHERE UNTIL UNLESS TYPE THEN SUBTRACTIVE STAR SEMISEMI SEMI RPAREN RESET RBRACE OR OPEN NODE MINUSGREATER LET INIT INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 IN HYBRID FUN FBY EVERY EQUAL EOF END ELSE DOT DONE DISCRETE CONTINUE COMMA BARBAR BAR ATOMIC AND AMPERSAND AMPERAMPER AFTER
follow(match_handlers(block_of_equation)) = UNTIL UNLESS TYPE THEN SEMISEMI OPEN NODE LET IN HYBRID FUN EVERY EOF END ELSE DONE DISCRETE CONTINUE BAR ATOMIC AND
follow(match_handler(expression)) = WITH WHERE UNTIL UNLESS TYPE THEN SUBTRACTIVE STAR SEMISEMI SEMI RPAREN RESET RBRACE OR OPEN NODE MINUSGREATER LET INIT INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 IN HYBRID FUN FBY EVERY EQUAL EOF END ELSE DOT DONE DISCRETE CONTINUE COMMA BARBAR BAR ATOMIC AND AMPERSAND AMPERAMPER AFTER
follow(match_handler(block_of_equation)) = UNTIL UNLESS TYPE THEN SEMISEMI OPEN NODE LET IN HYBRID FUN EVERY EOF END ELSE DONE DISCRETE CONTINUE BAR ATOMIC AND
follow(localized(simple_equation_desc)) = UNTIL UNLESS TYPE THEN SEMISEMI OPEN NODE LET IN HYBRID FUN EVERY EOF END ELSE DONE DISCRETE CONTINUE BAR ATOMIC AND
follow(localized(interface)) = VAL TYPE SEMISEMI OPEN EOF
follow(localized(implementation)) = TYPE SEMISEMI OPEN NODE LET HYBRID FUN EOF DISCRETE ATOMIC
follow(localized(expression_desc)) = WITH WHERE UNTIL UNLESS TYPE THEN SUBTRACTIVE STAR SEMISEMI SEMI RPAREN RESET RBRACE OR OPEN NODE MINUSGREATER LET INIT INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 IN HYBRID FUN FBY EVERY EQUAL EOF END ELSE DOT DONE DISCRETE CONTINUE COMMA BARBAR BAR ATOMIC AND AMPERSAND AMPERAMPER AFTER
follow(localized(equation_desc)) = UNTIL UNLESS TYPE THEN SEMISEMI OPEN NODE LET IN HYBRID FUN EVERY EOF DONE DISCRETE CONTINUE ATOMIC AND
follow(local_list) = DO
follow(list_of(COMMA,type_var)) = RPAREN COMMA
follow(list_of(COMMA,one_local)) = IN COMMA
follow(list_of(COMMA,IDENT)) = RPAREN COMMA
follow(list_of(BAR,CONSTRUCTOR)) = VAL TYPE SEMISEMI OPEN NODE LET HYBRID FUN EOF DISCRETE BAR ATOMIC
follow(list_of(AND,localized(equation_desc))) = UNTIL UNLESS TYPE THEN SEMISEMI OPEN NODE LET IN HYBRID FUN EVERY EOF DONE DISCRETE CONTINUE ATOMIC AND
follow(let_list) = LOCAL DO CONSTRUCTOR
follow(label_type) = SEMI RBRACE
follow(label_list(label_type)) = RBRACE
follow(label_expression_list) = RBRACE
follow(label_expression) = SEMI RBRACE
follow(kind) = IDENT
follow(is_rec) = UNDERSCORE SUBTRACTIVE STRING RESET PRESENT PERIOD NEXT MATCH LPAREN LOCAL LET LBRACE INT INIT IF IDENT FLOAT EMIT DO DER CONSTRUCTOR CHAR BOOL AUTOMATON
follow(is_let) = NODE HYBRID FUN DISCRETE ATOMIC
follow(is_atomic) = NODE HYBRID FUN DISCRETE
follow(interface_file) = #
follow(interface) = VAL TYPE SEMISEMI OPEN EOF
follow(infx) = RPAREN
follow(implementation_file) = #
follow(implementation) = TYPE SEMISEMI OPEN NODE LET HYBRID FUN EOF DISCRETE ATOMIC
follow(ide) = WITH WHERE VAL UNTIL UNLESS UNDERSCORE TYPE THEN SUBTRACTIVE STRING STAR SEMISEMI SEMI RPAREN RESET RBRACE PLUSEQUAL OR OPEN ON NODE MINUSGREATER LPAREN LET LBRACE INT INIT INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 IN IDENT HYBRID FUN FLOAT FBY EVERY EQUAL EOF END ELSE DOT DONE DISCRETE DFUN DEFAULT CONTINUE CONSTRUCTOR COMMA COLON CHAR CFUN BOOL BARBAR BAR ATOMIC AS AND AMPERSAND AMPERAMPER AFUN AFTER ADFUN
follow(fun_params) = EQUAL
follow(ext_ident) = WITH WHERE VAL UNTIL UNLESS UNDERSCORE TYPE THEN SUBTRACTIVE STRING STAR SEMISEMI SEMI RPAREN RESET RBRACE OR OPEN ON NODE MINUSGREATER LPAREN LET LBRACE INT INIT INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 IN IDENT HYBRID FUN FLOAT FBY EVERY EQUAL EOF END ELSE DOT DONE DISCRETE DFUN CONTINUE CONSTRUCTOR COMMA COLON CHAR CFUN BOOL BARBAR BAR ATOMIC AND AMPERSAND AMPERAMPER AFUN AFTER ADFUN
follow(expression_desc) = WITH WHERE UNTIL UNLESS TYPE THEN SUBTRACTIVE STAR SEMISEMI SEMI RPAREN RESET RBRACE OR OPEN NODE MINUSGREATER LET INIT INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 IN HYBRID FUN FBY EVERY EQUAL EOF END ELSE DOT DONE DISCRETE CONTINUE COMMA BARBAR BAR ATOMIC AND AMPERSAND AMPERAMPER AFTER
follow(expression_comma_list) = WITH WHERE UNTIL UNLESS TYPE THEN SUBTRACTIVE STAR SEMISEMI SEMI RPAREN RESET RBRACE OR OPEN NODE MINUSGREATER LET INIT INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 IN HYBRID FUN FBY EVERY EQUAL EOF END ELSE DOT DONE DISCRETE CONTINUE COMMA BARBAR BAR ATOMIC AND AMPERSAND AMPERAMPER AFTER
follow(expression) = WITH WHERE UNTIL UNLESS TYPE THEN SUBTRACTIVE STAR SEMISEMI SEMI RPAREN RESET RBRACE OR OPEN NODE MINUSGREATER LET INIT INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 IN HYBRID FUN FBY EVERY EQUAL EOF END ELSE DOT DONE DISCRETE CONTINUE COMMA BARBAR BAR ATOMIC AND AMPERSAND AMPERAMPER AFTER
follow(escape_list) = WITH WHERE UNTIL UNLESS TYPE THEN SUBTRACTIVE STAR SEMISEMI SEMI RPAREN RESET RBRACE OR OPEN NODE MINUSGREATER LET INIT INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 IN HYBRID FUN FBY EVERY EQUAL EOF END ELSE DOT DONE DISCRETE CONTINUE COMMA BARBAR BAR ATOMIC AND AMPERSAND AMPERAMPER AFTER
follow(escape) = WITH WHERE UNTIL UNLESS TYPE THEN SUBTRACTIVE STAR SEMISEMI SEMI RPAREN RESET RBRACE OR OPEN NODE MINUSGREATER LET INIT INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 IN HYBRID FUN FBY EVERY EQUAL EOF END ELSE DOT DONE DISCRETE CONTINUE COMMA BARBAR BAR ATOMIC AND AMPERSAND AMPERAMPER AFTER
follow(equation_empty_list) = UNTIL UNLESS THEN IN DONE CONTINUE
follow(equation_desc) = UNTIL UNLESS TYPE THEN SEMISEMI OPEN NODE LET IN HYBRID FUN EVERY EOF DONE DISCRETE CONTINUE ATOMIC AND
follow(emission) = CONSTRUCTOR
follow(default_or_init) = WITH IN COMMA
follow(decl_list(localized(interface))) = VAL TYPE OPEN EOF
follow(decl_list(localized(implementation))) = TYPE OPEN NODE LET HYBRID FUN EOF DISCRETE ATOMIC
follow(constructor) = WITH WHERE UNTIL UNLESS UNDERSCORE TYPE THEN SUBTRACTIVE STRING STAR SEMISEMI SEMI RPAREN RESET RBRACE OR OPEN ON NODE MINUSGREATER LPAREN LET LBRACE INT INIT INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 IN IDENT HYBRID FUN FLOAT FBY EVERY EQUAL EOF END ELSE DOT DONE DISCRETE CONTINUE CONSTRUCTOR COMMA COLON CHAR BOOL BARBAR BAR ATOMIC AS AND AMPERSAND AMPERAMPER AFTER
follow(constant) = WITH IN COMMA
follow(block_of_equation) = UNTIL UNLESS TYPE THEN SEMISEMI OPEN NODE LET IN HYBRID FUN EVERY EOF END ELSE DONE DISCRETE CONTINUE BAR ATOMIC AND
follow(block(expression)) = UNTIL UNLESS THEN DONE CONTINUE
follow(block(equation_empty_list)) = UNTIL UNLESS THEN DONE CONTINUE
follow(automaton_handlers(expression)) = WITH WHERE UNTIL UNLESS TYPE THEN SUBTRACTIVE STAR SEMISEMI SEMI RPAREN RESET RBRACE OR OPEN NODE MINUSGREATER LET INIT INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 IN HYBRID FUN FBY EVERY EQUAL EOF END ELSE DOT DONE DISCRETE CONTINUE COMMA BARBAR BAR ATOMIC AND AMPERSAND AMPERAMPER AFTER
follow(automaton_handlers(equation_empty_list)) = UNTIL UNLESS TYPE THEN SEMISEMI OPEN NODE LET INIT IN HYBRID FUN EVERY EOF END ELSE DONE DISCRETE CONTINUE BAR ATOMIC AND
follow(automaton_handler(expression)) = WITH WHERE UNTIL UNLESS TYPE THEN SUBTRACTIVE STAR SEMISEMI SEMI RPAREN RESET RBRACE OR OPEN NODE MINUSGREATER LET INIT INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 IN HYBRID FUN FBY EVERY EQUAL EOF END ELSE DOT DONE DISCRETE CONTINUE COMMA BARBAR BAR ATOMIC AND AMPERSAND AMPERAMPER AFTER
follow(automaton_handler(equation_empty_list)) = UNTIL UNLESS TYPE THEN SEMISEMI OPEN NODE LET INIT IN HYBRID FUN EVERY EOF END ELSE DONE DISCRETE CONTINUE BAR ATOMIC AND
follow(atomic_constant) = WITH WHERE UNTIL UNLESS UNDERSCORE TYPE THEN SUBTRACTIVE STRING STAR SEMISEMI SEMI RPAREN RESET RBRACE OR OPEN ON NODE MINUSGREATER LPAREN LET LBRACE INT INIT INFIX4 INFIX3 INFIX2 INFIX1 INFIX0 IN IDENT HYBRID FUN FLOAT FBY EVERY EQUAL EOF END ELSE DOT DONE DISCRETE CONTINUE CONSTRUCTOR COMMA COLON CHAR BOOL BARBAR BAR ATOMIC AS AND AMPERSAND AMPERAMPER AFTER
follow(arrow) = QUOTE LPAREN IDENT CONSTRUCTOR
Built an LR(0) automaton with 558 states.
The grammar is not SLR(1) -- 78 states have a conflict.
The construction mode is pager.
Built an LR(1) automaton with 558 states.
561 shift/reduce conflicts were silently solved.
189 out of 558 states have a default reduction.
251 out of 558 states are represented.
67 out of 180 symbols keep track of their start position.
113 out of 180 symbols keep track of their end position.
150 out of 287 productions exploit shiftreduce optimization.
0 out of 558 states can peek at an error.
1500 functions before inlining, 213 functions after inlining.
