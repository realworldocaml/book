<html style="" lang="en" class="js flexbox fontface"><head><meta charset="utf-8"><meta content="width=device-width, initial-scale=1.0" name="viewport"><title>GADTs - Real World OCaml</title><link href="css/app.css" rel="stylesheet"><link href="css/prism.css" rel="stylesheet"><script src="js/min/modernizr-min.js"></script><script src="js/prism.js"></script><script src="//use.typekit.net/gfj8wez.js"></script><script>try{Typekit.load();}catch(e){}</script></head><body><div class="title-bar"><div class="title"><h1>Real World OCaml</h1><h5>2<sup>nd</sup> Edition (published in Q4 2021)</h5><nav><a href="index.html">Home</a><a href="toc.html">Table of Contents</a><a href="faqs.html">FAQs</a><a href="install.html">Install</a><a href="https://ocaml.janestreet.com/ocaml-core/">API Docs</a></nav></div></div><div class="wrap"><div class="left-column"><a class="to-chapter" href="toc.html"><small>Back</small><h5>Table of Contents</h5></a></div><article class="main-body"><section class="level1" id="gadts">
<h1>GADTs</h1>
<p>Generalized Algebraic Data Types, or GADTs for short, are an
extension of the variants we saw in <a data-type="xref" href="variants.html#variants">Chapter 6, Variants</a>. GADTs are more expressive than regular
variants, which helps you create types that more precisely match the
shape of the program you want to write. That can help you write code
that’s safer, more concise, and more efficient. <a data-primary="Generalized Algebraic Data Type" data-type="indexterm">&nbsp;</a><a data-primary="GADT" data-type="indexterm">&nbsp;</a></p>
<p>At the same time, GADTs are an advanced feature of OCaml, and their
power comes at a distinct cost. GADTs are harder to use and less
intuitive than ordinary variants, and it can sometimes be a bit of a
puzzle to figure out how to use them effectively. All of which is to say
that you should only use a GADT when it makes a big qualitative
improvement to your design.</p>
<p>That said, for the right use-case, GADTs can be really
transformative, and this chapter will walk through several examples that
demonstrate the range of use-cases that GADTs support.</p>
<p>At their heart, GADTs provide two extra features above and beyond
ordinary variants:</p>
<ul>
<li>They let the compiler learn more type information when you descend
into a case of a pattern match.</li>
<li>They make it easy to use <em>existential types</em>, which let you
work with data of a specific but unknown type. <a data-primary="existential type" data-type="indexterm">&nbsp;</a></li>
</ul>
<p>It’s a little hard to understand these features without working
through some examples, so we’ll do that next.</p>
<section class="level2" id="a-little-language">
<h2>A little language</h2>
<p>One classic use-case for GADTs is for writing typed expression
languages, similar to the boolean expression language described in <a data-type="xref" href="variants.html#variants-and-recursive-data-structures">Chapter 6, Variants</a>. In this section, we’ll create a slightly
richer language that lets us mix arithmetic and boolean expressions.
This means that we have to deal with the possibility of ill-typed
expressions, e.g., an expression that adds a <code>bool</code> and an
<code>int</code>.</p>
<p>Let’s first try to do this with an ordinary variant. We’ll declare
two types here: <code>value</code>, which represents a primitive value
in the language (i.e., an <code>int</code> or a <code>bool</code>), and
<code>expr</code>, which represents the full set of possible
expressions.</p>
<div class="highlight">
<pre><code class="language-ocaml">open Base

type value =
  | Int of int
  | Bool of bool

type expr =
  | Value of value
  | Eq of expr * expr
  | Plus of expr * expr
  | If of expr * expr * expr</code></pre>
</div>
<p>We can write a recursive evaluator for this type in a pretty
straight-ahead style. First, we’ll declare an exception that can be
thrown when we hit an ill-typed expression, e.g., when encountering an
expression that tries to add a bool and an int.</p>
<div class="highlight">
<pre><code class="language-ocaml">exception Ill_typed</code></pre>
</div>
<p> With that in hand, we can write the evaluator itself.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let rec eval expr =
  match expr with
  | Value v -&gt; v
  | If (c, t, e) -&gt;
    (match eval c with
     | Bool b -&gt; if b then eval t else eval e
     | Int _ -&gt; raise Ill_typed)
  | Eq (x, y) -&gt;
    (match eval x, eval y with
     | Bool _, _ | _, Bool _ -&gt; raise Ill_typed
     | Int f1, Int f2 -&gt; Bool (f1 = f2))
  | Plus (x, y) -&gt;
    (match eval x, eval y with
     | Bool _, _ | _, Bool _ -&gt; raise Ill_typed
     | Int f1, Int f2 -&gt; Int (f1 + f2));;
&gt;val eval : expr -&gt; value = &lt;fun&gt;
</code></pre>
</div>
<p>This implementation is a bit ugly because it has a lot of dynamic
checks to detect type errors. Indeed, it’s entirely possible to create
an ill-typed expression which will trip these checks.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let i x = Value (Int x)
and b x = Value (Bool x)
and (+:) x y = Plus (x,y);;
&gt;val i : int -&gt; expr = &lt;fun&gt;
&gt;val b : bool -&gt; expr = &lt;fun&gt;
&gt;val ( +: ) : expr -&gt; expr -&gt; expr = &lt;fun&gt;
eval (i 3 +: b false);;
&gt;Exception: Ill_typed.
</code></pre>
</div>
<p>This possibility of ill-typed expressions doesn’t just complicate the
implementation: it’s also a problem for users, since it’s all too easy
to create ill-typed expressions by mistake.</p>
<section class="level3" id="making-the-language-type-safe">
<h3>Making the language type-safe</h3>
<p>Let’s consider what a type-safe version of this API might look like
in the absence of GADTs. To even express the type constraints, we’ll
need expressions to have a type parameter to distinguish integer
expressions from boolean expressions. Given such a parameter, the
signature for such a language might look like this.</p>
<div class="highlight">
<pre><code class="language-ocaml">module type Typesafe_lang_sig = sig
  type 'a t

  (** functions for constructing expressions *)

  val int : int -&gt; int t
  val bool : bool -&gt; bool t
  val if_ : bool t -&gt; 'a t -&gt; 'a t -&gt; 'a t
  val eq : 'a t -&gt; 'a t -&gt; bool t
  val plus : int t -&gt; int t -&gt; int t

  (** Evaluation functions *)

  val int_eval : int t -&gt; int
  val bool_eval : bool t -&gt; bool
end</code></pre>
</div>
<p>The functions <code>int_eval</code> and <code>bool_eval</code>
deserve some explanation. You might expect there to be a single
evaluation function, with this signature.</p>
<div class="highlight">
<pre><code class="language-ocaml">val eval : 'a t -&gt; 'a</code></pre>
</div>
<p> But as we’ll see, we’re not going to be able to implement that, at
least, not without using GADTs. So for now, we’re stuck with two
different evaluators, one for each type of expression.</p>
<p>Now let’s write an implementation that matches this signature.</p>
<div class="highlight">
<pre><code class="language-ocaml">module Typesafe_lang : Typesafe_lang_sig = struct
  type 'a t = expr

  let int x = Value (Int x)
  let bool x = Value (Bool x)
  let if_ c t e = If (c, t, e)
  let eq x y = Eq (x, y)
  let plus x y = Plus (x, y)

  let int_eval expr =
    match eval expr with
    | Int x -&gt; x
    | Bool _ -&gt; raise Ill_typed

  let bool_eval expr =
    match eval expr with
    | Bool x -&gt; x
    | Int _ -&gt; raise Ill_typed
end</code></pre>
</div>
<p>As you can see, the ill-typed expression we had trouble with before
can’t be constructed, because it’s rejected by OCaml’s type-system.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let expr = Typesafe_lang.(plus (int 3) (bool false));;
&gt;Line 1, characters 40-52:
&gt;Error: This expression has type bool t but an expression was expected of type
&gt;         int t
&gt;       Type bool is not compatible with type int
</code></pre>
</div>
<p>So, what happened here? How did we add the type-safety we wanted? The
fundamental trick is to add what’s called a <em>phantom type</em>. In
this definition: <a data-primary="phantom types" data-type="indexterm">&nbsp;</a></p>
<div class="highlight">
<pre><code class="language-ocaml">type 'a t = expr</code></pre>
</div>
<p> the type parameter <code>'a</code> is the phantom type, since it
doesn’t show up in the body of the definition of <code>t</code>.</p>
<p>Because the type parameter is unused, it’s free to take on any value.
That means we can constrain the use of that type parameter arbitrarily
in the signature, which is a freedom we use to add the type-safety rules
that we wanted.</p>
<p>This all amounts to an improvement in terms of the API, but the
implementation is if anything worse. We still have the same evaluator
with all of its dynamic checking for type errors. But we’ve had to write
yet more wrapper code to make this work.</p>
<p>Also, the phantom-type discipline is quite error prone. You might
have missed the fact that the type on the <code>eq</code> function above
is wrong!</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Typesafe_lang.eq;;
&gt;- : 'a Typesafe_lang.t -&gt; 'a Typesafe_lang.t -&gt; bool Typesafe_lang.t = &lt;fun&gt;
</code></pre>
</div>
<p> It looks like it’s polymorphic over the type of expressions, but the
evaluator only supports checking equality on integers. As a result, we
can still construct an ill-typed expression, phantom-types
notwithstanding.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let expr = Typesafe_lang.(eq (bool true) (bool false));;
&gt;val expr : bool Typesafe_lang.t = &lt;abstr&gt;
Typesafe_lang.bool_eval expr;;
&gt;Exception: Ill_typed.
</code></pre>
</div>
<p>This highlights why we still need the dynamic checks in the
implementation: the types within the implementation don’t necessarily
rule out ill-typed expressions. The same fact explains why we needed two
different <code>eval</code> functions: the implementation of eval
doesn’t have any type-level guarantee of when it’s handling a bool
expression versus an int expression, so it can’t safely give results
where the type of the result varies based on the result of the
expression.</p>
</section>
<section class="level3" id="trying-to-do-better-with-ordinary-variants">
<h3>Trying to do better with ordinary variants</h3>
<p>To see why we need GADTs, let’s see how far we can get without them.
In particular, let’s see what happens when we try to encode the typing
rules we want for our DSL directly into the definition of the expression
type. We’ll do that by putting an ordinary type parameter on our
<code>expr</code> and <code>value</code> types, in order to represent
the type of an expression or value.</p>
<div class="highlight">
<pre><code class="language-ocaml">type 'a value =
  | Int of 'a
  | Bool of 'a

type 'a expr =
  | Value of 'a value
  | Eq of 'a expr * 'a expr
  | Plus of 'a expr * 'a expr
  | If of bool expr * 'a expr * 'a expr</code></pre>
</div>
<p> This looks promising at first, but it doesn’t quite do what we want.
Let’s experiment a little.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let i x = Value (Int x)
and b x = Value (Bool x)
and (+:) x y = Plus (x,y);;
&gt;val i : 'a -&gt; 'a expr = &lt;fun&gt;
&gt;val b : 'a -&gt; 'a expr = &lt;fun&gt;
&gt;val ( +: ) : 'a expr -&gt; 'a expr -&gt; 'a expr = &lt;fun&gt;
i 3;;
&gt;- : int expr = Value (Int 3)
b false;;
&gt;- : bool expr = Value (Bool false)
i 3 +: i 4;;
&gt;- : int expr = Plus (Value (Int 3), Value (Int 4))
</code></pre>
</div>
<p>So far so good. But if you think about it for a minute, you’ll
realize this doesn’t actually do what we want. For one thing, the type
of the outer expression is always just equal to the type of the inner
expression, which means that some things that should type-check
don’t.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">If (Eq (i 3, i 4), i 0, i 1);;
&gt;Line 1, characters 9-12:
&gt;Error: This expression has type int expr
&gt;       but an expression was expected of type bool expr
&gt;       Type int is not compatible with type bool
</code></pre>
</div>
<p> Also, some things that shouldn’t typecheck do.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">b 3;;
&gt;- : int expr = Value (Bool 3)
</code></pre>
</div>
<p>The problem here is that the way we want to use the type parameter
isn’t supported by ordinary variants. In particular, we want the type
parameter to be populated in different ways in the different tags, and
to depend in non-trivial ways on the types of the data associated with
each tag. That’s where GADTs can help.</p>
</section>
<section class="level3" id="gadts-to-the-rescue">
<h3>GADTs to the rescue</h3>
<p>Now we’re ready write our first GADT. Here’s a new version of our
<code>value</code> and <code>expr</code> types that correctly encode our
desired typing rules.</p>
<div class="highlight">
<pre><code class="language-ocaml">type _ value =
  | Int : int -&gt; int value
  | Bool : bool -&gt; bool value

type _ expr =
  | Value : 'a value -&gt; 'a expr
  | Eq : int expr * int expr -&gt; bool expr
  | Plus : int expr * int expr -&gt; int expr
  | If : bool expr * 'a expr * 'a expr -&gt; 'a expr</code></pre>
</div>
<p>The syntax here requires some decoding. The colon to the right of
each tag is what tells you that this is a GADT. To the right of the
colon, you’ll see what looks like an ordinary, single-argument function
type, and you can almost think of it that way; specifically, as the type
signature for that particular tag, viewed as a type constructor. The
left-hand side of the arrow states the types of the arguments to the
constructor, and the right hand side determines the type of the
constructed value.</p>
<p>In the definition of each tag in a GADT, the right-hand side of the
arrow is an instance of the type of the overall GADT, with independent
choices for the type parameter in each case. Importantly, the type
parameter can depend both on the tag and on the type of the arguments.
<code>Eq</code> is an example where the type parameter is determined
entirely by the tag: it always corresponds to a <code>bool expr</code>.
<code>If</code> is an example where the type parameter depends on the
arguments to the tag, in particular the type parameter of the
<code>If</code> is the type parameter of the then and else clauses.</p>
<p>Let’s try some examples.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let i x = Value (Int x)
and b x = Value (Bool x)
and (+:) x y = Plus (x,y);;
&gt;val i : int -&gt; int expr = &lt;fun&gt;
&gt;val b : bool -&gt; bool expr = &lt;fun&gt;
&gt;val ( +: ) : int expr -&gt; int expr -&gt; int expr = &lt;fun&gt;
i 3;;
&gt;- : int expr = Value (Int 3)
b 3;;
&gt;Line 1, characters 3-4:
&gt;Error: This expression has type int but an expression was expected of type
&gt;         bool
i 3 +: i 6;;
&gt;- : int expr = Plus (Value (Int 3), Value (Int 6))
i 3 +: b false;;
&gt;Line 1, characters 8-15:
&gt;Error: This expression has type bool expr
&gt;       but an expression was expected of type int expr
&gt;       Type bool is not compatible with type int
</code></pre>
</div>
<p>What we see here is that the type-safety rules we previously enforced
with signature-level restrictions on phantom types are now directly
encoded in the definition of the expression type.</p>
<p>These type-safety rules apply not just when constructing an
expression, but also when deconstructing one, which means we can write a
simpler and more concise evaluator that doesn’t need any type-safety
checks.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let eval_value : type a. a value -&gt; a = function
  | Int x -&gt; x
  | Bool x -&gt; x;;
&gt;val eval_value : 'a value -&gt; 'a = &lt;fun&gt;
let rec eval : type a. a expr -&gt; a = function
  | Value v -&gt; eval_value v
  | If (c, t, e) -&gt; if eval c then eval t else eval e
  | Eq (x, y) -&gt; eval x = eval y
  | Plus (x, y) -&gt; eval x + eval y;;
&gt;val eval : 'a expr -&gt; 'a = &lt;fun&gt;
</code></pre>
</div>
<p>Note that we now have a single polymorphic eval function, as opposed
to the two type-specific evaluators we needed when using phantom
types.</p>
</section>
<section class="level3" id="gadts-locally-abstract-types-and-polymorphic-recursion">
<h3>GADTs, locally abstract types, and polymorphic recursion</h3>
<p>The above example lets us see one of the downsides of GADTs, which is
that code using them needs extra type annotations. Look at what happens
if we write the definition of <code>value</code> without the
annotation.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let eval_value = function
  | Int x -&gt; x
  | Bool x -&gt; x;;
&gt;Line 3, characters 7-13:
&gt;Error: This pattern matches values of type bool value
&gt;       but a pattern was expected which matches values of type int value
&gt;       Type bool is not compatible with type int
</code></pre>
</div>
<p>The issue here is that OCaml by default isn’t willing to instantiate
ordinary type variables in different ways in the body of the same
function, which is what is required here. We can fix that by adding a
<em>locally abstract type</em>, which doesn’t have that restriction.
<a data-primary="locally abstract types" data-type="indexterm">&nbsp;</a></p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let eval_value (type a) (v : a value) : a =
  match v with
  | Int x -&gt; x
  | Bool x -&gt; x;;
&gt;val eval_value : 'a value -&gt; 'a = &lt;fun&gt;
</code></pre>
</div>
<p>This isn’t the same annotation we wrote earlier, and indeed, if we
try this approach with <code>eval</code>, we’ll see that it doesn’t
work.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let rec eval (type a) (e : a expr) : a =
  match e with
  | Value v -&gt; eval_value v
  | If (c, t, e) -&gt; if eval c then eval t else eval e
  | Eq (x, y) -&gt; eval x = eval y
  | Plus (x, y) -&gt; eval x + eval y;;
&gt;Line 4, characters 43-44:
&gt;Error: This expression has type a expr but an expression was expected of type
&gt;         bool expr
&gt;       The type constructor a would escape its scope
</code></pre>
</div>
<p> This is a pretty unhelpful error message, but the basic problem is
that <code>eval</code> is recursive, and inference of GADTs doesn’t play
well with recursive calls.</p>
<p>More specifically, the issue is that the type-checker is trying to
merge the locally abstract type <code>a</code> into the type of the
recursive function <code>eval</code>, and merging it into the outer
scope within which <code>eval</code> is defined is the way in which
<code>a</code> is escaping its scope.</p>
<p>We can fix this by explicitly marking <code>eval</code> as
polymorphic, which OCaml has a handy type annotation for.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let rec eval : 'a. 'a expr -&gt; 'a =
  fun (type a) (x : a expr) -&gt;
   match x with
   | Value v -&gt; eval_value v
   | If (c, t, e) -&gt; if eval c then eval t else eval e
   | Eq (x, y) -&gt; eval x = eval y
   | Plus (x, y) -&gt; eval x + eval y;;
&gt;val eval : 'a expr -&gt; 'a = &lt;fun&gt;
</code></pre>
</div>
<p> This works because by marking <code>eval</code> as polymorphic, the
type of <code>eval</code> isn’t specialized to <code>a</code>, and so
<code>a</code> doesn’t escape its scope.</p>
<p>It’s also helpful here because <code>eval</code> itself is an example
of <em>polymorphic recursion</em>, which is to say that
<code>eval</code> needs to call itself at multiple different types. This
comes up, for example, with <code>If</code>, since the <code>If</code>
itself must be of type <code>bool</code>, but the type of the then and
else clauses could be of type <code>int</code>. This means that when
evaluating <code>If</code>, we’ll dispatch <code>eval</code> at a
different type than it was called on. <a data-primary="polymorphic
recursion" data-type="indexterm">&nbsp;</a></p>
<p>As such, <code>eval</code> needs to see itself as polymorphic. This
kind of polymorphism is basically impossible to infer automatically,
which is a second reason we need to annotate <code>eval</code>’s
polymorphism explicitly.</p>
<p>The above syntax is a bit verbose, so OCaml has syntactic sugar to
combine the polymorphism annotation and the creation of the locally
abstract types:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let rec eval : type a. a expr -&gt; a = function
  | Value v -&gt; eval_value v
  | If (c, t, e) -&gt; if eval c then eval t else eval e
  | Eq (x, y) -&gt; eval x = eval y
  | Plus (x, y) -&gt; eval x + eval y;;
&gt;val eval : 'a expr -&gt; 'a = &lt;fun&gt;
</code></pre>
</div>
<p>This type of annotation is the right one to pick when you write any
recursive function that makes use of GADTs.</p>
</section>
</section>
<section class="level2" id="when-are-gadts-useful">
<h2>When are GADTs useful?</h2>
<p>The typed language we showed above is a perfectly reasonable example,
but GADTs are useful for a lot more than designing little languages. In
this section, we’ll try to give you a broader sampling of the kinds of
things you can do with GADTs.</p>
<section class="level3" id="varying-your-return-type">
<h3>Varying your return type</h3>
<p>Sometimes, you want to write a single function that can effectively
have different types in different circumstances. In some sense, this is
totally ordinary. After all, OCaml’s polymorphism means that values can
take on different types in different contexts. <code>List.find</code> is
a fine example. The signature indicates that the type of the result
varies with the type of the input list.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">List.find;;
&gt;- : 'a list -&gt; f:('a -&gt; bool) -&gt; 'a option = &lt;fun&gt;
</code></pre>
</div>
<p> And of course you can use <code>List.find</code> to produce values
of different types.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">List.find ~f:(fun x -&gt; x &gt; 3) [1;3;5;2];;
&gt;- : int option = Some 5
List.find ~f:(Char.is_uppercase) ['a';'B';'C'];;
&gt;- : char option = Some B
</code></pre>
</div>
<p>But this approach is limited to simple dependencies between types
that correspond to how data flows through your code. Sometimes you want
types to vary in a more flexible way.</p>
<p>To make this concrete, let’s say we wanted to create a version of
<code>find</code> that is configurable in terms of how it handles the
case of not finding an item. There are three different behaviors you
might want:</p>
<ul>
<li>Throw an exception.</li>
<li>Return <code>None</code>.</li>
<li>Return a default value.</li>
</ul>
<p>Let’s try to write a function that exhibits these behaviors without
using GADTs. First, we’ll create a variant type that represents the
three possible behaviors.</p>
<div class="highlight">
<pre><code class="language-ocaml">module If_not_found = struct
  type 'a t =
    | Raise
    | Return_none
    | Default_to of 'a
end</code></pre>
</div>
<p>Now we can write <code>flexible_find</code>, which takes an
<code>If_not_found.t</code> as a parameter and varies its behavior
accordingly.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let rec flexible_find list ~f (if_not_found : _ If_not_found.t) =
  match list with
  | hd :: tl -&gt;
    if f hd then Some hd else flexible_find ~f tl if_not_found
  | [] -&gt;
    (match if_not_found with
    | Raise -&gt; failwith "Element not found"
    | Return_none -&gt; None
    | Default_to x -&gt; Some x);;
&gt;val flexible_find :
&gt;  'a list -&gt; f:('a -&gt; bool) -&gt; 'a If_not_found.t -&gt; 'a option = &lt;fun&gt;
</code></pre>
</div>
<p>Here are some examples of the above function in action:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">flexible_find ~f:(fun x -&gt; x &gt; 10) [1;2;5] Return_none;;
&gt;- : int option = None
flexible_find ~f:(fun x -&gt; x &gt; 10) [1;2;5] (Default_to 10);;
&gt;- : int option = Some 10
flexible_find ~f:(fun x -&gt; x &gt; 10) [1;2;5] Raise;;
&gt;Exception: (Failure "Element not found")
flexible_find ~f:(fun x -&gt; x &gt; 10) [1;2;20] Raise;;
&gt;- : int option = Some 20
</code></pre>
</div>
<p>This mostly does what we want, but the problems is that
<code>flexible_find</code> always returns an option, even when it’s
passed <code>Raise</code> or <code>Default_to</code>, which guarantee
that the <code>None</code> case is never used.</p>
<p>To eliminate the unnecessary option in the <code>Raise</code> and
<code>Default_to</code> cases, we’re going to turn
<code>If_not_found.t</code> into a GADT. In particular, we’ll mint it as
a GADT with two type parameters: one for the type of the list element,
and one for the return type of the function.</p>
<div class="highlight">
<pre><code class="language-ocaml">module If_not_found = struct
  type (_, _) t =
    | Raise : ('a, 'a) t
    | Return_none : ('a, 'a option) t
    | Default_to : 'a -&gt; ('a, 'a) t
end</code></pre>
</div>
<p>As you can see, <code>Raise</code> and <code>Default_to</code> both
have the same element type and return type, but <code>Return_none</code>
provides an optional return value.</p>
<p>Here’s a definition of <code>flexible_find</code> that takes
advantage of this GADT. <a data-primary="flexible find" data-type="indexterm">&nbsp;</a></p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let rec flexible_find
 : type a b. f:(a -&gt; bool) -&gt; a list -&gt; (a, b) If_not_found.t -&gt; b =
 fun ~f list if_not_found -&gt;
  match list with
  | [] -&gt;
    (match if_not_found with
    | Raise -&gt; failwith "No matching item found"
    | Return_none -&gt; None
    | Default_to x -&gt; x)
  | hd :: tl -&gt;
    if f hd
    then (
      match if_not_found with
      | Raise -&gt; hd
      | Return_none -&gt; Some hd
      | Default_to _ -&gt; hd)
    else flexible_find ~f tl if_not_found;;
&gt;val flexible_find :
&gt;  f:('a -&gt; bool) -&gt; 'a list -&gt; ('a, 'b) If_not_found.t -&gt; 'b = &lt;fun&gt;
</code></pre>
</div>
<p>As you can see from the signature of <code>flexible_find</code>, the
return value now depends on the type of <code>If_not_found.t</code>,
which means it can depend on the particular variant of
<code>If_not_found.t</code> that’s in use. As a result,
<code>flexible_find</code> only returns an option when it needs to.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">flexible_find ~f:(fun x -&gt; x &gt; 10) [1;2;5] Return_none;;
&gt;- : int option = Base.Option.None
flexible_find ~f:(fun x -&gt; x &gt; 10) [1;2;5] (Default_to 10);;
&gt;- : int = 10
flexible_find ~f:(fun x -&gt; x &gt; 10) [1;2;5] Raise;;
&gt;Exception: (Failure "No matching item found")
flexible_find ~f:(fun x -&gt; x &gt; 10) [1;2;20] Raise;;
&gt;- : int = 20
</code></pre>
</div>
</section>
<section class="level3" id="capturing-the-unknown">
<h3>Capturing the unknown</h3>
<p>Code that works with unknown types is routine in OCaml, and comes up
in the simplest of examples:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let tuple x y = (x,y);;
&gt;val tuple : 'a -&gt; 'b -&gt; 'a * 'b = &lt;fun&gt;
</code></pre>
</div>
<p>The type variables <code>'a</code> and <code>'b</code> indicate that
there are two unknown types here, and these type variables are
<em>universally quantified</em>. Which is to say, the type of
<code>tuple</code> is: <em>for all</em> types <code>a</code> and
<code>b</code>, <code>a -&gt; b -&gt; a * b</code>.</p>
<p>And indeed, we can restrict the type of <code>tuple</code> to any
<code>'a</code> and <code>'b</code> we want.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">(tuple : int -&gt; float -&gt; int * float);;
&gt;- : int -&gt; float -&gt; int * float = &lt;fun&gt;
(tuple : string -&gt; string * string -&gt; string * (string * string));;
&gt;- : string -&gt; string * string -&gt; string * (string * string) = &lt;fun&gt;
</code></pre>
</div>
<p>Sometimes, however, we want type variables that are <em>existentially
quantified</em>, meaning that instead of being compatible with all
types, the type represents a particular but unknown type. <a data-primary="existential types" data-type="indexterm">&nbsp;</a></p>
<p>GADTs provide one natural way of encoding such type variables. Here’s
a simple example.</p>
<div class="highlight">
<pre><code class="language-ocaml">type stringable =
  Stringable : { value: 'a; to_string: 'a -&gt; string } -&gt; stringable</code></pre>
</div>
<p> This type packs together a value of some arbitrary type, along with
a function for converting values of that type to strings.</p>
<p>We can tell that <code>'a</code> is existentially quantified because
it shows up on the left-hand side of the arrow but not on the right, so
the <code>'a</code> that shows up internally doesn’t appear in a type
parameter for <code>stringable</code> itself. Essentially, the
existentially quantified type is bound within the definition of
<code>stringable</code>.</p>
<p>The following function can print an arbitrary
<code>stringable</code>:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let print_stringable (Stringable s) =
  Stdio.print_endline (s.to_string s.value);;
&gt;val print_stringable : stringable -&gt; unit = &lt;fun&gt;
</code></pre>
</div>
<p> We can use <code>print_stringable</code> on a collection of
<code>stringable</code>s of different underlying types.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let stringables =
  (let s value to_string = Stringable { to_string; value } in
    [ s 100 Int.to_string
    ; s 12.3 Float.to_string
    ; s "foo" Fn.id
    ]);;
&gt;val stringables : stringable list =
&gt;  [Stringable {value = &lt;poly&gt;; to_string = &lt;fun&gt;};
&gt;   Stringable {value = &lt;poly&gt;; to_string = &lt;fun&gt;};
&gt;   Stringable {value = &lt;poly&gt;; to_string = &lt;fun&gt;}]
List.iter ~f:print_stringable stringables;;
&gt;100
&gt;12.3
&gt;foo
&gt;- : unit = ()
</code></pre>
</div>
<p>The thing that lets this all work is that the type of the underlying
object is existentially bound within the type <code>stringable</code>.
As such, the type of the underlying values can’t escape the scope of
<code>stringable</code>, and any function that tries to return such a
value won’t type-check.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let get_value (Stringable s) = s.value;;
&gt;Line 1, characters 32-39:
&gt;Error: This expression has type $Stringable_'a
&gt;       but an expression was expected of type 'a
&gt;       The type constructor $Stringable_'a would escape its scope
</code></pre>
</div>
<p>It’s worth spending a moment to decode this error message, and the
meaning of the type variable <code>$Stringable_'a</code> in particular.
You can think of this variable as having three parts:</p>
<ul>
<li>The <code>$</code> marks the variable as an existential.</li>
<li><code>Stringable</code> is the name of the GADT tag that this
variable came from.</li>
<li><code>'a</code> is the name of the type variable from inside that
tag.</li>
</ul>
</section>
<section class="level3" id="abstracting-computational-machines">
<h3>Abstracting computational machines</h3>
<p>A common idiom in OCaml is to combine small components into larger
computational machines, using a collection of component-combining
functions, or <em>combinators</em>. <a data-primary="combinators" data-type="indexterm">&nbsp;</a></p>
<p>GADTs can be helpful for writing such combinators. To see how, let’s
consider an example: <em>pipelines</em>. Here, a pipeline is a sequence
of steps where each step consumes the output of the previous step,
potentially does some side effects, and returns a value to be passed to
the next step. This is analogous to a shell pipeline, and is useful for
all sorts of system automation tasks.</p>
<p>But, can’t we write pipelines already? After all, OCaml comes with a
perfectly serviceable pipeline operator:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">open Core;;
let sum_file_sizes () =
  Sys.ls_dir "."
  |&gt; List.filter ~f:Sys.is_file_exn
  |&gt; List.map ~f:(fun file_name -&gt; (Unix.lstat file_name).st_size)
  |&gt; List.sum (module Int) ~f:Int64.to_int_exn;;
&gt;val sum_file_sizes : unit -&gt; int = &lt;fun&gt;
</code></pre>
</div>
<p> This works well enough, but the advantage of a custom pipeline type
is that it lets you build extra services beyond basic execution of the
pipeline, e.g.:</p>
<ul>
<li>Profiling, so that when you run a pipeline, you get a report of how
long each step of the pipeline took.</li>
<li>Control over execution, like allowing users to pause the pipeline
mid-execution, and restart it later.</li>
<li>Custom error handling, so, for example, you could build a pipeline
that kept track of where it failed, and offered the possibility of
restarting it.</li>
</ul>
<p>The type signature of such a pipeline type might look something like
this:</p>
<div class="highlight">
<pre><code class="language-ocaml">module type Pipeline = sig
  type ('input,'output) t

  val ( @&gt; ) : ('a -&gt; 'b) -&gt; ('b,'c) t -&gt; ('a,'c) t
  val empty : ('a,'a) t
end</code></pre>
</div>
<p>Here, the type <code>('a,'b) t</code> represents a pipeline that
consumes values of type <code>'a</code> and emits values of type
<code>'b</code>. The operator <code>@&gt;</code> lets you add a step to
a pipeline by providing a function to prepend on to an existing
pipeline, and <code>empty</code> gives you an empty pipeline, which can
be used to seed the pipeline.</p>
<p>The following shows how we could use this API for building a pipeline
like our earlier example using <code>|&gt;</code>. Here, we’re using a
<em>functor</em>, which we’ll see in more detail in <a data-type="xref" href="functors.html#functors">Chapter 10, Functors</a>, as a way to
write code using the pipeline API before we’ve implemented it.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">module Example_pipeline (Pipeline : Pipeline) = struct
  open Pipeline
  let sum_file_sizes =
    (fun () -&gt; Sys.ls_dir ".")
    @&gt; List.filter ~f:Sys.is_file_exn
    @&gt; List.map ~f:(fun file_name -&gt; (Unix.lstat file_name).st_size)
    @&gt; List.sum (module Int) ~f:Int64.to_int_exn
    @&gt; empty
end;;
&gt;module Example_pipeline :
&gt;  functor (Pipeline : Pipeline) -&gt;
&gt;    sig val sum_file_sizes : (unit, int) Pipeline.t end
</code></pre>
</div>
<p>If all we want is a pipeline capable of a no-frills execution, we can
define our pipeline itself as a simple function, the <code>@&gt;</code>
operator as function composition. Then executing the pipeline is just
function application.</p>
<div class="highlight">
<pre><code class="language-ocaml">module Basic_pipeline : sig
   include Pipeline
   val exec : ('a,'b) t -&gt; 'a -&gt; 'b
 end= struct
  type ('input, 'output) t = 'input -&gt; 'output

  let empty = Fn.id

  let ( @&gt; ) f t input =
    t (f input)

  let exec t input = t input
end</code></pre>
</div>
<p>But this way of implementing a pipeline doesn’t give us any of the
extra services we discussed. All we’re really doing is step-by-step
building up the same kind of function that we could have gotten using
the <code>|&gt;</code> operator.</p>
<p>We could get a more powerful pipeline by simply enhancing the
pipeline type, providing it with extra runtime structures to track
profiles, or handle exceptions, or provide whatever else is needed for
the particular use-case. But this approach is awkward, since it requires
us to pre-commit to whatever services we’re going to support, and to
embed all of them in our pipeline representation.</p>
<p>GADTs provide a simpler approach. Instead of concretely building a
machine for executing a pipeline, we can use GADTs to abstractly
represent the pipeline we want, and then build the functionality we want
on top of that representation.</p>
<p>Here’s what such a representation might look like.</p>
<div class="highlight">
<pre><code class="language-ocaml">type (_, _) pipeline =
  | Step : ('a -&gt; 'b) * ('b, 'c) pipeline -&gt; ('a, 'c) pipeline
  | Empty : ('a, 'a) pipeline</code></pre>
</div>
<p>The tags here represent the two building blocks of a pipeline:
<code>Step</code> corresponds to the <code>@&gt;</code> operator, and
<code>Empty</code> corresponds to the <code>empty</code> pipeline, as
you can see below.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let ( @&gt; ) f pipeline = Step (f,pipeline);;
&gt;val ( @&gt; ) : ('a -&gt; 'b) -&gt; ('b, 'c) pipeline -&gt; ('a, 'c) pipeline = &lt;fun&gt;
let empty = Empty;;
&gt;val empty : ('a, 'a) pipeline = Empty
</code></pre>
</div>
<p> With that in hand, we can do a no-frills pipeline execution easily
enough.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let rec exec : type a b. (a, b) pipeline -&gt; a -&gt; b =
 fun pipeline input -&gt;
  match pipeline with
  | Empty -&gt; input
  | Step (f, tail) -&gt; exec tail (f input);;
&gt;val exec : ('a, 'b) pipeline -&gt; 'a -&gt; 'b = &lt;fun&gt;
</code></pre>
</div>
<p>But we can also do more interesting things. For example, here’s a
function that executes a pipeline and produces a profile showing how
long each step of a pipeline took.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let exec_with_profile pipeline input =
  let rec loop
      : type a b.
        (a, b) pipeline -&gt; a -&gt; Time_ns.Span.t list -&gt; b * Time_ns.Span.t list
    =
   fun pipeline input rev_profile -&gt;
    match pipeline with
    | Empty -&gt; input, rev_profile
    | Step (f, tail) -&gt;
      let start = Time_ns.now () in
      let output = f input in
      let elapsed = Time_ns.diff (Time_ns.now ()) start in
      loop tail output (elapsed :: rev_profile)
  in
  let output, rev_profile = loop pipeline input [] in
  output, List.rev rev_profile;;
&gt;val exec_with_profile : ('a, 'b) pipeline -&gt; 'a -&gt; 'b * Time_ns.Span.t list =
&gt;  &lt;fun&gt;
</code></pre>
</div>
<p>The more abstract GADT approach for creating a little combinator
library like this has several advantages over having combinators that
build a more concrete computational machine: <a data-primary="combinators, implementing with GADTs" data-type="indexterm">&nbsp;</a></p>
<ul>
<li><p>The core types are simpler, since they are typically built out of
GADT tags that are just reflections the types of the base
combinators.</p></li>
<li><p>The design is more modular, since your core types don’t need to
contemplate every possible use you want to make of them.</p></li>
<li><p>The code tends to be more efficient, since the more concrete
approach typically involves allocating closures to wrap up the necessary
functionality, and closures are more heavyweight than GADT
tags.</p></li>
</ul>
</section>
<section class="level3" id="narrowing-the-possibilities">
<h3>Narrowing the possibilities</h3>
<p>Another use-case for GADTs is to narrow the set of possible states
for a given data-type in different circumstances.</p>
<p>One context where this can be useful is when managing complex
application state, where the available data changes over time. Let’s
consider a simple example, where we’re writing code to handle a logon
request from a user, and we want to check if the user in question is
authorized to logon.</p>
<p>We’ll assume that the user logging in is authenticated as a
particular name, but that in order to authenticate, we need to do two
things: to translate that user-name into a numeric user-id, and to fetch
permissions for the service in question; once we have both, we can check
if the user-id is permitted to log on.</p>
<p>Without GADTs, we might model the state of a single logon request as
follows.</p>
<div class="highlight">
<pre><code class="language-ocaml">type logon_request =
  { user_name : User_name.t
  ; user_id : User_id.t option
  ; permissions : Permissions.t option
  }</code></pre>
</div>
<p>Here, <code>User_name.t</code> represents a textual name,
<code>User_id.t</code> represents an integer identifier associated with
a user, and a <code>Permissions.t</code> lets you determine which
<code>User_id.t</code>’s are authorized to log in.</p>
<p>Here’s how we might write a function for testing whether a given
request is authorized.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let authorized request =
  match request.user_id, request.permissions with
  | None, _ | _, None -&gt;
    Error "Can't check authorization: data incomplete"
  | Some user_id, Some permissions -&gt;
    Ok (Permissions.check permissions user_id);;
&gt;val authorized : logon_request -&gt; (bool, string) result = &lt;fun&gt;
</code></pre>
</div>
<p> The intent is to only call this function once the data is complete,
i.e., when the <code>user_id</code> and <code>permissions</code> fields
have been filled in, which is why it errors out if the data is
incomplete.</p>
<p>The code above works just fine for a simple case like this. But in a
real system, your code can get more complicated in multiple ways,
e.g.,</p>
<ul>
<li>more fields to manage, including more optional fields,</li>
<li>more operations that depend on these optional fields,</li>
<li>multiple requests to be handled in parallel, each of which might be
in a different state of completion.</li>
</ul>
<p>As this kind of complexity creeps in, it can be useful to be able to
track the state of a given request at the type level, and to use that to
narrow the set of states a given request can be in, thereby removing
some extra case analysis and error handling, which can reduce the
complexity of the code and remove opportunities for mistakes.</p>
<p>One way of doing this is to mint different types to represent
different states of the request, e.g., one type for an incomplete
request where various fields are optional, and a different type where
all of the data is mandatory.</p>
<p>While this works, it can be awkward and verbose. With GADTs, we can
track the state of the request in a type parameter, and have that
parameter be used to narrow the set of available cases, without
duplicating the type.</p>
<section class="level4" id="a-completion-sensitive-option-type">
<h4>A completion-sensitive option type</h4>
<p>We’ll start by creating an option type that is sensitive to whether
our request is in a complete or incomplete state. To do that, we’ll mint
types to represent the states of being complete and incomplete.</p>
<div class="highlight">
<pre><code class="language-ocaml">type incomplete = Incomplete
type complete = Complete</code></pre>
</div>
<p>The definition of the types doesn’t really matter, since we’re never
instantiating these types, just using them as markers of different
states. All that matters is that the types are distinct.</p>
<p>Now we can mint a completeness-sensitive option type. Note the two
type variables: the first indicates the type of the contents of the
option, and the second indicates whether this is being used in an
incomplete state.</p>
<div class="highlight">
<pre><code class="language-ocaml">type (_, _) coption =
  | Absent : (_, incomplete) coption
  | Present : 'a -&gt; ('a, _) coption</code></pre>
</div>
<p> We use <code>Absent</code> and <code>Present</code> rather than
<code>Some</code> or <code>None</code> to make the code less confusing
when both <code>option</code> and <code>coption</code> are used
together.</p>
<p>You might notice that we haven’t used <code>complete</code> here
explicitly. Instead, what we’ve done is to ensure that only an
<code>incomplete coption</code> can be <code>Absent</code>. Accordingly,
a <code>coption</code> that’s <code>complete</code> (and therefore not
<code>incomplete</code>) can only be <code>Present</code>.</p>
<p>This is easier to understand with some examples. Consider the
following function for getting the value out of a <code>coption</code>,
returning a default value if <code>Absent</code> is found.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let get ~default o =
   match o with
   | Present x -&gt; x
   | Absent -&gt; default;;
&gt;val get : default:'a -&gt; ('a, incomplete) coption -&gt; 'a = &lt;fun&gt;
</code></pre>
</div>
<p> Note that the <code>incomplete</code> type was inferred here. If we
annotate the <code>coption</code> as <code>complete</code>, the code no
longer compiles.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let get ~default (o : (_,complete) coption) =
  match o with
  | Absent -&gt; default
  | Present x -&gt; x;;
&gt;Line 3, characters 7-13:
&gt;Error: This pattern matches values of type ('a, incomplete) coption
&gt;       but a pattern was expected which matches values of type
&gt;         ('a, complete) coption
&gt;       Type incomplete is not compatible with type complete
</code></pre>
</div>
<p>We can make this compile by deleting the <code>Absent</code> branch
(and the now useless <code>default</code> argument).</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let get (o : (_,complete) coption) =
  match o with
  | Present x -&gt; x;;
&gt;val get : ('a, complete) coption -&gt; 'a = &lt;fun&gt;
</code></pre>
</div>
<p>We could write this more simply as:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let get (Present x : (_,complete) coption) = x;;
&gt;val get : ('a, complete) coption -&gt; 'a = &lt;fun&gt;
</code></pre>
</div>
<p> As we can see, when the <code>coption</code> is known to be
<code>complete</code>, the pattern matching is narrowed to just the
<code>Present</code> case.</p>
</section>
<section class="level4" id="a-completion-sensitive-request-type">
<h4>A completion-sensitive request type</h4>
<p>We can use <code>coption</code> to define a completion-sensitive
version of <code>logon_request</code>.</p>
<div class="highlight">
<pre><code class="language-ocaml">type 'c logon_request =
  { user_name : User_name.t
  ; user_id : (User_id.t, 'c) coption
  ; permissions : (Permissions.t, 'c) coption
  }</code></pre>
</div>
<p>There’s a single type parameter for the <code>logon_request</code>
that marks whether it’s <code>complete</code>, at which point, both the
<code>user_id</code> and <code>permissions</code> fields will be
<code>complete</code> as well.</p>
<p>As before, it’s easy to fill in the <code>user_id</code> and
<code>permissions</code> fields.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let set_user_id request x = { request with user_id = Present x };;
&gt;val set_user_id : 'a logon_request -&gt; User_id.t -&gt; 'a logon_request = &lt;fun&gt;
let set_permissions request x = { request with permissions = Present x };;
&gt;val set_permissions : 'a logon_request -&gt; Permissions.t -&gt; 'a logon_request =
&gt;  &lt;fun&gt;
</code></pre>
</div>
<p>Note that filling in the fields doesn’t automatically mark a request
as <code>complete</code>. To do that, we need to explicitly test for
completeness, and then construct a version of the record with just the
completed fields filled in.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let check_completeness request =
  match request.user_id, request.permissions with
  | Absent, _ | _, Absent -&gt; None
  | (Present _ as user_id), (Present _ as permissions) -&gt;
    Some { request with user_id; permissions };;
&gt;val check_completeness : incomplete logon_request -&gt; 'a logon_request option =
&gt;  &lt;fun&gt;
</code></pre>
</div>
<p>The result is polymorphic, meaning it can return a logon request of
any kind, which includes the possibility of returning a complete
request. In practice, the function type is easier to understand if we
constrain the return value to explicitly return a <code>complete</code>
request.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let check_completeness request : complete logon_request option =
  match request.user_id, request.permissions with
  | Absent, _ | _, Absent -&gt; None
  | (Present _ as user_id), (Present _ as permissions) -&gt;
    Some { request with user_id; permissions };;
&gt;val check_completeness :
&gt;  incomplete logon_request -&gt; complete logon_request option = &lt;fun&gt;
</code></pre>
</div>
<p>Finally, we can write an authorization checker that works
unconditionally on a complete login request.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let authorized (request : complete logon_request) =
  let { user_id = Present user_id; permissions = Present permissions; _ } = request in
  Permissions.check permissions user_id;;
&gt;val authorized : complete logon_request -&gt; bool = &lt;fun&gt;
</code></pre>
</div>
<p>After all that work, the result may seem a bit underwhelming, and
indeed, most of the time, this kind of narrowing isn’t worth the
complexity of setting it up. But for a sufficiently complex state
machine, cutting down on the possibilities that your code needs to
contemplate can make a big difference to the comprehensibility and
correctness of the result.</p>
</section>
<section class="level4" id="type-distinctness-and-abstraction">
<h4>Type distinctness and abstraction</h4>
<p>In the example in this section, we used two types,
<code>complete</code> and <code>incomplete</code> to mark different
states, and we defined those types so as to be in some sense obviously
different.</p>
<div class="highlight">
<pre><code class="language-ocaml">type incomplete = Incomplete
type complete = Complete</code></pre>
</div>
<p>This isn’t strictly necessary. Here’s another way of defining these
types that makes them less obviously distinct.</p>
<div class="highlight">
<pre><code class="language-ocaml">type incomplete = Z
type complete = Z</code></pre>
</div>
<p>OCaml’s variant types are nominal, so <code>complete</code> and
<code>incomplete</code> are distinct types, despite having variants of
the same name, as you can see when we try to put instances of each type
in the same list.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let i = (Z : incomplete) and c = (Z : complete);;
&gt;val i : incomplete = Z
&gt;val c : complete = Z
[i; c];;
&gt;Line 1, characters 5-6:
&gt;Error: This expression has type complete
&gt;       but an expression was expected of type incomplete
</code></pre>
</div>
<p> As a result, we can narrow a pattern match using these types as
indices, much as we did earlier. First, we set up the
<code>coption</code> type:</p>
<div class="highlight">
<pre><code class="language-ocaml">type ('a, _) coption =
  | Absent : (_, incomplete) coption
  | Present : 'a -&gt; ('a, _) coption</code></pre>
</div>
<p> Then, we write a function that requires the <code>coption</code> to
be complete, and accordingly, need only contemplate the
<code>Present</code> case.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let assume_complete (coption : (_,complete) coption) =
  match coption with
  | Present x -&gt; x;;
&gt;val assume_complete : ('a, complete) coption -&gt; 'a = &lt;fun&gt;
</code></pre>
</div>
<p>An easy-to-miss issue here is that the way we expose these types
through an interface can cause OCaml to lose track of the distinctness
of the types in question. Consider this version, where we entirely hide
the definition of <code>complete</code> and <code>incomplete</code>.</p>
<div class="highlight">
<pre><code class="language-ocaml">module M : sig
  type incomplete
  type complete
end = struct
  type incomplete = Z
  type complete = Z
end
include M

type ('a, _) coption =
  | Absent : (_, incomplete) coption
  | Present : 'a -&gt; ('a, _) coption</code></pre>
</div>
<p> Now, the <code>assume_complete</code> function we wrote is no longer
found to be exhaustive.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let assume_complete (coption : (_,complete) coption) =
  match coption with
  | Present x -&gt; x;;
&gt;Lines 2-3, characters 5-21:
&gt;Warning 8 [partial-match]: this pattern-matching is not exhaustive.
&gt;Here is an example of a case that is not matched:
&gt;Absent
&gt;val assume_complete : ('a, complete) coption -&gt; 'a = &lt;fun&gt;
</code></pre>
</div>
<p>That’s because by leaving the types abstract, we’ve entirely hidden
the underlying types, leaving the type system with no evidence that the
types are distinct.</p>
<p>Let’s see what happens if we expose the implementation of these
types.</p>
<div class="highlight">
<pre><code class="language-ocaml">module M : sig
  type incomplete = Z
  type complete = Z
end = struct
  type incomplete = Z
  type complete = Z
end
include M

type ('a, _) coption =
  | Absent : (_, incomplete) coption
  | Present : 'a -&gt; ('a, _) coption</code></pre>
</div>
<p> But the result is still not exhaustive!</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let assume_complete (coption : (_,complete) coption) =
  match coption with
  | Present x -&gt; x;;
&gt;Lines 2-3, characters 5-21:
&gt;Warning 8 [partial-match]: this pattern-matching is not exhaustive.
&gt;Here is an example of a case that is not matched:
&gt;Absent
&gt;val assume_complete : ('a, complete) coption -&gt; 'a = &lt;fun&gt;
</code></pre>
</div>
<p>In order to be exhaustive, we need the types that are exposed to be
definitively different, which would be the case if we defined them as
variants with differently named tags, as we did originally.</p>
<p>The reason for this is that types that appear to be different in an
interface may turn out to be the same in the implementation, as we can
see below.</p>
<div class="highlight">
<pre><code class="language-ocaml">module M : sig
  type incomplete = Z
  type complete = Z
end = struct
  type incomplete = Z
  type complete = incomplete = Z
end</code></pre>
</div>
<p>All of which is to say: when creating types to act as abstract
markers for the type parameter of a GADT, you should chose definitions
that make the distinctness of those types clear, and you should expose
those definitions in your <code>mli</code>s.</p>
</section>
<section class="level4" id="narrowing-without-gadts">
<h4>Narrowing without GADTs</h4>
<p>Thus far, we’ve only seen narrowing in the context of GADTs, but
OCaml can eliminate impossible cases from ordinary variants too. As with
GADTs, to eliminate a case you need to demonstrate that the case in
question is impossible at the type level.</p>
<p>One way to do this is via an <em>uninhabited type</em>, which is a
type that has no associated values. You can declare such a value by
creating a variant with no tags. <a data-primary="uninhabited
type" data-type="indexterm">&nbsp;</a><a data-primary="type, uninhabited" data-type="indexterm">&nbsp;</a></p>
<div class="highlight">
<pre><code class="language-ocaml">type nothing = |</code></pre>
</div>
<p> This turns out to be useful enough that <code>Base</code> has a
standard uninhabited type, <code>Nothing.t</code>. <a data-primary="Nothing.t" data-type="indexterm">&nbsp;</a></p>
<p>So, how does an uninhabited type help? Well, consider the
<code>Result.t</code> type, discussed in as described in <a data-type="xref" href="error-handling.html#encoding-errors-with-result">Chapter 7, Error Handling</a>. Normally, to match a
<code>Result.t</code>, you need to handle both the <code>Ok</code> and
<code>Error</code> cases.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">open Stdio;;
let print_result (x : (int,string) Result.t) =
  match x with
  | Ok x -&gt; printf "%d\n" x
  | Error x -&gt; printf "ERROR: %s\n" x;;
&gt;val print_result : (int, string) result -&gt; unit = &lt;fun&gt;
</code></pre>
</div>
<p> But if the <code>Error</code> case contains an uninhabitable type,
well, that case can never be instantiated, and OCaml will tell you as
much.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let print_result (x : (int, Nothing.t) Result.t) =
  match x with
  | Ok x -&gt; printf "%d\n" x
  | Error _ -&gt; printf "ERROR\n";;
&gt;Line 4, characters 7-14:
&gt;Warning 56 [unreachable-case]: this match case is unreachable.
&gt;Consider replacing it with a refutation case '&lt;pat&gt; -&gt; .'
&gt;val print_result : (int, Nothing.t) result -&gt; unit = &lt;fun&gt;
</code></pre>
</div>
<p> We can follow the advice above, and add a so-called <em>refutation
case</em>. <a data-primary="refutation case" data-type="indexterm">&nbsp;</a></p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let print_result (x : (int, Nothing.t) Result.t) =
  match x with
  | Ok x -&gt; printf "%d\n" x
  | Error _ -&gt; .;;
&gt;val print_result : (int, Nothing.t) result -&gt; unit = &lt;fun&gt;
</code></pre>
</div>
<p>The period in the final case tells the compiler that we believe this
case can never be reached, and OCaml will verify that it’s true. In some
simple cases, however, the compiler can automatically add the refutation
case for you, so you don’t need to write it out explicitly.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let print_result (x : (int, Nothing.t) Result.t) =
  match x with
  | Ok x -&gt; printf "%d\n" x;;
&gt;val print_result : (int, Nothing.t) result -&gt; unit = &lt;fun&gt;
</code></pre>
</div>
<p>Narrowing with uninhabitable types can be useful when using a highly
configurable library that supports multiple different modes of use, not
all of which are necessarily needed for a given application. One example
of this comes from <code>Async</code>’s RPC (remote procedure-call)
library. Async RPCs support a particular flavor of interaction called a
<code>State_rpc</code>. Such an RPC is parameterized by four types, for
four different kinds of data: <a data-primary="Async_rpc" data-type="indexterm">&nbsp;</a> <a data-primary="State_rpc" data-type="indexterm">&nbsp;</a></p>
<ul>
<li><code>query</code>, for the initial client request,</li>
<li><code>state</code>, for the initial snapshot returned by the
server,</li>
<li><code>update</code>, for the sequence of updates to that snapshot,
and</li>
<li><code>error</code>, for an error to terminate the stream.</li>
</ul>
<p>Now, imagine you want to use a <code>State_rpc</code> in a context
where you don’t need to terminate the stream with a custom error. We
could just instantiate the <code>State_rpc</code> using the type
<code>unit</code> for the error type.</p>
<div class="highlight">
<pre><code class="language-ocaml">open Core
open Async
let rpc =
  Rpc.State_rpc.create
    ~name:"int-map"
    ~version:1
    ~bin_query:[%bin_type_class: unit]
    ~bin_state:[%bin_type_class: int Map.M(String).t]
    ~bin_update:[%bin_type_class: int Map.M(String).t]
    ~bin_error:[%bin_type_class: unit]
    ()</code></pre>
</div>
<p> But with this approach, you still have to handle the error case when
writing code to dispatch the RPC.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let dispatch conn =
  match%bind Rpc.State_rpc.dispatch rpc conn () &gt;&gt;| ok_exn with
  | Ok (initial_state, updates, _) -&gt; handle_state_changes initial_state updates
  | Error () -&gt; failwith "this is not supposed to happen";;
&gt;val dispatch : Rpc.Connection.t -&gt; unit Deferred.t = &lt;fun&gt;
</code></pre>
</div>
<p>An alternative approach is to use an uninhabited type for the
error:</p>
<div class="highlight">
<pre><code class="language-ocaml">let rpc =
  Rpc.State_rpc.create
    ~name:"foo"
    ~version:1
    ~bin_query:[%bin_type_class: unit]
    ~bin_state:[%bin_type_class: int Map.M(String).t]
    ~bin_update:[%bin_type_class: int Map.M(String).t]
    ~bin_error:[%bin_type_class: Nothing.t]
    ()</code></pre>
</div>
<p>Now, we’ve essentially banned the use of the <code>error</code> type,
and as a result, our dispatch function needs only deal with the
<code>Ok</code> case.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let dispatch conn =
  match%bind Rpc.State_rpc.dispatch rpc conn () &gt;&gt;| ok_exn with
  | Ok (initial_state, updates, _) -&gt; handle_state_changes initial_state updates;;
&gt;val dispatch : Rpc.Connection.t -&gt; unit Deferred.t = &lt;fun&gt;
</code></pre>
</div>
<p>What’s nice about this example is that it shows that narrowing can be
applied to code that isn’t designed with narrowing in mind.</p>
</section>
</section>
</section>
<section class="level2" id="limitations-of-gadts">
<h2>Limitations of GADTs</h2>
<p>Hopefully, we’ve demonstrated the utility of GADTs, while at the same
time showing some of the attendant complexities. In this final section,
we’re going to highlight some remaining difficulties with using GADTs
that you may run in to, as well as how to work around them.</p>
<section class="level3" id="or-patterns">
<h3>Or-patterns</h3>
<p>GADTs don’t work well with or-patterns. Consider the following type
that represents various ways we might use for obtaining some piece of
data. <a data-primary="or-patterns" data-type="indexterm">&nbsp;</a></p>
<div class="highlight">
<pre><code class="language-ocaml">open Core
module Source_kind = struct
  type _ t =
    | Filename : string t
    | Host_and_port : Host_and_port.t t
    | Raw_data : string t
end</code></pre>
</div>
<p>We can write a function that takes a <code>Source_kind.t</code> and
the corresponding source, and prints it out.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let source_to_sexp (type a) (kind : a Source_kind.t) (source : a) =
  match kind with
  | Filename -&gt; String.sexp_of_t source
  | Host_and_port -&gt; Host_and_port.sexp_of_t source
  | Raw_data -&gt; String.sexp_of_t source;;
&gt;val source_to_sexp : 'a Source_kind.t -&gt; 'a -&gt; Sexp.t = &lt;fun&gt;
</code></pre>
</div>
<p> But, observing that the right hand side of <code>Raw_data</code> and
<code>Filename</code> are the same, you might try to merge those cases
together with an or-pattern. Unfortunately, that doesn’t work.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let source_to_sexp (type a) (kind : a Source_kind.t) (source : a) =
  match kind with
  | Filename | Raw_data -&gt; String.sexp_of_t source
  | Host_and_port -&gt; Host_and_port.sexp_of_t source;;
&gt;Line 3, characters 47-53:
&gt;Error: This expression has type a but an expression was expected of type
&gt;         string
</code></pre>
</div>
<p>Or-patterns do sometimes work, but only when you don’t make use of
the type information that is discovered during the pattern match. Here’s
an example of a function that uses or-patterns successfully.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let requires_io (type a) (kind : a Source_kind.t) =
  match kind with
  | Filename | Host_and_port -&gt; true
  | Raw_data -&gt; false;;
&gt;val requires_io : 'a Source_kind.t -&gt; bool = &lt;fun&gt;
</code></pre>
</div>
<p>In any case, the lack of or-patterns is annoying, but it’s not a big
deal, since you can reduce the code duplication by pulling out most of
the content of the duplicated right-hand sides into functions that can
be called in each of the duplicated cases.</p>
</section>
<section class="level3" id="deriving-serializers">
<h3>Deriving serializers</h3>
<p>As will be discussed in more detail in <a data-type="xref" href="data-serialization.html#data-serialization-with-s-expressions">Chapter 20, Data Serialization With S-Expressions</a>,
s-expressions are a convenient data format for representing structured
data. Rather than write the serializers and deserializers by hand, we
typically use <code>ppx_sexp_value</code>, which is a syntax extension
which auto-generates these functions for a given type, based on that
type’s definition. <a data-secondary="ppx_sexp_value" data-primary="syntax
extension" data-type="indexterm">&nbsp;</a> <a data-primary="ppx_sexp_value" data-type="indexterm">&nbsp;</a></p>
<p>Here’s an example:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">type position = { x: float; y: float } [@@deriving sexp];;
&gt;type position = { x : float; y : float; }
&gt;val position_of_sexp : Sexp.t -&gt; position = &lt;fun&gt;
&gt;val sexp_of_position : position -&gt; Sexp.t = &lt;fun&gt;
sexp_of_position { x = 3.5; y = -2. };;
&gt;- : Sexp.t = ((x 3.5) (y -2))
position_of_sexp (Sexp.of_string "((x 72) (y 1.2))");;
&gt;- : position = {x = 72.; y = 1.2}
</code></pre>
</div>
<p>While <code>[@@deriving sexp]</code> works with most types, it
doesn’t always work with GADTs.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">type _ number_kind =
  | Int : int number_kind
  | Float : float number_kind
[@@deriving sexp];;
&gt;Lines 1-4, characters 1-20:
&gt;Error: This expression has type int number_kind
&gt;       but an expression was expected of type a__001_ number_kind
&gt;       Type int is not compatible with type a__001_
</code></pre>
</div>
<p>The error message is pretty awful, but if you stop and think about
it, it’s not too surprising that we ran into trouble here. What should
the type of <code>number_kind_of_sexp</code> be anyway? When parsing
<code>"Int"</code>, the returned type would have to be
<code>int number_kind</code>, and when parsing <code>"Float"</code>, the
type would have to be <code>float number_kind</code>. That kind of
dependency between the value of an argument and the type of the returned
value is just not expressible in OCaml’s type system.</p>
<p>This argument doesn’t stop us from serializing, and indeed,
<code>[@@deriving sexp_of]</code>, which only creates the serializer,
works just fine.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">type _ number_kind =
 | Int : int number_kind
 | Float : float number_kind
[@@deriving sexp_of];;
&gt;type _ number_kind = Int : int number_kind | Float : float number_kind
&gt;val sexp_of_number_kind :
&gt;  ('a__001_ -&gt; Sexp.t) -&gt; 'a__001_ number_kind -&gt; Sexp.t = &lt;fun&gt;
sexp_of_number_kind Int.sexp_of_t Int;;
&gt;- : Sexp.t = Int
</code></pre>
</div>
<p>It is possible to build a deserializer for <code>number_kind</code>,
but it’s tricky. First, we’ll need a type that packs up a
<code>number_kind</code> while hiding its type parameter. This is going
to be the value we return from our parser.</p>
<div class="highlight">
<pre><code class="language-ocaml">type packed_number_kind = P : _ number_kind -&gt; packed_number_kind</code></pre>
</div>
<p> Next, we’ll need to create a non-GADT version of our type, for which
we’ll derive a deserializer.</p>
<div class="highlight">
<pre><code class="language-ocaml">type simple_number_kind = Int | Float [@@deriving of_sexp]</code></pre>
</div>
<p> Then, we write a function for converting from our non-GADT type to
the packed variety.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let simple_number_kind_to_packed_number_kind kind :
  packed_number_kind
  =
  match kind with
  | Int -&gt; P Int
  | Float -&gt; P Float;;
&gt;val simple_number_kind_to_packed_number_kind :
&gt;  simple_number_kind -&gt; packed_number_kind = &lt;fun&gt;
</code></pre>
</div>
<p>Finally, we combine our generated sexp-converter with our conversion
type to produce the full deserialization function.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let number_kind_of_sexp sexp =
  simple_number_kind_of_sexp sexp
  |&gt; simple_number_kind_to_packed_number_kind;;
&gt;val number_kind_of_sexp : Sexp.t -&gt; packed_number_kind = &lt;fun&gt;
</code></pre>
</div>
<p>And here’s that function in action.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">List.map ~f:number_kind_of_sexp
  [ Sexp.of_string "Float"; Sexp.of_string "Int" ];;
&gt;- : packed_number_kind list = [P Float; P Int]
</code></pre>
</div>
<p>While all of this is doable, it’s definitely awkward, and requires
some unpleasant code duplication.</p>
</section>
</section>
</section>
</article></div><a href="functors.html" class="next-chapter"><div class="content"><h1><small>Next: Chapter 10</small>Functors</h1></div></a><footer><div class="content"><ul><li><a href="http://twitter.com/realworldocaml">@realworldocaml</a></li><li><a href="http://twitter.com/yminsky">@yminsky</a></li><li><a href="http://twitter.com/avsm">@avsm</a></li><li><a href="https://github.com/realworldocaml">GitHub</a></li><li><a href="http://www.goodreads.com/book/show/16087552-real-world-ocaml">goodreads</a></li></ul><p>Copyright 2012-2022 Anil Madhavapeddy and Yaron Minsky.</p></div></footer><script src="js/jquery.min.js"></script><script src="js/min/app-min.js"></script></body></html>