<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="imperative-programming-1">
  <title>Imperative Programming</title>

  <para>Most of the code shown so far in this book, and indeed, most OCaml
  code in general, is <emphasis>pure</emphasis>. Pure code works without
  mutating the program's internal state, performing I/O, reading the clock, or
  in any other way interacting with changeable parts of the world. Thus, a
  pure function behaves like a mathematical function, always returning the
  same results when given the same inputs, and never affecting the world
  except insofar as it returns the value of its computation.
  <emphasis>Imperative</emphasis> code, on the other hand, operates by
  side-effects that modify a program's internal state or interact with the
  outside world. An imperative function has a new effect, and potentially
  returns different results, every time it's called.<indexterm
      class="singular">
      <primary>imperative programming</primary>

      <secondary>benefits of</secondary>
    </indexterm><indexterm class="singular">
      <primary>pure code</primary>
    </indexterm><indexterm class="singular">
      <primary>programming</primary>

      <secondary>immutable vs. imperative</secondary>
    </indexterm><indexterm class="startofrange" id="PROGimper">
      <primary>programming</primary>

      <secondary>imperative programming</secondary>
    </indexterm></para>

  <para>Pure code is the default in OCaml, and for good reason—it's generally
  easier to reason about, less error prone and more composable. But imperative
  code is of fundamental importance to any practical programming language
  because real-world tasks require that you interact with the outside world,
  which is by its nature imperative. Imperative programming can also be
  important for performance. While pure code is quite efficient in OCaml,
  there are many algorithms that can only be implemented efficiently using
  imperative techniques.</para>

  <para>OCaml offers a happy compromise here, making it easy and natural to
  program in a pure style, but also providing great support for imperative
  programming. This chapter will walk you through OCaml's imperative features,
  and help you use them to their fullest.</para>

  <sect1 id="example-imperative-dictionaries">
    <title>Example: Imperative Dictionaries</title>

    <para>We'll start with the implementation of a simple imperative
    dictionary, i.e., a mutable mapping from keys to values. This is really
    for illustration purposes; both Core and the standard library provide
    imperative dictionaries, and for most real-world tasks, you should use one
    of those implementations. There's more advice on using Core's
    implementation in particular in <xref
    linkend="maps-and-hash-tables"/>.<indexterm class="startofrange"
        id="DICTimper">
        <primary>dictionaries, imperative</primary>
      </indexterm><indexterm class="singular">
        <primary>Core standard library</primary>

        <secondary>imperative dictionaries in</secondary>
      </indexterm><indexterm class="singular">
        <primary>mutable mapping</primary>
      </indexterm><indexterm class="startofrange" id="IPimpdict">
        <primary>imperative programming</primary>

        <secondary>imperative dictionaries</secondary>
      </indexterm></para>

    <para>The dictionary we'll describe now, like those in Core and the
    standard library, will be implemented as a hash table. In particular,
    we'll use an <emphasis>open hashing</emphasis> scheme, where the hash
    table will be an array of buckets, each bucket containing a list of
    key/value pairs that have been hashed into that bucket.<indexterm
        class="singular">
        <primary>open hashing schemes</primary>
      </indexterm></para>

    <para>Here's the interface we'll match, provided as an <literal
    moreinfo="none">mli</literal>. The type <literal moreinfo="none">('a, 'b)
    t</literal> represents a dictionary with keys of type <literal
    moreinfo="none">'a</literal> and data of type <literal
    moreinfo="none">'b</literal>:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/dictionary.mli">imperative-programming/dictionary.mli</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml">(* file: dictionary.mli *)
open Core.Std

type ('a, 'b) t

val create : unit -&gt; ('a, 'b) t
val length : ('a, 'b) t -&gt; int
val add    : ('a, 'b) t -&gt; key:'a -&gt; data:'b -&gt; unit
val find   : ('a, 'b) t -&gt; 'a -&gt; 'b option
val iter   : ('a, 'b) t -&gt; f:(key:'a -&gt; data:'b -&gt; unit) -&gt; unit
val remove : ('a, 'b) t -&gt; 'a -&gt; unit</programlisting>

    <para>The <literal moreinfo="none">mli</literal> also includes a
    collection of helper functions whose purpose and behavior should be
    largely inferrable from their names and type signatures. Notice that a
    number of the functions, in particular, ones like <literal
    moreinfo="none">add</literal> that modify the dictionary, return unit.
    This is typical of functions that act by side effect.</para>

    <para>We'll now walk through the implementation (contained in the
    corresponding <literal moreinfo="none">ml</literal> file) piece by piece,
    explaining different imperative constructs as they come up.</para>

    <para>Our first step is to define the type of a dictionary as a record
    with two fields:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/dictionary.ml">imperative-programming/dictionary.ml</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml">(* file: dictionary.ml *)
open Core.Std

type ('a, 'b) t = { mutable length: int;
                    buckets: ('a * 'b) list array;
                  }</programlisting>

    <para>The first field, <literal moreinfo="none">length</literal> is
    declared as mutable. In OCaml, records are immutable by default, but
    individual fields are mutable when marked as such. The second field,
    <literal moreinfo="none">buckets</literal>, is immutable but contains an
    array, which is itself a mutable data structure.<indexterm
        class="singular">
        <primary>fields</primary>

        <secondary>mutability of</secondary>
      </indexterm></para>

    <para>Now we'll start putting together the basic functions for
    manipulating a dictionary:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/dictionary.ml">imperative-programming/dictionary.ml</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml">let num_buckets = 17

let hash_bucket key = (Hashtbl.hash key) mod num_buckets

let create () =
  { length = 0;
    buckets = Array.create ~len:num_buckets [];
  }

let length t = t.length

let find t key =
  List.find_map t.buckets.(hash_bucket key)
    ~f:(fun (key',data) -&gt; if key' = key then Some data else None)</programlisting>

    <para>Note that <literal moreinfo="none">num_buckets</literal> is a
    constant, which means our bucket array is of fixed length. A practical
    implementation would need to be able to grow the array as the number of
    elements in the dictionary increases, but we'll omit this to simplify the
    presentation.</para>

    <para>The function <literal moreinfo="none">hash_bucket</literal> is used
    throughout the rest of the module to choose the position in the array that
    a given key should be stored at. It is implemented on top of <literal
    moreinfo="none">Hashtbl.hash</literal>, which is a hash function provided
    by the OCaml runtime that can be applied to values of any type. Thus, its
    own type is polymorphic: <literal moreinfo="none">'a -&gt;
    int</literal>.</para>

    <para>The other functions defined above are fairly straightforward:</para>

    <variablelist>
      <varlistentry>
        <term><literal moreinfo="none">create</literal></term>

        <listitem>
          <para>Creates an empty dictionary.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">length</literal></term>

        <listitem>
          <para>Grabs the length from the corresponding record field, thus
          returning the number of entries stored in the dictionary.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><literal moreinfo="none">find</literal></term>

        <listitem>
          <para>Looks for a matching key in the table and returns the
          corresponding value if found as an option.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>Another important piece of imperative syntax shows up in <literal
    moreinfo="none">find</literal>: we write <literal
    moreinfo="none">array.(index)</literal> to grab a value from an array.
    <literal moreinfo="none">find</literal> also uses <literal
    moreinfo="none">List.find_map</literal>, which you can see the type of by
    typing it into the toplevel:</para>

    <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/examples.topscript">imperative-programming/examples.topscript</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">List.find_map;;</userinput>
<computeroutput moreinfo="none">- : 'a list -&gt; f:('a -&gt; 'b option) -&gt; 'b option = &lt;fun&gt;</computeroutput></programlisting>

    <para><literal moreinfo="none">List.find_map</literal> iterates over the
    elements of the list, calling <literal moreinfo="none">f</literal> on each
    one until a <literal moreinfo="none">Some</literal> is returned by
    <literal moreinfo="none">f</literal>, at which point that value is
    returned. If <literal moreinfo="none">f</literal> returns <literal
    moreinfo="none">None</literal> on all values, then <literal
    moreinfo="none">None</literal> is returned.</para>

    <para>Now let's look at the implementation of <literal
    moreinfo="none">iter</literal>:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/dictionary.ml">imperative-programming/dictionary.ml</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml">let iter t ~f =
  for i = 0 to Array.length t.buckets - 1 do
    List.iter t.buckets.(i) ~f:(fun (key, data) -&gt; f ~key ~data)
  done</programlisting>

    <para><literal moreinfo="none">iter</literal> is designed to walk over all
    the entries in the dictionary. In particular, <literal
    moreinfo="none">iter t ~f</literal> will call <literal
    moreinfo="none">f</literal> for each key/value pair in dictionary <literal
    moreinfo="none">t</literal>. Note that <literal
    moreinfo="none">f</literal> must return <literal
    moreinfo="none">unit</literal>, since it is expected to work by side
    effect rather than by returning a value, and the overall <literal
    moreinfo="none">iter</literal> function returns <literal
    moreinfo="none">unit</literal> as well.</para>

    <para>The code for <literal moreinfo="none">iter</literal> uses two forms
    of iteration: a <literal moreinfo="none">for</literal> loop to walk over
    the array of buckets; and within that loop a call to <literal
    moreinfo="none">List.iter</literal> to walk over the values in a given
    bucket. We could have done the outer loop with a recursive function
    instead of a <literal moreinfo="none">for</literal> loop, but <literal
    moreinfo="none">for</literal> loops are syntactically convenient, and are
    more familiar and idiomatic in the context of imperative code.</para>

    <para>The following code is for adding and removing mappings from the
    dictionary:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/dictionary.ml">imperative-programming/dictionary.ml</ulink>
    (part 4)</para>

    <programlisting format="linespecific" language="ocaml">let bucket_has_key t i key =
  List.exists t.buckets.(i) ~f:(fun (key',_) -&gt; key' = key)

let add t ~key ~data =
  let i = hash_bucket key in
  let replace = bucket_has_key t i key in
  let filtered_bucket =
    if replace then
      List.filter t.buckets.(i) ~f:(fun (key',_) -&gt; key' &lt;&gt; key)
    else
      t.buckets.(i)
  in
  t.buckets.(i) &lt;- (key, data) :: filtered_bucket;
  if not replace then t.length &lt;- t.length + 1

let remove t key =
  let i = hash_bucket key in
  if bucket_has_key t i key then (
    let filtered_bucket =
      List.filter t.buckets.(i) ~f:(fun (key',_) -&gt; key' &lt;&gt; key)
    in
    t.buckets.(i) &lt;- filtered_bucket;
    t.length &lt;- t.length - 1
  )</programlisting>

    <para>This preceding code is made more complicated by the fact that we
    need to detect whether we are overwriting or removing an existing binding,
    so we can decide whether <literal moreinfo="none">t.length</literal> needs
    to be changed. The helper function <literal
    moreinfo="none">bucket_has_key</literal> is used for this purpose.</para>

    <para>Another piece of syntax shows up in both <literal
    moreinfo="none">add</literal> and <literal
    moreinfo="none">remove</literal>: the use of the <literal
    moreinfo="none">&lt;-</literal> operator to update elements of an array
    (<literal moreinfo="none">array.(i) &lt;- expr</literal>) and for updating
    a record field (<literal moreinfo="none">record.field &lt;-
    expression</literal>).</para>

    <para>We also use <literal moreinfo="none">;</literal>, the sequencing
    operator, to express a sequence of imperative actions. We could have done
    the same using let bindings:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/dictionary2.ml">imperative-programming/dictionary2.ml</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml">let () = t.buckets.(i) &lt;- (key, data) :: filtered_bucket in
  if not replace then t.length &lt;- t.length + 1</programlisting>

    <para>but <literal moreinfo="none">;</literal> is more concise and
    idiomatic. More generally,</para>

    <para role="sourcecode">Syntax: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/semicolon.syntax">imperative-programming/semicolon.syntax</ulink></para>

    <programlisting format="linespecific" language="">&lt;expr1&gt;;
&lt;expr2&gt;;
...
&lt;exprN&gt;</programlisting>

    <para>is equivalent to</para>

    <para role="sourcecode">Syntax: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/let-unit.syntax">imperative-programming/let-unit.syntax</ulink></para>

    <programlisting format="linespecific" language="">let () = &lt;expr1&gt; in
let () = &lt;expr2&gt; in
...
&lt;exprN&gt;</programlisting>

    <para>When a sequence expression <literal moreinfo="none">expr1;
    expr2</literal> is evaluated, <literal moreinfo="none">expr1</literal> is
    evaluated first, and then <literal moreinfo="none">expr2</literal>. The
    expression <literal moreinfo="none">expr1</literal> should have type
    <literal moreinfo="none">unit</literal> (though this is a warning rather
    than a hard restriction. The <literal
    moreinfo="none">-strict-sequence</literal> compiler flag makes this a hard
    restriction, which is generally a good idea), and the value of <literal
    moreinfo="none">expr2</literal> is returned as the value of the entire
    sequence. For example, the sequence <literal moreinfo="none">print_string
    "hello world"; 1 + 2</literal> first prints the string <literal
    moreinfo="none">"hello world"</literal>, then returns the integer <literal
    moreinfo="none">3</literal>.</para>

    <para>Note also that we do all of the side-effecting operations at the
    very end of each function. This is good practice because it minimizes the
    chance that such operations will be interrupted with an exception, leaving
    the data structure in an inconsistent state.<indexterm class="endofrange"
    startref="DICTimper"/><indexterm class="endofrange"
    startref="IPimpdict"/></para>
  </sect1>

  <sect1 id="primitive-mutable-data">
    <title>Primitive Mutable Data</title>

    <para>Now that we've looked at a complete example, let's take a more
    systematic look at imperative programming in OCaml. We encountered two
    different forms of mutable data above: records with mutable fields and
    arrays. We'll now discuss these in more detail, along with the other
    primitive forms of mutable data that are available in OCaml.<indexterm
        class="singular">
        <primary>array-like data</primary>
      </indexterm><indexterm class="singular">
        <primary>data structures</primary>

        <secondary>primitive mutable data</secondary>
      </indexterm><indexterm class="singular">
        <primary>mutable data</primary>
      </indexterm><indexterm class="singular">
        <primary>primitive mutable data</primary>

        <secondary>array-like data</secondary>
      </indexterm><indexterm class="singular">
        <primary>imperative programming</primary>

        <secondary>primitive mutable data</secondary>
      </indexterm></para>

    <sect2 id="array-like-data">
      <title>Array-like Data</title>

      <para>OCaml supports a number of array-like data structures; i.e.,
      mutable integer-indexed containers that provide constant-time access to
      their elements. We'll discuss several of them in this section.</para>

      <sect3 id="ordinary-arrays">
        <title>Ordinary arrays</title>

        <para>The <literal moreinfo="none">array</literal> type is used for
        general purpose polymorphic arrays. The <literal
        moreinfo="none">Array</literal> module has a variety of utility
        functions for interacting with arrays, including a number of mutating
        operations. These include <literal
        moreinfo="none">Array.set</literal>, for setting an individual
        element, and <literal moreinfo="none">Array.blit</literal>, for
        efficiently copying values from one range of indices to
        another.<indexterm class="singular">
            <primary>values</primary>

            <secondary>copying with Array.blit</secondary>
          </indexterm><indexterm class="singular">
            <primary>elements</primary>

            <secondary>setting with Array.set</secondary>
          </indexterm><indexterm class="singular">
            <primary>Array module</primary>

            <secondary>Array.blit</secondary>
          </indexterm><indexterm class="singular">
            <primary>Array module</primary>

            <secondary>Array.set</secondary>
          </indexterm></para>

        <para>Arrays also come with special syntax for retrieving an element
        from an array:</para>

        <para role="sourcecode">Syntax: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/array-get.syntax">imperative-programming/array-get.syntax</ulink></para>

        <programlisting format="linespecific" language="">&lt;array_expr&gt;.(&lt;index_expr&gt;)</programlisting>

        <para>and for setting an element in an array:</para>

        <para role="sourcecode">Syntax: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/array-set.syntax">imperative-programming/array-set.syntax</ulink></para>

        <programlisting format="linespecific" language="">&lt;array_expr&gt;.(&lt;index_expr&gt;) &lt;- &lt;value_expr&gt;</programlisting>

        <para>Out-of-bounds accesses for arrays (and indeed for all the
        array-like data structures) will lead to an exception being
        thrown.</para>

        <para>Array literals are written using <literal
        moreinfo="none">[|</literal> and <literal moreinfo="none">|]</literal>
        as delimiters. Thus, <literal moreinfo="none">[| 1; 2; 3 |]</literal>
        is a literal integer array.</para>
      </sect3>

      <sect3 id="strings">
        <title>Strings</title>

        <para>Strings are essentially byte arrays which are often used for
        textual data. The main advantage of using a <literal
        moreinfo="none">string</literal> in place of a <literal
        moreinfo="none">Char.t array</literal> (a <literal
        moreinfo="none">Char.t</literal> is an 8-bit character) is that the
        former is considerably more space efficient; an array uses one
        word—eight bytes on a 64-bit machine—to store a single entry, whereas
        strings use one byte per character.<indexterm class="singular">
            <primary>byte arrays</primary>
          </indexterm><indexterm class="singular">
            <primary>strings</primary>

            <secondary>vs. Char.t arrays</secondary>
          </indexterm></para>

        <para>Strings also come with their own syntax for getting and setting
        values:</para>

        <para role="sourcecode">Syntax: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/string.syntax">imperative-programming/string.syntax</ulink></para>

        <programlisting format="linespecific" language="">&lt;string_expr&gt;.[&lt;index_expr&gt;]
&lt;string_expr&gt;.[&lt;index_expr&gt;] &lt;- &lt;char_expr&gt;</programlisting>

        <para>And string literals are bounded by quotes. There's also a module
        <literal moreinfo="none">String</literal> where you'll find useful
        functions for working with strings.</para>
      </sect3>

      <sect3 id="bigarrays">
        <title>Bigarrays</title>

        <para>A <literal moreinfo="none">Bigarray.t</literal> is a handle to a
        block of memory stored outside of the OCaml heap. These are mostly
        useful for interacting with C or Fortran libraries, and are discussed
        in <xref linkend="memory-representation-of-values"/>. Bigarrays too
        have their own getting and setting syntax:<indexterm class="singular">
            <primary>bigarrays</primary>
          </indexterm></para>

        <para role="sourcecode">Syntax: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/bigarray.syntax">imperative-programming/bigarray.syntax</ulink></para>

        <programlisting format="linespecific" language="">&lt;bigarray_expr&gt;.{&lt;index_expr&gt;}
&lt;bigarray_expr&gt;.{&lt;index_expr&gt;} &lt;- &lt;value_expr&gt;</programlisting>
      </sect3>
    </sect2>

    <sect2 id="mutable-record-and-object-fields-and-ref-cells">
      <title>Mutable Record and Object Fields and Ref Cells</title>

      <para>As we've seen, records are immutable by default, but individual
      record fields can be declared as mutable. These mutable fields can be
      set using the <literal moreinfo="none">&lt;-</literal> operator, i.e.,
      <literal moreinfo="none">record.field &lt;- expr</literal>.<indexterm
          class="singular">
          <primary>fields</primary>

          <secondary>mutability of</secondary>
        </indexterm></para>

      <para>As we'll see in <xref linkend="objects"/>, fields of an object can
      similarly be declared as mutable, and can then be modified in much the
      same way as record fields.<indexterm class="singular">
          <primary>primitive mutable data</primary>

          <secondary>record/object fields and ref cells</secondary>
        </indexterm></para>

      <sect3 id="ref-cells">
        <title>Ref cells</title>

        <para>Variables in OCaml are never mutable—they can refer to mutable
        data, but what the variable points to can't be changed. Sometimes,
        though, you want to do exactly what you would do with a mutable
        variable in another language: define a single, mutable value. In OCaml
        this is typically achieved using a <literal
        moreinfo="none">ref</literal>, which is essentially a container with a
        single mutable polymorphic field.<indexterm class="singular">
            <primary>ref cells</primary>
          </indexterm></para>

        <para>The definition for the ref type is as follows:</para>

        <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/ref.topscript">imperative-programming/ref.topscript</ulink>
        (part 1)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">type 'a ref = { mutable contents : 'a };;</userinput>
<computeroutput moreinfo="none">type 'a ref = { mutable contents : 'a; }</computeroutput></programlisting>

        <para>The standard library defines the following operators for working
        with refs.</para>

        <variablelist>
          <varlistentry>
            <term><literal moreinfo="none">ref expr</literal></term>

            <listitem>
              <para>Constructs a reference cell containing the value defined
              by the expression <literal
              moreinfo="none">expr</literal>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal moreinfo="none">!refcell</literal></term>

            <listitem>
              <para>Returns the contents of the reference cell.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal moreinfo="none">refcell := expr</literal></term>

            <listitem>
              <para>Replaces the contents of the reference cell.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>You can see these in action:</para>

        <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/ref.topscript">imperative-programming/ref.topscript</ulink>
        (part 3)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">let x = ref 1;;</userinput>
<computeroutput moreinfo="none">val x : int ref = {contents = 1}</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">  !x;;</userinput>
<computeroutput moreinfo="none">- : int = 1</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">  x := !x + 1;;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">  !x;;</userinput>
<computeroutput moreinfo="none">- : int = 2</computeroutput></programlisting>

        <para>The preceding are just ordinary OCaml functions, which could be
        defined as follows:</para>

        <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/ref.topscript">imperative-programming/ref.topscript</ulink>
        (part 2)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">let ref x = { contents = x };;</userinput>
<computeroutput moreinfo="none">val ref : 'a -&gt; 'a ref = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">  let (!) r = r.contents;;</userinput>
<computeroutput moreinfo="none">val ( ! ) : 'a ref -&gt; 'a = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">  let (:=) r x = r.contents &lt;- x;;</userinput>
<computeroutput moreinfo="none">val ( := ) : 'a ref -&gt; 'a -&gt; unit = &lt;fun&gt;</computeroutput></programlisting>
      </sect3>
    </sect2>

    <sect2 id="foreign-functions">
      <title>Foreign Functions</title>

      <para>Another source of imperative operations in OCaml is resources that
      come from interfacing with external libraries through OCaml's foreign
      function interface (FFI). The FFI opens OCaml up to imperative
      constructs that are exported by system calls or other external
      libraries. Many of these come built in, like access to the <literal
      moreinfo="none">write</literal> system call, or to the <literal
      moreinfo="none">clock</literal>; while others come from user libraries,
      like LAPACK bindings.<indexterm class="singular">
          <primary>libraries</primary>

          <secondary>interfacing with external</secondary>
        </indexterm><indexterm class="singular">
          <primary>external libraries</primary>

          <secondary>interfacing with</secondary>
        </indexterm><indexterm class="singular">
          <primary>LAPACK bindings</primary>
        </indexterm><indexterm class="singular">
          <primary>foreign function interface (FFI)</primary>
        </indexterm><indexterm class="singular">
          <primary>primitive mutable data</primary>

          <secondary>foreign functions</secondary>
        </indexterm></para>
    </sect2>
  </sect1>

  <sect1 id="for-and-while-loops-1">
    <title><literal moreinfo="none">for</literal> and <literal
    moreinfo="none">while</literal> Loops</title>

    <para>OCaml provides support for traditional imperative looping
    constructs, in particular, <literal moreinfo="none">for</literal> and
    <literal moreinfo="none">while</literal> loops. Neither of these
    constructs is strictly necessary, since they can be simulated with
    recursive functions. Nonetheless, explicit <literal
    moreinfo="none">for</literal> and <literal moreinfo="none">while</literal>
    loops are both more concise and more idiomatic when programming
    imperatively.<indexterm class="singular">
        <primary>looping constructs</primary>
      </indexterm><indexterm class="singular">
        <primary>while loops</primary>
      </indexterm><indexterm class="singular">
        <primary>for loops</primary>
      </indexterm></para>

    <para>The <literal moreinfo="none">for</literal> loop is the simpler of
    the two. Indeed, we've already seen the <literal
    moreinfo="none">for</literal> loop in action—the <literal
    moreinfo="none">iter</literal> function in <literal
    moreinfo="none">Dictionary</literal> is built using it. Here's a simple
    example of <literal moreinfo="none">for</literal>:</para>

    <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/for.topscript">imperative-programming/for.topscript</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">for i = 0 to 3 do printf "i = %d\n" i done;;</userinput>
<computeroutput moreinfo="none">i = 0</computeroutput>
<computeroutput moreinfo="none">i = 1</computeroutput>
<computeroutput moreinfo="none">i = 2</computeroutput>
<computeroutput moreinfo="none">i = 3</computeroutput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput></programlisting>

    <para>As you can see, the upper and lower bounds are inclusive. We can
    also use <literal moreinfo="none">downto</literal> to iterate in the other
    direction:</para>

    <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/for.topscript">imperative-programming/for.topscript</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">for i = 3 downto 0 do printf "i = %d\n" i done;;</userinput>
<computeroutput moreinfo="none">i = 3</computeroutput>
<computeroutput moreinfo="none">i = 2</computeroutput>
<computeroutput moreinfo="none">i = 1</computeroutput>
<computeroutput moreinfo="none">i = 0</computeroutput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput></programlisting>

    <para>Note that the loop variable of a <literal
    moreinfo="none">for</literal> loop, <literal moreinfo="none">i</literal>
    in this case, is immutable in the scope of the loop and is also local to
    the loop, i.e., it can't be referenced outside of the loop.</para>

    <para>OCaml also supports <literal moreinfo="none">while</literal> loops,
    which include a condition and a body. The loop first evaluates the
    condition, and then, if it evaluates to true, evaluates the body and
    starts the loop again. Here's a simple example of a function for reversing
    an array in place:</para>

    <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/for.topscript">imperative-programming/for.topscript</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let rev_inplace ar =</userinput>
<userinput moreinfo="none">    let i = ref 0 in</userinput>
<userinput moreinfo="none">    let j = ref (Array.length ar - 1) in</userinput>
<userinput moreinfo="none">    (* terminate when the upper and lower indices meet *)</userinput>
<userinput moreinfo="none">    while !i &lt; !j do</userinput>
<userinput moreinfo="none">      (* swap the two elements *)</userinput>
<userinput moreinfo="none">      let tmp = ar.(!i) in</userinput>
<userinput moreinfo="none">      ar.(!i) &lt;- ar.(!j);</userinput>
<userinput moreinfo="none">      ar.(!j) &lt;- tmp;</userinput>
<userinput moreinfo="none">      (* bump the indices *)</userinput>
<userinput moreinfo="none">      incr i;</userinput>
<userinput moreinfo="none">      decr j</userinput>
<userinput moreinfo="none">    done</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val rev_inplace : 'a array -&gt; unit = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let nums = [|1;2;3;4;5|];;</userinput>
<computeroutput moreinfo="none">val nums : int array = [|1; 2; 3; 4; 5|]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">rev_inplace nums;;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">nums;;</userinput>
<computeroutput moreinfo="none">- : int array = [|5; 4; 3; 2; 1|]</computeroutput></programlisting>

    <para>In the preceding example, we used <literal
    moreinfo="none">incr</literal> and <literal
    moreinfo="none">decr</literal>, which are built-in functions for
    incrementing and decrementing an <literal moreinfo="none">int
    ref</literal> by one, respectively.</para>
  </sect1>

  <sect1 id="example-doubly-linked-lists">
    <title>Example: Doubly-Linked Lists</title>

    <para>Another common imperative data structure is the doubly-linked list.
    Doubly-linked lists can be traversed in both directions, and elements can
    be added and removed from the list in constant time. Core defines a
    doubly-linked list (the module is called <literal
    moreinfo="none">Doubly_linked</literal>), but we'll define our own linked
    list library as an illustration.<indexterm class="singular">
        <primary>lists</primary>

        <secondary>doubly-linked lists</secondary>
      </indexterm><indexterm class="singular">
        <primary>doubly-linked lists</primary>
      </indexterm><indexterm class="startofrange" id="IPdoublink">
        <primary>imperative programming</primary>

        <secondary>doubly-linked lists</secondary>
      </indexterm></para>

    <para>Here's the <literal moreinfo="none">mli</literal> of the module
    we'll build:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/dlist.mli">imperative-programming/dlist.mli</ulink></para>

    <programlisting format="linespecific" language="ocaml">(* file: dlist.mli *)
open Core.Std

type 'a t
type 'a element

(** Basic list operations  *)
val create   : unit -&gt; 'a t
val is_empty : 'a t -&gt; bool

(** Navigation using [element]s *)
val first : 'a t -&gt; 'a element option
val next  : 'a element -&gt; 'a element option
val prev  : 'a element -&gt; 'a element option
val value : 'a element -&gt; 'a

(** Whole-data-structure iteration *)
val iter    : 'a t -&gt; f:('a -&gt; unit) -&gt; unit
val find_el : 'a t -&gt; f:('a -&gt; bool) -&gt; 'a element option

(** Mutation *)
val insert_first : 'a t -&gt; 'a -&gt; 'a element
val insert_after : 'a element -&gt; 'a -&gt; 'a element
val remove : 'a t -&gt; 'a element -&gt; unit</programlisting>

    <para>Note that there are two types defined here: <literal
    moreinfo="none">'a t</literal>, the type of a list; and <literal
    moreinfo="none">'a element</literal>, the type of an element. Elements act
    as pointers to the interior of a list and allow us to navigate the list
    and give us a point at which to apply mutating operations.</para>

    <para>Now let's look at the implementation. We'll start by defining
    <literal moreinfo="none">'a element</literal> and <literal
    moreinfo="none">'a t</literal>:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/dlist.ml">imperative-programming/dlist.ml</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml">(* file: dlist.ml *)
open Core.Std

type 'a element =
  { value : 'a;
    mutable next : 'a element option;
    mutable prev : 'a element option
  }

type 'a t = 'a element option ref</programlisting>

    <para>An <literal moreinfo="none">'a element</literal> is a record
    containing the value to be stored in that node as well as optional (and
    mutable) fields pointing to the previous and next elements. At the
    beginning of the list, the <literal moreinfo="none">prev</literal> field
    is <literal moreinfo="none">None</literal>, and at the end of the list,
    the <literal moreinfo="none">next</literal> field is <literal
    moreinfo="none">None</literal>.</para>

    <para>The type of the list itself, <literal moreinfo="none">'a
    t</literal>, is a mutable reference to an optional <literal
    moreinfo="none">element</literal>. This reference is <literal
    moreinfo="none">None</literal> if the list is empty, and <literal
    moreinfo="none">Some</literal> otherwise.</para>

    <para>Now we can define a few basic functions that operate on lists and
    elements:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/dlist.ml">imperative-programming/dlist.ml</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml">let create () = ref None
let is_empty t = !t = None

let value elt = elt.value

let first t = !t
let next elt = elt.next
let prev elt = elt.prev</programlisting>

    <para>These all follow relatively straightforwardly from our type
    definitions.</para>

    <note>
      <title>Cyclic Data Structures</title>

      <para>Doubly-linked lists are a cyclic data structure, meaning that it
      is possible to follow a nontrivial sequence of pointers that closes in
      on itself. In general, building cyclic data structures requires the use
      of side effects. This is done by constructing the data elements first,
      and then adding cycles using assignment afterward.<indexterm
          class="singular">
          <primary>let rec</primary>
        </indexterm><indexterm class="singular">
          <primary>data structures</primary>

          <secondary>cyclic</secondary>
        </indexterm><indexterm class="singular">
          <primary>cyclic data structures</primary>
        </indexterm></para>

      <para>There is an exception to this, though: you can construct
      fixed-size cyclic data-structures using <literal moreinfo="none">let
      rec</literal>:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/examples.topscript">imperative-programming/examples.topscript</ulink>
      (part 2)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let rec endless_loop = 1 :: 2 :: 3 :: endless_loop;;</userinput>
<computeroutput moreinfo="none">val endless_loop : int list =</computeroutput>
<computeroutput moreinfo="none">  [1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1;</computeroutput>
<computeroutput moreinfo="none">   2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2;</computeroutput>
<computeroutput moreinfo="none">   3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3;</computeroutput>
<computeroutput moreinfo="none">   1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1;</computeroutput>
<computeroutput moreinfo="none">   2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2;</computeroutput>
<computeroutput moreinfo="none">   3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3;</computeroutput>
<computeroutput moreinfo="none">   1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1;</computeroutput>
<computeroutput moreinfo="none">   2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2;</computeroutput>
<computeroutput moreinfo="none">   3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3;</computeroutput>
<computeroutput moreinfo="none">   1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1;</computeroutput>
<computeroutput moreinfo="none">   2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2;</computeroutput>
<computeroutput moreinfo="none">   3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2; 3; 1; 2;</computeroutput>
<computeroutput moreinfo="none">   ...]</computeroutput></programlisting>

      <para>This approach is quite limited, however. General purpose cyclic
      data structures require mutation.</para>
    </note>

    <sect2 id="modifying-the-list">
      <title>Modifying the List</title>

      <para>Now, we'll start considering operations that mutate the list,
      starting with <literal moreinfo="none">insert_first</literal>, which
      inserts an element at the front of the list:<indexterm class="singular">
          <primary>elements</primary>

          <secondary>inserting in lists</secondary>
        </indexterm></para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/dlist.ml">imperative-programming/dlist.ml</ulink>
      (part 3)</para>

      <programlisting format="linespecific" language="ocaml">let insert_first t value =
  let new_elt = { prev = None; next = !t; value } in
  begin match !t with
  | Some old_first -&gt; old_first.prev &lt;- Some new_elt
  | None -&gt; ()
  end;
  t := Some new_elt;
  new_elt</programlisting>

      <para><literal moreinfo="none">insert_first</literal> first defines a
      new element <literal moreinfo="none">new_elt</literal>, and then links
      it into the list, finally setting the list itself to point to <literal
      moreinfo="none">new_elt</literal>. Note that the precedence of a
      <literal moreinfo="none">match</literal> expression is very low, so to
      separate it from the following assignment (<literal moreinfo="none">t :=
      Some new_elt</literal>), we surround the match with <literal
      moreinfo="none">begin ... end</literal>. We could have used parentheses
      for the same purpose. Without some kind of bracketing, the final
      assignment would incorrectly become part of the <literal
      moreinfo="none">None</literal> case.<indexterm class="singular">
          <primary>elements</primary>

          <secondary>defining new</secondary>
        </indexterm></para>

      <para>We can use <literal moreinfo="none">insert_after</literal> to
      insert elements later in the list. <literal
      moreinfo="none">insert_after</literal> takes as arguments both an
      <literal moreinfo="none">element</literal> after which to insert the new
      node and a value to insert:</para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/dlist.ml">imperative-programming/dlist.ml</ulink>
      (part 4)</para>

      <programlisting format="linespecific" language="ocaml">let insert_after elt value =
  let new_elt = { value; prev = Some elt; next = elt.next } in
  begin match elt.next with
  | Some old_next -&gt; old_next.prev &lt;- Some new_elt
  | None -&gt; ()
  end;
  elt.next &lt;- Some new_elt;
  new_elt</programlisting>

      <para>Finally, we need a <literal moreinfo="none">remove</literal>
      function:</para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/dlist.ml">imperative-programming/dlist.ml</ulink>
      (part 5)</para>

      <programlisting format="linespecific" language="ocaml">let remove t elt =
  let { prev; next; _ } = elt in
  begin match prev with
  | Some prev -&gt; prev.next &lt;- next
  | None -&gt; t := next
  end;
  begin match next with
  | Some next -&gt; next.prev &lt;- prev;
  | None -&gt; ()
  end;
  elt.prev &lt;- None;
  elt.next &lt;- None</programlisting>

      <para>Note that the preceding code is careful to change the <literal
      moreinfo="none">prev</literal> pointer of the following element and the
      <literal moreinfo="none">next</literal> pointer of the previous element,
      if they exist. If there's no previous element, then the list pointer
      itself is updated. In any case, the next and previous pointers of the
      element itself are set to <literal
      moreinfo="none">None</literal>.</para>

      <para>These functions are more fragile than they may seem. In
      particular, misuse of the interface may lead to corrupted data. For
      example, double-removing an element will cause the main list reference
      to be set to <literal moreinfo="none">None</literal>, thus emptying the
      list. Similar problems arise from removing an element from a list it
      doesn't belong to.</para>

      <para>This shouldn't be a big surprise. Complex imperative data
      structures can be quite tricky, considerably trickier than their pure
      equivalents. The issues described previously can be dealt with by more
      careful error detection, and such error correction is taken care of in
      modules like Core's <literal moreinfo="none">Doubly_linked</literal>.
      You should use imperative data structures from a well-designed library
      when you can. And when you can't, you should make sure to put great care
      into your error handling.<indexterm class="singular">
          <primary>imperative programming</primary>

          <secondary>drawbacks of</secondary>
        </indexterm><indexterm class="singular">
          <primary>Doubly-linked module</primary>
        </indexterm><indexterm class="singular">
          <primary>error handling</primary>

          <secondary sortas="imperative">and imperative data
          structures</secondary>
        </indexterm></para>
    </sect2>

    <sect2 id="iteration-functions">
      <title>Iteration Functions</title>

      <para>When defining containers like lists, dictionaries and trees,
      you'll typically want to define a set of iteration functions, like
      <literal moreinfo="none">iter</literal>, <literal
      moreinfo="none">map</literal>, and <literal
      moreinfo="none">fold</literal>, which let you concisely express common
      iteration patterns.<indexterm class="singular">
          <primary>functions</primary>

          <secondary>iteration functions</secondary>
        </indexterm><indexterm class="singular">
          <primary>iteration functions</primary>
        </indexterm></para>

      <para><literal moreinfo="none">Dlist</literal> has two such iterators:
      <literal moreinfo="none">iter</literal>, the goal of which is to call a
      <literal moreinfo="none">unit</literal> producing function on every
      element of the list, in order; and <literal
      moreinfo="none">find_el</literal>, which runs a provided test function
      on each values stored in the list, returning the first <literal
      moreinfo="none">element</literal> that passes the test. Both <literal
      moreinfo="none">iter</literal> and <literal
      moreinfo="none">find_el</literal> are implemented using simple recursive
      loops that use <literal moreinfo="none">next</literal> to walk from
      element to element and <literal moreinfo="none">value</literal> to
      extract the element from a given node:</para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/dlist.ml">imperative-programming/dlist.ml</ulink>
      (part 6)</para>

      <programlisting format="linespecific" language="ocaml">let iter t ~f =
  let rec loop = function
    | None -&gt; ()
    | Some el -&gt; f (value el); loop (next el)
  in
  loop !t

let find_el t ~f =
  let rec loop = function
    | None -&gt; None
    | Some elt -&gt;
      if f (value elt) then Some elt
      else loop (next elt)
  in
  loop !t</programlisting>

      <para>This completes our implementation, but there's still considerably
      more work to be done to make a really usable doubly-linked list. As
      mentioned earlier, you're probably better off using something like
      Core's <literal moreinfo="none">Doubly_linked</literal> module that has
      a more complete interface and has more of the tricky corner cases worked
      out. Nonetheless, this example should serve to demonstrate some of the
      techniques you can use to build nontrivial imperative data structure in
      OCaml, as well as some of the pitfalls.<indexterm class="endofrange"
      startref="IPdoublink"/></para>
    </sect2>
  </sect1>

  <sect1 id="laziness-and-other-benign-effects">
    <title>Laziness and Other Benign Effects</title>

    <para>There are many instances where you basically want to program in a
    pure style, but you want to make limited use of side effects to improve
    the performance of your code. Such side effects are sometimes called
    <emphasis>benign effects</emphasis>, and they are a useful way of
    leveraging OCaml's imperative features while still maintaining most of the
    benefits of pure programming.<indexterm class="singular">
        <primary>lazy keyword</primary>
      </indexterm><indexterm class="singular">
        <primary>side effects</primary>
      </indexterm><indexterm class="singular">
        <primary>laziness</primary>
      </indexterm><indexterm class="singular">
        <primary>benign effects</primary>

        <secondary>laziness</secondary>
      </indexterm><indexterm class="singular">
        <primary>imperative programming</primary>

        <secondary>benign effects and</secondary>
      </indexterm></para>

    <para>One of the simplest benign effects is <emphasis>laziness</emphasis>.
    A lazy value is one that is not computed until it is actually needed. In
    OCaml, lazy values are created using the <literal
    moreinfo="none">lazy</literal> keyword, which can be used to convert any
    expression of type <literal moreinfo="none">s</literal> into a lazy value
    of type <literal moreinfo="none">s Lazy.t</literal>. The evaluation of
    that expression is delayed until forced with <literal
    moreinfo="none">Lazy.force</literal>:</para>

    <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/lazy.topscript">imperative-programming/lazy.topscript</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let v = lazy (print_string "performing lazy computation\n"; sqrt 16.);;</userinput>
<computeroutput moreinfo="none">val v : float lazy_t = &lt;lazy&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Lazy.force v;;</userinput>
<computeroutput moreinfo="none">performing lazy computation</computeroutput>
<computeroutput moreinfo="none">- : float = 4.</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">Lazy.force v;;</userinput>
<computeroutput moreinfo="none">- : float = 4.</computeroutput></programlisting>

    <para>You can see from the print statement that the actual computation was
    performed only once, and only after <literal
    moreinfo="none">force</literal> had been called.</para>

    <para>To better understand how laziness works, let's walk through the
    implementation of our own lazy type. We'll start by declaring types to
    represent a lazy value:</para>

    <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/lazy.topscript">imperative-programming/lazy.topscript</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">type 'a lazy_state =</userinput>
<userinput moreinfo="none">    | Delayed of (unit -&gt; 'a)</userinput>
<userinput moreinfo="none">    | Value of 'a</userinput>
<userinput moreinfo="none">    | Exn of exn</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">type 'a lazy_state = Delayed of (unit -&gt; 'a) | Value of 'a | Exn of exn</computeroutput></programlisting>

    <para>A <literal moreinfo="none">lazy_state</literal> represents the
    possible states of a lazy value. A lazy value is <literal
    moreinfo="none">Delayed</literal> before it has been run, where <literal
    moreinfo="none">Delayed</literal> holds a function for computing the value
    in question. A lazy value is in the <literal
    moreinfo="none">Value</literal> state when it has been forced and the
    computation ended normally. The <literal moreinfo="none">Exn</literal>
    case is for when the lazy value has been forced, but the computation ended
    with an exception. A lazy value is simply a <literal
    moreinfo="none">ref</literal> containing a <literal
    moreinfo="none">lazy_state</literal>, where the <literal
    moreinfo="none">ref</literal> makes it possible to change from being in
    the <literal moreinfo="none">Delayed</literal> state to being in the
    <literal moreinfo="none">Value</literal> or <literal
    moreinfo="none">Exn</literal> states.</para>

    <para>We can create a lazy value from a thunk, i.e., a function that takes
    a unit argument. Wrapping an expression in a thunk is another way to
    suspend the computation of an expression:<indexterm class="singular">
        <primary>thunks</primary>
      </indexterm></para>

    <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/lazy.topscript">imperative-programming/lazy.topscript</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let create_lazy f = ref (Delayed f);;</userinput>
<computeroutput moreinfo="none">val create_lazy : (unit -&gt; 'a) -&gt; 'a lazy_state ref = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let v = create_lazy</userinput>
<userinput moreinfo="none">    (fun () -&gt; print_string "performing lazy computation\n"; sqrt 16.);;</userinput>
<computeroutput moreinfo="none">val v : float lazy_state ref = {contents = Delayed &lt;fun&gt;}</computeroutput></programlisting>

    <para>Now we just need a way to force a lazy value. The following function
    does just that:</para>

    <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/lazy.topscript">imperative-programming/lazy.topscript</ulink>
    (part 4)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let force v =</userinput>
<userinput moreinfo="none">    match !v with</userinput>
<userinput moreinfo="none">    | Value x -&gt; x</userinput>
<userinput moreinfo="none">    | Exn e -&gt; raise e</userinput>
<userinput moreinfo="none">    | Delayed f -&gt;</userinput>
<userinput moreinfo="none">      try</userinput>
<userinput moreinfo="none">        let x = f () in</userinput>
<userinput moreinfo="none">        v := Value x;</userinput>
<userinput moreinfo="none">        x</userinput>
<userinput moreinfo="none">      with exn -&gt;</userinput>
<userinput moreinfo="none">        v := Exn exn;</userinput>
<userinput moreinfo="none">        raise exn</userinput>
<userinput moreinfo="none">     ;;</userinput>
<computeroutput moreinfo="none">val force : 'a lazy_state ref -&gt; 'a = &lt;fun&gt;</computeroutput></programlisting>

    <para>Which we can use in the same way we used <literal
    moreinfo="none">Lazy.force</literal>:</para>

    <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/lazy.topscript">imperative-programming/lazy.topscript</ulink>
    (part 5)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">force v;;</userinput>
<computeroutput moreinfo="none">performing lazy computation</computeroutput>
<computeroutput moreinfo="none">- : float = 4.</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">force v;;</userinput>
<computeroutput moreinfo="none">- : float = 4.</computeroutput></programlisting>

    <para>The main user-visible difference between our implementation of
    laziness and the built-in version is syntax. Rather than writing <literal
    moreinfo="none">create_lazy (fun () -&gt; sqrt 16.)</literal>, we can with
    the built-in <literal moreinfo="none">lazy</literal> just write <literal
    moreinfo="none">lazy (sqrt 16.)</literal>.</para>

    <sect2 id="memoization-and-dynamic-programming">
      <title>Memoization and Dynamic Programming</title>

      <para>Another benign effect is <emphasis>memoization</emphasis>. A
      memoized function remembers the result of previous invocations of the
      function so that they can be returned without further computation when
      the same arguments are presented again.<indexterm class="singular">
          <primary>memoization</primary>

          <secondary>function of</secondary>
        </indexterm><indexterm class="startofrange" id="BEmem">
          <primary>benign effects</primary>

          <secondary>memoization</secondary>
        </indexterm></para>

      <para>Here's a function that takes as an argument an arbitrary
      single-argument function and returns a memoized version of that
      function. Here we'll use Core's <literal
      moreinfo="none">Hashtbl</literal> module, rather than our toy <literal
      moreinfo="none">Dictionary</literal>:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/memo.topscript">imperative-programming/memo.topscript</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let memoize f =</userinput>
<userinput moreinfo="none">    let table = Hashtbl.Poly.create () in</userinput>
<userinput moreinfo="none">    (fun x -&gt;</userinput>
<userinput moreinfo="none">      match Hashtbl.find table x with</userinput>
<userinput moreinfo="none">      | Some y -&gt; y</userinput>
<userinput moreinfo="none">      | None -&gt;</userinput>
<userinput moreinfo="none">        let y = f x in</userinput>
<userinput moreinfo="none">        Hashtbl.add_exn table ~key:x ~data:y;</userinput>
<userinput moreinfo="none">        y</userinput>
<userinput moreinfo="none">    );;</userinput>
<computeroutput moreinfo="none">val memoize : ('a -&gt; 'b) -&gt; 'a -&gt; 'b = &lt;fun&gt;</computeroutput></programlisting>

      <para>The preceding code is a bit tricky. <literal
      moreinfo="none">memoize</literal> takes as its argument a function
      <literal moreinfo="none">f</literal> and then allocates a hash table
      (called <literal moreinfo="none">table</literal>) and returns a new
      function as the memoized version of <literal
      moreinfo="none">f</literal>. When called, this new function looks in
      <literal moreinfo="none">table</literal> first, and if it fails to find
      a value, calls <literal moreinfo="none">f</literal> and stashes the
      result in <literal moreinfo="none">table</literal>. Note that <literal
      moreinfo="none">table</literal> doesn't go out of scope as long as the
      function returned by <literal moreinfo="none">memoize</literal> is in
      scope.<indexterm class="singular">
          <primary>memoization</primary>

          <secondary>benefits and drawbacks of</secondary>
        </indexterm></para>

      <para>Memoization can be useful whenever you have a function that is
      expensive to recompute and you don't mind caching old values
      indefinitely. One important caution: a memoized function by its nature
      leaks memory. As long as you hold on to the memoized function, you're
      holding every result it has returned thus far.</para>

      <para>Memoization is also useful for efficiently implementing some
      recursive algorithms. One good example is the algorithm for computing
      the <emphasis>edit distance</emphasis> (also called the Levenshtein
      distance) between two strings. The edit distance is the number of
      single-character changes (including letter switches, insertions and
      deletions) required to convert one string to the other. This kind of
      distance metric can be useful for a variety of approximate string
      matching problems, like spell checkers.<indexterm class="singular">
          <primary>string matching</primary>
        </indexterm><indexterm class="singular">
          <primary>Levenshtein distance</primary>
        </indexterm><indexterm class="singular">
          <primary>edit distance</primary>
        </indexterm></para>

      <para>Consider the following code for computing the edit distance.
      Understanding the algorithm isn't important here, but you should pay
      attention to the structure of the recursive calls:<indexterm
          class="singular">
          <primary>memoization</primary>

          <secondary>example of</secondary>
        </indexterm></para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/memo.topscript">imperative-programming/memo.topscript</ulink>
      (part 2)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let rec edit_distance s t =</userinput>
<userinput moreinfo="none">    match String.length s, String.length t with</userinput>
<userinput moreinfo="none">    | (0,x) | (x,0) -&gt; x</userinput>
<userinput moreinfo="none">    | (len_s,len_t) -&gt;</userinput>
<userinput moreinfo="none">      let s' = String.drop_suffix s 1 in</userinput>
<userinput moreinfo="none">      let t' = String.drop_suffix t 1 in</userinput>
<userinput moreinfo="none">      let cost_to_drop_both =</userinput>
<userinput moreinfo="none">        if s.[len_s - 1] = t.[len_t - 1] then 0 else 1</userinput>
<userinput moreinfo="none">      in</userinput>
<userinput moreinfo="none">      List.reduce_exn ~f:Int.min</userinput>
<userinput moreinfo="none">        [ edit_distance s' t  + 1</userinput>
<userinput moreinfo="none">        ; edit_distance s  t' + 1</userinput>
<userinput moreinfo="none">        ; edit_distance s' t' + cost_to_drop_both</userinput>
<userinput moreinfo="none">        ]</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val edit_distance : string -&gt; string -&gt; int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">edit_distance "OCaml" "ocaml";;</userinput>
<computeroutput moreinfo="none">- : int = 2</computeroutput></programlisting>

      <para>The thing to note is that if you call <literal
      moreinfo="none">edit_distance "OCaml" "ocaml"</literal>, then that will
      in turn dispatch the following calls:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/edit_distance.ascii">Diagram</ulink></para>

      <informalfigure>
        <mediaobject>
          <imageobject role="web">
            <imagedata fileref="images/rwoc_0801.png" format="PNG"/>
          </imageobject>
        </mediaobject>
      </informalfigure>

      <para>And these calls will in turn dispatch other calls:</para>

      <para role="sourcecode"><ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/edit_distance2.ascii">Diagram</ulink></para>

      <informalfigure>
        <mediaobject>
          <imageobject role="web">
            <imagedata fileref="images/rwoc_0802.png" format="PNG"/>
          </imageobject>
        </mediaobject>
      </informalfigure>

      <para>As you can see, some of these calls are repeats. For example,
      there are two different calls to <literal moreinfo="none">edit_distance
      "OCam" "oca"</literal>. The number of redundant calls grows
      exponentially with the size of the strings, meaning that our
      implementation of <literal moreinfo="none">edit_distance</literal> is
      brutally slow for large strings. We can see this by writing a small
      timing function:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/memo.topscript">imperative-programming/memo.topscript</ulink>
      (part 3)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let time f =</userinput>
<userinput moreinfo="none">    let start = Time.now () in</userinput>
<userinput moreinfo="none">    let x = f () in</userinput>
<userinput moreinfo="none">    let stop = Time.now () in</userinput>
<userinput moreinfo="none">    printf "Time: %s\n" (Time.Span.to_string (Time.diff stop start));</userinput>
<userinput moreinfo="none">    x ;;</userinput>
<computeroutput moreinfo="none">val time : (unit -&gt; 'a) -&gt; 'a = &lt;fun&gt;</computeroutput></programlisting>

      <para>And now we can use this to try out some examples:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/memo.topscript">imperative-programming/memo.topscript</ulink>
      (part 4)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">time (fun () -&gt; edit_distance "OCaml" "ocaml");;</userinput>
<computeroutput moreinfo="none">Time: 1.40405ms</computeroutput>
<computeroutput moreinfo="none">- : int = 2</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">time (fun () -&gt; edit_distance "OCaml 4.01" "ocaml 4.01");;</userinput>
<computeroutput moreinfo="none">Time: 6.79065s</computeroutput>
<computeroutput moreinfo="none">- : int = 2</computeroutput></programlisting>

      <para>Just those few extra characters made it thousands of times
      slower!</para>

      <para>Memoization would be a huge help here, but to fix the problem, we
      need to memoize the calls that <literal
      moreinfo="none">edit_distance</literal> makes to itself. This technique
      is sometimes referred to as <emphasis>dynamic programming</emphasis>. To
      see how to do this, let's step away from <literal
      moreinfo="none">edit_distance</literal> and instead consider a much
      simpler example: computing the nth element of the Fibonacci sequence.
      The Fibonacci sequence by definition starts out with two <literal
      moreinfo="none">1</literal>'s, with every subsequent element being the
      sum of the previous two. The classic recursive definition of Fibonacci
      is as follows:<indexterm class="singular">
          <primary>programming</primary>

          <secondary>dynamic programming</secondary>
        </indexterm><indexterm class="singular">
          <primary>dynamic programming</primary>
        </indexterm></para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/fib.topscript">imperative-programming/fib.topscript</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let rec fib i =</userinput>
<userinput moreinfo="none">    if i &lt;= 1 then 1 else fib (i - 1) + fib (i - 2);;</userinput>
<computeroutput moreinfo="none">val fib : int -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

      <para>This is, however, exponentially slow, for the same reason that
      <literal moreinfo="none">edit_distance</literal> was slow: we end up
      making many redundant calls to <literal moreinfo="none">fib</literal>.
      It shows up quite dramatically in the performance:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/fib.topscript">imperative-programming/fib.topscript</ulink>
      (part 2)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">time (fun () -&gt; fib 20);;</userinput>
<computeroutput moreinfo="none">Time: 0.844955ms</computeroutput>
<computeroutput moreinfo="none">- : int = 10946</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">time (fun () -&gt; fib 40);;</userinput>
<computeroutput moreinfo="none">Time: 12.7751s</computeroutput>
<computeroutput moreinfo="none">- : int = 165580141</computeroutput></programlisting>

      <para>As you can see, <literal moreinfo="none">fib 40</literal> takes
      thousands of times longer to compute than <literal moreinfo="none">fib
      20</literal>.</para>

      <para>So, how can we use memoization to make this faster? The tricky bit
      is that we need to insert the memoization before the recursive calls
      within <literal moreinfo="none">fib</literal>. We can't just define
      <literal moreinfo="none">fib</literal> in the ordinary way and memoize
      it after the fact and expect the first call to <literal
      moreinfo="none">fib</literal> to be improved:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/fib.topscript">imperative-programming/fib.topscript</ulink>
      (part 3)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let fib = memoize fib;;</userinput>
<computeroutput moreinfo="none">val fib : int -&gt; int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">time (fun () -&gt; fib 40);;</userinput>
<computeroutput moreinfo="none">Time: 12.774s</computeroutput>
<computeroutput moreinfo="none">- : int = 165580141</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">time (fun () -&gt; fib 40);;</userinput>
<computeroutput moreinfo="none">Time: 0.00309944ms</computeroutput>
<computeroutput moreinfo="none">- : int = 165580141</computeroutput></programlisting>

      <para>In order to make <literal moreinfo="none">fib</literal> fast, our
      first step will be to rewrite <literal moreinfo="none">fib</literal> in
      a way that unwinds the recursion. The following version expects as its
      first argument a function (called <literal
      moreinfo="none">fib</literal>) that will be called in lieu of the usual
      recursive call:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/fib.topscript">imperative-programming/fib.topscript</ulink>
      (part 4)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let fib_norec fib i =</userinput>
<userinput moreinfo="none">    if i &lt;= 1 then i</userinput>
<userinput moreinfo="none">    else fib (i - 1) + fib (i - 2) ;;</userinput>
<computeroutput moreinfo="none">val fib_norec : (int -&gt; int) -&gt; int -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

      <para>We can now turn this back into an ordinary Fibonacci function by
      tying the recursive knot:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/fib.topscript">imperative-programming/fib.topscript</ulink>
      (part 5)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let rec fib i = fib_norec fib i;;</userinput>
<computeroutput moreinfo="none">val fib : int -&gt; int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">fib 20;;</userinput>
<computeroutput moreinfo="none">- : int = 6765</computeroutput></programlisting>

      <para>We can even write a polymorphic function that we'll call <literal
      moreinfo="none">make_rec</literal> that can tie the recursive knot for
      any function of this form:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/fib.topscript">imperative-programming/fib.topscript</ulink>
      (part 6)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let make_rec f_norec =</userinput>
<userinput moreinfo="none">    let rec f x = f_norec f x in</userinput>
<userinput moreinfo="none">    f</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val make_rec : (('a -&gt; 'b) -&gt; 'a -&gt; 'b) -&gt; 'a -&gt; 'b = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let fib = make_rec fib_norec;;</userinput>
<computeroutput moreinfo="none">val fib : int -&gt; int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">fib 20;;</userinput>
<computeroutput moreinfo="none">- : int = 6765</computeroutput></programlisting>

      <para>This is a pretty strange piece of code, and it may take a few
      minutes of thought to figure out what's going on. Like <literal
      moreinfo="none">fib_norec</literal>, the function <literal
      moreinfo="none">f_norec</literal> passed into <literal
      moreinfo="none">make_rec</literal> is a function that isn't recursive
      but takes as an argument a function that it will call. What <literal
      moreinfo="none">make_rec</literal> does is to essentially feed <literal
      moreinfo="none">f_norec</literal> to itself, thus making it a true
      recursive function.</para>

      <para>This is clever enough, but all we've really done is find a new way
      to implement the same old slow Fibonacci function. To make it faster, we
      need a variant on <literal moreinfo="none">make_rec</literal> that
      inserts memoization when it ties the recursive knot. We'll call that
      function <literal moreinfo="none">memo_rec</literal>:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/fib.topscript">imperative-programming/fib.topscript</ulink>
      (part 7)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let memo_rec f_norec x =</userinput>
<userinput moreinfo="none">    let fref = ref (fun _ -&gt; assert false) in</userinput>
<userinput moreinfo="none">    let f = memoize (fun x -&gt; f_norec !fref x) in</userinput>
<userinput moreinfo="none">    fref := f;</userinput>
<userinput moreinfo="none">    f x</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val memo_rec : (('a -&gt; 'b) -&gt; 'a -&gt; 'b) -&gt; 'a -&gt; 'b = &lt;fun&gt;</computeroutput></programlisting>

      <para>Note that <literal moreinfo="none">memo_rec</literal> has the same
      signature as <literal moreinfo="none">make_rec</literal>.</para>

      <para>We're using the reference here as a way of tying the recursive
      knot without using a <literal moreinfo="none">let rec</literal>, which
      for reasons we'll describe later wouldn't work here.</para>

      <para>Using <literal moreinfo="none">memo_rec</literal>, we can now
      build an efficient version of <literal
      moreinfo="none">fib</literal>:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/fib.topscript">imperative-programming/fib.topscript</ulink>
      (part 8)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let fib = memo_rec fib_norec;;</userinput>
<computeroutput moreinfo="none">val fib : int -&gt; int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">time (fun () -&gt; fib 40);;</userinput>
<computeroutput moreinfo="none">Time: 0.0591278ms</computeroutput>
<computeroutput moreinfo="none">- : int = 102334155</computeroutput></programlisting>

      <para>And as you can see, the exponential time complexity is now
      gone.</para>

      <para>The memory behavior here is important. If you look back at the
      definition of <literal moreinfo="none">memo_rec</literal>, you'll see
      that the call <literal moreinfo="none">memo_rec fib_norec</literal> does
      not trigger a call to <literal moreinfo="none">memoize</literal>. Only
      when <literal moreinfo="none">fib</literal> is called and thereby the
      final argument to <literal moreinfo="none">memo_rec</literal> is
      presented does <literal moreinfo="none">memoize</literal> get called.
      The result of that call falls out of scope when the <literal
      moreinfo="none">fib</literal> call returns, and so calling <literal
      moreinfo="none">memo_rec</literal> on a function does not create a
      memory leak—the memoization table is collected after the computation
      completes.</para>

      <para>We can use <literal moreinfo="none">memo_rec</literal> as part of
      a single declaration that makes this look like it's little more than a
      special form of <literal moreinfo="none">let rec</literal>:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/fib.topscript">imperative-programming/fib.topscript</ulink>
      (part 9)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let fib = memo_rec (fun fib i -&gt;</userinput>
<userinput moreinfo="none">    if i &lt;= 1 then 1 else fib (i - 1) + fib (i - 2));;</userinput>
<computeroutput moreinfo="none">val fib : int -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

      <para>Memoization is overkill for implementing Fibonacci, and indeed,
      the <literal moreinfo="none">fib</literal> defined above is not
      especially efficient, allocating space linear in the number passed in to
      <literal moreinfo="none">fib</literal>. It's easy enough to write a
      Fibonacci function that takes a constant amount of space.</para>

      <para>But memoization is a good approach for optimizing <literal
      moreinfo="none">edit_distance</literal>, and we can apply the same
      approach we used on <literal moreinfo="none">fib</literal> here. We will
      need to change <literal moreinfo="none">edit_distance</literal> to take
      a pair of strings as a single argument, since <literal
      moreinfo="none">memo_rec</literal> only works on single-argument
      functions. (We can always recover the original interface with a wrapper
      function.) With just that change and the addition of the <literal
      moreinfo="none">memo_rec</literal> call, we can get a memoized version
      of <literal moreinfo="none">edit_distance</literal>:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/memo.topscript">imperative-programming/memo.topscript</ulink>
      (part 6)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let edit_distance = memo_rec (fun edit_distance (s,t) -&gt;</userinput>
<userinput moreinfo="none">    match String.length s, String.length t with</userinput>
<userinput moreinfo="none">    | (0,x) | (x,0) -&gt; x</userinput>
<userinput moreinfo="none">    | (len_s,len_t) -&gt;</userinput>
<userinput moreinfo="none">      let s' = String.drop_suffix s 1 in</userinput>
<userinput moreinfo="none">      let t' = String.drop_suffix t 1 in</userinput>
<userinput moreinfo="none">      let cost_to_drop_both =</userinput>
<userinput moreinfo="none">        if s.[len_s - 1] = t.[len_t - 1] then 0 else 1</userinput>
<userinput moreinfo="none">      in</userinput>
<userinput moreinfo="none">      List.reduce_exn ~f:Int.min</userinput>
<userinput moreinfo="none">        [ edit_distance (s',t ) + 1</userinput>
<userinput moreinfo="none">        ; edit_distance (s ,t') + 1</userinput>
<userinput moreinfo="none">        ; edit_distance (s',t') + cost_to_drop_both</userinput>
<userinput moreinfo="none">        ]) ;;</userinput>
<computeroutput moreinfo="none">val edit_distance : string * string -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

      <para>This new version of <literal
      moreinfo="none">edit_distance</literal> is much more efficient than the
      one we started with; the following call is many thousands of times
      faster than it was without memoization:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/memo.topscript">imperative-programming/memo.topscript</ulink>
      (part 7)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">time (fun () -&gt; edit_distance ("OCaml 4.01","ocaml 4.01"));;</userinput>
<computeroutput moreinfo="none">Time: 0.500917ms</computeroutput>
<computeroutput moreinfo="none">- : int = 2</computeroutput></programlisting>

      <note>
        <title>Limitations of <literal moreinfo="none">let
        rec</literal></title>

        <para>You might wonder why we didn't tie the recursive knot in
        <literal moreinfo="none">memo_rec</literal> using <literal
        moreinfo="none">let rec</literal>, as we did for <literal
        moreinfo="none">make_rec</literal> earlier. Here's code that tries to
        do just that:<indexterm class="singular">
            <primary>let rec</primary>
          </indexterm></para>

        <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/letrec.topscript">imperative-programming/letrec.topscript</ulink>
        (part 1)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">let memo_rec f_norec =</userinput>
<userinput moreinfo="none">    let rec f = memoize (fun x -&gt; f_norec f x) in</userinput>
<userinput moreinfo="none">    f</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">Characters 39-69:</computeroutput>
<computeroutput moreinfo="none">Error: This kind of expression is not allowed as right-hand side of `let rec'</computeroutput></programlisting>

        <para>OCaml rejects the definition because OCaml, as a strict
        language, has limits on what it can put on the right hand side of a
        <literal moreinfo="none">let rec</literal>. In particular, imagine how
        the following code snippet would be compiled:</para>

        <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/let_rec.ml">imperative-programming/let_rec.ml</ulink></para>

        <programlisting format="linespecific" language="ocaml">let rec x = x + 1</programlisting>

        <para>Note that <literal moreinfo="none">x</literal> is an ordinary
        value, not a function. As such, it's not clear how this definition
        should be handled by the compiler. You could imagine it compiling down
        to an infinite loop, but <literal moreinfo="none">x</literal> is of
        type <literal moreinfo="none">int</literal>, and there's no <literal
        moreinfo="none">int</literal> that corresponds to an infinite loop. As
        such, this construct is effectively impossible to compile.</para>

        <para>To avoid such impossible cases, the compiler only allows three
        possible constructs to show up on the right-hand side of a <literal
        moreinfo="none">let rec</literal>: a function definition, a
        constructor, or the lazy keyword. This excludes some reasonable
        things, like our definition of <literal
        moreinfo="none">memo_rec</literal>, but it also blocks things that
        don't make sense, like our definition of <literal
        moreinfo="none">x</literal>.</para>

        <para>It's worth noting that these restrictions don't show up in a
        lazy language like Haskell. Indeed, we can make something like our
        definition of <literal moreinfo="none">x</literal> work if we use
        OCaml's laziness:</para>

        <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/letrec.topscript">imperative-programming/letrec.topscript</ulink>
        (part 2)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">let rec x = lazy (Lazy.force x + 1);;</userinput>
<computeroutput moreinfo="none">val x : int lazy_t = &lt;lazy&gt;</computeroutput></programlisting>

        <para>Of course, actually trying to compute this will fail. OCaml's
        <literal moreinfo="none">lazy</literal> throws an exception when a
        lazy value tries to force itself as part of its own evaluation.</para>

        <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/letrec.topscript">imperative-programming/letrec.topscript</ulink>
        (part 3)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">Lazy.force x;;</userinput>
<computeroutput moreinfo="none">Exception: Lazy.Undefined.</computeroutput></programlisting>

        <para>But we can also create useful recursive definitions with
        <literal moreinfo="none">lazy</literal>. In particular, we can use
        laziness to make our definition of <literal
        moreinfo="none">memo_rec</literal> work without explicit
        mutation:</para>

        <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/letrec.topscript">imperative-programming/letrec.topscript</ulink>
        (part 5)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">let lazy_memo_rec f_norec x =</userinput>
<userinput moreinfo="none">    let rec f = lazy (memoize (fun x -&gt; f_norec (Lazy.force f) x)) in</userinput>
<userinput moreinfo="none">    (Lazy.force f) x</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val lazy_memo_rec : (('a -&gt; 'b) -&gt; 'a -&gt; 'b) -&gt; 'a -&gt; 'b = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">time (fun () -&gt; lazy_memo_rec fib_norec 40);;</userinput>
<computeroutput moreinfo="none">Time: 0.0650883ms</computeroutput>
<computeroutput moreinfo="none">- : int = 102334155</computeroutput></programlisting>

        <para>Laziness is more constrained than explicit mutation, and so in
        some cases can lead to code whose behavior is easier to think
        about.<indexterm class="endofrange" startref="BEmem"/></para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="input-and-output">
    <title>Input and Output</title>

    <para>Imperative programming is about more than modifying in-memory data
    structures. Any function that doesn't boil down to a deterministic
    transformation from its arguments to its return value is imperative in
    nature. That includes not only things that mutate your program's data, but
    also operations that interact with the world outside of your program. An
    important example of this kind of interaction is I/O, i.e., operations for
    reading or writing data to things like files, terminal input and output,
    and network sockets.<indexterm class="singular">
        <primary>I/O (input/output) operations</primary>

        <secondary>terminal I/O</secondary>
      </indexterm><indexterm class="startofrange" id="IPinpout">
        <primary>imperative programming</primary>

        <secondary>input and output</secondary>
      </indexterm></para>

    <para>There are multiple I/O libraries in OCaml. In this section we'll
    discuss OCaml's buffered I/O library that can be used through the <literal
    moreinfo="none">In_channel</literal> and <literal
    moreinfo="none">Out_channel</literal> modules in Core. Other I/O
    primitives are also available through the <literal
    moreinfo="none">Unix</literal> module in Core as well as <literal
    moreinfo="none">Async</literal>, the asynchronous I/O library that is
    covered in <xref linkend="concurrent-programming-with-async"/>. Most of
    the functionality in Core's <literal moreinfo="none">In_channel</literal>,
    <literal moreinfo="none">Out_channel</literal> (and in Core's <literal
    moreinfo="none">Unix</literal> module) derives from the standard library,
    but we'll use Core's interfaces here.</para>

    <sect2 id="terminal-io">
      <title>Terminal I/O</title>

      <para>OCaml's buffered I/O library is organized around two types:
      <literal moreinfo="none">in_channel</literal>, for channels you read
      from, and <literal moreinfo="none">out_channel</literal>, for channels
      you write to. The <literal moreinfo="none">In_channel</literal> and
      <literal moreinfo="none">Out_channel</literal> modules only have direct
      support for channels corresponding to files and terminals; other kinds
      of channels can be created through the <literal
      moreinfo="none">Unix</literal> module.<indexterm class="singular">
          <primary>Out_channel module</primary>

          <secondary>Out_channel.stderr</secondary>
        </indexterm><indexterm class="singular">
          <primary>Out_channel module</primary>

          <secondary>Out_channel.stdout</secondary>
        </indexterm><indexterm class="singular">
          <primary>In_channel module</primary>
        </indexterm></para>

      <para>We'll start our discussion of I/O by focusing on the terminal.
      Following the UNIX model, communication with the terminal is organized
      around three channels, which correspond to the three standard file
      descriptors in Unix:</para>

      <variablelist>
        <varlistentry>
          <term><literal moreinfo="none">In_channel.stdin</literal></term>

          <listitem>
            <para>The "standard input" channel. By default, input comes from
            the terminal, which handles keyboard input.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal moreinfo="none">Out_channel.stdout</literal></term>

          <listitem>
            <para>The "standard output" channel. By default, output written to
            <literal moreinfo="none">stdout</literal> appears on the user
            terminal.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><literal moreinfo="none">Out_channel.stderr</literal></term>

          <listitem>
            <para>The "standard error" channel. This is similar to <literal
            moreinfo="none">stdout</literal> but is intended for error
            messages.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>The values <literal moreinfo="none">stdin</literal>, <literal
      moreinfo="none">stdout</literal>, and <literal
      moreinfo="none">stderr</literal> are useful enough that they are also
      available in the global namespace directly, without having to go through
      the <literal moreinfo="none">In_channel</literal> and <literal
      moreinfo="none">Out_channel</literal> modules.</para>

      <para>Let's see this in action in a simple interactive application. The
      following program, <literal moreinfo="none">time_converter</literal>,
      prompts the user for a timezone, and then prints out the current time in
      that timezone. Here, we use Core's <literal
      moreinfo="none">Zone</literal> module for looking up a timezone, and the
      <literal moreinfo="none">Time</literal> module for computing the current
      time and printing it out in the timezone in question:</para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/time_converter.ml">imperative-programming/time_converter.ml</ulink></para>

      <programlisting format="linespecific" language="ocaml">open Core.Std

let () =
  Out_channel.output_string stdout "Pick a timezone: ";
  Out_channel.flush stdout;
  match In_channel.input_line stdin with
  | None -&gt; failwith "No timezone provided"
  | Some zone_string -&gt;
    let zone = Zone.find_exn zone_string in
    let time_string = Time.to_string_abs (Time.now ()) ~zone in
    Out_channel.output_string stdout
      (String.concat
         ["The time in ";Zone.to_string zone;" is ";time_string;".\n"]);
    Out_channel.flush stdout</programlisting>

      <para>We can build this program using <command
      moreinfo="none">corebuild</command> and run it. You'll see that it
      prompts you for input, as follows:</para>

      <para role="sourcecode">Terminal: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/time_converter.out">imperative-programming/time_converter.out</ulink></para>

      <programlisting format="linespecific" language="console"><prompt
          moreinfo="none">$ </prompt><userinput moreinfo="none">corebuild time_converter.byte</userinput>
<prompt moreinfo="none">$ </prompt><userinput moreinfo="none">./time_converter.byte</userinput>
<computeroutput moreinfo="none">Pick a timezone:</computeroutput></programlisting>

      <para>You can then type in the name of a timezone and hit Return, and it
      will print out the current time in the timezone in question:</para>

      <para role="sourcecode">Terminal: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/time_converter2.out">imperative-programming/time_converter2.out</ulink></para>

      <programlisting format="linespecific" language="console"><computeroutput
          moreinfo="none">Pick a timezone: Europe/London</computeroutput>
<computeroutput moreinfo="none">The time in Europe/London is 2013-08-15 00:03:10.666220+01:00.</computeroutput></programlisting>

      <para>We called <literal moreinfo="none">Out_channel.flush</literal> on
      <literal moreinfo="none">stdout</literal> because <literal
      moreinfo="none">out_channel</literal>s are buffered, which is to say
      that OCaml doesn't immediately do a write every time you call <literal
      moreinfo="none">output_string</literal>. Instead, writes are buffered
      until either enough has been written to trigger the flushing of the
      buffers, or until a flush is explicitly requested. This greatly
      increases the efficiency of the writing process by reducing the number
      of system calls.</para>

      <para>Note that <literal moreinfo="none">In_channel.input_line</literal>
      returns a <literal moreinfo="none">string option</literal>, with
      <literal moreinfo="none">None</literal> indicating that the input stream
      has ended (i.e., an end-of-file condition). <literal
      moreinfo="none">Out_channel.output_string</literal> is used to print the
      final output, and <literal moreinfo="none">Out_channel.flush</literal>
      is called to flush that output to the screen. The final flush is not
      technically required, since the program ends after that instruction, at
      which point all remaining output will be flushed anyway, but the
      explicit flush is nonetheless good practice.</para>
    </sect2>

    <sect2 id="formatted-output-with-printf">
      <title>Formatted Output with <literal
      moreinfo="none">printf</literal></title>

      <para>Generating output with functions like <literal
      moreinfo="none">Out_channel.output_string</literal> is simple and easy
      to understand, but can be a bit verbose. OCaml also supports formatted
      output using the <literal moreinfo="none">printf</literal> function,
      which is modeled after <literal moreinfo="none">printf</literal> in the
      C standard library. <literal moreinfo="none">printf</literal> takes a
      <emphasis>format string</emphasis> that describe what to print and how
      to format it, as well as arguments to be printed, as determined by the
      formatting directives embedded in the format string. So, for example, we
      can write:<indexterm class="singular">
          <primary>strings</primary>

          <secondary>format strings</secondary>
        </indexterm><indexterm class="singular">
          <primary>format strings</primary>
        </indexterm><indexterm class="singular">
          <primary>printf</primary>

          <secondary>function</secondary>
        </indexterm><indexterm class="singular">
          <primary>I/O (input/output) operations</primary>

          <secondary>formatted output</secondary>
        </indexterm></para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/printf.topscript">imperative-programming/printf.topscript</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">printf "%i is an integer, %F is a float, \"%s\" is a string\n"</userinput>
<userinput moreinfo="none">    3 4.5 "five";;</userinput>
<computeroutput moreinfo="none">3 is an integer, 4.5 is a float, "five" is a string</computeroutput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput></programlisting>

      <para>Unlike C's <literal moreinfo="none">printf</literal>, the <literal
      moreinfo="none">printf</literal> in OCaml is type-safe. In particular,
      if we provide an argument whose type doesn't match what's presented in
      the format string, we'll get a type error:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/printf.topscript">imperative-programming/printf.topscript</ulink>
      (part 2)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">printf "An integer: %i\n" 4.5;;</userinput>
<computeroutput moreinfo="none">Characters 26-29:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type float but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         int</computeroutput></programlisting>

      <sidebar>
        <title>Understanding Format Strings</title>

        <para>The format strings used by <literal
        moreinfo="none">printf</literal> turn out to be quite different from
        ordinary strings. This difference ties to the fact that OCaml format
        strings, unlike their equivalent in C, are type-safe. In particular,
        the compiler checks that the types referred to by the format string
        match the types of the rest of the arguments passed to <literal
        moreinfo="none">printf</literal>.</para>

        <para>To check this, OCaml needs to analyze the contents of the format
        string at compile time, which means the format string needs to be
        available as a string literal at compile time. Indeed, if you try to
        pass an ordinary string to <literal moreinfo="none">printf</literal>,
        the compiler will complain:</para>

        <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/printf.topscript">imperative-programming/printf.topscript</ulink>
        (part 3)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">let fmt = "%i is an integer, %F is a float, \"%s\" is a string\n";;</userinput>
<computeroutput moreinfo="none">val fmt : string = "%i is an integer, %F is a float, \"%s\" is a string\n"</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">  printf fmt 3 4.5 "five";;</userinput>
<computeroutput moreinfo="none">Characters 9-12:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type string but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         ('a -&gt; 'b -&gt; 'c -&gt; 'd, out_channel, unit) format =</computeroutput>
<computeroutput moreinfo="none">           ('a -&gt; 'b -&gt; 'c -&gt; 'd, out_channel, unit, unit, unit, unit)</computeroutput>
<computeroutput moreinfo="none">           format6</computeroutput></programlisting>

        <para>If OCaml infers that a given string literal is a format string,
        then it parses it at compile time as such, choosing its type in
        accordance with the formatting directives it finds. Thus, if we add a
        type-annotation indicating that the string we're defining is actually
        a format string, it will be interpreted as such:</para>

        <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/printf.topscript">imperative-programming/printf.topscript</ulink>
        (part 4)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">let fmt : ('a, 'b, 'c) format =</userinput>
<userinput moreinfo="none">    "%i is an integer, %F is a float, \"%s\" is a string\n";;</userinput>
<computeroutput moreinfo="none">val fmt : (int -&gt; float -&gt; string -&gt; 'c, 'b, 'c) format = &lt;abstr&gt;</computeroutput></programlisting>

        <para>And accordingly, we can pass it to <literal
        moreinfo="none">printf</literal>:</para>

        <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
        url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/printf.topscript">imperative-programming/printf.topscript</ulink>
        (part 4)</para>

        <programlisting format="linespecific" language="ocaml"><prompt
            moreinfo="none"># </prompt><userinput moreinfo="none">let fmt : ('a, 'b, 'c) format =</userinput>
<userinput moreinfo="none">    "%i is an integer, %F is a float, \"%s\" is a string\n";;</userinput>
<computeroutput moreinfo="none">val fmt : (int -&gt; float -&gt; string -&gt; 'c, 'b, 'c) format = &lt;abstr&gt;</computeroutput></programlisting>

        <para>If this looks different from everything else you've seen so far,
        that's because it is. This is really a special case in the type
        system. Most of the time, you don't need to worry about this special
        handling of format strings—you can just use <literal
        moreinfo="none">printf</literal> and not worry about the details. But
        it's useful to keep the broad outlines of the story in the back of
        your head.</para>
      </sidebar>

      <para>Now let's see how we can rewrite our time conversion program to be
      a little more concise using <literal
      moreinfo="none">printf</literal>:</para>

      <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/time_converter2.ml">imperative-programming/time_converter2.ml</ulink></para>

      <programlisting format="linespecific" language="ocaml">open Core.Std

let () =
  printf "Pick a timezone: %!";
  match In_channel.input_line stdin with
  | None -&gt; failwith "No timezone provided"
  | Some zone_string -&gt;
    let zone = Zone.find_exn zone_string in
    let time_string = Time.to_string_abs (Time.now ()) ~zone in
    printf "The time in %s is %s.\n%!" (Zone.to_string zone) time_string</programlisting>

      <para>In the preceding example, we've used only two formatting
      directives: <literal moreinfo="none">%s</literal>, for including a
      string, and <literal moreinfo="none">%!</literal> which causes <literal
      moreinfo="none">printf</literal> to flush the channel.</para>

      <para><literal moreinfo="none">printf</literal>'s formatting directives
      offer a significant amount of control, allowing you to specify things
      like:<indexterm class="singular">
          <primary>binary numbers, formatting with printf</primary>
        </indexterm><indexterm class="singular">
          <primary>hex numbers, formating with printf</primary>
        </indexterm><indexterm class="singular">
          <primary>decimals, formatting with printf</primary>
        </indexterm><indexterm class="singular">
          <primary>padding, formatting with printf</primary>
        </indexterm><indexterm class="singular">
          <primary>alignment, formatting with printf</primary>
        </indexterm></para>

      <itemizedlist>
        <listitem>
          <para>Alignment and padding</para>
        </listitem>

        <listitem>
          <para>Escaping rules for strings</para>
        </listitem>

        <listitem>
          <para>Whether numbers should be formatted in decimal, hex, or
          binary</para>
        </listitem>

        <listitem>
          <para>Precision of float conversions</para>
        </listitem>
      </itemizedlist>

      <para>There are also <literal moreinfo="none">printf</literal>-style
      functions that target outputs other than <literal
      moreinfo="none">stdout</literal>, including:<indexterm class="singular">
          <primary>sprintf function</primary>
        </indexterm><indexterm class="singular">
          <primary>fprintf function</primary>
        </indexterm><indexterm class="singular">
          <primary>eprintf function</primary>
        </indexterm></para>

      <itemizedlist>
        <listitem>
          <para><literal moreinfo="none">eprintf</literal>, which prints to
          <literal moreinfo="none">stderr</literal>.</para>
        </listitem>

        <listitem>
          <para><literal moreinfo="none">fprintf</literal>, which prints to an
          arbitrary <literal moreinfo="none">out_channel</literal></para>
        </listitem>

        <listitem>
          <para><literal moreinfo="none">sprintf</literal>, which returns a
          formatted string</para>
        </listitem>
      </itemizedlist>

      <para>All of this, and a good deal more, is described in the API
      documentation for the <literal moreinfo="none">Printf</literal> module
      in the OCaml Manual.</para>
    </sect2>

    <sect2 id="file-io">
      <title>File I/O</title>

      <para>Another common use of <literal
      moreinfo="none">in_channel</literal>s and <literal
      moreinfo="none">out_channel</literal>s is for working with files. Here's
      a couple of functions, one that creates a file full of numbers, and the
      other that reads in such a file and returns the sum of those
      numbers:<indexterm class="singular">
          <primary>files</primary>

          <secondary>file I/O</secondary>
        </indexterm><indexterm class="singular">
          <primary>I/O (input/output) operations</primary>

          <secondary>file I/O</secondary>
        </indexterm></para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/file.topscript">imperative-programming/file.topscript</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let create_number_file filename numbers =</userinput>
<userinput moreinfo="none">    let outc = Out_channel.create filename in</userinput>
<userinput moreinfo="none">    List.iter numbers ~f:(fun x -&gt; fprintf outc "%d\n" x);</userinput>
<userinput moreinfo="none">    Out_channel.close outc</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val create_number_file : string -&gt; int list -&gt; unit = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">let sum_file filename =</userinput>
<userinput moreinfo="none">     let file = In_channel.create filename in</userinput>
<userinput moreinfo="none">     let numbers = List.map ~f:Int.of_string (In_channel.input_lines file) in</userinput>
<userinput moreinfo="none">     let sum = List.fold ~init:0 ~f:(+) numbers in</userinput>
<userinput moreinfo="none">     In_channel.close file;</userinput>
<userinput moreinfo="none">     sum</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val sum_file : string -&gt; int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">create_number_file "numbers.txt" [1;2;3;4;5];;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sum_file "numbers.txt";;</userinput>
<computeroutput moreinfo="none">- : int = 15</computeroutput></programlisting>

      <para>For both of these functions, we followed the same basic sequence:
      we first create the channel, then use the channel, and finally close the
      channel. The closing of the channel is important, since without it, we
      won't release resources associated with the file back to the operating
      system.</para>

      <para>One problem with the preceding code is that if it throws an
      exception in the middle of its work, it won't actually close the file.
      If we try to read a file that doesn't actually contain numbers, we'll
      see such an error:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/file.topscript">imperative-programming/file.topscript</ulink>
      (part 2)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">sum_file "/etc/hosts";;</userinput>
<computeroutput moreinfo="none">Exception: (Failure "Int.of_string: \"127.0.0.1    localhost\"").</computeroutput></programlisting>

      <para>And if we do this over and over in a loop, we'll eventually run
      out of file descriptors:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/file.topscript">imperative-programming/file.topscript</ulink>
      (part 3)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">for i = 1 to 10000 do try ignore (sum_file "/etc/hosts") with _ -&gt; () done;;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sum_file "numbers.txt";;</userinput>
<computeroutput moreinfo="none">Exception: (Sys_error "numbers.txt: Too many open files").</computeroutput></programlisting>

      <para>And now, you'll need to restart your toplevel if you want to open
      any more files!</para>

      <para>To avoid this, we need to make sure that our code cleans up after
      itself. We can do this using the <literal
      moreinfo="none">protect</literal> function described in <xref
      linkend="error-handling"/>, as follows:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/file2.topscript">imperative-programming/file2.topscript</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let sum_file filename =</userinput>
<userinput moreinfo="none">    let file = In_channel.create filename in</userinput>
<userinput moreinfo="none">    protect ~f:(fun () -&gt;</userinput>
<userinput moreinfo="none">        let numbers = List.map ~f:Int.of_string (In_channel.input_lines file) in</userinput>
<userinput moreinfo="none">        List.fold ~init:0 ~f:(+) numbers)</userinput>
<userinput moreinfo="none">      ~finally:(fun () -&gt; In_channel.close file)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val sum_file : string -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

      <para>And now, the file descriptor leak is gone:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/file2.topscript">imperative-programming/file2.topscript</ulink>
      (part 2)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">for i = 1 to 10000 do try ignore (sum_file "/etc/hosts") with _ -&gt; () done;;</userinput>
<computeroutput moreinfo="none">- : unit = ()</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">sum_file "numbers.txt";;</userinput>
<computeroutput moreinfo="none">- : int = 15</computeroutput></programlisting>

      <para>This is really an example of a more general issue with imperative
      programming. When programming imperatively, you need to be quite careful
      to make sure that exceptions don't leave you in an awkward state.</para>

      <para><literal moreinfo="none">In_channel</literal> has functions that
      automate the handling of some of these details. For example, <literal
      moreinfo="none">In_channel.with_file</literal> takes a filename and a
      function for processing data from an <literal
      moreinfo="none">in_channel</literal> and takes care of the bookkeeping
      associated with opening and closing the file. We can rewrite <literal
      moreinfo="none">sum_file</literal> using this function, as shown
      here:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/file2.topscript">imperative-programming/file2.topscript</ulink>
      (part 3)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let sum_file filename =</userinput>
<userinput moreinfo="none">    In_channel.with_file filename ~f:(fun file -&gt;</userinput>
<userinput moreinfo="none">      let numbers = List.map ~f:Int.of_string (In_channel.input_lines file) in</userinput>
<userinput moreinfo="none">      List.fold ~init:0 ~f:(+) numbers)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val sum_file : string -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

      <para>Another misfeature of our implementation of <literal
      moreinfo="none">sum_file</literal> is that we read the entire file into
      memory before processing it. For a large file, it's more efficient to
      process a line at a time. You can use the <literal
      moreinfo="none">In_channel.fold_lines</literal> function to do just
      that:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/file2.topscript">imperative-programming/file2.topscript</ulink>
      (part 4)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let sum_file filename =</userinput>
<userinput moreinfo="none">    In_channel.with_file filename ~f:(fun file -&gt;</userinput>
<userinput moreinfo="none">      In_channel.fold_lines file ~init:0 ~f:(fun sum line -&gt;</userinput>
<userinput moreinfo="none">        sum + Int.of_string line))</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val sum_file : string -&gt; int = &lt;fun&gt;</computeroutput></programlisting>

      <para>This is just a taste of the functionality of <literal
      moreinfo="none">In_channel</literal> and <literal
      moreinfo="none">Out_channel</literal>. To get a fuller understanding,
      you should review the API documentation for those modules.<indexterm
      class="endofrange" startref="IPinpout"/></para>
    </sect2>
  </sect1>

  <sect1 id="order-of-evaluation">
    <title>Order of Evaluation</title>

    <para>The order in which expressions are evaluated is an important part of
    the definition of a programming language, and it is particularly important
    when programming imperatively. Most programming languages you're likely to
    have encountered are <emphasis>strict</emphasis>, and OCaml is, too. In a
    strict language, when you bind an identifier to the result of some
    expression, the expression is evaluated before the variable is defined.
    Similarly, if you call a function on a set of arguments, those arguments
    are evaluated before they are passed to the function.<indexterm
        class="singular">
        <primary>strict evaluation</primary>
      </indexterm><indexterm class="singular">
        <primary>expressions, order of evaluation</primary>
      </indexterm><indexterm class="singular">
        <primary>evaluation, order of</primary>
      </indexterm><indexterm class="singular">
        <primary>order of evaluation</primary>
      </indexterm><indexterm class="singular">
        <primary>imperative programming</primary>

        <secondary>order of evaluation</secondary>
      </indexterm></para>

    <para>Consider the following simple example. Here, we have a collection of
    angles and we want to determine if any of them have a negative <literal
    moreinfo="none">sin</literal>. The following snippet of code would answer
    that question:</para>

    <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/order.topscript">imperative-programming/order.topscript</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let x = sin 120. in</userinput>
<userinput moreinfo="none">  let y = sin 75.  in</userinput>
<userinput moreinfo="none">  let z = sin 128. in</userinput>
<userinput moreinfo="none">  List.exists ~f:(fun x -&gt; x &lt; 0.) [x;y;z]</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">- : bool = true</computeroutput></programlisting>

    <para>In some sense, we don't really need to compute the <literal
    moreinfo="none">sin 128.</literal> because <literal moreinfo="none">sin
    75.</literal> is negative, so we could know the answer before even
    computing <literal moreinfo="none">sin 128.</literal>.</para>

    <para>It doesn't have to be this way. Using the <literal
    moreinfo="none">lazy</literal> keyword, we can write the original
    computation so that <literal moreinfo="none">sin 128.</literal> won't ever
    be computed:</para>

    <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/order.topscript">imperative-programming/order.topscript</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let x = lazy (sin 120.) in</userinput>
<userinput moreinfo="none">  let y = lazy (sin 75.)  in</userinput>
<userinput moreinfo="none">  let z = lazy (sin 128.) in</userinput>
<userinput moreinfo="none">  List.exists ~f:(fun x -&gt; Lazy.force x &lt; 0.) [x;y;z]</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">- : bool = true</computeroutput></programlisting>

    <para>We can confirm that fact by a few well-placed <literal
    moreinfo="none">printf</literal>s:</para>

    <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/order.topscript">imperative-programming/order.topscript</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let x = lazy (printf "1\n"; sin 120.) in</userinput>
<userinput moreinfo="none">  let y = lazy (printf "2\n"; sin 75.)  in</userinput>
<userinput moreinfo="none">  let z = lazy (printf "3\n"; sin 128.) in</userinput>
<userinput moreinfo="none">  List.exists ~f:(fun x -&gt; Lazy.force x &lt; 0.) [x;y;z]</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">1</computeroutput>
<computeroutput moreinfo="none">2</computeroutput>
<computeroutput moreinfo="none">- : bool = true</computeroutput></programlisting>

    <para>OCaml is strict by default for a good reason: lazy evaluation and
    imperative programming generally don't mix well because laziness makes it
    harder to reason about when a given side effect is going to occur.
    Understanding the order of side effects is essential to reasoning about
    the behavior of an imperative program.</para>

    <para>In a strict language, we know that expressions that are bound by a
    sequence of let-bindings will be evaluated in the order that they're
    defined. But what about the evaluation order within a single expression?
    Officially, the answer is that evaluation order within an expression is
    undefined. In practice, OCaml has only one compiler, and that behavior is
    a kind of de facto standard. Unfortunately, the evaluation order in this
    case is often the opposite of what one might expect.</para>

    <para>Consider the following example:</para>

    <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/order.topscript">imperative-programming/order.topscript</ulink>
    (part 4)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">List.exists ~f:(fun x -&gt; x &lt; 0.)</userinput>
<userinput moreinfo="none">  [ (printf "1\n"; sin 120.);</userinput>
<userinput moreinfo="none">    (printf "2\n"; sin 75.);</userinput>
<userinput moreinfo="none">    (printf "3\n"; sin 128.); ]</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">3</computeroutput>
<computeroutput moreinfo="none">2</computeroutput>
<computeroutput moreinfo="none">1</computeroutput>
<computeroutput moreinfo="none">- : bool = true</computeroutput></programlisting>

    <para>Here, you can see that the subexpression that came last was actually
    evaluated first! This is generally the case for many different kinds of
    expressions. If you want to make sure of the evaluation order of different
    subexpressions, you should express them as a series of <literal
    moreinfo="none">let</literal> bindings.</para>
  </sect1>

  <sect1 id="side-effects-and-weak-polymorphism">
    <title>Side Effects and Weak Polymorphism</title>

    <para>Consider the following simple, imperative function:<indexterm
        class="singular">
        <primary>polymorphism</primary>

        <secondary>weak polymorphism</secondary>
      </indexterm><indexterm class="singular">
        <primary>weak polymorphism</primary>
      </indexterm><indexterm class="singular">
        <primary>side effects</primary>
      </indexterm><indexterm class="startofrange" id="IPsideweak">
        <primary>imperative programming</primary>

        <secondary>side effects/weak polymorphism</secondary>
      </indexterm></para>

    <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/weak.topscript">imperative-programming/weak.topscript</ulink>
    (part 1)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let remember =</userinput>
<userinput moreinfo="none">    let cache = ref None in</userinput>
<userinput moreinfo="none">    (fun x -&gt;</userinput>
<userinput moreinfo="none">       match !cache with</userinput>
<userinput moreinfo="none">       | Some y -&gt; y</userinput>
<userinput moreinfo="none">       | None -&gt; cache := Some x; x)</userinput>
<userinput moreinfo="none">  ;;</userinput>
<computeroutput moreinfo="none">val remember : '_a -&gt; '_a = &lt;fun&gt;</computeroutput></programlisting>

    <para><literal moreinfo="none">remember</literal> simply caches the first
    value that's passed to it, returning that value on every call. That's
    because <literal moreinfo="none">cache</literal> is created and
    initialized once and is shared across invocations of <literal
    moreinfo="none">remember</literal>.</para>

    <para><literal moreinfo="none">remember</literal> is not a terribly useful
    function, but it raises an interesting question: what is its type?</para>

    <para>On its first call, <literal moreinfo="none">remember</literal>
    returns the same value it's passed, which means its input type and return
    type should match. Accordingly, <literal
    moreinfo="none">remember</literal> should have type <literal
    moreinfo="none">t -&gt; t</literal> for some type <literal
    moreinfo="none">t</literal>. There's nothing about <literal
    moreinfo="none">remember</literal> that ties the choice of <literal
    moreinfo="none">t</literal> to any particular type, so you might expect
    OCaml to generalize, replacing <literal moreinfo="none">t</literal> with a
    polymorphic type variable. It's this kind of generalization that gives us
    polymorphic types in the first place. The identity function, as an
    example, gets a polymorphic type in this way:</para>

    <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/weak.topscript">imperative-programming/weak.topscript</ulink>
    (part 2)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let identity x = x;;</userinput>
<computeroutput moreinfo="none">val identity : 'a -&gt; 'a = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">identity 3;;</userinput>
<computeroutput moreinfo="none">- : int = 3</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">identity "five";;</userinput>
<computeroutput moreinfo="none">- : string = "five"</computeroutput></programlisting>

    <para>As you can see, the polymorphic type of <literal
    moreinfo="none">identity</literal> lets it operate on values with
    different types.</para>

    <para>This is not what happens with <literal
    moreinfo="none">remember</literal>, though. As you can see from the
    preceding <command moreinfo="none">utop</command>, the type that OCaml
    infers for <literal moreinfo="none">remember</literal> looks almost, but
    not quite, like the type of the identity function. Here it is
    again:</para>

    <para role="sourcecode">OCaml: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/remember_type.ml">imperative-programming/remember_type.ml</ulink></para>

    <programlisting format="linespecific" language="ocaml">val remember : '_a -&gt; '_a = &lt;fun&gt;</programlisting>

    <para>The underscore in the type variable <literal
    moreinfo="none">'_a</literal> tells us that the variable is only
    <emphasis>weakly polymorphic</emphasis>, which is to say that it can be
    used with any <emphasis>single</emphasis> type. That makes sense because,
    unlike <literal moreinfo="none">identity</literal>, <literal
    moreinfo="none">remember</literal> always returns the value it was passed
    on its first invocation, which means its return value must always have the
    same type.</para>

    <para>OCaml will convert a weakly polymorphic variable to a concrete type
    as soon as it gets a clue as to what concrete type it is to be used
    as:</para>

    <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
    url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/weak.topscript">imperative-programming/weak.topscript</ulink>
    (part 3)</para>

    <programlisting format="linespecific" language="ocaml"><prompt
        moreinfo="none"># </prompt><userinput moreinfo="none">let remember_three () = remember 3;;</userinput>
<computeroutput moreinfo="none">val remember_three : unit -&gt; int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">remember;;</userinput>
<computeroutput moreinfo="none">- : int -&gt; int = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">remember "avocado";;</userinput>
<computeroutput moreinfo="none">Characters 9-18:</computeroutput>
<computeroutput moreinfo="none">Error: This expression has type string but an expression was expected of type</computeroutput>
<computeroutput moreinfo="none">         int</computeroutput></programlisting>

    <para>Note that the type of <literal moreinfo="none">remember</literal>
    was settled by the definition of <literal
    moreinfo="none">remember_three</literal>, even though <literal
    moreinfo="none">remember_three</literal> was never called!</para>

    <sect2 id="the-value-restriction">
      <title>The Value Restriction</title>

      <para>So, when does the compiler infer weakly polymorphic types? As
      we've seen, we need weakly polymorphic types when a value of unknown
      type is stored in a persistent mutable cell. Because the type system
      isn't precise enough to determine all cases where this might happen,
      OCaml uses a rough rule to flag cases that don't introduce any
      persistent mutable cells, and to only infer polymorphic types in those
      cases. This rule is called <emphasis>the value
      restriction</emphasis>.<indexterm class="singular">
          <primary>value restriction</primary>
        </indexterm></para>

      <para>The core of the value restriction is the observation that some
      kinds of expressions, which we'll refer to as <emphasis>simple
      values</emphasis>, by their nature can't introduce persistent mutable
      cells, including:</para>

      <itemizedlist>
        <listitem>
          <para>Constants (i.e., things like integer and floating-point
          literals)</para>
        </listitem>

        <listitem>
          <para>Constructors that only contain other simple values</para>
        </listitem>

        <listitem>
          <para>Function declarations, i.e., expressions that begin with
          <literal moreinfo="none">fun</literal> or <literal
          moreinfo="none">function</literal>, or the equivalent let binding,
          <literal moreinfo="none">let f x = ...</literal></para>
        </listitem>

        <listitem>
          <para><literal moreinfo="none">let</literal> bindings of the form
          <literal moreinfo="none">let</literal> <emphasis><literal
          moreinfo="none">var</literal></emphasis> <literal
          moreinfo="none">=</literal> <emphasis><literal
          moreinfo="none">expr1</literal></emphasis> <literal
          moreinfo="none">in</literal> <emphasis><literal
          moreinfo="none">expr2</literal></emphasis>, where both
          <emphasis><literal moreinfo="none">expr1</literal></emphasis> and
          <emphasis><literal moreinfo="none">expr2</literal></emphasis> are
          simple values</para>
        </listitem>
      </itemizedlist>

      <para>Thus, the following expression is a simple value, and as a result,
      the types of values contained within it are allowed to be
      polymorphic:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/value_restriction.topscript">imperative-programming/value_restriction.topscript</ulink>
      (part 1)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">(fun x -&gt; [x;x]);;</userinput>
<computeroutput moreinfo="none">- : 'a -&gt; 'a list = &lt;fun&gt;</computeroutput></programlisting>

      <para>But, if we write down an expression that isn't a simple value by
      the preceding definition, we'll get different results. For example,
      consider what happens if we try to memoize the function defined
      previously.</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/value_restriction.topscript">imperative-programming/value_restriction.topscript</ulink>
      (part 2)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">memoize (fun x -&gt; [x;x]);;</userinput>
<computeroutput moreinfo="none">- : '_a -&gt; '_a list = &lt;fun&gt;</computeroutput></programlisting>

      <para>The memoized version of the function does in fact need to be
      restricted to a single type because it uses mutable state behind the
      scenes to cache values returned by previous invocations of the function.
      But OCaml would make the same determination even if the function in
      question did no such thing. Consider this example:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/value_restriction.topscript">imperative-programming/value_restriction.topscript</ulink>
      (part 3)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">identity (fun x -&gt; [x;x]);;</userinput>
<computeroutput moreinfo="none">- : '_a -&gt; '_a list = &lt;fun&gt;</computeroutput></programlisting>

      <para>It would be safe to infer a fully polymorphic variable here, but
      because OCaml's type system doesn't distinguish between pure and impure
      functions, it can't separate those two cases.</para>

      <para>The value restriction doesn't require that there is no mutable
      state, only that there is no <emphasis>persistent</emphasis> mutable
      state that could share values between uses of the same function. Thus, a
      function that produces a fresh reference every time it's called can have
      a fully polymorphic type:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/value_restriction.topscript">imperative-programming/value_restriction.topscript</ulink>
      (part 4)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let f () = ref None;;</userinput>
<computeroutput moreinfo="none">val f : unit -&gt; 'a option ref = &lt;fun&gt;</computeroutput></programlisting>

      <para>But a function that has a mutable cache that persists across
      calls, like memoize, can only be weakly polymorphic.</para>
    </sect2>

    <sect2 id="partial-application-and-the-value-restriction">
      <title>Partial Application and the Value Restriction</title>

      <para>Most of the time, when the value restriction kicks in, it's for a
      good reason, i.e., it's because the value in question can actually only
      safely be used with a single type. But sometimes, the value restriction
      kicks in when you don't want it. The most common such case is partially
      applied functions. A partially applied function, like any function
      application, is not a simple value, and as such, functions created by
      partial application are sometimes less general than you might
      expect.<indexterm class="singular">
          <primary>partial application</primary>
        </indexterm></para>

      <para>Consider the <literal moreinfo="none">List.init</literal>
      function, which is used for creating lists where each element is created
      by calling a function on the index of that element:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/value_restriction.topscript">imperative-programming/value_restriction.topscript</ulink>
      (part 5)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">List.init;;</userinput>
<computeroutput moreinfo="none">- : int -&gt; f:(int -&gt; 'a) -&gt; 'a list = &lt;fun&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">List.init 10 ~f:Int.to_string;;</userinput>
<computeroutput moreinfo="none">- : string list = ["0"; "1"; "2"; "3"; "4"; "5"; "6"; "7"; "8"; "9"]</computeroutput></programlisting>

      <para>Imagine we wanted to create a specialized version of <literal
      moreinfo="none">List.init</literal> that always created lists of length
      10. We could do that using partial application, as follows:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/value_restriction.topscript">imperative-programming/value_restriction.topscript</ulink>
      (part 6)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let list_init_10 = List.init 10;;</userinput>
<computeroutput moreinfo="none">val list_init_10 : f:(int -&gt; '_a) -&gt; '_a list = &lt;fun&gt;</computeroutput></programlisting>

      <para>As you can see, we now infer a weakly polymorphic type for the
      resulting function. That's because there's nothing that guarantees that
      <literal moreinfo="none">List.init</literal> isn't creating a persistent
      <literal moreinfo="none">ref</literal> somewhere inside of it that would
      be shared across multiple calls to <literal
      moreinfo="none">list_init_10</literal>. We can eliminate this
      possibility, and at the same time get the compiler to infer a
      polymorphic type, by avoiding partial application:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/value_restriction.topscript">imperative-programming/value_restriction.topscript</ulink>
      (part 7)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">let list_init_10 ~f = List.init 10 ~f;;</userinput>
<computeroutput moreinfo="none">val list_init_10 : f:(int -&gt; 'a) -&gt; 'a list = &lt;fun&gt;</computeroutput></programlisting>

      <para>This transformation is referred to as <emphasis>eta
      expansion</emphasis> and is often useful to resolve problems that arise
      from the value restriction.</para>
    </sect2>

    <sect2 id="relaxing-the-value-restriction">
      <title>Relaxing the Value Restriction</title>

      <para>OCaml is actually a little better at inferring polymorphic types
      than is suggested previously. The value restriction as we described it
      is basically a syntactic check: there are a few operations that you can
      do that count as simple values, and anything that's a simple value can
      be generalized.</para>

      <para>But OCaml actually has a relaxed version of the value restriction
      that can make some use of type information to allow polymorphic types
      for things that are not simple values.</para>

      <para>For example, we saw that a function application, even a simple
      application of the identity function, is not a simple value and thus can
      turn a polymorphic value into a weakly polymorphic one:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/value_restriction.topscript">imperative-programming/value_restriction.topscript</ulink>
      (part 8)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">identity (fun x -&gt; [x;x]);;</userinput>
<computeroutput moreinfo="none">- : '_a -&gt; '_a list = &lt;fun&gt;</computeroutput></programlisting>

      <para>But that's not always the case. When the type of the returned
      value is immutable, then OCaml can typically infer a fully polymorphic
      type:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/value_restriction.topscript">imperative-programming/value_restriction.topscript</ulink>
      (part 9)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">identity [];;</userinput>
<computeroutput moreinfo="none">- : 'a list = []</computeroutput></programlisting>

      <para>On the other hand, if the returned type is potentially mutable,
      then the result will be weakly polymorphic:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/value_restriction.topscript">imperative-programming/value_restriction.topscript</ulink>
      (part 10)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">[||];;</userinput>
<computeroutput moreinfo="none">- : 'a array = [||]</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">identity [||];;</userinput>
<computeroutput moreinfo="none">- : '_a array = [||]</computeroutput></programlisting>

      <para>A more important example of this comes up when defining abstract
      data types. Consider the following simple data structure for an
      immutable list type that supports constant-time concatenation:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/value_restriction.topscript">imperative-programming/value_restriction.topscript</ulink>
      (part 11)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">module Concat_list : sig</userinput>
<userinput moreinfo="none">    type 'a t</userinput>
<userinput moreinfo="none">    val empty : 'a t</userinput>
<userinput moreinfo="none">    val singleton : 'a -&gt; 'a t</userinput>
<userinput moreinfo="none">    val concat  : 'a t -&gt; 'a t -&gt; 'a t  (* constant time *)</userinput>
<userinput moreinfo="none">    val to_list : 'a t -&gt; 'a list       (* linear time   *)</userinput>
<userinput moreinfo="none">  end = struct</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    type 'a t = Empty | Singleton of 'a | Concat of 'a t * 'a t</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    let empty = Empty</userinput>
<userinput moreinfo="none">    let singleton x = Singleton x</userinput>
<userinput moreinfo="none">    let concat x y = Concat (x,y)</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    let rec to_list_with_tail t tail =</userinput>
<userinput moreinfo="none">      match t with</userinput>
<userinput moreinfo="none">      | Empty -&gt; tail</userinput>
<userinput moreinfo="none">      | Singleton x -&gt; x :: tail</userinput>
<userinput moreinfo="none">      | Concat (x,y) -&gt; to_list_with_tail x (to_list_with_tail y tail)</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">    let to_list t =</userinput>
<userinput moreinfo="none">      to_list_with_tail t []</userinput>
<userinput moreinfo="none"/>
<userinput moreinfo="none">  end;;</userinput>
<computeroutput moreinfo="none">module Concat_list :</computeroutput>
<computeroutput moreinfo="none">  sig</computeroutput>
<computeroutput moreinfo="none">    type 'a t</computeroutput>
<computeroutput moreinfo="none">    val empty : 'a t</computeroutput>
<computeroutput moreinfo="none">    val singleton : 'a -&gt; 'a t</computeroutput>
<computeroutput moreinfo="none">    val concat : 'a t -&gt; 'a t -&gt; 'a t</computeroutput>
<computeroutput moreinfo="none">    val to_list : 'a t -&gt; 'a list</computeroutput>
<computeroutput moreinfo="none">  end</computeroutput></programlisting>

      <para>The details of the implementation don't matter so much, but it's
      important to note that a <literal
      moreinfo="none">Concat_list.t</literal> is unquestionably an immutable
      value. However, when it comes to the value restriction, OCaml treats it
      as if it were mutable:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/value_restriction.topscript">imperative-programming/value_restriction.topscript</ulink>
      (part 12)</para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">Concat_list.empty;;</userinput>
<computeroutput moreinfo="none">- : 'a Concat_list.t = &lt;abstr&gt;</computeroutput>
<prompt moreinfo="none"># </prompt><userinput moreinfo="none">identity Concat_list.empty;;</userinput>
<computeroutput moreinfo="none">- : '_a Concat_list.t = &lt;abstr&gt;</computeroutput></programlisting>

      <para>The issue here is that the signature, by virtue of being abstract,
      has obscured the fact that <literal
      moreinfo="none">Concat_list.t</literal> is in fact an immutable data
      type. We can resolve this in one of two ways: either by making the type
      concrete (i.e., exposing the implementation in the <literal
      moreinfo="none">mli</literal>), which is often not desirable; or by
      marking the type variable in question as <emphasis>covariant</emphasis>.
      We'll learn more about covariance and contravariance in <xref
      linkend="objects"/>, but for now, you can think of it as an annotation
      which can be put in the interface of a pure data structure.<indexterm
          class="singular">
          <primary>datatypes</primary>

          <secondary>covariant</secondary>
        </indexterm></para>

      <para>In particular, if we replace <literal moreinfo="none">type 'a
      t</literal> in the interface with <literal moreinfo="none">type +'a
      t</literal>, that will make it explicit in the interface that the data
      structure doesn't contain any persistent references to values of type
      <literal moreinfo="none">'a</literal>, at which point, OCaml can infer
      polymorphic types for expressions of this type that are not simple
      values:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/value_restriction-13.rawscript">imperative-programming/value_restriction-13.rawscript</ulink></para>

      <programlisting format="linespecific" language="ocaml"><userinput
          moreinfo="none"># module Concat_list : sig
    type 'a t
    val empty : 'a t
    val singleton : 'a -&gt; 'a t
    val concat  : 'a t -&gt; 'a t -&gt; 'a t  (* constant time *)
    val to_list : 'a t -&gt; 'a list       (* linear time   *)
  end = struct

    type 'a t = Empty | Singleton of 'a | Concat of 'a t * 'a t

    ...

  end;;</userinput>
<computeroutput moreinfo="none"> module Concat_list :
  sig
    type 'a t
    val empty : 'a t
    val singleton : 'a -&gt; 'a t
    val concat : 'a t -&gt; 'a t -&gt; 'a t
    val to_list : 'a t -&gt; 'a list
  end</computeroutput></programlisting>

      <para>Now, we can apply the identity function to <literal
      moreinfo="none">Concat_list.empty</literal> without without losing any
      polymorphism:</para>

      <para role="sourcecode">OCaml Utop: <ulink role="orm:hideurl:ital"
      url="https://github.com/realworldocaml/examples/tree/beta3/code/imperative-programming/value_restriction.topscript">imperative-programming/value_restriction.topscript</ulink>
      (part 14)<indexterm class="endofrange" startref="IPsideweak"/></para>

      <programlisting format="linespecific" language="ocaml"><prompt
          moreinfo="none"># </prompt><userinput moreinfo="none">identity Concat_list.empty;;</userinput>
<computeroutput moreinfo="none">- : 'a Concat_list.t = &lt;abstr&gt;</computeroutput></programlisting>
    </sect2>
  </sect1>

  <sect1 id="summary">
    <title>Summary</title>

    <para>This chapter has covered quite a lot of ground, including:<indexterm
        class="singular">
        <primary>imperative programming</primary>

        <secondary>overview of</secondary>
      </indexterm></para>

    <itemizedlist>
      <listitem>
        <para>Discussing the building blocks of mutable data structures as
        well as the basic imperative constructs like <literal
        moreinfo="none">for</literal> loops, <literal
        moreinfo="none">while</literal> loops, and the sequencing operator
        <literal moreinfo="none">;</literal></para>
      </listitem>

      <listitem>
        <para>Walking through the implementation of a couple of classic
        imperative data structures</para>
      </listitem>

      <listitem>
        <para>Discussing so-called benign effects like memoization and
        laziness</para>
      </listitem>

      <listitem>
        <para>Covering OCaml's API for blocking I/O</para>
      </listitem>

      <listitem>
        <para>Discussing how language-level issues like order of evaluation
        and weak polymorphism interact with OCaml's imperative features</para>
      </listitem>
    </itemizedlist>

    <para>The scope and sophistication of the material here is an indication
    of the importance of OCaml's imperative features. The fact that OCaml
    defaults to immutability shouldn't obscure the fact that imperative
    programming is a fundamental part of building any serious application, and
    that if you want to be an effective OCaml programmer, you need to
    understand OCaml's approach to imperative programming.<indexterm
    class="endofrange" startref="PROGimper"/></para>
  </sect1>
</chapter>
