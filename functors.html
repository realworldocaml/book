<html style="" lang="en" class="js flexbox fontface"><head><meta charset="utf-8"><meta content="width=device-width, initial-scale=1.0" name="viewport"><title>Functors - Real World OCaml</title><link href="css/app.css" rel="stylesheet"><link href="css/prism.css" rel="stylesheet"><script src="js/min/modernizr-min.js"></script><script src="js/prism.js"></script><script src="//use.typekit.net/gfj8wez.js"></script><script>try{Typekit.load();}catch(e){}</script></head><body><div class="title-bar"><div class="title"><h1>Real World OCaml</h1><h5>2<sup>nd</sup> Edition (in progress)</h5><nav><a href="index.html">Home</a><a href="toc.html">Table of Contents</a><a href="faqs.html">FAQs</a><a href="install.html">Install</a><a href="https://ocaml.janestreet.com/ocaml-core/">API Docs</a></nav></div></div><div class="wrap"><div class="left-column"><a class="to-chapter" href="toc.html"><small>Back</small><h5>Table of Contents</h5></a></div><article class="main-body"><section class="level1" id="functors">
<h1>Functors</h1>
<p>Up until now, we’ve seen OCaml’s modules play an important but limited role. In particular, we’ve seen them as a mechanism for organizing code into units with specified interfaces. But OCaml’s module system can do much more than that, serving as a powerful tool for building generic code and structuring large-scale systems. Much of that power comes from functors. <a data-secondary="benefits of" data-primary="functors" data-type="indexterm">&nbsp;</a></p>
<p>Functors are, roughly speaking, functions from modules to modules, and they can be used to solve a variety of code-structuring problems, including:</p>
<dl>
<dt>Dependency injection</dt>
<dd>Makes the implementations of some components of a system swappable. This is particularly useful when you want to mock up parts of your system for testing and simulation purposes.
</dd>
<dt>Autoextension of modules</dt>
<dd>Functors give you a way of extending existing modules with new functionality in a standardized way. For example, you might want to add a slew of comparison operators derived from a base comparison function. To do this by hand would require a lot of repetitive code for each type, but functors let you write this logic just once and apply it to many different types.
</dd>
<dt>Instantiating modules with state</dt>
<dd>Modules can contain mutable states, and that means that you’ll occasionally want to have multiple instantiations of a particular module, each with its own separate and independent mutable state. Functors let you automate the construction of such modules.
</dd>
</dl>
<p>These are really just some of the uses that you can put functors to. We’ll make no attempt to provide examples of all of the uses of functors here. Instead, this chapter will try to provide examples that illuminate the language features and design patterns that you need to master in order to use functors effectively.</p>
<section class="level2" id="a-trivial-example">
<h2>A Trivial Example</h2>
<p>Let’s create a functor that takes a module containing a single integer variable <code>x</code> and returns a new module with <code>x</code> incremented by one. This is intended to serve as a way to walk through the basic mechanics of functors, even though it’s not something you’d want to do in practice. <a data-secondary="basic mechanics of" data-primary="functors" data-type="indexterm">&nbsp;</a></p>
<p>First, let’s define a signature for a module that contains a single value of type <code>int</code>:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">open Base;;
module type X_int = sig val x : int end;;
&gt;module type X_int = sig val x : int end
</code></pre>
</div>
<p>Now we can define our functor. We’ll use <code>X_int</code> both to constrain the argument to the functor and to constrain the module returned by the functor:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">module Increment (M : X_int) : X_int = struct
  let x = M.x + 1
end
;;
&gt;module Increment : functor (M : X_int) -&gt; X_int
</code></pre>
</div>
<p>One thing that immediately jumps out is that functors are more syntactically heavyweight than ordinary functions. For one thing, functors require explicit (module) type annotations, which ordinary functions do not. Technically, only the type on the input is mandatory, although in practice, you should usually constrain the module returned by the functor, just as you should use an <code>mli</code>, even though it’s not mandatory.</p>
<p>The following shows what happens when we omit the module type for the output of the functor:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">module Increment (M : X_int) = struct
  let x = M.x + 1
end
;;
&gt;module Increment : functor (M : X_int) -&gt; sig val x : int end
</code></pre>
</div>
<p>We can see that the inferred module type of the output is now written out explicitly, rather than being a reference to the named signature <code>X_int</code>.</p>
<p>We can use <code>Increment</code> to define new modules:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">module Three = struct let x = 3 end;;
&gt;module Three : sig val x : int end
module Four = Increment(Three);;
&gt;module Four : sig val x : int end
Four.x - Three.x;;
&gt;- : int = 1
</code></pre>
</div>
<p>In this case, we applied <code>Increment</code> to a module whose signature is exactly equal to <code>X_int</code>. But we can apply <code>Increment</code> to any module that <em>satisfies</em> the interface <code>X_int</code>, in the same way that the contents of an <code>ml</code> file must satisfy the <code>mli</code>. That means that the module type can omit some information available in the module, either by dropping fields or by leaving some fields abstract. Here’s an example:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">module Three_and_more = struct
  let x = 3
  let y = "three"
end
;;
&gt;module Three_and_more : sig val x : int val y : string end
module Four = Increment(Three_and_more);;
&gt;module Four : sig val x : int end
</code></pre>
</div>
<p>The rules for determining whether a module matches a given signature are similar in spirit to the rules in an object-oriented language that determine whether an object satisfies a given interface. As in an object-oriented context, the extra information that doesn’t match the signature you’re looking for (in this case, the variable <code>y</code>) is simply ignored.</p>
</section>
<section class="level2" id="a-bigger-example-computing-with-intervals">
<h2>A Bigger Example: Computing with Intervals</h2>
<p>Let’s consider a more realistic example of how to use functors: a library for computing with intervals. Intervals are a common computational object, and they come up in different contexts and for different types. You might need to work with intervals of floating-point values or strings or times, and in each of these cases, you want similar operations: testing for emptiness, checking for containment, intersecting intervals, and so on.</p>
<p>Let’s see how to use functors to build a generic interval library that can be used with any type that supports a total ordering on the underlying set over which you want to build intervals. <a data-secondary="generic library for" data-primary="interval computation" data-type="indexterm">&nbsp;</a><a id="FUNCTinterv" data-secondary="interval computation with" data-primary="functors" data-type="indexterm">&nbsp;</a></p>
<p>First we’ll define a module type that captures the information we’ll need about the endpoints of the intervals. This interface, which we’ll call <code>Comparable</code>, contains just two things: a comparison function and the type of the values to be compared:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">module type Comparable = sig
  type t
  val compare : t -&gt; t -&gt; int
end
;;
&gt;module type Comparable = sig type t val compare : t -&gt; t -&gt; int end
</code></pre>
</div>
<p>The comparison function follows the standard OCaml idiom for such functions, returning <code>0</code> if the two elements are equal, a positive number if the first element is larger than the second, and a negative number if the first element is smaller than the second. Thus, we could rewrite the standard comparison functions on top of <code>compare</code>.</p>
<div class="highlight">
<pre><code class="language-ocaml">compare x y &lt; 0     (* x &lt; y *)
compare x y = 0     (* x = y *)
compare x y &gt; 0     (* x &gt; y *)</code></pre>
</div>
<p>(This idiom is a bit of a historical error. It would be better if <code>compare</code> returned a variant with three cases for less than, greater than, and equal. But it’s a well-established idiom at this point, and unlikely to change.)</p>
<p>The functor for creating the interval module follows. We represent an interval with a variant type, which is either <code>Empty</code> or <code>Interval (x,y)</code>, where <code>x</code> and <code>y</code> are the bounds of the interval. In addition to the type, the body of the functor contains implementations of a number of useful primitives for interacting with intervals:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">module Make_interval(Endpoint : Comparable) = struct

  type t = | Interval of Endpoint.t * Endpoint.t
           | Empty

  (** [create low high] creates a new interval from [low] to
      [high].  If [low &gt; high], then the interval is empty *)
  let create low high =
    if Endpoint.compare low high &gt; 0 then Empty
    else Interval (low,high)

  (** Returns true iff the interval is empty *)
  let is_empty = function
    | Empty -&gt; true
    | Interval _ -&gt; false

  (** [contains t x] returns true iff [x] is contained in the
      interval [t] *)
  let contains t x =
    match t with
    | Empty -&gt; false
    | Interval (l,h) -&gt;
      Endpoint.compare x l &gt;= 0 &amp;&amp; Endpoint.compare x h &lt;= 0

  (** [intersect t1 t2] returns the intersection of the two input
      intervals *)
  let intersect t1 t2 =
    let min x y = if Endpoint.compare x y &lt;= 0 then x else y in
    let max x y = if Endpoint.compare x y &gt;= 0 then x else y in
    match t1,t2 with
    | Empty, _ | _, Empty -&gt; Empty
    | Interval (l1,h1), Interval (l2,h2) -&gt;
      create (max l1 l2) (min h1 h2)

end
;;
&gt;module Make_interval :
&gt;  functor (Endpoint : Comparable) -&gt;
&gt;    sig
&gt;      type t = Interval of Endpoint.t * Endpoint.t | Empty
&gt;      val create : Endpoint.t -&gt; Endpoint.t -&gt; t
&gt;      val is_empty : t -&gt; bool
&gt;      val contains : t -&gt; Endpoint.t -&gt; bool
&gt;      val intersect : t -&gt; t -&gt; t
&gt;    end
</code></pre>
</div>
<p>We can instantiate the functor by applying it to a module with the right signature. In the following code, rather than name the module first and then call the functor, we provide the functor input as an anonymous module:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">module Int_interval =
  Make_interval(struct
    type t = int
    let compare = Int.compare
end)
;;
&gt;module Int_interval :
&gt;  sig
&gt;    type t = Interval of int * int | Empty
&gt;    val create : int -&gt; int -&gt; t
&gt;    val is_empty : t -&gt; bool
&gt;    val contains : t -&gt; int -&gt; bool
&gt;    val intersect : t -&gt; t -&gt; t
&gt;  end
</code></pre>
</div>
<p>If the input interface for your functor is aligned with the standards of the libraries you use, then you don’t need to construct a custom module to feed to the functor. In this case, we can directly use the <code>Int</code> or <code>String</code> modules provided by <code>Base</code>:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">module Int_interval = Make_interval(Int);;
&gt;module Int_interval :
&gt;  sig
&gt;    type t = Make_interval(Base.Int).t = Interval of int * int | Empty
&gt;    val create : int -&gt; int -&gt; t
&gt;    val is_empty : t -&gt; bool
&gt;    val contains : t -&gt; int -&gt; bool
&gt;    val intersect : t -&gt; t -&gt; t
&gt;  end
module String_interval = Make_interval(String);;
&gt;module String_interval :
&gt;  sig
&gt;    type t =
&gt;      Make_interval(Base.String).t =
&gt;        Interval of string * string
&gt;      | Empty
&gt;    val create : string -&gt; string -&gt; t
&gt;    val is_empty : t -&gt; bool
&gt;    val contains : t -&gt; string -&gt; bool
&gt;    val intersect : t -&gt; t -&gt; t
&gt;  end
</code></pre>
</div>
<p>This works because many modules in Base, including <code>Int</code> and <code>String</code>, satisfy an extended version of the <code>Comparable</code> signature described previously. Such standardized signatures are good practice, both because they make functors easier to use, and because they encourage standardization that makes your codebase easier to navigate.</p>
<p>We can use the newly defined <code>Int_interval</code> module like any ordinary module:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let i1 = Int_interval.create 3 8;;
&gt;val i1 : Int_interval.t = Int_interval.Interval (3, 8)
let i2 = Int_interval.create 4 10;;
&gt;val i2 : Int_interval.t = Int_interval.Interval (4, 10)
Int_interval.intersect i1 i2;;
&gt;- : Int_interval.t = Int_interval.Interval (4, 8)
</code></pre>
</div>
<p>This design gives us the freedom to use any comparison function we want for comparing the endpoints. We could, for example, create a type of integer interval with the order of the comparison reversed, as follows:<a data-secondary="comparison function for" data-primary="interval computation" data-type="indexterm">&nbsp;</a></p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">module Rev_int_interval =
  Make_interval(struct
    type t = int
    let compare x y = Int.compare y x
end)
;;
&gt;module Rev_int_interval :
&gt;  sig
&gt;    type t = Interval of int * int | Empty
&gt;    val create : int -&gt; int -&gt; t
&gt;    val is_empty : t -&gt; bool
&gt;    val contains : t -&gt; int -&gt; bool
&gt;    val intersect : t -&gt; t -&gt; t
&gt;  end
</code></pre>
</div>
<p>The behavior of <code>Rev_int_interval</code> is of course different from <code>Int_interval</code>:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">let interval = Int_interval.create 4 3;;
&gt;val interval : Int_interval.t = Int_interval.Empty
let rev_interval = Rev_int_interval.create 4 3;;
&gt;val rev_interval : Rev_int_interval.t = Rev_int_interval.Interval (4, 3)
</code></pre>
</div>
<p>Importantly, <code>Rev_int_interval.t</code> is a different type than <code>Int_interval.t</code>, even though its physical representation is the same. Indeed, the type system will prevent us from confusing them.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Int_interval.contains rev_interval 3;;
&gt;Line 1, characters 23-35:
&gt;Error: This expression has type Rev_int_interval.t
&gt;       but an expression was expected of type Int_interval.t
</code></pre>
</div>
<p>This is important, because confusing the two kinds of intervals would be a semantic error, and it’s an easy one to make. The ability of functors to mint new types is a useful trick that comes up a lot.</p>
<section class="level3" id="making-the-functor-abstract">
<h3>Making the Functor Abstract</h3>
<p>There’s a problem with <code>Make_interval</code>. The code we wrote depends on the invariant that the upper bound of an interval is greater than its lower bound, but that invariant can be violated. The invariant is enforced by the <code>create</code> function, but because <code>Interval.t</code> is not abstract, we can bypass the <code>create</code> function:<a data-secondary="abstract functor for" data-primary="interval computation" data-type="indexterm">&nbsp;</a></p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Int_interval.is_empty (* going through create *)
(Int_interval.create 4 3)
;;
&gt;- : bool = true
Int_interval.is_empty (* bypassing create *)
(Int_interval.Interval (4,3))
;;
&gt;- : bool = false
</code></pre>
</div>
<p>To make <code>Int_interval.t</code> abstract, we need to restrict the output of <code>Make_interval</code> with an interface. Here’s an explicit interface that we can use for that purpose:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">module type Interval_intf = sig
  type t
  type endpoint
  val create : endpoint -&gt; endpoint -&gt; t
  val is_empty : t -&gt; bool
  val contains : t -&gt; endpoint -&gt; bool
  val intersect : t -&gt; t -&gt; t
end
;;
&gt;module type Interval_intf =
&gt;  sig
&gt;    type t
&gt;    type endpoint
&gt;    val create : endpoint -&gt; endpoint -&gt; t
&gt;    val is_empty : t -&gt; bool
&gt;    val contains : t -&gt; endpoint -&gt; bool
&gt;    val intersect : t -&gt; t -&gt; t
&gt;  end
</code></pre>
</div>
<p>This interface includes the type <code>endpoint</code> to give us a way of referring to the endpoint type. Given this interface, we can redo our definition of <code>Make_interval</code>. Notice that we added the type <code>endpoint</code> to the implementation of the module to match <code>Interval_intf</code>:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">module Make_interval(Endpoint : Comparable) : Interval_intf = struct
  type endpoint = Endpoint.t
  type t = | Interval of Endpoint.t * Endpoint.t
           | Empty

  (* CR: avoid this duplication *)

  (** [create low high] creates a new interval from [low] to
      [high].  If [low &gt; high], then the interval is empty *)
  let create low high =
    if Endpoint.compare low high &gt; 0 then Empty
    else Interval (low,high)

  (** Returns true iff the interval is empty *)
  let is_empty = function
    | Empty -&gt; true
    | Interval _ -&gt; false

  (** [contains t x] returns true iff [x] is contained in the
      interval [t] *)
  let contains t x =
    match t with
    | Empty -&gt; false
    | Interval (l,h) -&gt;
      Endpoint.compare x l &gt;= 0 &amp;&amp; Endpoint.compare x h &lt;= 0

  (** [intersect t1 t2] returns the intersection of the two input
      intervals *)
  let intersect t1 t2 =
    let min x y = if Endpoint.compare x y &lt;= 0 then x else y in
    let max x y = if Endpoint.compare x y &gt;= 0 then x else y in
    match t1,t2 with
    | Empty, _ | _, Empty -&gt; Empty
    | Interval (l1,h1), Interval (l2,h2) -&gt;
      create (max l1 l2) (min h1 h2)

end
;;
&gt;module Make_interval : functor (Endpoint : Comparable) -&gt; Interval_intf
</code></pre>
</div>
</section>
<section class="level3" id="sharing-constraints">
<h3>Sharing Constraints</h3>
<p>The resulting module is abstract, but it’s unfortunately too abstract. In particular, we haven’t exposed the type <code>endpoint</code>, which means that we can’t even construct an interval anymore: <a data-primary="sharing constraint" data-type="indexterm">&nbsp;</a></p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">module Int_interval = Make_interval(Int);;
&gt;module Int_interval :
&gt;  sig
&gt;    type t = Make_interval(Base.Int).t
&gt;    type endpoint = Make_interval(Base.Int).endpoint
&gt;    val create : endpoint -&gt; endpoint -&gt; t
&gt;    val is_empty : t -&gt; bool
&gt;    val contains : t -&gt; endpoint -&gt; bool
&gt;    val intersect : t -&gt; t -&gt; t
&gt;  end
Int_interval.create 3 4;;
&gt;Line 1, characters 21-22:
&gt;Error: This expression has type int but an expression was expected of type
&gt;         Int_interval.endpoint
</code></pre>
</div>
<p>To fix this, we need to expose the fact that <code>endpoint</code> is equal to <code>Int.t</code> (or more generally, <code>Endpoint.t</code>, where <code>Endpoint</code> is the argument to the functor). One way of doing this is through a <em>sharing constraint</em>, which allows you to tell the compiler to expose the fact that a given type is equal to some other type. The syntax for a simple sharing constraint is as follows:</p>
<div class="highlight">
<pre><code class="language-clike">&lt;Module_type&gt; with type &lt;type&gt; = &lt;type'&gt;</code></pre>
</div>
<p>The result of this expression is a new signature that’s been modified so that it exposes the fact that <em><code>type</code></em> defined inside of the module type is equal to <em><code>type'</code></em> whose definition is outside of it. One can also apply multiple sharing constraints to the same signature:</p>
<div class="highlight">
<pre><code class="language-clike">&lt;Module_type&gt; with type &lt;type1&gt; = &lt;type1'&gt; and type &lt;type2&gt; = &lt;type2'&gt;</code></pre>
</div>
<p>We can use a sharing constraint to create a specialized version of <code>Interval_intf</code> for integer intervals:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">module type Int_interval_intf =
Interval_intf with type endpoint = int
;;
&gt;module type Int_interval_intf =
&gt;  sig
&gt;    type t
&gt;    type endpoint = int
&gt;    val create : endpoint -&gt; endpoint -&gt; t
&gt;    val is_empty : t -&gt; bool
&gt;    val contains : t -&gt; endpoint -&gt; bool
&gt;    val intersect : t -&gt; t -&gt; t
&gt;  end
</code></pre>
</div>
<p>We can also use sharing constraints in the context of a functor. The most common use case is where you want to expose that some of the types of the module being generated by the functor are related to the types in the module fed to the functor.</p>
<p>In this case, we’d like to expose an equality between the type <code>endpoint</code> in the new module and the type <code>Endpoint.t</code>, from the module <code>Endpoint</code> that is the functor argument. We can do this as follows:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">module Make_interval(Endpoint : Comparable)
  : (Interval_intf with type endpoint = Endpoint.t)
= struct

  type endpoint = Endpoint.t
  type t = | Interval of Endpoint.t * Endpoint.t
           | Empty

  (** [create low high] creates a new interval from [low] to
      [high].  If [low &gt; high], then the interval is empty *)
  let create low high =
    if Endpoint.compare low high &gt; 0 then Empty
    else Interval (low,high)

  (** Returns true iff the interval is empty *)
  let is_empty = function
    | Empty -&gt; true
    | Interval _ -&gt; false

  (** [contains t x] returns true iff [x] is contained in the
      interval [t] *)
  let contains t x =
    match t with
    | Empty -&gt; false
    | Interval (l,h) -&gt;
      Endpoint.compare x l &gt;= 0 &amp;&amp; Endpoint.compare x h &lt;= 0

  (** [intersect t1 t2] returns the intersection of the two input
      intervals *)
  let intersect t1 t2 =
    let min x y = if Endpoint.compare x y &lt;= 0 then x else y in
    let max x y = if Endpoint.compare x y &gt;= 0 then x else y in
    match t1,t2 with
    | Empty, _ | _, Empty -&gt; Empty
    | Interval (l1,h1), Interval (l2,h2) -&gt;
      create (max l1 l2) (min h1 h2)

end
;;
&gt;module Make_interval :
&gt;  functor (Endpoint : Comparable) -&gt;
&gt;    sig
&gt;      type t
&gt;      type endpoint = Endpoint.t
&gt;      val create : endpoint -&gt; endpoint -&gt; t
&gt;      val is_empty : t -&gt; bool
&gt;      val contains : t -&gt; endpoint -&gt; bool
&gt;      val intersect : t -&gt; t -&gt; t
&gt;    end
</code></pre>
</div>
<p>So now, the interface is as it was, except that <code>endpoint</code> is known to be equal to <code>Endpoint.t</code>. As a result of that type equality, we can again do things that require that <code>endpoint</code> be exposed, like constructing intervals:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">module Int_interval = Make_interval(Int);;
&gt;module Int_interval :
&gt;  sig
&gt;    type t = Make_interval(Base.Int).t
&gt;    type endpoint = int
&gt;    val create : endpoint -&gt; endpoint -&gt; t
&gt;    val is_empty : t -&gt; bool
&gt;    val contains : t -&gt; endpoint -&gt; bool
&gt;    val intersect : t -&gt; t -&gt; t
&gt;  end
let i = Int_interval.create 3 4;;
&gt;val i : Int_interval.t = &lt;abstr&gt;
Int_interval.contains i 5;;
&gt;- : bool = false
</code></pre>
</div>
</section>
<section class="level3" id="destructive-substitution">
<h3>Destructive Substitution</h3>
<p>Sharing constraints basically do the job, but they have some downsides. In particular, we’ve now been stuck with the useless type declaration of <code>endpoint</code> that clutters up both the interface and the implementation. A better solution would be to modify the <code>Interval_intf</code> signature by replacing <code>endpoint</code> with <code>Endpoint.t</code> everywhere it shows up, and deleting the definition of <code>endpoint</code> from the signature. We can do just this using what’s called <em>destructive substitution</em>. Here’s the basic syntax:<a data-primary="destructive substitution" data-type="indexterm">&nbsp;</a><a data-secondary="destructive substitution" data-primary="interval computation" data-type="indexterm">&nbsp;</a></p>
<div class="highlight">
<pre><code class="language-clike">&lt;Module_type&gt; with type &lt;type&gt; := &lt;type'&gt;</code></pre>
</div>
<p>This looks just like a sharing constraint, except that we use <code>:=</code> instead of <code>=</code>. The following shows how we could use this with <code>Make_interval</code>.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">module type Int_interval_intf =
Interval_intf with type endpoint := int
;;
&gt;module type Int_interval_intf =
&gt;  sig
&gt;    type t
&gt;    val create : int -&gt; int -&gt; t
&gt;    val is_empty : t -&gt; bool
&gt;    val contains : t -&gt; int -&gt; bool
&gt;    val intersect : t -&gt; t -&gt; t
&gt;  end
</code></pre>
</div>
<p>There’s now no <code>endpoint</code> type: all of its occurrences of have been replaced by <code>int</code>. As with sharing constraints, we can also use this in the context of a functor:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">(* Suspicious # ? *)
module Make_interval(Endpoint : Comparable)
  : Interval_intf with type endpoint := Endpoint.t =
struct

  type t = | Interval of Endpoint.t * Endpoint.t
           | Empty

  (** [create low high] creates a new interval from [low] to
      [high].  If [low &gt; high], then the interval is empty *)
  let create low high =
    if Endpoint.compare low high &gt; 0 then Empty
    else Interval (low,high)

  (** Returns true iff the interval is empty *)
  let is_empty = function
    | Empty -&gt; true
    | Interval _ -&gt; false

  (** [contains t x] returns true iff [x] is contained in the
      interval [t] *)
  let contains t x =
    match t with
    | Empty -&gt; false
    | Interval (l,h) -&gt;
      Endpoint.compare x l &gt;= 0 &amp;&amp; Endpoint.compare x h &lt;= 0

  (** [intersect t1 t2] returns the intersection of the two input
      intervals *)
  let intersect t1 t2 =
    let min x y = if Endpoint.compare x y &lt;= 0 then x else y in
    let max x y = if Endpoint.compare x y &gt;= 0 then x else y in
    match t1,t2 with
    | Empty, _ | _, Empty -&gt; Empty
    | Interval (l1,h1), Interval (l2,h2) -&gt;
      create (max l1 l2) (min h1 h2)

end
;;
&gt;module Make_interval :
&gt;  functor (Endpoint : Comparable) -&gt;
&gt;    sig
&gt;      type t
&gt;      val create : Endpoint.t -&gt; Endpoint.t -&gt; t
&gt;      val is_empty : t -&gt; bool
&gt;      val contains : t -&gt; Endpoint.t -&gt; bool
&gt;      val intersect : t -&gt; t -&gt; t
&gt;    end
</code></pre>
</div>
<p>The interface is precisely what we want: the type <code>t</code> is abstract, and the type of the endpoint is exposed; so we can create values of type <code>Int_interval.t</code> using the creation function, but not directly using the constructors and thereby violating the invariants of the module:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">module Int_interval = Make_interval(Int);;
&gt;module Int_interval :
&gt;  sig
&gt;    type t = Make_interval(Base.Int).t
&gt;    val create : int -&gt; int -&gt; t
&gt;    val is_empty : t -&gt; bool
&gt;    val contains : t -&gt; int -&gt; bool
&gt;    val intersect : t -&gt; t -&gt; t
&gt;  end
Int_interval.is_empty
(Int_interval.create 3 4)
;;
&gt;- : bool = false
Int_interval.is_empty (Int_interval.Interval (4,3));;
&gt;Line 1, characters 24-45:
&gt;Error: Unbound constructor Int_interval.Interval
</code></pre>
</div>
<p>In addition, the <code>endpoint</code> type is gone from the interface, meaning we no longer need to define the <code>endpoint</code> type alias in the body of the module.</p>
<p>It’s worth noting that the name is somewhat misleading, in that there’s nothing destructive about destructive substitution; it’s really just a way of creating a new signature by transforming an existing one.</p>
</section>
<section class="level3" id="using-multiple-interfaces">
<h3>Using Multiple Interfaces</h3>
<p>Another feature that we might want for our interval module is the ability to <em>serialize</em>, i.e., to be able to read and write intervals as a stream of bytes. In this case, we’ll do this by converting to and from s-expressions, which were mentioned already in <a data-type="xref" href="error-handling.html#error-handling">Chapter 7, Error Handling</a>. To recall, an s-expression is essentially a parenthesized expression whose atoms are strings, and it is a serialization format that is used commonly in <code>Base</code>. Here’s an example: <a data-secondary="example of" data-primary="s-expressions" data-type="indexterm">&nbsp;</a><a data-secondary="multiple interfaces and" data-primary="interval computation" data-type="indexterm">&nbsp;</a></p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">Sexp.List [ Sexp.Atom "This"; Sexp.Atom "is"
; Sexp.List [Sexp.Atom "an"; Sexp.Atom "s-expression"]]
;;
&gt;- : Sexp.t = (This is (an s-expression))
</code></pre>
</div>
<p><code>Base</code> is designed to work well with a syntax extension called <code>ppx_sexp_conv</code> which will generate s-expression conversion functions for any type annotated with <code>[@@deriving sexp]</code>. We can enable <code>ppx_sexp_conv</code> along with a collection of other useful extensions by enabling <code>ppx_jane</code>:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">#require "ppx_jane";;
</code></pre>
</div>
<p>Now, we can use the deriving annotation to create sexp-converters for a given type.</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">type some_type = int * string list [@@deriving sexp];;
&gt;type some_type = int * string list
&gt;val some_type_of_sexp : Sexp.t -&gt; some_type = &lt;fun&gt;
&gt;val sexp_of_some_type : some_type -&gt; Sexp.t = &lt;fun&gt;
sexp_of_some_type (33, ["one"; "two"]);;
&gt;- : Sexp.t = (33 (one two))
Core_kernel.Sexp.of_string "(44 (five six))" |&gt; some_type_of_sexp;;
&gt;- : some_type = (44, ["five"; "six"])
</code></pre>
</div>
<p>We’ll discuss s-expressions and Sexplib in more detail in <a data-type="xref" href="data-serialization.html#data-serialization-with-s-expressions">Chapter 18, Data Serialization With S Expressions</a>, but for now, let’s see what happens if we attach the <code>[@@deriving sexp]</code> declaration to the definition of <code>t</code> within the functor:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">module Make_interval(Endpoint : Comparable)
  : (Interval_intf with type endpoint := Endpoint.t) = struct

  type t = | Interval of Endpoint.t * Endpoint.t
           | Empty
  [@@deriving sexp]

  (** [create low high] creates a new interval from [low] to
      [high].  If [low &gt; high], then the interval is empty *)
  let create low high =
    if Endpoint.compare low high &gt; 0 then Empty
    else Interval (low,high)

  (** Returns true iff the interval is empty *)
  let is_empty = function
    | Empty -&gt; true
    | Interval _ -&gt; false

  (** [contains t x] returns true iff [x] is contained in the
      interval [t] *)
  let contains t x =
    match t with
    | Empty -&gt; false
    | Interval (l,h) -&gt;
      Endpoint.compare x l &gt;= 0 &amp;&amp; Endpoint.compare x h &lt;= 0

  (** [intersect t1 t2] returns the intersection of the two input
      intervals *)
  let intersect t1 t2 =
    let min x y = if Endpoint.compare x y &lt;= 0 then x else y in
    let max x y = if Endpoint.compare x y &gt;= 0 then x else y in
    match t1,t2 with
    | Empty, _ | _, Empty -&gt; Empty
    | Interval (l1,h1), Interval (l2,h2) -&gt;
      create (max l1 l2) (min h1 h2)

end
;;
&gt;Line 4, characters 28-38:
&gt;Error: Unbound value Endpoint.t_of_sexp
</code></pre>
</div>
<p>The problem is that <code>[@@deriving sexp]</code> adds code for defining the s-expression converters, and that code assumes that <code>Endpoint</code> has the appropriate sexp-conversion functions for <code>Endpoint.t</code>. But all we know about <code>Endpoint</code> is that it satisfies the <code>Comparable</code> interface, which doesn’t say anything about s-expressions.</p>
<p>Happily, <code>Base</code> comes with a built-in interface for just this purpose called <code>Sexpable</code>, which is defined as follows:</p>
<div class="highlight">
<pre><code class="language-ocaml">module type Sexpable = sig
  type t
  val sexp_of_t : t -&gt; Sexp.t
  val t_of_sexp : Sexp.t -&gt; t
end</code></pre>
</div>
<p>We can modify <code>Make_interval</code> to use the <code>Sexpable</code> interface, for both its input and its output. First, let’s create an extended version of the <code>Interval_intf</code> interface that includes the functions from the <code>Sexpable</code> interface. We can do this using destructive substitution on the <code>Sexpable</code> interface, to avoid having multiple distinct type <code>t</code>’s clashing with each other:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">module type Interval_intf_with_sexp = sig
  include Interval_intf
  include Core_kernel.Sexpable with type t := t
end
;;
&gt;module type Interval_intf_with_sexp =
&gt;  sig
&gt;    type t
&gt;    type endpoint
&gt;    val create : endpoint -&gt; endpoint -&gt; t
&gt;    val is_empty : t -&gt; bool
&gt;    val contains : t -&gt; endpoint -&gt; bool
&gt;    val intersect : t -&gt; t -&gt; t
&gt;    val t_of_sexp : Sexp.t -&gt; t
&gt;    val sexp_of_t : t -&gt; Sexp.t
&gt;  end
</code></pre>
</div>
<p>Equivalently, we can define a type <code>t</code> within our new module, and apply destructive substitutions to all of the included interfaces, <code>Interval_intf</code> included, as shown in the following example. This is somewhat cleaner when combining multiple interfaces, since it correctly reflects that all of the signatures are being handled equivalently:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">module type Interval_intf_with_sexp = sig
  type t
  include Interval_intf with type t := t
  include Core_kernel.Sexpable      with type t := t
end
;;
&gt;module type Interval_intf_with_sexp =
&gt;  sig
&gt;    type t
&gt;    type endpoint
&gt;    val create : endpoint -&gt; endpoint -&gt; t
&gt;    val is_empty : t -&gt; bool
&gt;    val contains : t -&gt; endpoint -&gt; bool
&gt;    val intersect : t -&gt; t -&gt; t
&gt;    val t_of_sexp : Sexp.t -&gt; t
&gt;    val sexp_of_t : t -&gt; Sexp.t
&gt;  end
</code></pre>
</div>
<p>Now we can write the functor itself. We have been careful to override the sexp converter here to ensure that the data structure’s invariants are still maintained when reading in from an s-expression:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">module Make_interval(Endpoint : sig
    type t
    include Comparable with type t := t
    include Core_kernel.Sexpable with type t := t
  end)
  : (Interval_intf_with_sexp with type endpoint := Endpoint.t)
= struct

  type t = | Interval of Endpoint.t * Endpoint.t
           | Empty
  [@@deriving sexp]

  (** [create low high] creates a new interval from [low] to
      [high].  If [low &gt; high], then the interval is empty *)
  let create low high =
    if Endpoint.compare low high &gt; 0 then Empty
    else Interval (low,high)

  (* put a wrapper around the autogenerated [t_of_sexp] to enforce
     the invariants of the data structure *)
  let t_of_sexp sexp =
    match t_of_sexp sexp with
    | Empty -&gt; Empty
    | Interval (x,y) -&gt; create x y

  (** Returns true iff the interval is empty *)
  let is_empty = function
    | Empty -&gt; true
    | Interval _ -&gt; false

  (** [contains t x] returns true iff [x] is contained in the
      interval [t] *)
  let contains t x =
    match t with
    | Empty -&gt; false
    | Interval (l,h) -&gt;
      Endpoint.compare x l &gt;= 0 &amp;&amp; Endpoint.compare x h &lt;= 0

  (** [intersect t1 t2] returns the intersection of the two input
      intervals *)
  let intersect t1 t2 =
    let min x y = if Endpoint.compare x y &lt;= 0 then x else y in
    let max x y = if Endpoint.compare x y &gt;= 0 then x else y in
    match t1,t2 with
    | Empty, _ | _, Empty -&gt; Empty
    | Interval (l1,h1), Interval (l2,h2) -&gt;
      create (max l1 l2) (min h1 h2)
end
;;
&gt;module Make_interval :
&gt;  functor
&gt;    (Endpoint : sig
&gt;                  type t
&gt;                  val compare : t -&gt; t -&gt; int
&gt;                  val t_of_sexp : Sexp.t -&gt; t
&gt;                  val sexp_of_t : t -&gt; Sexp.t
&gt;                end)
&gt;    -&gt;
&gt;    sig
&gt;      type t
&gt;      val create : Endpoint.t -&gt; Endpoint.t -&gt; t
&gt;      val is_empty : t -&gt; bool
&gt;      val contains : t -&gt; Endpoint.t -&gt; bool
&gt;      val intersect : t -&gt; t -&gt; t
&gt;      val t_of_sexp : Sexp.t -&gt; t
&gt;      val sexp_of_t : t -&gt; Sexp.t
&gt;    end
</code></pre>
</div>
<p>And now, we can use that sexp converter in the ordinary way:</p>
<div class="highlight">
<pre data-filter-output=">" data-prompt="#" class="command-line"><code class="language-ocaml">module Int_interval = Make_interval(Int);;
&gt;module Int_interval :
&gt;  sig
&gt;    type t = Make_interval(Base.Int).t
&gt;    val create : int -&gt; int -&gt; t
&gt;    val is_empty : t -&gt; bool
&gt;    val contains : t -&gt; int -&gt; bool
&gt;    val intersect : t -&gt; t -&gt; t
&gt;    val t_of_sexp : Sexp.t -&gt; t
&gt;    val sexp_of_t : t -&gt; Sexp.t
&gt;  end
Int_interval.sexp_of_t (Int_interval.create 3 4);;
&gt;- : Sexp.t = (Interval 3 4)
Int_interval.sexp_of_t (Int_interval.create 4 3);;
&gt;- : Sexp.t = Empty
</code></pre>
</div>
</section>
</section>
<section class="level2" id="extending-modules">
<h2>Extending Modules</h2>
<p>Another common use of functors is to generate type-specific functionality for a given module in a standardized way. Let’s see how this works in the context of a functional queue, which is just a functional version of a FIFO (first-in, first-out) queue. Being functional, operations on the queue return new queues, rather than modifying the queues that were passed in.<a data-secondary="type-specific functionality in" data-primary="modules" data-type="indexterm">&nbsp;</a><a data-primary="FIFO (first-in, first-out) queue" data-type="indexterm">&nbsp;</a><a data-secondary="module extension with" data-primary="functors" data-type="indexterm">&nbsp;</a></p>
<p>Here’s a reasonable <code>mli</code> for such a module:</p>
<div class="highlight">
<pre><code class="language-ocaml">type 'a t

val empty : 'a t

(** [enqueue q el] adds [el] to the back of [q] *)
val enqueue : 'a t -&gt; 'a -&gt; 'a t

(** [dequeue q] returns None if the [q] is empty, otherwise returns
    the first element of the queue and the remainder of the queue *)
val dequeue : 'a t -&gt; ('a * 'a t) option

(** Folds over the queue, from front to back *)
val fold : 'a t -&gt; init:'acc -&gt; f:('acc -&gt; 'a -&gt; 'acc) -&gt; 'acc</code></pre>
</div>
<p>The preceding <code>Fqueue.fold</code> function requires some explanation. It follows the same pattern as the <code>List.fold</code> function we described in <a data-type="xref" href="lists-and-patterns.html#using-the-list-module-effectively">Chapter 3, Using The List Module Effectively</a>. Essentially, <code>Fqueue.fold q ~init ~f</code> walks over the elements of <code>q</code> from front to back, starting with an accumulator of <code>init</code> and using <code>f</code> to update the accumulator value as it walks over the queue, returning the final value of the accumulator at the end of the computation. <code>fold</code> is a quite powerful operation, as we’ll see.</p>
<p>We’ll implement <code>Fqueue</code> using the well known trick of maintaining an input and an output list so that one can both efficiently enqueue on the input list and dequeue from the output list. If you attempt to dequeue when the output list is empty, the input list is reversed and becomes the new output list. Here’s the implementation:</p>
<div class="highlight">
<pre><code class="language-ocaml">open Base

type 'a t = 'a list * 'a list

let empty = ([],[])

let enqueue (in_list, out_list) x =
  (x :: in_list,out_list)

let dequeue (in_list, out_list) =
  match out_list with
  | hd :: tl -&gt; Some (hd, (in_list, tl))
  | [] -&gt;
    match List.rev in_list with
    | [] -&gt; None
    | hd :: tl -&gt; Some (hd, ([], tl))

let fold (in_list, out_list) ~init ~f =
  let after_out = List.fold ~init ~f out_list in
  List.fold_right ~init:after_out ~f:(fun x acc -&gt; f acc x) in_list</code></pre>
</div>
<p>One problem with <code>Fqueue</code> is that the interface is quite skeletal. There are lots of useful helper functions that one might want that aren’t there. The <code>List</code> module, by way of contrast, has functions like <code>List.iter</code>, which runs a function on each element; and <code>List.for_all</code>, which returns true if and only if the given predicate evaluates to <code>true</code> on every element of the list. Such helper functions come up for pretty much every container type, and implementing them over and over is a dull and repetitive affair.</p>
<p>As it happens, many of these helper functions can be derived mechanically from the <code>fold</code> function we already implemented. Rather than write all of these helper functions by hand for every new container type, we can instead use a functor to add this functionality to any container that has a <code>fold</code> function.</p>
<p>We’ll create a new module, <code>Foldable</code>, that automates the process of adding helper functions to a <code>fold</code>-supporting container. As you can see, <code>Foldable</code> contains a module signature <code>S</code> which defines the signature that is required to support folding; and a functor <code>Extend</code> that allows one to extend any module that matches <code>Foldable.S</code>:</p>
<div class="highlight">
<pre><code class="language-ocaml">open Base

module type S = sig
  type 'a t
  val fold : 'a t -&gt; init:'acc -&gt; f:('acc -&gt; 'a -&gt; 'acc) -&gt; 'acc
end

module type Extension = sig
  type 'a t
  val iter    : 'a t -&gt; f:('a -&gt; unit) -&gt; unit
  val length  : 'a t -&gt; int
  val count   : 'a t -&gt; f:('a -&gt; bool) -&gt; int
  val for_all : 'a t -&gt; f:('a -&gt; bool) -&gt; bool
  val exists  : 'a t -&gt; f:('a -&gt; bool) -&gt; bool
end

(* For extending a Foldable module *)
module Extend(Arg : S)
  : (Extension with type 'a t := 'a Arg.t) =
struct
  open Arg

  let iter t ~f =
    fold t ~init:() ~f:(fun () a -&gt; f a)

  let length t =
    fold t ~init:0  ~f:(fun acc _ -&gt; acc + 1)

  let count t ~f =
    fold t ~init:0  ~f:(fun count x -&gt; count + if f x then 1 else 0)

  exception Short_circuit

  let for_all c ~f =
    try iter c ~f:(fun x -&gt; if not (f x) then raise Short_circuit); true
    with Short_circuit -&gt; false

  let exists c ~f =
    try iter c ~f:(fun x -&gt; if f x then raise Short_circuit); false
    with Short_circuit -&gt; true
end</code></pre>
</div>
<p>Now we can apply this to <code>Fqueue</code>. We can create an interface for an extended version of <code>Fqueue</code> as follows:</p>
<div class="highlight">
<pre><code class="language-ocaml">type 'a t
include (module type of Fqueue) with type 'a t := 'a t
include Foldable.Extension with type 'a t := 'a t</code></pre>
</div>
<p>In order to apply the functor, we’ll put the definition of <code>Fqueue</code> in a submodule called <code>T</code>, and then call <code>Foldable.Extend</code> on <code>T</code>:</p>
<div class="highlight">
<pre><code class="language-ocaml">include Fqueue
include Foldable.Extend(Fqueue)</code></pre>
</div>
<p><code>Base</code> comes with a number of functors for extending modules that follow this same basic pattern, including: <a data-primary="Monad.Make" data-type="indexterm">&nbsp;</a><a data-primary="Hashable.Make" data-type="indexterm">&nbsp;</a><a data-secondary="Comparable.Make" data-primary="Comparable module" data-type="indexterm">&nbsp;</a><a data-primary="Container.Make" data-type="indexterm">&nbsp;</a></p>
<dl>
<dt><code>Container.Make</code></dt>
<dd>Very similar to <code>Foldable.Extend</code>.
</dd>
<dt><code>Comparable.Make</code></dt>
<dd>Adds support for functionality that depends on the presence of a comparison function, including support for containers like maps and sets.
</dd>
<dt><code>Hashable.Make</code></dt>
<dd>Adds support for hashing-based data structures including hash tables, hash sets, and hash heaps.
</dd>
<dt><code>Monad.Make</code></dt>
<dd>For so-called monadic libraries, like those discussed in Chapters <a data-xrefstyle="select:   labelnumber" data-type="xref" href="error-handling.html#error-handling">Chapter 7, Error Handling</a> and <a data-xrefstyle="select:   labelnumber" data-type="xref" href="concurrent-programming.html#concurrent-programming-with-async">Chapter 15, Concurrent Programming With Async</a>. Here, the functor is used to provide a collection of standard helper functions based on the <code>bind</code> and <code>return</code> operators.
</dd>
</dl>
<p>These functors come in handy when you want to add the same kind of functionality that is commonly available in <code>Base</code> to your own types.</p>
<p>We’ve really only covered some of the possible uses of functors. Functors are really a quite powerful tool for modularizing your code. The cost is that functors are syntactically heavyweight compared to the rest of the language, and that there are some tricky issues you need to understand to use them effectively, with sharing constraints and destructive substitution being high on that list.</p>
<p>All of this means that for small and simple programs, heavy use of functors is probably a mistake. But as your programs get more complicated and you need more effective modular architectures, functors become a highly valuable tool.</p>
</section>
</section>
</article></div><a href="first-class-modules.html" class="next-chapter"><div class="content"><h1><small>Next: Chapter 10</small>First-Class Modules</h1></div></a><footer><div class="content"><ul><li><a href="http://twitter.com/realworldocaml">@realworldocaml</a></li><li><a href="http://twitter.com/yminsky">@yminsky</a></li><li><a href="http://twitter.com/avsm">@avsm</a></li><li><a href="https://plus.google.com/111219778721183890368">+hickey</a></li><li><a href="https://github.com/realworldocaml">GitHub</a></li><li><a href="http://www.goodreads.com/book/show/16087552-real-world-ocaml">goodreads</a></li></ul><p>Copyright 2012-2014 Jason Hickey, Anil Madhavapeddy and Yaron Minsky.</p></div></footer><script src="js/jquery.min.js"></script><script src="js/min/app-min.js"></script></body></html>